{"description": "The adjacent_edge()  function selects edges based on their length, the angles at their\nendpoints, and their respective adjacent lengths. The complement of this function is the\nnot_adjacent_edge()  function.", "syntax": "adjacent_edge(\nlayer1           = data_layer,\nlength           = doubleconstraint,\nangle1           = doubleconstraint,           //optional\nangle2           = doubleconstraint,           //optional\nadjacent_length1 = doubleconstraint,           //optional\nadjacent_length2 = doubleconstraint,           //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",              //optional\nadjacent1        = PRESENT  | MISSING | ALL,    //optional\nadjacent2        = PRESENT  | MISSING | ALL     //optional\n);\nnot_adjacent_edge(\nlayer1           = data_layer,\nlength           = doubleconstraint,\nangle1           = doubleconstraint,           //optional\nangle2           = doubleconstraint,           //optional\nadjacent_length1 = doubleconstraint,           //optional\nadjacent_length2 = doubleconstraint,           //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",              //optional\nadjacent1        = PRESENT  | MISSING | ALL,    //optional\nadjacent2        = PRESENT  | MISSING | ALL     //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "length": "Required. Specifies the length for any edge to be selected. See\nConstraints  for\nmore information.\nadjacent_edge() and not_adjacent_edge()\nFigure 1  shows the effect of the length  argument settings with the\nadjacent_edge()  function.\nFigure 1 Example of length Argument", "angle1": "Optional. Specifies the angle that must be formed at one of the endpoints. The\nangle is measured internally. The angles must be greater than 0 and less than\n360. See\nConstraints  for more information. The default is >0.", "angle2": "Optional. Specifies the angle that must be formed at one of the endpoints. The\nangle is measured internally. The angles must be greater than 0 and less than\n360. See\nConstraints  for more information. The default is >0.\nFigure 2  shows the effect of the angle  arguments with the adjacent_edge()\nfunction.\nFigure 2 Example of angle Arguments", "adjacent_length1": "Optional. Specifies the length that must be satisfied by the edges adjacent to an\nangle1  angle. See\nConstraints  for more information. The default is >0.\nadjacent_edge() and not_adjacent_edge()", "adjacent_length2": "Optional. Specifies the length that must be satisfied by the edges adjacent to an\nangle2  angle. See\nConstraints  for more information. The default is >0.\nFigure 3  shows the effect of the adjacent length arguments with the\nadjacent_edge()  function.\nFigure 3 Example of adjacent_length Arguments", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "adjacent1": "Optional. Specifies for the endpoint of the edge that has angle as angle1\nwhether the other edge adjacent to this endpoint must be existing, missing, or\neither existing or missing. The default is PRESENT.\nadjacent_edge() and not_adjacent_edge()\n\u2022 PRESENT. Specifies that an adjacent edge of an edge must be existing.\n\u2022 MISSING. Specifies that an adjacent edge of an edge must be missing.\n\u2022 ALL. Specifies that an adjacent edge of an edge can be existing or missing.", "adjacent2": "Optional. Specifies for the endpoint of the edge that has angle as angle2\nwhether the other edge adjacent to this endpoint must be existing, missing, or\neither existing or missing. The default is PRESENT.\n\u2022 PRESENT. Specifies that an adjacent edge of an edge must be existing.\n\u2022 MISSING. Specifies that an adjacent edge of an edge must be missing.\n\u2022 ALL. Specifies that an adjacent edge of an edge can be existing or missing.\nFigure 4  shows the effect of the adjacent1  and adjacent2  arguments with the\nadjacent_edge()  function.\nadjacent_edge() and not_adjacent_edge()\nFigure 4 Example of adjacent1 and adjacent2 Arguments"}, "summary": "The adjacent_edge()  function selects edges based on their length, the angles at their\nendpoints, and their respective adjacent lengths.", "function_name": "not_adjacent_edge()"}
{"description": "The adjacent_edge()  function selects edges based on their length, the angles at their\nendpoints, and their respective adjacent lengths. The complement of this function is the\nnot_adjacent_edge()  function.", "syntax": "adjacent_edge(\nlayer1           = data_layer,\nlength           = doubleconstraint,\nangle1           = doubleconstraint,           //optional\nangle2           = doubleconstraint,           //optional\nadjacent_length1 = doubleconstraint,           //optional\nadjacent_length2 = doubleconstraint,           //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",              //optional\nadjacent1        = PRESENT  | MISSING | ALL,    //optional\nadjacent2        = PRESENT  | MISSING | ALL     //optional\n);\nnot_adjacent_edge(\nlayer1           = data_layer,\nlength           = doubleconstraint,\nangle1           = doubleconstraint,           //optional\nangle2           = doubleconstraint,           //optional\nadjacent_length1 = doubleconstraint,           //optional\nadjacent_length2 = doubleconstraint,           //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",              //optional\nadjacent1        = PRESENT  | MISSING | ALL,    //optional\nadjacent2        = PRESENT  | MISSING | ALL     //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "length": "Required. Specifies the length for any edge to be selected. See\nConstraints  for\nmore information.\nadjacent_edge() and not_adjacent_edge()\nFigure 1  shows the effect of the length  argument settings with the\nadjacent_edge()  function.\nFigure 1 Example of length Argument", "angle1": "Optional. Specifies the angle that must be formed at one of the endpoints. The\nangle is measured internally. The angles must be greater than 0 and less than\n360. See\nConstraints  for more information. The default is >0.", "angle2": "Optional. Specifies the angle that must be formed at one of the endpoints. The\nangle is measured internally. The angles must be greater than 0 and less than\n360. See\nConstraints  for more information. The default is >0.\nFigure 2  shows the effect of the angle  arguments with the adjacent_edge()\nfunction.\nFigure 2 Example of angle Arguments", "adjacent_length1": "Optional. Specifies the length that must be satisfied by the edges adjacent to an\nangle1  angle. See\nConstraints  for more information. The default is >0.\nadjacent_edge() and not_adjacent_edge()", "adjacent_length2": "Optional. Specifies the length that must be satisfied by the edges adjacent to an\nangle2  angle. See\nConstraints  for more information. The default is >0.\nFigure 3  shows the effect of the adjacent length arguments with the\nadjacent_edge()  function.\nFigure 3 Example of adjacent_length Arguments", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "adjacent1": "Optional. Specifies for the endpoint of the edge that has angle as angle1\nwhether the other edge adjacent to this endpoint must be existing, missing, or\neither existing or missing. The default is PRESENT.\nadjacent_edge() and not_adjacent_edge()\n\u2022 PRESENT. Specifies that an adjacent edge of an edge must be existing.\n\u2022 MISSING. Specifies that an adjacent edge of an edge must be missing.\n\u2022 ALL. Specifies that an adjacent edge of an edge can be existing or missing.", "adjacent2": "Optional. Specifies for the endpoint of the edge that has angle as angle2\nwhether the other edge adjacent to this endpoint must be existing, missing, or\neither existing or missing. The default is PRESENT.\n\u2022 PRESENT. Specifies that an adjacent edge of an edge must be existing.\n\u2022 MISSING. Specifies that an adjacent edge of an edge must be missing.\n\u2022 ALL. Specifies that an adjacent edge of an edge can be existing or missing.\nFigure 4  shows the effect of the adjacent1  and adjacent2  arguments with the\nadjacent_edge()  function.\nadjacent_edge() and not_adjacent_edge()\nFigure 4 Example of adjacent1 and adjacent2 Arguments"}, "summary": "The adjacent_edge()  function selects edges based on their length, the angles at their\nendpoints, and their respective adjacent lengths.", "function_name": "adjacent_edge()"}
{"description": "The adjust_color_graph  function supports the reduction of LDR (Low Degree Remove)\nin the two_color()  function and the location of the corner nodes in the network.", "syntax": "adjust_color_graph(\nnodes                  = polygon_layer,\nlinks                  = geometry_layer,\nminimum_node_degree     = integer,                     //optional\ntarget_anchor_location = NONE  | LEFT_BOTTOM |\nLEFT_TOP | RIGHT_BOTTOM | RIGHT_TOP |\nBOTTOM_LEFT | BOTTOM_RIGHT | TOP_LEFT |\nTOP_RIGHT,                   //optional\npre_reduction_select_degree   = {integer, ...},\npost_reduction_select_degree  = {integer, ...}\n);", "returns": "void\nThe output is a structure of polygons:\nadjust_color_graph_s : newtype struct of {\nlow_degree_nodes     : polygon_layer;\nlow_degree_links     : polygon_layer;\ncorner_anchors       : polygon_layer;\npre_reduction_selected_nodes    : {polygon_layer, ...};\npost_reduction_selected_nodes   : {polygon_layer, ...};\n);\nlow_degree_nodes\nRequired. Specifies the output polygon layer that contains the low degree\npolygons after LDR reduction. It can be empty if not doing LDR reductions.\nlow_degree_links\nRequired. Specifies the output polygon layer that contains edge links that\nconnect low_degree_nodes  polygons after LDR reduction. It can be empty if not\ndoing LDR reductions.\ncorner_anchors\nRequired. Specifies the output polygon layer that contains the anchor polygon\nfound in corner locating. It can be empty if not doing corner locating.\nadjust_color_graph()\npre_reduction_selected_nodes\nRequired. Outputs all of the node layers received from the graph before LDR,\naccording to the input degree ranges in the pre_reduction_select_degree\nargument.\npost_reduction_selected_nodes\nRequired. Outputs all of the node layers received from the graph after LDR,\naccording to the input degree ranges in the post_reduction_select_degree\nargument.", "arguments": {"nodes": "Required. Specifies the input polygon layer that contains the polygons targeted\nfor LDR or corner locating.", "links": "Required. Specifies the input geometry layer that contains polygons that connect\nnodes  polygons to do LDR reductions.", "minimum_node_degree": "Optional. Specifies the standard limit for LDR reduction. Nodes with a degree\nless than this limit are taken as low-degree nodes and are removed in LDR. The\nother nodes are taken as high-degree nodes and are kept in the reduction. The\ndefault is 0, therefore, that is, not doing LDR.\nNote:\nOnly a nonnegative integer, except 0  is an enabled input, and only\nwith an enabled input can LDR be done. Otherwise, it is skipped and\nthe output is empty.", "target_anchor_location": "Optional. Specifies which of the anchor nodes you want to find. The default is\nNONE, that is, does not do corner locating.\nThe valid values are:\nNONE\nLEFT_BOTTOM\nLEFT_TOP\nRIGHT_BOTTOM\nRIGHT_TOP\nBOTTOM_LEFT\nBOTTOM_RIGHT\nTOP_LEFT\nTOP_RIGHT\nadjust_color_graph()\nFor example, if you set the target_anchor_location  argument to anything\nbut NONE, adjust_color_graph()  output a corner node on the nets after\nLDR reduction (on the specified corner direction), in the output layer of\ncorner_anchors.\nIf minimum_node_degree=0, (no node is reduced in LDR) and\ntarget_anchor_location = TOP_RIGHT, adjust_color_graph()  outputs the\ntop right node on each original net (connected graph composed of input nodes\nand links).\nTOP_RIGHT  means that the node bounding box (bbox) is the TOP-most, and then\nthe RIGHT-most node.\nFor two nodes, the comparison sequence: bbox.top > bbox.right > bbox.bottom\n> bbox.left means that only one, the most TOP_RIGHT  node can be found after all\nof these comparisons.\nNote:\nWhen the input is LEFT_BOTTOM, BOTTOM_LEFT, LEFT_TOP, TOP_LEFT,\nRIGHT_BOTTOM, BOTTOM_RIGHT, RIGHT_TOP  or TOP_RIGHT, corner\nlocating is performed. Otherwise, it is skipped and the output is\nempty.", "pre_reduction_select_degree": "Required. Specifies the degrees of nodes in the graph before LDR. The default\nis an empty list ({}), which means that no nodes are received from the graph\nbefore the LDR. You can add valid integer-like constraints, such as, {==2, < 3,\n>= 4, != 4, [1, 3], (2, 5] ...}  to this empty list to get the corresponding\nnode layers. The size of this constraints list must not be greater than 32.", "post_reduction_select_degree": "Required. Specifies the degrees of nodes in the graph after LDR. The default\nis an empty list ({}), which means that no nodes are received from the graph\nafter the LDR. You can add valid integer-like constraints, such as, {==2, < 3,\n>= 4, != 4, [1, 3], (2, 5] ...}  to this empty list to get the corresponding\nnode layers. The size of this constraints list must not be greater than 32."}, "summary": "The adjust_color_graph  function supports the reduction of LDR (Low Degree Remove)\nin the two_color()  function and the location of the corner nodes in the network.", "function_name": "adjust_color_graph()"}
{"description": "The and()  function creates polygons that represent the intersection of two specified\npolygon layers. Only those areas where the layers overlap are placed in the output.", "syntax": "and(\nlayer1                      = polygon_layer,\nlayer2                      = polygon_layer,\nprocessing_mode             = CELL_LEVEL | HIERARCHICAL,    //optional\nremove_hierarchical_overlap = true  | false,                 //optional\nname                        = \"layer_label\",                //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\npredicate                 = true  | false                     //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "remove_hierarchical_overlap": "Optional. Specifies the processing of hierarchical overlap resulting from the AND\noperation. This processing is a hierarchical optimization. The default is true.\nand()\n\u2022 true. Removes duplicate material, from the parent cell of hierarchically\noverlapping polygons.\n\u2022 false. Keeps hierarchical overlap as is. This overlap can cause performance\ndegradation for subsequent operations on the output layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "predicate": "Optional. Specifies a predicate_handle for empty layer optimization. The\npredicate controls the operation as follows:\n\u2022 true. The function operates as normal.\n\u2022 false. The function produces empty output.\nFor example:\ntemp_layer = and(poly, diff, predicate = [[metal1]]);\nIf the metal1  layer is empty, the and()  function is skipped and temp_layer  is\nempty."}, "summary": "The and()  function creates polygons that represent the intersection of two specified\npolygon layers.", "function_name": "and()"}
{"description": "The and_edge()  function selects the portion of all layer1  edges that are inside layer2\npolygons.", "syntax": "and_edge(\nlayer1           = data_layer,\nlayer2           = polygon_layer,\ncoincident       = true  | false,                //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,   //optional\nname             = \"layer_label\",               //optional\ncoincident_edges  = INSIDE | OUTSIDE | BOTH      //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "layer2": "Required. Specifies the polygon layer checked against layer1  edges.", "coincident": "Optional. Specifies if inside coincident is included in the result. The default is\ntrue.\n\u2022 true. Includes inside coincident in the result.\n\u2022 false. Does not include inside coincident in the result.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nand_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincident_edges": "Optional. Specifies which edges must be included in the output result. This\nargument works only when coincident=true. The default is INSIDE.\n\u2022 INSIDE. Keeps the inside coincident edges in the output.\n\u2022 OUTSIDE. Keeps the outside coincident edges in the output.\n\u2022 BOTH. Keeps all of the inside and outside coincident edges in the output."}, "summary": "The and_edge()  function selects the portion of all layer1  edges that are inside layer2\npolygons.", "function_name": "and_edge()"}
{"description": "The and_overlap()  function creates polygons that represent the hierarchical intersections\nof the material from two specified layers. Intersection in a given cell instance is ignored.\nNote:\nThe and_overlap()  function operates on the optimized hierarchy after\nhierarchy preprocessing and not on the original layout hierarchy. Because the\nand_overlap()  function generates output based on hierarchical interactions,\nin is important to note that results are based on the optimized hierarchy and not\nthe original layout hierarchy.", "syntax": "and_overlap(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nname            = \"layer_label\",             //optional\nlayer1_relation = {SIBLING, PARENT, CHILD}   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "layer1_relation": "Optional. Specifies the position of layer1  in the hierarchical relationship of\nthe intersections that are created. By default, the list is {PARENT, CHILD,\nSIBLING}, where all hierarchical overlaps are reported.\nand_overlap()\n\u2022 SIBLING. Specifies that the hierarchical intersection is formed by placements\ndown different branches of a common parent.\n\u2022 PARENT. Specifies that the hierarchical intersection is formed by placements\nin the same branch, and the layer1  data is above the layer2  data.\n\u2022 CHILD. Specifies that the hierarchical intersection is formed by placements in\nthe same branch, and the layer1  data is below the layer2  data."}, "summary": "The and_overlap()  function creates polygons that represent the hierarchical intersections\nof the material from two specified layers.", "function_name": "and_overlap()"}
{"description": "The angle_edge()  function selects edges based on the specified minimum angle with the\nx-axis. The complement of this function is the not_angle_edge()  function.", "syntax": "angle_edge(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\nmeasurement       = MIN  | COUNTERCLOCKWISE     //optional\n);\nnot_angle_edge(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\nmeasurement      = MIN  | COUNTERCLOCKWISE      //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "angles": "Required. Specifies the angles whose values are in the range [0.0, 90.0]. See\nConstraints  for more information. An edge of angle 0 is parallel to the x-axis.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nangle_edge() and not_angle_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "measurement": "Optional. Specifies how the angles are measured in relation to the x-axis of a\nmeasured edge\u2019s endpoint at the bottom. The default is MIN.\n\u2022 MIN. Specifies that the angle of a given edge is determined by the minimum\nangle to the x-axis. Valid values are in the range [0.0,90].\n\u2022 COUNTERCLOCKWISE. Specifies that the angle of a given edge is determined\nby the measurement in a counterclockwise direction from the x-axis. Valid\nvalues are in the range [0.0,180)."}, "summary": "The angle_edge()  function selects edges based on the specified minimum angle with the\nx-axis.", "function_name": "not_angle_edge()"}
{"description": "The angle_edge()  function selects edges based on the specified minimum angle with the\nx-axis. The complement of this function is the not_angle_edge()  function.", "syntax": "angle_edge(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\nmeasurement       = MIN  | COUNTERCLOCKWISE     //optional\n);\nnot_angle_edge(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\nmeasurement      = MIN  | COUNTERCLOCKWISE      //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "angles": "Required. Specifies the angles whose values are in the range [0.0, 90.0]. See\nConstraints  for more information. An edge of angle 0 is parallel to the x-axis.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nangle_edge() and not_angle_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "measurement": "Optional. Specifies how the angles are measured in relation to the x-axis of a\nmeasured edge\u2019s endpoint at the bottom. The default is MIN.\n\u2022 MIN. Specifies that the angle of a given edge is determined by the minimum\nangle to the x-axis. Valid values are in the range [0.0,90].\n\u2022 COUNTERCLOCKWISE. Specifies that the angle of a given edge is determined\nby the measurement in a counterclockwise direction from the x-axis. Valid\nvalues are in the range [0.0,180)."}, "summary": "The angle_edge()  function selects edges based on the specified minimum angle with the\nx-axis.", "function_name": "angle_edge()"}
{"description": "The annotate_by_property()  function makes a copy of a polygon layer annotated with\nuser-defined properties from nets in the connect database.\nNote:\nThe annotate_by_property()  function only supports attaching a double\nproperty to an output layer.\nNote:\nProperties on a polygon layer are recognized only by the drc_features(),\nnet_polygon_by_property(), and select_by_double_property()\nfunctions. All other functions ignore properties on a polygon layer and do not\npropagate the properties to their result.", "syntax": "annotate_by_property(\nconnect_sequence       = connect_database,\nlayer1                 = polygon_layer,\nproperty_names         = {\"string\", ...},\nname                   = \"layer_label\"         //optional\n);", "returns": "polygon layer", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "layer1": "Required. Specifies the polygon layer.", "property_names": "Required. Specifies the user-defined properties to annotate from nets to\npolygons.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nannotate_by_property()"}, "summary": "The annotate_by_property()  function makes a copy of a polygon layer annotated with\nuser-defined properties from nets in the connect database.", "function_name": "annotate_by_property()"}
{"description": "The apply_bias()  function moves the edge segments based on the attached bias value\nproperty, and outputs a polygon layer.", "syntax": "apply_bias_edge(\nlayer1            = edge_layer,\nmain_layer        = polygon_layer,\nvalid_bias_range  = doubleconstraint    //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the segments to be biased.", "main_layer": "Required. Specifies the input polygon layer.", "valid_bias_range": "Optional. Specifies the valid range of the bias rule. For example:\n\u2022 The return layer of apply_bias()  is the polygon layer formed by displaced\nlayer1 segments.\n\u2022 The return layer of apply_bias_edge()  is the edge layer formed by\ndisplaced layer1 segments.\nSee the\napply_bias()  function for more information."}, "summary": "The apply_bias()  function moves the edge segments based on the attached bias value\nproperty, and outputs a polygon layer.", "function_name": "apply_bias()"}
{"description": "The area()  function selects polygons whose area fits the specified value. The\ncomplement of this function is the not_area()  function.", "syntax": "area(\nlayer1           = polygon_layer,\nvalue            = doubleconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_area(\nlayer1           = polygon_layer,\nvalue            = doubleconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "value": "Required. Specifies the area. See\nConstraints  for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\narea() and not_area()"}, "summary": "The area()  function selects polygons whose area fits the specified value.", "function_name": "area()"}
{"description": "The aspect_ratio()  function selects layer1  polygons that are rectangles which fit\nthe specified aspect ratio. The complement of this function is the not_aspect_ratio()\nfunction.", "syntax": "aspect_ratio(\nlayer1          = polygon_layer,\nratio           = doubleconstraint,\norientation     = ORTHOGONAL | ALL,           //optional\ndirection       = X_BY_Y | LONG_BY_SHORT\n|SHORT_BY_LONG,     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_aspect_ratio(\nlayer1          = polygon_layer,\nratio           = doubleconstraint,\norientation     = ORTHOGONAL | ALL,           //optional\ndirection       = X_BY_Y | LONG_BY_SHORT\n|SHORT_BY_LONG,     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "ratio": "Required. Specifies the aspect ratio that must be met for a rectangle to be\nselected. Squares have an aspect ratio of 1. See\nFigure 11  for examples of the\nratio  argument.", "orientation": "Optional. Specifies the orientation of rectangles to be measured. See Figure 12\nfor examples of the orientation  argument. The default is ALL.\naspect_ratio() and not_aspect_ratio()\n\u2022 ORTHOGONAL. Measures only orthogonal rectangles.\n\u2022 ALL. Measures all rectangles regardless of orientation.", "direction": "Optional. Specifies how the aspect ratio is calculated. See Figure 13  for\nexamples of the direction  argument. The default is SHORT_BY_LONG.\n\u2022 X_BY_Y. Specifies that the aspect ratio is the dimension in the x-direction\ndivided by the dimension in the y-direction.\nThis argument is available only when the orientation  argument\nis ORTHOGONAL. When the direction  argument is X_BY_Y  and the\nprocessing_mode  argument is HIERARCHICAL, calculating the aspect ratio\nis a\ndirectional operation\ndirectional operation that requires special consideration for polygons\nwhich are rotated 90 or 270 degrees. In runsets that use multiple directional\noperations, careful application of the\nprototype_options()  function can\nimprove performance.\n\u2022 SHORT_BY_LONG. Specifies that the aspect ratio is the short dimension\ndivided by the long dimension.\n\u2022 LONG_BY_SHORT. Specifies that the aspect ratio is the long dimension divided\nby the short dimension.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The aspect_ratio()  function selects layer1  polygons that are rectangles which fit\nthe specified aspect ratio.", "function_name": "aspect_ratio()"}
{"description": "The aspect_ratio()  function selects layer1  polygons that are rectangles which fit\nthe specified aspect ratio. The complement of this function is the not_aspect_ratio()\nfunction.", "syntax": "aspect_ratio(\nlayer1          = polygon_layer,\nratio           = doubleconstraint,\norientation     = ORTHOGONAL | ALL,           //optional\ndirection       = X_BY_Y | LONG_BY_SHORT\n|SHORT_BY_LONG,     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_aspect_ratio(\nlayer1          = polygon_layer,\nratio           = doubleconstraint,\norientation     = ORTHOGONAL | ALL,           //optional\ndirection       = X_BY_Y | LONG_BY_SHORT\n|SHORT_BY_LONG,     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "ratio": "Required. Specifies the aspect ratio that must be met for a rectangle to be\nselected. Squares have an aspect ratio of 1. See\nFigure 11  for examples of the\nratio  argument.", "orientation": "Optional. Specifies the orientation of rectangles to be measured. See Figure 12\nfor examples of the orientation  argument. The default is ALL.\naspect_ratio() and not_aspect_ratio()\n\u2022 ORTHOGONAL. Measures only orthogonal rectangles.\n\u2022 ALL. Measures all rectangles regardless of orientation.", "direction": "Optional. Specifies how the aspect ratio is calculated. See Figure 13  for\nexamples of the direction  argument. The default is SHORT_BY_LONG.\n\u2022 X_BY_Y. Specifies that the aspect ratio is the dimension in the x-direction\ndivided by the dimension in the y-direction.\nThis argument is available only when the orientation  argument\nis ORTHOGONAL. When the direction  argument is X_BY_Y  and the\nprocessing_mode  argument is HIERARCHICAL, calculating the aspect ratio\nis a\ndirectional operation\ndirectional operation that requires special consideration for polygons\nwhich are rotated 90 or 270 degrees. In runsets that use multiple directional\noperations, careful application of the\nprototype_options()  function can\nimprove performance.\n\u2022 SHORT_BY_LONG. Specifies that the aspect ratio is the short dimension\ndivided by the long dimension.\n\u2022 LONG_BY_SHORT. Specifies that the aspect ratio is the long dimension divided\nby the short dimension.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The aspect_ratio()  function selects layer1  polygons that are rectangles which fit\nthe specified aspect ratio.", "function_name": "not_aspect_ratio()"}
{"description": "The assign()  function assigns data found on specified layers in the layout to a polygon-\nlayer variable. This function reads only positive width paths and polygons, and ignores\nzero width paths. Data assigned to the polygon-layer variable can be restricted to data of a\nspecified datatype.\nSee the\nassign_openaccess()  function for an assign function that is specific to the\nOpenAccess format. The assign_openaccess()  function accepts layer and purpose\nnames as arguments, rather than numeric layer and datatype ranges. If you use the\nassign()  function for OpenAccess data, you must specify an OpenAccess layer mapping\nfile in the\nopenaccess_options()  function. The openaccess_options()  function allows\nyou to read OpenAccess system objects such as blockages and boundaries.", "syntax": "assign(\nldt_list     = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},      //optional\n...},\nmilkyway     = {views               = {\"string\", ...},\nobjects             = {object_type, ...},\ncell_types          = {cell_type, ...},\nnet_types           = {net_type, ...},\nroute_guide_layers  = {layer_type, ...},\nroute_types         = {route_type, ...},\nkeep_properties     = {OWNER_NET, ROUTE_TYPE},\nuser_attributes     = {\n{boolean_attributes = {\n{name  = \"string\", value = true | false},\n...},\ndouble_attributes  = {\n{name   = \"string\",\nvalues = {doubleconstraint, ...}},\n...},\nfloat_attributes   = {\n{name   = \"string\",\nvalues = {doubleconstraint, ...}},\n...},\ninteger_attributes = {\n{name   = \"string\",\nvalues = {integerconstraint, ...}},\n...},\nstring_attributes  = {\n{name   = \"string\",\nvalues = {\"string\", ...}},\n...}},\n...},\ncolors              = {color, ...},\nassign()\nread_fill_view_from = {TOP_CELL, LOWER_CELLS}\n},                                           //optional\nopenaccess    = {objects = {DONUT, DOT, ELLIPSE, PATH, PATH_SEGMENT,\nPIN, POLYGON, RECTANGLE},\nblockage_types = {openaccess_blockage_type, ...},\narea_boundary_names = {\"string\", ...},      //optional\ncolors = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME}},             //optional\ngrid_check   = {resolution = double,\ncheck_45   = {POLYGON, PATH},\ncheck_90   = {POLYGON, PATH},\npath_check = CENTERLINE | BOUNDARY,\nresolution_violation_comment = \"string\",\ncheck_45_violation_comment = \"string\",\ncheck_90_violation_comment = \"string\"},\n//optional\nselect_cells = {\"string\", ...},                             //optional\npolygons     = {{coordinates = {{{x = double, y = double}, ...}, ...},\ncell        = \"string\"}, ...},             //optional\nlibraries    = {library},                                   //optional\nname         = \"layer_label\",                               //optional\nlayer_intent  = {LAYER_INTENT_METAL, LAYER_INTENT_FILL,\nLAYER_INTENT_INTERCONNECT,\nLAYER_INTENT_BASE, LAYER_INTENT_VIA,\nLAYER_INTENT_COLORED_SUBSET,\nLAYER_INTENT_DEVICE},                       //optional\ngds      = {\nuser_defined_properties = {{\ndouble_properties = {{name   = \"string\",\nnumber = integer}, ...},\n...}\n},\n//optional\noasis     = {\nuser_defined_properties = {{\ndouble_properties = {{name   = \"string\",\nnumber = integer}, ...},\n...}\n},                                               //optional\nndm       = {views              = {view_type, ...},\nobjects            = {object_type, ...},\nshape_uses         = {shape_use_type, ...},\nnet_types          = {net_type, ...},\ndesign_types       = {design_type, ...},\nblockage_types     = {ndm_blockage_type, ...},\nblockage_layers    = {integer, ...},\nutilization_layers = {integer, ...},\nmasks              = {ndm_mask, ...},\nread_from          = {assign_ndm_read_from, ...},\ninternal_designs   = {ndm_internal_design_use, ...},\nroute_guide_layers = {integer, ...},\nassign()\nread_internal_designs_from = {TOP_CELL, LOWER_CELLS},\nkeep_properties    = {OWNER_NET, SHAPE_USE}\nuser_attributes    = {\n{boolean_attributes = {\n{name  = \"string\", value = true | false},\n...},\ndouble_attributes  = {\n{name   = \"string\",\nvalues = {doubleconstraint, ...}},\n...},\nfloat_attributes   = {\n{name   = \"string\",\nvalues = {doubleconstraint, ...}},\n...},\ninteger_attributes = {\n{name   = \"string\",\nvalues = {integerconstraint, ...}},\n...},\nstring_attributes  = {\n{name   = \"string\",\nvalues = {\"string\", ...}},\n...}},\n...},\nset_z_level = integer,\n},\nselect   = {cells = {\"string\", ...},\nmarker_layers = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...},\ndepth = CELL_LEVEL | DESCENDANTS |\nALL,\ncomplement                   = true | false,\npolygon_property_sets        = {\n{\n{property_number = integer,\nproperty_values = {{\"string\"}, ...},\nmatch           =\nALL  | ALL_SAME_ORDER | SUPERSET |\nSUBSET}, ...\n},...\n},                                              //optional\nexclude_polygon_property_set = {\n{property_number = integer,\nproperty_values = {\"string\", ...},\nmatch           =\nALL  | ALL_SAME_ORDER | SUPERSET |\nSUBSET},...\n},                                              //optional\ngeometry_exclude = {\ngeometry_exclude_type   = {CIRCLE, STADIUM, TEARDROP}\n},                                              //optional\nplacement_sets               = {\n{cells           = {\"string\", ...},\nproperty_sets   = {\nassign()\n{\n{property_number = integer,\nproperty_values = {\"string\", ...},\nmatch           =\nALL  | ALL_SAME_ORDER |\nSUPERSET | SUBSET}, ...\n}, ...\n},\nexclude_property_set  = {\n{property_number = integer,\nproperty_values = {\"string\", ...},\nmatch           =\nALL  | ALL_SAME_ORDER |\nSUPERSET | SUBSET}, ...\n},\ninstance_names        = {\"string\", ...},\ndepth                 =\nCELL_LEVEL  | DESCENDANTS |\nALL\n}, ...\n},                                              //optional\nexclude_placement_set        = {\ncells           = {\"string\", ...},\nproperty_sets   = {\n{\n{property_number = integer,\nproperty_values = {\"string\", ...},\nmatch           =\nALL  | ALL_SAME_ORDER |\nSUPERSET | SUBSET}, ...\n}, ...\n},\nexclude_property_set = {\n{property_number = integer,\nproperty_values = {\"string\", ...},\nmatch           =\nALL  | ALL_SAME_ORDER |\nSUPERSET | SUBSET}, ...\n}\n},\ngeometry_match               = {\nbaseline_cells   = {\"string\", ...},\nbaseline_sources = {\nGOLDEN_LIBRARY,\nINPUT_LIBRARY}\n},                                      //optional\ngeometry_select  = {\ngeometry_type    =\nNONE  | CIRCLE | ANNULUS |\nSTADIUM | OCTAGON | TEARDROP |\nROUTE_LINE,\nstadium_parameters = {angle_tolerance_45 = double,\nradial_tolerance =\ndouble}, //optional\nteardrop_parameters = {\nradius = doubleconstraint\n= double, // optional\npeak_length = doubleconstraint\n= double, // optional\nside_length = doubleconstraint\nassign()\n= double, // optional\ntolerance = double, // optional\ntype = {STANDARD, CROPPED,\nALL}, //optional\nroute_line_parameters = {\ntolerance = double,\nmax_width = double,\nline_ends_only = true |\nfalse, //optional\n} // optional\n}\n}\n},\nexclude_from_keepout_check_in_drc_black_box  = true | false,\n//optional\ndelete_exploded_data                         = true | false\n//optional\n);", "returns": "polygon layer", "arguments": {"ldt_list": "Required. Lists the layer range and datatype range pairs. The\ndata_type_range  value for each pair is optional, with a default of all datatypes.\nSee\nLayout Layer and Datatype Ranges  for information about the limits of the\nvalues.\nNote:\nYou can use the assign_layer_out_of_range  argument of the\nrun_options()  function to specify the behavior of the IC Validator\ntool when an assign function contains layer or datatype numbers\nthat are greater than the maximum allowed range of the input library\nformat.\nFor NDM libraries, lists the layer range and layer purpose range pairs. The\ndata_type_range  value, which is the layer purpose, for each pair is optional,\nwith a default of all datatypes. See\nLayout Layer and Datatype Ranges  for\ninformation about the limits of the values.", "milkyway": "Optional. Controls the reading of data from a Milkyway library on a layer-\nby-layer basis. This argument works with the drc_black_box_cells  and\nlvs_black_box_cells  arguments of the\nmilkyway_options()  function. These\narguments of the milkyway_options()  function control the views on a cell-by-\ncell basis.\nassign()\nNote:\nThe milkyway  argument is ignored for non-Milkyway libraries.\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer basis,\nwhen reading the Milkyway library. By default, the IC Validator tool reads all\nviews.\nNote:\nAny number of views can be referenced in the Milkyway library.\nThe maximum combined number of unique view names used in all\nassign functions in the runset is 32.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the Milkyway library.\nTable 12  lists the objects. By default,\nthe IC Validator tool reads all objects except HORIZONTAL_WIRE_TRACK  and\nVERTICAL_WIRE_TRACK.\nTable 12 Milkyway objects Options for the assign() Function\nBOUNDARY CELL_ROW CONTACT CONTACTARRAY\nCORE_REGION HORIZONTAL_WIRE_TRACK HORIZONTALWIRE PATH\nPIN POLYGON RECTANGLE VERTICAL_WIRE_TRACK\nVERTICALWIRE\n\u2022 cell_types. Optional. Includes the specified cell types, on a layer-\nby-layer basis, when reading the Milkyway library. This argument\nworks with the cell_types  and exclude_cell_types  arguments\nof the\nmilkyway_options()  function. These arguments of the\nmilkyway_options()  function globally constrain the cell types that are read.\nYou can use the exclude_milkyway_cell_types()  function to obtain a list\nof all possible cell types except those specified by the exclude  argument. By\ndefault, the IC Validator tool reads data from all cell types. See Table 56  for a\nlist of cell types.\n\u2022 net_types. Optional. Includes the specified net types, on a layer-by-layer\nbasis, when reading the Milkyway library. This argument works with the\nnet_types  argument of the\nmilkyway_options()  function. This argument\nof the milkyway_options()  function globally constrains the net types that\nare read. You can use the exclude_milkyway_net_types()  function to\nobtain a list of all possible net types except those specified. By default, the\nIC Validator tool reads data of all net types. See\nTable 57  for the list of net\ntypes.\nassign()\nFor example, you can specify power and ground as net types:\nm1_power_ground = assign({{==1}},\nmilkyway={net_types={POWER,GROUND}}\n);\n\u2022 route_guide_layers. Optional. Includes the specified route guides, on a\nlayer-by-layer basis, when reading the Milkyway library. Route guides are\nrectangles on a specific layer that have a BlockLayer property set which\ndefines the blocked layers. This argument filters based on the BlockLayer\nproperty, and works with the route_guide_layers  argument of the\nmilkyway_options()  function. The route_guide_layers  argument of the\nmilkyway_options()  function globally constrains the route guides that are\nread. You can use the exclude_milkyway_route_guide_layers()  function\nto obtain a list of all possible route guides except those specified by the\nexclude  argument. By default, the IC Validator tool reads all route guides.\nSee\nTable 58  for a list of route guide layers.\nFor example, you can specify to read only one route guide:\nm1_blockage = assign({{==190}},\nmilkyway={route_guide_layers={M1_ROUTE_GU\nIDE}}\n);\n\u2022 route_types. Optional. Includes the specified route types, on a layer-\nby-layer basis, when reading the Milkyway library. This argument works\nwith the route_types  argument of the\nmilkyway_options()  function.\nThe route_types  argument of the milkyway_options()  function\nglobally constrains the route types that are read. You can use the\nexclude_milkyway_route_types()  function to obtain a list of all possible\nroute types except those specified. By default, the IC Validator tool reads all\nroute types. See\nTable 59  for a list of route types.\nNote:\nThe route type is only used for the shapes RECTANGLE, PATH,\nHORIZONTALWIRE, and VERTICALWIRE, as specified in the objects\nargument.\nFor example, you can specify multiple route types:\n// Route type either PG_* or not set\nm1_pg_noroute = assign({{==1}},\nmilkyway = {\nroute_types={NONE,PG_RING,PG_STRIPE,PG_PIN,PG_FOLLOW_P\nIN}\n}\n);\nassign()\n\u2022 keep_properties. Optional. Keeps the specified Milkyway properties for\ndata on the layer when reading the Milkyway library. These properties can be\nused by the write_milkyway()  function to set properties on output shapes\nbased on input layer shapes they interact with. By default, the IC Validator\ntool does not keep any properties.\n\u25e6 OWNER_NET. Keeps the net property that each shape is assigned to as\ndefined in the Milkyway library. Information about the net is kept, including\nthe net name and net type. This option keeps only net information for\nshapes in the top level CEL view.\n\u25e6 ROUTE_TYPE. Keeps the route type property on each shape as defined in\nthe Milkyway library. Only certain types of objects can have a route type\nassociated: rectangles, paths, wires, contacts, and contact arrays.\nIn the following example, both OWNER_NET  and ROUTE_TYPE  properties are\npreserved on Milkyway layer 31.\nm1 = assign({{31}},\nmilkyway = {\nkeep_properties={OWNER_NET,ROUTE_TYPE}\n}\n);\n\u2022 user_attributes. Optional. Lists the Milkyway attributes that are used to\nfilter shapes when reading the Milkyway library. Only shapes with specified\nattribute values are read in.\nWhen the user_attributes  argument is used, shapes matching one or\nmore of the value sets listed are kept for the runset layer. All conditions\nof a value set must be met for the shape to be considered a match. For\nexample, if a value set lists constraints for two different attributes, both must\nbe satisfied.\n\u25e6 If an attribute is specified in the runset as a different type from what is\ndefined in the Milkyway library, the IC Validator tool stops and issues an\nerror message.\n\u25e6 If an attribute is specified in the runset but is not defined in the Milkyway\nlibrary, the IC Validator tool writes a warning message and continues to\nrun.\nWhen the user_attributes  argument is an empty list, the default, the\nIC Validator tool does not filter data by attribute.\n\u25e6 boolean_attributes. Optional. Specifies the Boolean attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\nassign()\n-  value. Specifies the Boolean value of the attribute, true  or false.\n\u25e6 double_attributes. Optional. Specifies the double attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  values. Lists the double attribute values.\n\u25e6 float_attributes. Optional. Specifies the float attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  values. Lists the float attribute values.\n\u25e6 integer_attributes. Optional. Specifies the integer attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  values. Lists the integer attribute values.\n\u25e6 string_attributes. Optional. Specifies string attributes for the specified\nlayer.\n-  name. Specifies the attribute name.\n-  values. Lists the string attribute values.\nFor example,\n// Select metal1 with at least one of the two following value\nsets:\n//    Value Set 1:\n//       (my_integer_prop1 <= 10 || my_integer_prop1 >= 100)\n&&\n//       (my_integer_prop2 == 50) &&\n//       (my_string_prop1 is \"Value*\", \"!ValueD\")\n//\n//    Value Set 2:\n//       (my_double_prop1 == 5.0 && my_string_prop1==\"ValueD\")\nm1_user_filtered = assign({{31}},\nmilkyway = {\nuser_attributes = {\n// Value set 1\n{integer_attributes = {\n{\"my_integer_prop1\", {<=10, >=100} },\n{\"my_integer_prop2\", {==50 } } } ,\nstring_attributes = {\n{\"my_string_prop1\", {\"Value*\", \"!ValueD\"} } }\nassign()\n},\n// Value Set 2\n{double_attributes = {\n{\"my_double_prop1\", {==5.0 } } },\nstring_attributes = { {\"my_string_prop1\",\n{\"ValueD\"} } }\n}\n}\n}\n);\n\u2022 colors. Optional. Lists Milkyway library color attributes that are included, on\na layer-by-layer basis, when reading the Milkyway library. Only shapes with\nthe color attributes listed are read for this layer.\nTable 13  lists the attributes.\nBy default, the IC Validator tool reads data of all color attribute values.\nTable 13 Milkyway Color Attributes\nMASK_FIVE_HARD MASK_FIVE_SOFT MASK_FOUR_HARD MASK_FOUR_SOFT\nMASK_ONE_HARD MASK_ONE_SOFT MASK_SIX_HARD MASK_SIX_SOFT\nMASK_SEVEN_HARD MASK_SEVEN_SOFT MASK_THREE_HARD MASK_THREE_SOFT\nMASK_TWO_HARD MASK_TWO_SOFT NO_COLOR SAME_COLOR\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. Use the color  option of the layers  argument of the\nwrite_milkyway()  function to write the color attributes.\nassign()\n\u2022 read_fill_view_from. Optional. Lists the fill cells that are included on the\nspecified layer when the fill view is read. You can include the top fill cells\nonly, all of the fill cells except the top cells, or all of the fill cells. By default,\nthe IC Validator tool reads all of the fill cells when the fill view is read.\n\u25e6 TOP_CELL. Includes the top fill cells.\n\u25e6 LOWER_CELLS. Includes all of the fill cells except the top cells.", "openaccess": "Optional. Controls the reading of data from an OpenAccess database on a layer-\nby-layer basis.\nNote:\nThis argument is ignored for non-OpenAccess databases.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the OpenAccess database. By default, the IC Validator tool\nreads all objects.\n\u2022 blockage_types. Optional. Filters objects by blockage type. The\noaBlockage objects have an associated blockage type; other types of objects\ndo not. By default, the IC Validator tool reads all objects.\nNote:\nSee the\nopenaccess_options()  function for more information\nabout reading oaBlockage objects.\nTable 14  lists the blockage type options.\nTable 14 OpenAccess Blockage Types\nOption Blockage type\nFEEDTHRU_BLOCKAGE FEEDTHRU\nFILL_BLOCKAGE FILL\nNONE Read objects without a blockage type\nPIN_BLOCKAGE PIN\nPLACEMENT_BLOCKAGE PLACEMENT\nROUTING_BLOCKAGE ROUTING\nSCREEN_BLOCKAGE SCREEN\nSLOT_BLOCKAGE SLOT\nassign()\nOption Blockage type\nVIA_BLOCKAGE VIA\nWIRING_BLOCKAGE WIRING\n\u2022 area_boundary_names. Optional. Filters objects by area boundary name.\nThe oaAreaBoundary objects can have an associated name; other types\nof objects do not. See the\nopenaccess_options()  function for more\ninformation about reading oaAreaBoundary objects. String matching using\nmetacharacters is allowed. See\nString Matching  for more information. By\ndefault, the IC Validator tool reads all objects.\n\u2022 colors. Optional. Lists OpenAccess library color attributes that are included,\non a layer-by-layer basis, when reading the OpenAccess library. Only\nshapes with the color attributes listed are read for this layer.\nTable 15  lists\nthe attributes. By default, the IC Validator tool reads data of all color attribute\nvalues.\nTable 15 OpenAccess Color Attributes\nGRAY MASK_ONE_UNLOCKED MASK_ONE_LOCKED MASK_TWO_UNLOCKED\nMASK_TWO_LOCKED MASK_THREE_UNLOCKED MASK_THREE_LOCKED BLACK\nMULTI SAME\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. See the openaccess_options()  function for more\ninformation.", "grid_check": "Optional. Overrides the values specified in the layout_grid_options()\nfunction in the specific layer. Any values that are unspecified default to the\ncorresponding value specified in the layout_grid_options()  function.\n\u2022 resolution. Optional. Inspects the layer for off-grid data when set to a\nvalue greater than the input library resolution. The default is the resolution\nspecified in the\nlayout_grid_options()  function.\n\u2022 check_45. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 45 degrees. The\nassign()\ndefault is the layout data types specified in the layout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 45\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 45 degrees.\n\u2022 check_90. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 90 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 90\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 90 degrees.\n\u2022 path_check. Optional. Checks the specified path feature in the specific layer.\nThe default is the path feature specified in the\nlayout_grid_options()\nfunction.\n\u25e6 CENTERLINE. Specifies that only the centerline of the path, before\npath expansion, is checked for violations in accordance with the other\nargument settings.\n\u25e6 BOUNDARY. Specifies that the resulting boundary, after path expansion,\nis checked for violations in accordance with the other argument settings.\nPath width checking is disabled with this setting.\n\u2022 resolution_violation_comment. Optional. Specifies the violation\ncomment for the resolution  errors in the specific layer. The default is the\nresolution_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_45_violation_comment. Optional. Specifies the violation\ncomment for the check_45  errors in the specific layer. The default is the\ncheck_45_violation_comment  specified in the layout_grid_options()\nfunction.\nassign()\n\u2022 check_90_violation_comment. Optional. Specifies the violation\ncomment for the check_90  errors in the specific layer. The default is the\ncheck_90_violation_comment  specified in the layout_grid_options()\nfunction.", "select_cells": "Optional. Includes the specified cells when importing the assign layer. When\na cell is selected, its references are included. You can add the ! character,\nwhich is the NOT operator, as a prefix to a cell name to exclude its data and\nits descendant data from selection. String matching using metacharacters is\nallowed. See\nString Matching  for more information. By default, the IC Validator\ntool selects all cells.\nNote:\nExcluding the parent of a cell takes precedence over selecting a cell;\nthat is, a cell is excluded if its parent is excluded.\nSee the\nselect  argument for selecting cells based on the presence\nof a marker layer.\nIn the following example, all hierarchy in the MID_CELL cell is selected.\nselect_cells = {\"MID_CELL\"}\nFigure 14 select_cells Argument Hierarchy Example\nIn the following example, using the NOT operator (!) means that only data\noutside the BOT_CELL cell is selected (TOP_CELL and MID_CELL cells).\nselect_cells = { \"*\", \"!BOT_CELL\" }\nassign()\nFigure 15 select_cells Argument Example Using the NOT Operator\nIn the following example, using the NOT operator (!) means that only data\noutside the MID_CELL cell is selected (top-level data in the TOP_CELL cell).\nselect_cells = { \"TOP_CELL\", \"!MID_CELL\" }\nFigure 16 select_cells Argument Hierarchy Example Using the NOT Operator\nIn the following example, the output data includes the MID_CELL cell and below,\nand the BOT_CELL cell and below. Data from the MID2_CELL cell is selected\nwhen it is below the MID_CELL cell, but not selected when it is located only\nbelow the TOP_CELL cell.\nselect_cells = { \"MID_CELL\", \"BOT_CELL\" }\nassign()\nFigure 17 select_cells Argument Example With Multiple Hierarchies", "polygons": "Optional. Lists the polygons created in the specified cells. The polygons\nare added as data is read into cells, and polygons are treated as if they\nare direct input from the layout. Therefore, arguments, such as the\nmagnification_factor  argument of the\nlibrary()  function, that transform\ninput layout data is applied to the polygons that are created. Data counts in the\ntree files include these polygons.\nIf a cell name does not exist in the input layout, the name is ignored. If a cell\nname is not specified, the polygons in the associated list are created in the top\ncell. A list of two coordinates is considered a rectangle.\nNote:\nIf you are using the\nlibrary_import()  function, the magnification\nfactor specified in the libraries  argument of the assign()  function\nis applied.\nIf you are using the\nlibrary_import()  function and no cell name is\nspecified, polygons are created in the top cell of the library specified\nin the libraries  argument of the assign()  function.\nHere is an example of the polygons  argument:\nm1 = assign({{==1}},\npolygons = {\n// Two rectangles in the top cell\n{{\n{{1.0, 1.0}, {2.0, 2.0}},\n{{3.0, 3.0}, {4.0, 4.0}}\n}},\n// Two rectangles in cell A\n{cell = \"A\",\ncoordinates = {\nassign()\n{{1.0, 1.0}, {2.0, 2.0}, {2.0, 3.0}, {1.0,\n3.0}},\n{{3.0, 3.0}, {4.0, 4.0}}\n}}\n}\n);", "libraries": "Optional. Specifies the libraries. An assign function uses only layers from these\nlibraries. The libraries are defined by the return value of the\nlibrary()  or\nlibrary_import()  function.\nNote:\nThe list can contain multiple libraries.\nThe libraries  argument is required if you use the library_import()  function\nand the argument is prohibited if you do not use the library_import()\nfunction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "layer_intent": "Optional. Specifies the following layer types:\nLAYER_INTENT_METAL.\nLAYER_INTENT_FILL\nLAYER_INTENT_INTERCONNECT\nLAYER_INTENT_BASE\nLAYER_INTENT_VIA\nLAYER_INTENT_COLORED_SUBSET\nLAYER_INTENT_DEVICE\nYou can list more than one type. For example, a layer can be of type\nLAYER_INTENT_METAL  and LAYER_INTENT_INTERCONNECT. The default is\nunspecified intent.\nassign()\nNote:\nThe LAYER_INTENT_BASE  layer type provides identical functionality to\nthe LAYER_INTENT_DEVICE  layer type, and it is maintained for legacy\nsupport.\nThe LAYER_INTENT_DEVICE  type provides the tool with information about which\nlayers are used to derive device body layers. This ensures a hierarchically\ncorrect location for the device by maintaining, as much as possible, the drawn\nhierarchy for the functions used to derive the body layer. For most processes,\nthe poly and diffusion layers for MOSFET and marker layers used to define\npassive devices, are candidates for the use of the LAYER_INTENT_DEVICE  type.\nNote:\nDevice extraction flows require devices to be located where they are\ndesigned to ensure a high-quality layout extracted netlist. Use an\nassign layer as a reference layer in the device functions to define\nthe device location, that is, poly for\nnmos() and pmos(), marker\nlayer for resistors, and so on. When setting the reference layer, the\ntool attempts to place the extracted device where the reference\nlayer is drawn. However, when a reference layer is not defined, or\nwhere the reference layer must be derived, it is recommended that\nthe assign layer ancestors, which define the location, are set to\nLAYER_INTENT_DEVICE.", "gds": "Optional. Controls the reading of data from a GDSII file on a layer-by-layer\nbasis.\n\u2022 user_defined_properties. Optional. Reads the specified properties from\npolygons on this layer in the GDSII file. By default, IC Validator does not read\nany user-defined properties.\n\u25e6 double_properties. Specifies the double properties that are read from\nthe specified property numbers.\nname. Specifies the property name on the polygons in the output of the\nassign()  function.\nnumber. Specifies the property number in the GDSII file. The property\nnumber must be in the range of 0\u2013255, inclusive.", "oasis": "Optional. Controls the reading of data from an OASIS file on a layer-by-layer\nbasis.\nassign()\n\u2022 user_defined_properties. Optional. Reads the specified properties from\npolygons on this layer in the OASIS file. By default, the IC Validator tool does\nnot read any user-defined properties.\n\u25e6 double_properties. Specifies the double properties that are read from\nthe specified property numbers.\nname. Specifies the property name on the polygons in the output of the\nassign()  function..\nnumber. Specifies the property number in the OASIS file. The property\nnumber must be in the range of 0\u2013255, inclusive.", "ndm": "Optional. Controls the reading of data from an NDM library on a layer-by-\nlayer basis. This ndm  argument filters data only for the given layer. The\nndm_options()  function controls which data is read globally.\nNote:\nThe ndm  argument is ignored for non-NDM libraries.\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer\nbasis, when reading the NDM library. This option works with the\ndrc_black_box_cells, lvs_black_box_cells, and layout_view_cells\narguments of the\nndm_options()  function. See Table 16  in the assign()\nfunction section for a list of views. By default, the IC Validator tool reads all\nviews.\nTable 16 NDM views Options for assign Functions\nDESIGN_VIEW FRAME_VIEW LAYOUT_VIEW\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the NDM library. Table 17  lists the objects. By default, the\nIC Validator tool reads all objects except HORIZONTAL_TRACK_OBJECT  and\nVERTICAL_TRACK_OBJECT.\nTable 17 NDM objects Options for assign Functions\nBLOCKAGE_OBJECT BOUNDARY_OBJECT CORE_AREA_OBJECT\nHORIZONTAL_TRACK_OBJECT PATH_OBJECT PIN_OBJECT\nPOLYGON_OBJECT RECTANGLE_OBJECT ROUTE_GUIDE_OBJECT\nVIA_OBJECT VERTICAL_TRACK_OBJECT SITE_ROW_OBJECT\nassign()\n\u2022 shape_uses. Optional. Includes objects with the specified shape\nwhen reading the NDM library for this layer. You can use the\nexclude_ndm_shape_uses()  function to obtain a list of all possible shapes\nexcept those specified. By default, the IC Validator tool reads data of all\nshapes types.\nTable 18  lists the shape uses.\nTable 18 NDM shape_uses Options\nAREA_FILL_USE CORE_WIRE_USE DETAIL_ROUTE_USE\nFOLLOW_PIN_USE GLOBAL_ROUTE_USE LIB_CELL_PIN_CONNECT_USE\nMACRO_PIN_CONNECT_USE NONE OPC_USE\nPG_AUGMENTATION_USE RDL_USE RING_USE\nSHIELD_ROUTE_USE STRIPE_USE TRUNK_USE\nUNSPECIFIED USER_ROUTE_USE ZERO_SKEW_USE\n\u2022 net_types. Optional. Includes the specified net types, on a layer-\nby-layer basis, when reading the NDM library. You can use the\nexclude_ndm_net_types()  function to obtain a list of all possible net types\nexcept those specified. By default, the IC Validator tool reads data of all net\ntypes.\nTable 19  lists the net types.\nTable 19 NDM net_types Options\nANALOG_GROUND_NET ANALOG_POWER_NET ANALOG_SIGNAL_NET\nCLOCK_NET DEEP_NWELL_NET DEEP_PWELL_NET\nGROUND_NET LOGIC_0_NET LOGIC_1_NET\nNONE NWELL_NET POWER_NET\nPWELL_NET RESET_NET SCAN_NET\nSIGNAL_NET UNCONNECTED UNSET_NET\n\u2022 design_types. Optional. Includes only data from cells with the specified\ndesign types on this layer when reading the NDM library. It does not apply\nto the top cell.\nTable 20  lists the design types. By default, the tool reads all\ndesign types.\nassign()\nTable 20 NDM design_types Options\nABSTRACT_DESIGN ANALOG_DESIGN BLACK_BOX_DESIGN\nCORNER_PAD_DESIGN COVER_DESIGN DIODE_DESIGN\nEND_CAP_DESIGN FILL_DESIGN FILLER_DESIGN\nFLIP_CHIP_DRIVER_DESIGN FLIP_CHIP_PAD_DESIGN LIB_CELL_DESIGN\nMACRO_DESIGN MODULE_DESIGN PAD_DESIGN\nPAD_SPACER_DESIGN PHYSICAL_ONLY_DESIGN THREE_DIMENSIONAL_IC_DESIGN\nTSV_DESIGN VIB_DESIGN WELL_TAP_DESIGN\nRTL_DESIGN ANALYSIS_DESIGN DIE_DESIGN\nINTERPOSER_DESIGN BRIDGE_DESIGN SUBSTRATE_DESIGN\nPACKAGE_DESIGN\nThis argument works with the design_types  and exclude_design_types\narguments of the ndm_options()  function. These arguments of the\nndm_options()  function globally constrain the design types that are read.\nYou can use the exclude_ndm_design_types()  function to obtain a list of\nall possible design types except those specified by the exclude  argument.\nBy default, the IC Validator tool reads data from all design types.\n\u2022 blockage_types. Optional. Filters blockages by blockage\ntype. By default, the tool reads all blockages. You can use the\nexclude_ndm_blockage_types()  function to obtain a list of all possible\nblockage types except those specified by the exclude  argument. Table 21\nlists the blockage type options.\nTable 21 NDM blockage_types Options\nBOUNDARY_EXTERNAL_BLOCKAGE BOUNDARY_INTERNAL_BLOCKAGE CATEGORY_BLOCKAGE\nNONE OVERLAP_BLOCKAGE PLACEMENT_ALLOW_BUFFER_ON\nLY_BLOCKAGE\nPLACEMENT_ALLOW_RP_ONLY_BLOC\nKAGE\nPLACEMENT_HARD_BLOCKAGE PLACEMENT_HARD_MACRO_BLOC\nKAGE\nPLACEMENT_PARTIAL_BLOCKAGE PLACEMENT_REGISTER_BLOCKAGE PLACEMENT_SOFT_BLOCKAGE\nRC_METAL_BLOCKAGE ROUTING_ALLOW_FILL_ONLY ROUTING_ALLOW_FILL_ONLY_B\nLOCKAGE\nassign()\nROUTING_BLOCKAGE ROUTING_FOR_DESIGN_RULE_BLOCK\nAGE\nROUTING_FOR_TOP_LEVEL_BLO\nCKAGE\nROUTING_HORIZONTAL_BLOCKAGE ROUTING_VERTICAL_BLOCKAGE RPGROUP_BLOCKAGE\nSHAPING_BLOCKAGE ROUTING_FORBID_FILL_ONLY_BLOC\nKAGE\n\u2022 blockage_layers. Optional. Includes blockages and route guides with any\nof the given layer numbers in their blockage layer list. By default, there is no\nfiltering of blockages and route guides by blockage layer.\nHere is an example of the blockage_layers  argument:\naM2      = assign( { 2, 0} );\naM2_BLKG = assign( {{NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE}}, \\\nndm={blockage_layers={2},\nviews={DESIGN_VIEW, FRAME_VIEW} }\n);\n\u2022 utilization_layers. Optional. Includes route guides with any of the given\nlayer numbers in their utilization layer list. By default, there is no filtering of\nroute guides by utilization layer.\nHere is an example of the utilization_layers  argument:\naM3          = assign( { 3, 0} );\naM2_RT_GUIDE = assign( {{NDM_SYSTEM_LAYER_ROUTE_GUIDE}}, \\\nndm={utilization_layers={3},\nviews={DESIGN_VIEW, FRAME_VIEW} }\n);\n\u2022 masks. Specifies the multi-patterning mask that determine the shapes that\nare read from the NDM library. The default is no filtering by multi-patterning\nmask.\nTable 22  lists the mask options.\nTable 22 NDM Masks\nINHERIT_MASK NONE MASK_ONE MASK_TWO\nMASK_THREE MASK_FOUR MASK_FIVE MASK_SIX\nMASK_SEVEN MASK_EIGHT MASK_NINE MASK_TEN\nMASK_ELEVEN MASK_TWELVE MASK_THIRTEEN MASK_FOURTEEN\nMASK_FIFTEEN SAME_MASK\nassign()\n\u2022 read_from. Optional. Specifies whether data is read from design cell views\n(both design and frame), internal designs, or both. The default is no filtering\n({ }).\n\u25e6 VIEWS. Includes data from design cell views on this runset layer.\n\u25e6 INTERNAL_DESIGNS. Includes data from internal designs on this runset\nlayer.\n\u2022 internal_designs. Optional. Specifies the internal designs from which to\nread data for a given runset layer.\nTable 23  lists the internal design options.\nSee the internal_designs  argument of the ndm_options()  function for\nmore information.\nTable 23 NDM Internal Design Uses\nFILL_BLOCKAGE_USE FILL_USE NONE\n\u2022 route_guide_layers. Optional. Reads route guides of only the specified\nlayers. The default is to read all route guides.\n\u2022 read_internal_designs_from. Optional. Lists the internal design cells\nthat are included on the specified layer when an internal design is read.\nYou can include the top internal design cells only, all of the internal design\ncells except the top cells, or all of the internal design cells. By default, the IC\nValidator tool reads all of the internal design cells when the internal design is\nread.\n\u25e6 TOP_CELL. Includes the top internal design cells.\n\u25e6 LOWER_CELLS. Includes all of the internal design cells except the top cells.\n\u2022 keep_properties. Optional. Keeps the specified NDM properties for data\non the layer when reading the NDM library. These properties can be used\nby the write_ndm()  function to set properties on output shapes based on\ninput layer shapes they interact with. By default, the IC Validator tool does\nnot keep any properties.\n\u25e6 OWNER_NET. Keeps the net property that each shape is assigned to as\ndefined in the NDM library. Information about the net is kept, including the\nnet name and net type. This option keeps only net information for shapes\nin the top-level design view.\n\u25e6 SHAPE_USE. Keeps the shape_use  property on each shape as defined in\nthe NDM library. These properties are kept for every cell and are applied\nhierarchically.\nassign()\nIn the following example, both OWNER_NET  and SHAPE_USE  properties are\npreserved on NDM layer 31.\nm1 = assign({{31}},\nndm = {\nkeep_properties={SHAPE_USE,OWNER_NET}\n}\n);\n\u2022 user_attributes. Optional. Lists the NDM attributes that are used to filter\nshapes when reading the NDM library. Only shapes with specified attribute\nvalues are read in.\nWhen the user_attributes  argument is used, shapes matching one or\nmore of the value sets listed are kept for the runset layer. All conditions\nof a value set must be met for the shape to be considered a match. For\nexample, if a value set lists constraints for two different attributes, both must\nbe satisfied.\n\u25e6 If an attribute is specified in the runset as a different type from what is\ndefined in the NDM library, the IC Validator tool issues a warning and\ndiscards the attribute.\nWhen the user_attributes  argument is an empty list, the default, the\nIC Validator tool does not filter data by attribute.\n\u25e6 boolean_attributes. Optional. Specifies the Boolean attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  value. Specifies the Boolean value of the attribute, true  or false.\n\u25e6 double_attributes. Optional. Specifies the double attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  values. Lists the double attribute values.\n\u25e6 float_attributes. Optional. Specifies the float attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\n-  values. Lists the float attribute values.\n\u25e6 integer_attributes. Optional. Specifies the integer attributes for the\nspecified layer.\n-  name. Specifies the attribute name.\nassign()\n-  values. Lists the integer attribute values.\n\u25e6 string_attributes. Optional. Specifies string attributes for the specified\nlayer.\n-  name. Specifies the attribute name.\n-  values. Lists the string attribute values.\nFor example,\n// Select metal1 with at least one of the two following value\nsets:\n//    Value Set 1:\n//       (my_integer_prop1 <= 10 || my_integer_prop1 >= 100)\n&&\n//       (my_integer_prop2 == 50) &&\n//       (my_string_prop1 is \"Value*\", \"!ValueD\")\n//\n//    Value Set 2:\n//       (my_double_prop1 == 5.0 && my_string_prop1==\"ValueD\")\nm1_user_filtered = assign({{31}},\nndm      = {\nuser_attributes = {\n// Value set 1\n{integer_attributes = {\n{\"my_integer_prop1\", {<=10, >=100} },\n{\"my_integer_prop2\", {==50 } } } ,\nstring_attributes = {\n{\"my_string_prop1\", {\"Value*\", \"!ValueD\"} } }\n},\n// Value Set 2\n{double_attributes = {\n{\"my_double_prop1\", {==5.0 } } },\nstring_attributes = { {\"my_string_prop1\",\n{\"ValueD\"} } }\n}\n}\n}\n);\n\u2022 set_z_level. Optional. Specifies that violations involving this layer, which\nare written to In-Design error data for 3DIC Compiler, have the given z-level\nset.", "select": "Optional. Selects cells by cell name, marker layer, or both.\nassign()\n\u2022 cells. Includes the specified cells when importing the assign layer. When a\ncell is selected, its references are included. You can prefix a cell name with\nthe ! character to exclude its data and its descendant data from selection.\nString matching using metacharacters is allowed. See\nString Matching  for\nmore information. By default, the tool selects all cells.\nNote:\nExcluding the parent of a cell takes precedence over selecting a\ncell; that is, a cell is excluded if its parent is excluded.\n\u2022 marker_layers. Lists layer range and datatype range pairs. When set\nto an empty list (the default) then the marker_layers  list is ignored. The\ndata_type_range  value for each pair is optional, with a default of all\ndatatypes. See\nLayout Layer and Datatype Ranges  for information about the\nlimits of the values.\nThis option works in conjunction with the cells  option; it restricts selection to\nonly those cells that contain at least one marker layer. The cells list is pruned\nby removing any cells that do not directly (ignoring reference data) contain\nthe marker layer. Negated cells in the cells list are not pruned.\n\u2022 depth. Specifies the depth of the cell hierarchy included by the cells  and\nmarker_layers  options. The default is ALL.\n\u25e6 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u25e6 DESCENDANTS. Includes only data in the descendants of a cell, recursively.\nNo cell-level data is included unless the cell is a descendant of a cell in\nthe cells list.\n\u25e6 ALL. Includes all data in the cell and below.\n\u2022 complement. Specifies whether to include or exclude the selection performed\nby the cells  and marker_layers  options. The default is false.\n\u25e6 true. Selects all cells except for the cells specified by the cells  and\nmarker_layers  options.\n\u25e6 false. Selects the cells specified by the cells  and marker_layers\noptions.\n\u2022 polygon_property_sets. Specifies a list of sets of properties, from which a\npolygon must have at least one set, to be selected.\nassign()\n\u25e6 property_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property name\nusing the oasis_options()  function.\n\u25e6 property_values. Specifies a list of string values that must be\nassociated with the given property number.\n\u25e6 match. Specifies whether a given option matches a property from the\nGDSII or OASIS formats. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list must\nmatch a value related to the property in the GDSII or OASIS properties.\nThis matching of values is bidirectional, so there must be an equal\nnumber of values in both properties, and they all must match. Currently,\nonly string values are supported. String matching is performed using the\nstandard IC Validator regular expression matching.\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\n- SUPERSET. Specifies that the value must be a superset of the GDSII or\nOASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u2022 exclude_polygon_property_set. Specifies a set of properties that,\nif contained by a polygon, is not selected. This option supersedes the\npolygon_property_sets  option.\n\u25e6 property_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property name\nusing the oasis_options()  function.\n\u25e6 property_values. Specifies a list of values that must be associated with\nthe given property number.\n\u25e6 match. Specifies whether a given option matches a property from the\nGDSII or OASIS formats. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list must\nmatch a value related to the property in the GDSII or OASIS properties.\nThis matching of values is bidirectional, so there must be an equal\nnumber of values in both properties, and they all must match. Currently,\nonly string values are supported. String matching is performed using the\nstandard IC Validator regular expression matching.\nassign()\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\n- SUPERSET. Specifies that the value must be a superset of the GDSII or\nOASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u2022 geometry_exclude. Removes the shapes that match the\ngeometry_exclude_type  argument of geometry_exclude  from assigned\nunmerged layers and output remaining merged patterns.\n\u25e6 CIRCLE. Selects polygons that are an approximation of a circle.\n\u25e6 STADIUM. Selects polygons that fulfill the criteria to be considered a\nstadium.\n\u25e6 TEARDROP. Selects polygons that fulfill the criteria to be considered a\nteardrop.\n\u2022 placement_sets. Specifies a list of placement names and properties, from\nwhich a placement must match at least one name or property to be selected.\n\u25e6 cells. Specifies a list of cell names of placements that are selected.\n\u25e6 property_sets. Specifies a list of sets of properties, from which a\nplacement must have at least one set to be selected.\n\u25aa property_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property\nname using the oasis_options()  function.\n\u25aa property_values. Specifies a list of string values that must be\nassociated with the given property number.\n\u25aa match. Specifies whether a given option matches a property from the\nGDSII or OASIS formats. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list\nmust match a value related to the property in the GDSII or OASIS\nproperties. This matching of values is bidirectional, so there must\nbe an equal number of values in both properties, and they all must\nmatch. Currently, only string values are supported. String matching\nis performed using the standard IC Validator regular expression\nmatching.\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\nassign()\n- SUPERSET. Specifies that the value must be a superset of the GDSII\nor OASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u25e6 instance_names. Specifies a list of instance names in which a placement\nmust match to be selected.\n\u25e6 depth. Specifies the depth of the cell hierarchy included by the cells\nproperty_sets, and instance_names  arguments. . The default is\nCELL_LEVEL.\n\u25aa CELL_LEVEL. Includes only the geometric data in the cell; no\ndescendants are included unless they are also in the cells list.\n\u25aa DESCENDANTS. Includes only data in the descendants of a cell,\nrecursively. No cell-level data is included unless the cell is a\ndescendant of a cell in the cells list.\n\u25aa ALL. Includes all data in the cell and below.\n\u25e6 exclude_property_set. Specifies a set of properties that, if\ncontained by a placement, is not selected. This option supersedes the\nproperty_sets  option of the placement_sets  argument.\n\u25aa property_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property\nname using the oasis_options()  function.\n\u25aa property_values. Specifies a list of string values that must be\nassociated with the given property number.\n\u25aa match. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list\nmust match a value related to the property in the GDSII or OASIS\nproperties. This matching of values is bidirectional, so there must\nbe an equal number of values in both properties, and they all must\nmatch. Currently, only string values are supported. String matching\nis performed using the standard IC Validator regular expression\nmatching.\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\nassign()\n- SUPERSET. Specifies a superset of the GDSII or OASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u2022 exclude_placement_set. Specifies placement names or properties to\nexclude from selection.\n\u25e6 cells. Specifies a list of cell names of placements that are excluded from\nselection.\n\u25e6 property_sets. Specifies a list of sets of properties, from which a\nplacement must have at least one set, to be excluded from selection. This\noption supersedes the placement_sets  argument.\nproperty_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property name\nusing the oasis_options()  function.\nproperty_values. Specifies a list of string values that must be\nassociated with the given property number.\nmatch. Specifies whether a given option matches a property from the\nGDSII or OASIS formats. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list must\nmatch a value related to the property in the GDSII or OASIS properties.\nThis matching of values is bidirectional, so there must be an equal\nnumber of values in both properties, and they all must match. Currently,\nonly string values are supported. String matching is performed using the\nstandard IC Validator regular expression matching.\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\n- SUPERSET. Specifies a superset of the GDSII or OASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u25e6 exclude_property_set. Specifies a set of properties that, if\ncontained by a placement, is not excluded. This option supersedes the\nproperty_sets  option of the exclude_placement_set  argument.\nproperty_number. Specifies a property number that is directly from\nGDSII or OASIS properties, or is mapped from an OASIS property name\nusing the oasis_options()  function.\nassign()\nproperty_values. Specifies a list of string values that must be\nassociated with the given property number.\nmatch. Specifies whether a given option matches a property from the\nGDSII or OASIS formats. The default is ALL.\n- ALL. Defines a match as every value in the property_values  list must\nmatch a value related to the property in the GDSII or OASIS properties.\nThis matching of values is bidirectional, so there must be an equal\nnumber of values in both properties, and they all must match. Currently,\nonly string values are supported. String matching is performed using the\nstandard IC Validator regular expression matching.\n- ALL_SAME_ORDER. Specifies that the order of the values in both the\nrunset and the GDSII or OASIS property must be identical.\n- SUPERSET. Specifies a superset of the GDSII or OASIS property.\n- SUBSET. Specifies that the value must be a subset of the GDSII or\nOASIS property.\n\u2022 geometry_match. Specifies how geometric matching is performed between\nplaced cells from the original (tree0) hierarchy and unplaced cells, when\nthe main library is GDSII or OASIS, or golden library cells. By default, no\ngeometric matching is performed.\nCells match geometrically when a Boolean XOR of all required layers shows\nno differences. To be a required layer, a layer must be both:\n- assigned in the runset\n- used in at least one selected violation, used connectivity definition, or\noutput function, such as write_oasis()  or write_gds()\nIf a cell differs from the baseline only on a layer which is not used in the\nrunset, either because it is not assigned, or because the violations using it\nare unselected, the cells are considered to match geometrically. This means\nthat the result of assign statements using geometry_match  might change\nwhen a subset of violations is selected.\n\u25e6 baseline_cells. Optional. Specifies a list of cell names to use as a\nreference for geometric matching. String matching using metacharacters\nis allowed. See\nString Matching  on page 3353 for more information.\nNote:\nWhen you use this option, you cannot use the cells  option of\nthe select  argument.\nassign()\n\u25e6 baseline_sources. Optional. Specifies the source library type or\ntypes that IC Validator should use for the baseline cells. The default is\nGOLDEN_LIBRARY.\n- GOLDEN_LIBRARY. Baseline cells matching the name specifications\nfrom the baseline_cells  argument are selected from one of the golden\nlibraries specified by the golden_libraries  argument of the\nlibrary()\nfunction.\n- INPUT_LIBRARY. Baseline cells matching the name specifications from\nthe baseline_cells  argument are selected from unplaced cells in the\ninput library.\nIC Validator creates some internal data that is used for geometric\nmatching with golden libraries. By default, this data is calculated for\neach run. When the same set of golden libraries and runset settings are\nused for several runs, performance might be improved by caching this\ndata. You can enable caching by setting the ICV_MATCH_GOLDEN_CACHE\nenvironment variable to the full path to a directory where the golden\nlibrary cache is stored,\nsetenv ICV_MATCH_GOLDEN_CACHE full path to cachedirectory\nThis cache directory can be shared by multiple users. New data\nis saved for each combination of golden libraries and assign\nlayers (which can result from different runset settings). To limit the\nmaximum allowed size for the golden layer signatures cache, set the\nICV_MATCH_GOLDEN_CACHE_SIZE  environment variable to the maximum\nsize in MB.\nsetenv ICV_MATCH_GOLDEN_CACHE_SIZE size in MB\nThe default size is 200 MB. The tool reports in the dp.log file whether\ncached golden layer signatures were used in the run, or if new signatures\nwere computed and saved to the cache. The tool also displays warning\nmessages if the cache path or directory cannot be created, is not\nreadable or writable, or exceeds the size limit.\n\u2022 geometry_select. Optional. Enables polygon selection by geometry type.\nOnly the polygons that match the specified geometry type are selected and\nappear in the output layer. To be selected each geometry must be a single\npolygon. Polygons are not merged before recognition.\nNote:\nIf several polygons overlap and all individually meet the selected\ncriteria, then they are all output, even though the merged result\nmight not match the criteria. Merged data can be checked with\nassign()\nthe circles(), octagons(), stadiums(), and teardrops()\ncommands.\nThe default geometry_type  is NONE, meaning no geometry filtering is\nperformed.\n\u25e6 geometry_type. Required for geometry_select.\n- NONE. Does not select polygons by geometry type\n- CIRCLE. Selects polygons that are an approximation of a circle and\nmatch the following criteria:\n\u25aa The number of polygon vertices is greater than four.\n\u25aa The distance between the center of the extent of the polygon and\nevery polygon vertex varies by less than one percent.\n\u25aa The interior angle at each vertex varies by less than one percent.\n\u25aa The area of the polygon is greater than 75 percent of the area of a\ncircle whose radius is equal to the distance between the center of\nthe extent of the polygon and one of its vertices (after the preceding\ncriteria for a circle are met).\n- ANNULUS. Selects polygons that are an approximation of annuli (rings),\nwhich are regions formed by two concentric circles, or approximations of\ncircles. The following criteria must be met:\n\u25aa The polygon has exactly one \u201chole.\u201d\n\u25aa The vertices of the polygon satisfy the criteria of a circle (as previously\ndefined) for both the inner and outer boundaries.\n\u25aa The difference between the minimum and maximum thickness of\nthe polygon must be less than one percent, where thickness is the\ndifference between the inner and outer radii of the shape.\n- STADIUM. Selects polygons that are an approximation of a \u201cstadium\u201d or\n\u201cracetrack\u201d shape. The following criteria must be met:\n\u25aa The number of polygon vertices is greater than or equal to 8.\n\u25aa The polygon contains two parallel edges that define an orthogonal or\na 45-degree rectangle. An angle tolerance can be specified using the\nstadium_parameters  keyword.\n\u25aa The polygon contains vertices on two opposite sides of the rectangle\nthat define approximations of acceptable semicircles. The \u201cacceptable\nsemicircles\u201d is determined by treating both approximation regions\nassign()\nas if they abut, and then checking them against the CIRCLE  criteria\npreviously specified. A radius length variation tolerance can be\nspecified using the stadium_parameters  keyword.\n- OCTAGON. An octagon is formed by a figure with eight straight sides and\neight angles. When this option is specified, the output of assign()  exists\nas octagon-like polygons. The following criteria must be met, for more\ninformation see part (d) of\nFigure 19.\n\u25aa The vertex number must be equal to 8.\n\u25aa The diameter (length from a point to the third point after the point)\nmust vary by less than one percent.\n\u25aa The top and bottom sides must be horizontal, while the leftmost and\nrightmost sides are vertical. All the four sides must be within one\ndegree tolerance.\n\u25aa The interior angle of the octagon must vary by less than one percent.\n- TEARDROP. A teardrop is formed by concatenating a circle and a triangle.\nWhen this option is specified, the output of assign()  exists as teardrop-\nlike polygons. The following criteria must be met, for more information see\npart (b) of\nFigure 19:\n\u25aa The vertex number must be greater or equal to 32.\n\u25aa The circle radius (length from the circle center, c, to each vertex,\nr, except for the peak triangle vertex) must vary by less than one\npercent.\n\u25aa The length from the circle center, c, to the peak triangle vertex, P, must\nbe greater than 1.1 * circle radius, r.\n\u25aa The lengths from the peak triangle vertex to its two adjacent vertices,\nL1  and L2, must differ by less than one percent.\n\u25aa In the circular portion, the interior angle between adjacent edges, \u03b1,\nmust vary by less than four percent.\n-ROUTE_LINE. A route line identifies line objects from assigned unmerged\nlayers and outputs selected merge line patterns. It excludes circle,\noctagon, and teardrop shapes and selects the routing line candidates\nfrom the remaining shapes.\n\u25e6 stadium_parameters. Optional. Specifies parameters that modify the\ncriteria used to select STADIUM  shapes. If geometry_type  is not STADIUM,\nthey are ignored.\nassign()\n\u25aa angle_tolerance_45. Specifies a floating-point number between\nzero and one, which identifies the number of degrees variation that\nthe 45-degree sides might differ and still be considered a 45-degree\nrectangle. A default tolerance of one percent (0.45 degrees) is applied\nif this option is not specified.\n\u25aa radial_tolerance. Specifies a positive number, represented in user\nunits, that modifies the CIRCLE  criteria (applied to the semicircular\nregions), so the allowed difference between the largest and smallest\nradii (distance between the center of the extent and each vertex) is\nless than or equal to the specified value. When this is not specified, a\ndefault tolerance of 1 percent of the radii is applied.\n\u25e6 teardrop_parameters. Optional. Specifies parameters that modify the\ncriteria used to select TEARDROP  shapes. These parameters alter only\nthe TEARDROP  shape selection, and are ignored if geometry_type  is not\nTEARDROP. See part(b) and part(c) of\nFigure 19.\n\u25aa radius. Optional. Specifies the radius of the circle, r, that encloses the\nvertices, except for the peak vertex, P.\n\u25aa peak_length. Optional. Specifies the length from the circle center, c,\nto the peak point, P.\n\u25aa side_length. Optional. Specifies the length of the legs for the\nisosceles triangle, L1  and L2. For cropped teardrops, this option\nmeasures the length from the intersection point of the two cropped\nside edges to the points on the circle. If the legs are not equal length\nfor some numerical error, extract the larger one to compare with input\nconstraint.\n\u25aa tolerance. Optional. Specifies the expansion values to the original\nradius, peak_length, and side_length  constraints. Only valid if\nradius, side_length, or peak_length  is specified.\n\u25aa type. Optional. Specifies the teardrop variants to select. The default is\nSTANDARD.\n\u25aa STANDARD. Select only intact teardrops.\n\u25aa CROPPED. Select only line cropped teardrops. Note that the two\nangles of the cropped corners should be the same.\n\u25aa ALL. Select both STANDARD  and CROPPED  teardrops.\n\u25e6 route_line_parameters. Optional. Specifies parameters that modify the\ncriteria used to select ROUTE_LINE  shapes.\nassign()\n\u25aa tolerance. Optional. Specifies a value between 0.0 and 1.0, which\nidentifies the number of degrees that two parallel edges' angle might\ndiffer and still be considered as parallel edges. Each pair of parallel\nedges forms a single line part to the ROUTE_LINE. The default is 1.0\ndegree.\n\u25aa max_width. Optional. Specifies a value less than 101 \u00b5m. This\nidentifies the width of the rectangle, which is the distance between two\nparallel edges. Each pair of parallel edges forms a single line part to\nthe ROUTE_LINE. The default is 101 um.\n\u25aa line_ends_only. Optional. Specifies if only line ends must be output.\nThe default is false.\nFigure 18 Examples of Selectable Geometries\nFigure 19 Diagram showing measurements used to recognize the geometries.\na) circle, b)teardrop, c) truncated teardrop, d) octagon\nNote:\nTeardrops must have at least 32 vertices. Fewer vertices are used\nin the figure to make the figure clearer.\nassign()", "exclude_from_keepout_check_in_drc_black_box": "Optional. Specifies assign layers to be excluded from and_overlap  checking.\nThe default is false. See the keepout_layers_check  option of the\ndrc_black_box_options()  function for more information.", "delete_exploded_data": "Optional. Specifies whether exploded data in the polygon layer is removed\nduring hierarchy preprocessing. Data is not removed from cells that are not\nexploded. The default is false."}, "summary": "The assign()  function assigns data found on specified layers in the layout to a polygon-\nlayer variable.", "function_name": "assign()"}
{"description": "The assign_edge()  function assigns an edge-layer variable to data found on specified\nlayers in the layout. This function reads only zero width paths and the boundaries of\nMilkyway or NDM cell site rows, and ignores all other geometric data. Data assigned to the\nlayer can be restricted to data of a specified datatype.\nSee the\nassign_openaccess_edge()  function for an assign function that is specific to\nthe OpenAccess format. The assign_openaccess_edge()  accepts layer and purpose\nnames as arguments, rather than numeric layer and datatype ranges. If you use the\nassign_edge()  function for OpenAccess data, you must specify an OpenAccess layer\nmapping file in the\nopenaccess_options()  function.", "syntax": "assign_edge(\nldt_list   = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},\n...},\nmilkyway   = {views               = {\"string\", ...},\nobjects             = {object_type, ...},\ncell_types          = {cell_type, ...},\nnet_types           = {net_type, ...},\nroute_types         = {route_type, ...},\nread_fill_view_from = {TOP_CELL, LOWER_CELLS}\n},                                             //optional\nopenaccess  = {objects = {ARC, LINE, PATH, PATH_SEGMENT},    //optional\ncolors  = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME}},              //optional\ngrid_check = {resolution = double,\ncheck_45   = {POLYGON, PATH},\ncheck_90   = {POLYGON, PATH},\nresolution_violation_comment = \"string\",\ncheck_45_violation_comment = \"string\",\ncheck_90_violation_comment = \"string\"},\n//optional\nlibraries  = {library},                                     //optional\nname       = \"layer_label\",                                 //optional\nedges      = {{coordinates = {{{x = double, y = double}, ...}, ...},\ncell        = \"string\"}, ...},               //optional\nndm         = {views            = {view_type, ...},\nobjects          = {object_edge_type, ...},\nshape_uses       = {shape_use_type, ...},\nnet_types        = {net_type, ...},\ndesign_types     = {design_type, ...},\nmasks            = {ndm_mask, ...},\nread_from        = {assign_ndm_read_from, ...},\nassign_edge()\ninternal_designs = {ndm_internal_design_use, ...},\nread_internal_designs_from = {TOP_CELL, LOWER_CELLS}\n}                                              //optional\n);", "returns": "edge layer", "arguments": {"ldt_list": "Required. Lists the layer range and datatype range pairs. The\ndata_type_range  value for each pair is optional, with a default of all datatypes.\nSee\nLayout Layer and Datatype Ranges  for information about the limits of the\nvalues.\nNote:\nYou can use the assign_layer_out_of_range  argument of the\nrun_options()  function to specify the behavior of the IC Validator\ntool when an assign function contains layer or datatype numbers\nthat are greater than the maximum allowed range of the input library\nformat.\nFor NDM libraries, lists the layer range and layer purpose range pairs. The\ndata_type_range  value, which is the layer purpose, for each pair is optional,\nwith a default of all datatypes. See\nLayout Layer and Datatype Ranges  for\ninformation about the limits of the values.", "milkyway": "Optional. Controls the reading of data from a Milkyway library on a layer-\nby-layer basis. This argument works with the drc_black_box_cells  and\nlvs_black_box_cells  arguments of the\nmilkyway_options()  function. These\narguments of the milkyway_options()  function control the views on a cell-by-\ncell basis.\nNote:\nThe milkyway  argument is ignored for non-Milkyway libraries.\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer basis, from\na Milkyway library. By default, the IC Validator tool reads all views.\nNote:\nAny number of views can be referenced in the Milkyway library.\nThe maximum combined number of unique view names used in all\nassign functions in the runset is 32.\nassign_edge()\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the Milkyway library. Table 24  lists the objects. By default,\nthe IC Validator tool reads all objects except HORIZONTAL_WIRE_TRACK  and\nVERTICAL_WIRE_TRACK.\nTable 24 Milkyway objects Options for the assign_edge() Function\nCELL_ROW HORIZONTAL_WIRE_TRACK HORIZONTALWIRE PATH\nVERTICAL_WIRE_TRACK VERTICALWIRE\n\u2022 cell_types. Optional. Includes the specified cell types, on a layer-\nby-layer basis, when reading the Milkyway library. This argument\nworks with the cell_types  and exclude_cell_types  arguments\nof the\nmilkyway_options()  function. These arguments of the\nmilkyway_options()  function globally constrain the cell types that are read.\nYou can use the exclude_milkyway_cell_types()  function to obtain a list\nof all possible cell types except those specified by the exclude  argument. By\ndefault, the IC Validator tool reads data from all cell types. See Table 56  for a\nlist of cell types.\n\u2022 net_types. Optional. Includes the specified net types, on a layer-by-layer\nbasis, when reading the Milkyway library. This argument works with the\nnet_types  argument of the\nmilkyway_options()  function. This argument\nof the milkyway_options()  function globally constrains the net types that\nare read. You can use the exclude_milkyway_net_types()  function to\nobtain a list of all possible net types except those specified. By default, the\nIC Validator tool reads data of all net types. See\nTable 57  for the list of net\ntypes.\n\u2022 route_types. Optional. Includes the specified route types, on a layer-by-\nlayer basis, when reading the Milkyway library. This argument works with the\nroute_types  argument of the\nmilkyway_options()  function. This argument\nof the milkyway_options()  function globally constrains the route types that\nare read. You can use the exclude_milkyway_route_types()  function to\nobtain a list of all possible route types except those specified. By default, the\nIC Validator tool reads all route types. See\nTable 59  for a list of route types.\nNote:\nThe route type is only used for the shapes PATH,\nHORIZONTALWIRE, and VERTICALWIRE, as specified in the objects\nargument.\n\u2022 read_fill_view_from. Optional. Lists the fill cells that are included on the\nspecified layer when the fill view is read. You can include the top fill cells\nassign_edge()\nonly, all of the fill cells except the top cells, or all of the fill cells. By default,\nthe IC Validator tool reads all of the fill cells when the fill view is read.\n\u25e6 TOP_CELL. Includes the top fill cells.\n\u25e6 LOWER_CELLS. Includes all of the fill cells except the top cells.", "openaccess": "Optional. Controls the reading of data from an OpenAccess database on a layer-\nby-layer basis.\nNote:\nThis argument is ignored for non-OpenAccess databases.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the OpenAccess database. By default, the IC Validator tool\nreads all objects.\n\u2022 colors. Optional. Lists OpenAccess library color attributes that are included,\non a layer-by-layer basis, when reading the OpenAccess library. Only\nshapes with the color attributes listed are read for this layer.\nTable 25  lists\nthe attributes. By default, the IC Validator tool reads data of all color attribute\nvalues.\nTable 25 OpenAccess Color Attributes\nGRAY MASK_ONE_UNLOCKED MASK_ONE_LOCKED MASK_TWO_UNLOCKED\nMASK_TWO_LOCKED MASK_THREE_UNLOCKED MASK_THREE_LOCKED BLACK\nMULTI SAME\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. See the openaccess_options()  function for more\ninformation.", "grid_check": "Optional. Overrides the values specified in the layout_grid_options()\nfunction in the specific layer. Any values that are unspecified default to the\ncorresponding value specified in the layout_grid_options()  function.\nassign_edge()\n\u2022 resolution. Optional. Inspects the layer for off-grid data when set to a\nvalue greater than the input library resolution. The default is the resolution\nspecified in the\nlayout_grid_options()  function.\n\u2022 check_45. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 45 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 45\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 45 degrees.\n\u2022 check_90. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 90 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 90\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 90 degrees.\n\u2022 resolution_violation_comment. Optional. Specifies the violation\ncomment for the resolution  errors in the specific layer. The default is the\nresolution_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_45_violation_comment. Optional. Specifies the violation\ncomment for the check_45  errors in the specific layer. The default is the\ncheck_45_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_90_violation_comment. Optional. Specifies the violation\ncomment for the check_90  errors in the specific layer. The default is the\ncheck_90_violation_comment  specified in the layout_grid_options()\nfunction.\nassign_edge()", "libraries": "Optional. Specifies the libraries. An assign function uses only layers from\nthis library. The library is defined by the return value of the\nlibrary()  or\nlibrary_import()  function.\nNote:\nThe list can contain only one library.\nThe libraries  argument is required if you use the library_import()  function\nand the argument is prohibited if you do not use the library_import()\nfunction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edges": "Optional. Lists the edges created in the specified cells. Edges are added as data\nis read into cells, and polygons are treated as if they are direct input from the\nlayout. Therefore, arguments, such as the magnification_factor  argument\nof the\nlibrary()  function, that transform the input layout data is applied to the\nedges that are created. Data counts in the tree files include these edges.\nIf a cell name does not exist in the input layout, the name is ignored. If a cell\nname is not specified, the edges in the associated list are created in the top cell.\nNote:\nIf you are using the\nlibrary_import()  function, the magnification\nfactor specified in the library  argument of the assign_edge()\nfunction is applied.\nIf you are using the library_import()  function and no cell name is\nspecified, edges are created in the top cell of the library specified in\nthe library  argument of the assign_edge()  function.", "ndm": "Optional. Controls the reading of data from an NDM library on a layer-by-\nlayer basis. This ndm  argument filters data only for the given layer. The\nndm_options()  function controls which data is read globally.\nNote:\nThe ndm  argument is ignored for non-NDM libraries.\nassign_edge()\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer\nbasis, when reading the NDM library. This option works with the\ndrc_black_box_cells, lvs_black_box_cells, and layout_view_cells\narguments of the\nndm_options()  function. See Table 16  in the assign()\nfunction section for a list of views. By default, the IC Validator tool reads all\nviews.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer\nbasis, when reading the NDM library.\nTable 26  lists the objects. By default,\nthe IC Validator tool reads all objects except HORIZONTAL_TRACK  and\nVERTICAL_TRACK.\nTable 26 NDM objects Options for assign_edge() Function\nHORIZONTAL_TRACK LINE PATH VERTICAL_TRACK\nSITE_ROW\n\u2022 shape_uses. Optional. Specifies the shape when reading the NDM library for\nthis layer. You can use the exclude_ndm_shape_uses()  function to obtain a\nlist of all possible shapes except those specified. By default, the IC Validator\ntool reads data of all shapes types. See\nTable 18  in the assign()  function\nsection for a list of shape uses.\n\u2022 net_types. Optional. Includes the specified net types, on a layer-\nby-layer basis, when reading the NDM library. You can use the\nexclude_ndm_net_types()  function to obtain a list of all possible net types\nexcept those specified. By default, the IC Validator tool reads data of all net\ntypes.\nTable 19  in the assign()  function section lists the net types.\n\u2022 design_types. Optional. Includes only data from cells with the specified\ndesign types on this layer when reading the NDM library. It does not apply to\nthe top cell.\nTable 20  in the assign()  function lists the types. By default, the\ntool reads all design types.\n\u2022 masks. Specifies the multi-patterning mask that determine the shapes that\nare read from the NDM library. The default is not to set a multi-patterning\nmask.\nTable 22  in the assign()  function section lists the mask options.\n\u2022 read_from. Optional. Specifies whether data is read from design cell views\n(both design and frame), internal designs, or both. The default is no filtering\n({ }).\n\u25e6 VIEWS. Includes data from design cell views on this runset layer.\n\u25e6 INTERNAL_DESIGNS. Includes data from internal designs on this runset\nlayer.\nassign_edge()\n\u2022 internal_designs. Optional. Specifies the internal designs from which to\nread data for a given runset layer. Table 23  in the assign()  function section\nlists the internal design options. See the internal_designs  argument of the\nndm_options()  function for more information.\n\u2022 read_internal_designs_from. Optional. Lists the internal design cells\nthat are included on the specified layer when an internal design is read.\nYou can include the top internal design cells only, all of the internal design\ncells except the top cells, or all of the internal design cells. By default, the IC\nValidator tool reads all of the internal design cells when the internal design is\nread.\n\u25e6 TOP_CELL. Includes the top internal design cells.\n\u25e6 LOWER_CELLS. Includes all of the internal design cells except the top cells."}, "summary": "The assign_edge()  function assigns an edge-layer variable to data found on specified\nlayers in the layout.", "function_name": "assign_edge()"}
{"description": "The assign_layout()  function assigns data found on specified layers in the layout to\na layout-layer variable. This function reads only positive-width paths and polygons, and\nignores zero-width paths. Data assigned to the layout-layer variable can be restricted to\ndata of a specified datatype. Polygons in the layer are not merged together, regardless of\ntheir position in the layout hierarchy. Polygons exploded from cells remain unmerged in the\nparent cell.", "syntax": "assign_layout(\nldt_list    = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},      //optional\n...},\nopenaccess    = {objects = {DONUT, DOT, ELLIPSE, PATH, PATH_SEGMENT,\nPIN, POLYGON, RECTANGLE},\nblockage_types = {openaccess_blockage_type, ...},\narea_boundary_names = {\"string\", ...},      //optional\ncolors = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME}},             //optional\ngrid_check    = {resolution = double,\ncheck_45   = {POLYGON, PATH},\ncheck_90   = {POLYGON, PATH},\npath_check = CENTERLINE | BOUNDARY,\nresolution_violation_comment = \"string\",\ncheck_45_violation_comment = \"string\",\ncheck_90_violation_comment = \"string\"},\n//optional\npolygons     = {{coordinates = {{{x = double, y = double}, ...}, ...},\ncell        = \"string\"}, ...},             //optional\nlibraries    = {library},                                   //optional\nname         = \"layer_label\",                               //optional\nlayer_intent  = {LAYER_INTENT_METAL, LAYER_INTENT_FILL,\nLAYER_INTENT_INTERCONNECT,\nLAYER_INTENT_BASE, LAYER_INTENT_VIA,\nLAYER_INTENT_COLORED_SUBSET,\nLAYER_INTENT_DEVICE},                       //optional\ngds      = {\nuser_defined_properties = {{\ndouble_properties = {{name   = \"string\",\nnumber = integer}, ...},\nstring_properties = {{name   = \"string\",\nnumber = integer}, ...}}, ...}\n},                                               //optional\noasis   = {\nuser_defined_properties = {{\nassign_layout()\ndouble_properties = {{name   = \"string\",\nnumber = integer}, ...},\nstring_properties = {{name   = \"string\",\nnumber = integer}, ...}}, ...}\n},                                               //optional\nselect  = {cells = {\"string\", ...},\ndepth = CELL_LEVEL,\ngeometry_select  = {\ngeometry_type    =\nNONE  | CIRCLE | ANNULUS |\nSTADIUM | OCTAGON | TEARDROP,\nstadium_parameters = {angle_tolerance_45 = double,\nradial_tolerance\n= double}, //optional\nteardrop_parameters = {\nradius = doubleconstraint\n= double, // optional\npeak_length = doubleconstraint\n= double, // optional\nside_length = doubleconstraint\n= double, // optional\ntolerance = double, // optional\ntype = {\nSTANDARD, CROPPED,\nALL}, //optional\n} // optional\n}\n},\nexclude_from_keepout_check_in_drc_black_box  = true | false,\n//optional\ndelete_exploded_data                         = true | false\n//optional\n);", "returns": "layout layer", "arguments": {"ldt_list": "Required. Lists the layer range and datatype range pairs. The\ndata_type_range  value for each pair is optional, with a default of all datatypes.\nSee\nLayout Layer and Datatype Ranges  for information about the limits of the\nvalues.\nNote:\nYou can use the assign_layer_out_of_range  argument of the\nrun_options()  function to specify the behavior of the IC Validator\ntool when an assign function contains layer or datatype numbers\nthat are greater than the maximum allowed range of the input library\nformat.\nassign_layout()", "openaccess": "Optional. Controls the reading of data from an OpenAccess database on a layer-\nby-layer basis.\nNote:\nThis argument is ignored for non-OpenAccess databases.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the OpenAccess database. By default, the IC Validator tool\nreads all objects.\n\u2022 blockage_types. Optional. Filters objects by blockage type. The\noaBlockage objects have an associated blockage type; other types of objects\ndo not. By default, the IC Validator tool reads all objects.\nNote:\nSee the\nopenaccess_options()  function for more information\nabout reading oaBlockage objects.\nTable 27  lists the blockage type options.\nTable 27 OpenAccess Blockage Types\nOption Blockage type\nFEEDTHRU_BLOCKAGE FEEDTHRU\nFILL_BLOCKAGE FILL\nNONE Read objects without a blockage type\nPIN_BLOCKAGE PIN\nPLACEMENT_BLOCKAGE PLACEMENT\nROUTING_BLOCKAGE ROUTING\nSCREEN_BLOCKAGE SCREEN\nSLOT_BLOCKAGE SLOT\nVIA_BLOCKAGE VIA\nWIRING_BLOCKAGE WIRING\n\u2022 area_boundary_names. Optional. Filters objects by area boundary name.\nThe oaAreaBoundary objects can have an associated name; other types\nof objects do not. See the\nopenaccess_options()  function for more\nassign_layout()\ninformation about reading oaAreaBoundary objects. String matching using\nmetacharacters is allowed. See\nString Matching  for more information. By\ndefault, the IC Validator tool reads all objects.\n\u2022 colors. Optional. Lists OpenAccess library color attributes that are included,\non a layer-by-layer basis, when reading the OpenAccess library. Only\nshapes with the color attributes listed are read for this layer.\nTable 28  lists\nthe attributes. By default, the IC Validator tool reads data of all color attribute\nvalues.\nTable 28 OpenAccess Color Attributes\nGRAY MASK_ONE_UNLOCKED MASK_ONE_LOCKED MASK_TWO_UNLOCKED\nMASK_TWO_LOCKED MASK_THREE_UNLOCKED MASK_THREE_LOCKED BLACK\nMULTI SAME\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. See the openaccess_options()  function for more\ninformation.", "grid_check": "Optional. Overrides the values specified in the layout_grid_options()\nfunction in the specific layer. Any values that are unspecified default to the\ncorresponding value specified in the layout_grid_options()  function.\n\u2022 resolution. Optional. Inspects the layer for off-grid data when set to a\nvalue greater than the input library resolution. The default is the resolution\nspecified in the\nlayout_grid_options()  function.\n\u2022 check_45. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 45 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 45\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 45 degrees.\nassign_layout()\n\u2022 check_90. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 90 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 90\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 90 degrees.\n\u2022 path_check. Optional. Checks the specified path feature in the specific layer.\nThe default is the path feature specified in the layout_grid_options()\nfunction.\n\u25e6 CENTERLINE. Specifies that only the centerline of the path, before\npath expansion, is checked for violations in accordance with the other\nargument settings.\n\u25e6 BOUNDARY. Specifies that the resulting boundary, after path expansion,\nis checked for violations in accordance with the other argument settings.\nPath width checking is disabled with this setting.\n\u2022 resolution_violation_comment. Optional. Specifies the violation\ncomment for the resolution  errors in the specific layer. The default is the\nresolution_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_45_violation_comment. Optional. Specifies the violation\ncomment for the check_45  errors in the specific layer. The default is the\ncheck_45_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_90_violation_comment. Optional. Specifies the violation\ncomment for the check_90  errors in the specific layer. The default is the\ncheck_90_violation_comment  specified in the layout_grid_options()\nfunction.", "polygons": "Optional. Lists the polygons created in the specified cells. The polygons\nare added as data is read into cells, and polygons are treated as if they\nare direct input from the layout. Therefore, arguments, such as the\nmagnification_factor  argument of the\nlibrary()  function, that transform\ninput layout data is applied to the polygons that are created. Data counts in the\ntree files include these polygons.\nassign_layout()\nIf a cell name does not exist in the input layout, the name is ignored. If a cell\nname is not specified, the polygons in the associated list are created in the top\ncell. A list of two coordinates is considered a rectangle.\nNote:\nIf you are using the\nlibrary_import()  function, the magnification\nfactor specified in the libraries  argument of the assign_layout()\nfunction is applied.\nIf you are using the\nlibrary_import()  function and no cell name is\nspecified, polygons are created in the top cell of the library specified\nin the libraries  argument of the assign_layout()  function.\nHere is an example of the polygons  argument:\nm1 = assign_layout({{==1}},\npolygons = {\n// Two rectangles in the top cell\n{{\n{{1.0, 1.0}, {2.0, 2.0}},\n{{3.0, 3.0}, {4.0, 4.0}}\n}},\n// Two rectangles in cell A\n{cell = \"A\",\ncoordinates = {\n{{1.0, 1.0}, {2.0, 2.0}, {2.0, 3.0}, {1.0,\n3.0}},\n{{3.0, 3.0}, {4.0, 4.0}}\n}}\n}\n);", "libraries": "Optional. Specifies the library. An assign function uses only layers from\nthis library. The library is defined by the return value of the\nlibrary()  or\nlibrary_import()  function.\nNote:\nThe list can contain only one library.\nThe libraries  argument is required if you use the library_import()  function\nand the argument is prohibited if you do not use the library_import()\nfunction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nassign_layout()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "layer_intent": "Optional. Specifies the following layer types:\nLAYER_INTENT_METAL.\nLAYER_INTENT_FILL\nLAYER_INTENT_INTERCONNECT\nLAYER_INTENT_BASE\nLAYER_INTENT_VIA\nLAYER_INTENT_COLORED_SUBSET\nLAYER_INTENT_DEVICE\nYou can list more than one type. For example, a layer can be of type\nLAYER_INTENT_METAL  and LAYER_INTENT_INTERCONNECT. The default is\nunspecified intent.\nNote:\nThe LAYER_INTENT_BASE  layer type provides identical functionality to\nthe LAYER_INTENT_DEVICE  layer type, and it is maintained for legacy\nsupport.\nThe LAYER_INTENT_DEVICE  type provides the tool with information about which\nlayers are used to derive device body layers. This ensures a hierarchically\ncorrect location for the device by maintaining, as much as possible, the drawn\nhierarchy for the functions used to derive the body layer. For most processes,\nthe poly and diffusion layers for MOSFET and marker layers used to define\npassive devices, are candidates for the use of the LAYER_INTENT_DEVICE  type.\nNote:\nDevice extraction flows require devices to be located where they are\ndesigned to ensure a high-quality layout extracted netlist. Use an\nassign layer as a reference layer in the device functions to define\nthe device location, that is, poly for\nnmos() and pmos(), marker\nlayer for resistors, and so on. When setting the reference layer, the\ntool attempts to place the extracted device where the reference\nlayer is drawn. However, when a reference layer is not defined, or\nwhere the reference layer must be derived, it is recommended that\nthe assign layer ancestors, which define the location, are set to\nLAYER_INTENT_DEVICE.\nassign_layout()", "gds": "Optional. Controls the reading of data from a GDSII file on a layer-by-layer\nbasis.\n\u2022 user_defined_properties. Optional. Writes the specified GDSII property\nnumbers to the specified user-defined properties. By default, the IC Validator\ntool does not write any properties.\n\u25e6 double_properties. Specifies the properties that are written to the\nspecified property numbers.\nname. Specifies the property name.\nnumber. Specifies the property number. The property numbers must be in\nthe range of 0\u2013255, inclusive.\nSee the user_defined_properties  option of the\nlayers  argument in the\nwrite_oasis()  function for more information.", "oasis": "Optional. Controls the reading of data from an OASIS file on a layer-by-layer\nbasis.\n\u2022 user_defined_properties. Optional. Writes the specified OASIS property\nnumbers to the specified user-defined properties. By default, the IC Validator\ntool does not write any properties.\n\u25e6 double_properties. Specifies the properties that are written to the\nspecified property numbers.\nname. Specifies the property name.\nnumber. Specifies the property number. The property numbers must be in\nthe range of 0\u2013255, inclusive.\nSee the user_defined_properties  option of the\nlayers  argument in the\nwrite_oasis()  function for more information.", "select": "Optional. Selects cells by cell name.\n\u2022 cells. Includes the specified cells when importing the assign layer. When a\ncell is selected, its references are included. You can prefix a cell name with\nthe ! character to exclude its data and its descendant data from selection.\nString matching using metacharacters is allowed. See\nString Matching  for\nmore information. By default, the tool selects all cells.\nassign_layout()\nNote:\nExcluding the parent of a cell takes precedence over selecting a\ncell; that is, a cell is excluded if its parent is excluded.\n\u2022 depth. Specifies the depth of the cell hierarchy included by the cells .\nCELL_LEVEL  is the only allowed value and must be explicitly specified.\n\u25e6 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 geometry_select. For more information on the geometry_select\nargument, see the\ngeometry_select  argument in the assign()  function.", "exclude_from_keepout_check_in_drc_black_box": "Optional. Specifies assign layers to be excluded from and_overlap  checking.\nThe default is false. See the keepout_layers_check  option of the\ndrc_black_box_options()  function for more information.", "delete_exploded_data": "Optional. Specifies whether exploded data in the layout layer is removed during\nhierarchy preprocessing. Data is not removed from cells that are not exploded.\nThe default is false."}, "summary": "The assign_layout()  function assigns data found on specified layers in the layout to\na layout-layer variable.", "function_name": "assign_layout()"}
{"description": "The assign_openaccess()  function assigns a polygon-layer variable to data found on\nspecified layers in the layout. This function is an OpenAccess-specific version of the\nassign()  function that accepts layer and purpose names as arguments, rather than\nnumeric layer and datatype ranges.\nThis function reads only positive width paths and polygons, and ignores zero width paths.\nData assigned to the layer variable can be restricted to objects of a specified type.\nSee the\nopenaccess_options()  function for more information about reading OpenAccess\nsystem objects, such as blockages and boundaries.", "syntax": "assign_openaccess(\nlayer_purpose_list   = {{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},\nobjects             = {DONUT, DOT, ELLIPSE, PATH, PATH_SEGMENT,\nPIN, POLYGON, RECTANGLE},            //optional\ngrid_check          = {resolution = double,\ncheck_45   = {POLYGON, PATH},\ncheck_90   = {POLYGON, PATH},\npath_check = CENTERLINE | BOUNDARY,\nresolution_violation_comment = \"string\",\ncheck_45_violation_comment = \"string\",\ncheck_90_violation_comment = \"string\"},\n//optional\nselect_cells        = {\"string\", ...},                      //optional\npolygons     = {{coordinates = {{{x = double, y = double}, ...}, ...},\ncell        = \"string\"}, ...},             //optional\nname                = \"layer_label\",                        //optional\nblockage_types       = {NONE, ROUTING_BLOCKAGE, VIA_BLOCKAGE,\nPLACEMENT_BLOCKAGE, WIRING_BLOCKAGE,\nFILL_BLOCKAGE, SLOT_BLOCKAGE, PIN_BLOCKAGE,\nFEEDTHRU_BLOCKAGE, SCREEN_BLOCKAGE},\n//optional\narea_boundary_names  = {\"string\", ...},                      //optional\nlayer_intent         = {LAYER_INTENT_METAL, LAYER_INTENT_FILL,\nLAYER_INTENT_INTERCONNECT, LAYER_INTENT_BASE,\nLAYER_INTENT_VIA, LAYER_INTENT_COLORED_SUBSET,\nLAYER_INTENT_DEVICE},                //optional\nselect               = {cells = {\"string\", ...},\nmarker_layer_purposes = {\n{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},\ndepth = CELL_LEVEL | DESCENDANTS |\nALL,\nassign_openaccess()\ncomplement = true | false},\ncolors               = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME},                 //optional\nexclude_from_keepout_check_in_drc_black_box  = true | false   //optional\n);", "returns": "polygon layer", "arguments": {"layer_purpose_list": "Required. Lists the layer name and purpose name pairs. The purpose name for\neach pair is optional; the default is all purposes read to the layer.", "objects": "Optional. Includes the specified objects, on a layer-by-layer basis, when reading\nthe OpenAccess library. By default, the IC Validator tool reads all objects.\nNote:\nIn OpenAccess, a pin is also a shape. Therefore, an object can be\nboth a pin (PIN) and a shape, such as RECTANGLE  or POLYGON.\nIn the following example, the metal1_rect layer is assigned rectangles and pins\nthat are rectangles:\nmetal1_rect = assign_openaccess({{{\"metal1\"}}},\nobjects={RECTANGLE});\nIn the following example, the metal1_pin_r layer is assigned rectangles and all\npins, including those objects that are nonrectangular:\nmetal1_pin_r = assign_openaccess({{{\"metal1\"}}},\nobjects={RECTANGLE,PIN});", "grid_check": "Optional. Overrides the values specified in the\nlayout_grid_options()\nfunction in the specific layer. Any values that are unspecified default to the\ncorresponding value specified in the layout_grid_options()  function.\n\u2022 resolution. Optional. Inspects the layer for off-grid data when set to a\nvalue greater than the input library resolution. The default is the resolution\nspecified in the\nlayout_grid_options()  function.\n\u2022 check_45. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 45 degrees. The\nassign_openaccess()\ndefault is the layout data types specified in the layout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 45\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 45 degrees.\n\u2022 check_90. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 90 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 90\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 90 degrees.\n\u2022 path_check. Optional. Checks the specified path feature in the specific layer.\nThe default is the path feature specified in the layout_grid_options()\nfunction.\n\u25e6 CENTERLINE. Specifies that only the centerline of the path, before\npath expansion, is checked for violations in accordance with the other\nargument settings.\n\u25e6 BOUNDARY. Specifies that the resulting boundary, after path expansion,\nis checked for violations in accordance with the other argument settings.\nPath width checking is disabled with this setting.\n\u2022 resolution_violation_comment. Optional. Specifies the violation\ncomment for the resolution  errors in the specific layer. The default is the\nresolution_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_45_violation_comment. Optional. Specifies the violation\ncomment for the check_45  errors in the specific layer. The default is the\ncheck_45_violation_comment  specified in the layout_grid_options()\nfunction.\nassign_openaccess()\n\u2022 check_90_violation_comment. Optional. Specifies the violation\ncomment for the check_90  errors in the specific layer. The default is the\ncheck_90_violation_comment  specified in the layout_grid_options()\nfunction.", "select_cells": "Optional. Includes the specified cells when importing the assign layer. When\na cell is selected, its references are included. You can add the ! character,\nwhich is the NOT operator, as a prefix to a cell name to exclude its data and\nits descendant data from selection. String matching using metacharacters is\nallowed. See\nString Matching  for more information. By default, the IC Validator\ntool selects all cells.\nSee the Examples section of the\nassign()  function for more information.", "polygons": "Optional. Lists the polygons created in the specified cells. The polygons\nare added as data is read into cells, and polygons are treated as if they\nare direct input from the layout. Therefore, arguments, such as the\nmagnification_factor  argument of the\nlibrary()  function, that transform\ninput layout data is applied to the polygons that are created. Data counts in the\ntree files include these polygons.\nIf a cell name does not exist in the input layout, the name is ignored. If a cell\nname is not specified, the polygons in the associated list are created in the top\ncell. A list of two coordinates is considered a rectangle.\nNote:\nIf you are using the\nlibrary_import()  function, the\nmagnification factor specified in the library  argument of the\nassign_openaccess()  function is applied.\nIf you are using the library_import()  function and no cell name is\nspecified, polygons are created in the top cell of the library specified\nin the library  argument of the assign_openaccess()  function.\nSee the\nassign()  function for an example.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nassign_openaccess()", "blockage_types": "Optional. Filters objects by blockage type. The oaBlockage objects have\nan associated blockage type; other types of objects do not. By default, the\nIC Validator tool reads all objects.\nNote:\nSee the\nopenaccess_options()  function for more information about\nreading oaBlockage objects.\nTable 29  lists the blockage type options.\nTable 29 OpenAccess Blockage Types\nOption Blockage type\nNONE Read objects without a blockage type\nROUTING_BLOCKAGE ROUTING\nVIA_BLOCKAGE VIA\nPLACEMENT_BLOCKAGE PLACEMENT\nWIRING_BLOCKAGE WIRING\nFILL_BLOCKAGE FILL\nSLOT_BLOCKAGE SLOT\nPIN_BLOCKAGE PIN\nFEEDTHRU_BLOCKAGE FEEDTHRU\nSCREEN_BLOCKAGE SCREEN", "area_boundary_names": "Optional. Filters objects by area boundary name. The oaAreaBoundary\nobjects can have an associated name; other types of objects do not. See", "the": "openaccess_options()  function for more information about reading\noaAreaBoundary objects. String matching using metacharacters is allowed. See\nString Matching  for more information. By default, the IC Validator tool reads all\nobjects.\nassign_openaccess()", "layer_intent": "Optional. Specifies the layer types:\nLAYER_INTENT_METAL\nLAYER_INTENT_FILL\nLAYER_INTENT_INTERCONNECT\nLAYER_INTENT_BASE\nLAYER_INTENT_VIA\nLAYER_INTENT_COLORED_SUBSET\nLAYER_INTENT_DEVICE\nYou can list more than one type. For example, a layer can be of type\nLAYER_INTENT_METAL  and LAYER_INTENT_INTERCONNECT. The default is\nunspecified intent.\nNote:\nThe LAYER_INTENT_BASE  layer type provides identical functionality to\nthe LAYER_INTENT_DEVICE  layer type, and is maintained for legacy\nsupport.", "select": "Optional. Selects cells by cell name, marker layer, or both.\n\u2022 cells. Includes the specified cells when importing the assign layer. When a\ncell is selected, its references are included. You can prefix a cell name with\nthe ! character to exclude its data and its descendant data from selection.\nString matching using metacharacters is allowed. See\nString Matching  for\nmore information. By default, the tool selects all cells.\nNote:\nExcluding the parent of a cell takes precedence over selecting a\ncell; that is, a cell is excluded if its parent is excluded.\n\u2022 marker_layers. Lists layer range and datatype range pairs. When set\nto an empty list (the default) then the marker_layers  list is ignored. The\ndata_type_range  value for each pair is optional, with a default of all\ndatatypes. See\nLayout Layer and Datatype Ranges  for information about the\nlimits of the values.\nThis option works in conjunction with the cells  option; it restricts selection to\nonly those cells that contain at least one marker layer. The cells list is pruned\nassign_openaccess()\nby removing any cells that do not directly (ignoring reference data) contain\nthe marker layer. Negated cells in the cells list are not pruned.\n\u2022 depth. Specifies the depth of the cell hierarchy included by the cells  and\nmarker_layers  options. The default is ALL.\n\u25e6 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u25e6 DESCENDANTS. Includes only data in the descendants of a cell, recursively.\nNo cell-level data is included unless the cell is a descendant of a cell in\nthe cells list.\n\u25e6 ALL. Includes all data in the cell and below.\n\u2022 complement. Specifies whether to include or exclude the selection performed\nby the cells  and marker_layers  options. The default is false.\n\u25e6 true. Selects all cells except for the cells specified by the cells  and\nmarker_layers  options.\n\u25e6 false. Selects the cells specified by the cells  and marker_layers\noptions.\nSee the example in the definition of the select  argument of the\nassign()\nfunction.", "colors": "Optional. Lists OpenAccess library color attributes that are included, on a layer-\nby-layer basis, when reading the OpenAccess library. Only shapes with the color\nattributes listed are read for this layer.\nTable 30  lists the attributes. By default,\nthe IC Validator tool reads data of all color attribute values.\nTable 30 OpenAccess Color Attributes\nGRAY MASK_ONE_UNLOCKED MASK_ONE_LOCKED MASK_TWO_UNLOCKED\nMASK_TWO_LOCKED MASK_THREE_UNLOCKED MASK_THREE_LOCKED BLACK\nMULTI SAME\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. See the openaccess_options()  function for more\ninformation.\nassign_openaccess()", "exclude_from_keepout_check_in_drc_black_box": "Optional. Specifies assign layers to be excluded from and_overlap  checking.\nThe default is false. See the keepout_layers_check  option of the\ndrc_black_box_options()  for more information."}, "summary": "The assign_openaccess()  function assigns a polygon-layer variable to data found on\nspecified layers in the layout.", "function_name": "assign_openaccess()"}
{"description": "The assign_openaccess_edge()  function assigns an edge-layer variable to data found\non specified layers in the layout. This function is an OpenAccess-specific version of the\nassign_edge()  function that accepts layer and purpose names as arguments, rather than\nnumeric layer and datatype ranges.\nThis function reads only zero width paths and ignores all other geometric data. Data\nassigned to the layer can be restricted to objects of a specified type.", "syntax": "assign_openaccess_edge(\nlayer_purpose_list  = {{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},\nobjects            = {ARC, LINE, PATH, PATH_SEGMENT},       //optional\ngrid_check         = {resolution = double,\ncheck_45   = {POLYGON, PATH},\ncheck_90   = {POLYGON, PATH},\nresolution_violation_comment = \"string\",\ncheck_45_violation_comment = \"string\",\ncheck_90_violation_comment = \"string\"},\n//optional\nname               = \"layer_label\",                         //optional\nedges      = {{coordinates = {{{x = double, y = double}, ...}, ...},\ncell        = \"string\"}, ...},               //optional\ncolors              = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME}                   //optional\n);", "returns": "edge layer", "arguments": {"layer_purpose_list": "Required. Lists the layer name and purpose name pairs. The purpose name for\neach pair is optional; the default is all purposes read to the layer.", "objects": "Optional. Includes the specified objects, on a layer-by-layer basis, when reading\nthe OpenAccess library. By default, the IC Validator tool reads all objects.\nassign_openaccess_edge()", "grid_check": "Optional. Overrides the values specified in the layout_grid_options()\nfunction in the specific layer. Any values that are unspecified default to the\ncorresponding value specified in the layout_grid_options()  function.\n\u2022 resolution. Optional. Inspects the layer for off-grid data when set to a\nvalue greater than the input library resolution. The default is the resolution\nspecified in the\nlayout_grid_options()  function.\n\u2022 check_45. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 45 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 45\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 45 degrees.\n\u2022 check_90. Optional. Checks the specified layout data types function in the\nspecific layer for angles which are not even multiples of 90 degrees. The\ndefault is the layout data types specified in the\nlayout_grid_options()\nfunction.\n\u25e6 POLYGON. Reports polygon edges as an error if the angle, with respect to\nthe x-axis of the cell where the edges are defined, is not a multiple of 90\ndegrees.\n\u25e6 PATH. Reports path centerline segments as an error if the angle, with\nrespect to the x-axis of the cell where the edges are defined, is not a\nmultiple of 90 degrees.\n\u2022 resolution_violation_comment. Optional. Specifies the violation\ncomment for the resolution  errors in the specific layer. The default is the\nresolution_violation_comment  specified in the layout_grid_options()\nfunction.\n\u2022 check_45_violation_comment. Optional. Specifies the violation\ncomment for the check_45  errors in the specific layer. The default is the\ncheck_45_violation_comment  specified in the layout_grid_options()\nfunction.\nassign_openaccess_edge()\n\u2022 check_90_violation_comment. Optional. Specifies the violation\ncomment for the check_90  errors in the specific layer. The default is the\ncheck_90_violation_comment  specified in the layout_grid_options()\nfunction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edges": "Optional. Lists the edges created in the specified cells. Edges are added as data\nis read into cells, and polygons are treated as if they are direct input from the\nlayout. Therefore, arguments such as the magnification_factor  argument\nof the\nlibrary()  function, that transform the input layout data is applied to the\nedges that are created. Data counts in the tree files include these edges.\nIf a cell name does not exist in the input layout, the name is ignored. If a cell\nname is not specified, the edges in the associated list are created in the top cell.\nNote:\nIf you use the\nlibrary_import()  function, the magnification\nfactor specified in the library  argument of the\nassign_openaccess_edge()  function is applied.\nIf you use the library_import()  function and no cell name is\nspecified, edges are created in the top cell of the library specified in\nthe library  argument of the assign_openaccess_edge()  function.", "colors": "Optional. Lists OpenAccess library color attributes that are included, on a layer-\nby-layer basis, when reading the OpenAccess library. Only shapes with the color\nattributes listed are read for this layer.\nTable 31  lists the attributes. By default,\nthe IC Validator tool reads data of all color attribute values.\nTable 31 OpenAccess Color Attributes\nGRAY MASK_ONE_UNLOCKED MASK_ONE_LOCKED MASK_TWO_UNLOCKED\nMASK_TWO_LOCKED MASK_THREE_UNLOCKED MASK_THREE_LOCKED BLACK\nMULTI SAME\nassign_openaccess_edge()\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\nopenaccess_options()  and\ntwo_color()  functions for more information."}, "summary": "The assign_openaccess_edge()  function assigns an edge-layer variable to data found\non specified layers in the layout.", "function_name": "assign_openaccess_edge()"}
{"description": "The assign_openaccess_text()  function assigns a text-layer variable to the text found\non specified layers in the layout. This function is an OpenAccess-specific version of the\nassign_text()  function that accepts layer and purpose names as arguments, rather than\nnumeric layer and datatype ranges.", "syntax": "assign_openaccess_text(\nlayer_purpose_list  = {{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},\ndelete_text        = {{cells = {\"string\", ...},\ntext  = {\"string\", ...}},...},       //optional\nuse_exploded_text  = {{cells = {\"string\", ...},\ntext  = {\"string\", ...}}, ...},      //optional\nobjects             = {PIN_TEXT, POLYGON_TEXT, TEXT,\nTEXT_DISPLAY, TERMINAL_TEXT},         //optional\nname               = \"layer_label\"                          //optional\n);", "returns": "text layer", "arguments": {"layer_purpose_list": "Required. Lists the layer name and purpose name pairs. The purpose name for\neach pair is optional; the default is all purposes read to the layer.", "delete_text": "Optional. Lists the text deleted from specified cells. The list is additive; one list\nelement does not negate another list element. By default, text is not deleted.\n\u2022 cells. Optional. Deletes text from the specified cells. String matching using\nmetacharacters is allowed. See\nString Matching  for more information. By\ndefault, text is deleted from all cells.\n\u2022 text. Optional. Deletes the specified text strings. String matching using\nmetacharacters is allowed. See String Matching  for more information. By\ndefault, all text strings are deleted.\nNote:\nThis delete_text  argument does not delete text that is specified\nin the edtext  argument of the\ntext_options()  function.\nassign_openaccess_text()", "use_exploded_text": "Optional. Lists the cells where text strings for the specified layer and datatype\nare retained if the cells are exploded. The list is additive; one list element does\nnot negate another list element. By default, exploded cells do not retain their\ntext.\nNote:\nThe use_exploded_text  arguments in the\nassign_text(),\nassign_openaccess_text(), and text_options()  functions are\nadditive.\nUse the exploded_text_options  argument of the text_options()  function\nto control the prepending of the hierarchical path to text when the cell it is in is\nexploded.\n\u2022 cells. Optional. Specifies the cells from which text is used if these cells\nare exploded. String matching using metacharacters is allowed. See\nString\nMatching  for more information. By default, text is deleted from all cells.\n\u2022 text. Optional. Specifies the text strings that are used if a cell containing\nthe text is exploded. String matching using metacharacters is allowed. See\nString Matching  for more information. By default, the IC Validator tool uses all\ntext strings.", "objects": "Optional. Assigns the specified text types to a layer when reading an\nOpenAccess library. By default, the IC Validator tool allows all types to be read.\n\u2022 PIN_TEXT. Assigns IC Validator automatically generated text for pins. It can\nbe a pin name or a net name depending on the runset options set in the\npin_text  argument of the openaccess_options()  function.\n\u2022 POLYGON_TEXT. Assigns IC Validator automatically generated text for\npolygons. The text is always a net name.\n\u2022 TEXT. Assigns OpenAccess text object from the input database.\n\u2022 TEXT_DISPLAY. Assigns OpenAccess text display object from the input\ndatabase.\n\u2022 TERMINAL_TEXT. Assigns OpenAccess instance terminal objects\nfrom the input database. See the terminal_text  argument of the\nopenaccess_options()  function for more information.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nassign_openaccess_text()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The assign_openaccess_text()  function assigns a text-layer variable to the text found\non specified layers in the layout.", "function_name": "assign_openaccess_text()"}
{"description": "The assign_text()  function assigns a text-layer variable to the text found on specified\nlayers in the layout. Text from multiple layers can be assigned to one text-layer variable.\nSee\nText Strings  for rules applied to text strings.\nWhen the runset is optimized, unused text layers are pruned and, therefore, are not\nchecked for bad text.\nSee the\nassign_openaccess_text()  function for an assign function that is specific to\nthe OpenAccess format. The assign_openaccess_text()  function accepts layer and\npurpose names as arguments, rather than numeric layer and datatype ranges. If you use\nthe assign_text()  function for OpenAccess data, you must specify an OpenAccess layer\nmapping file in the\nopenaccess_options()  function.\nThe arguments of the assign_text()  and text_options()  functions are executed in the\nfollowing order:\n1. delete_text\n2. edtext\n3. empty_text\n4. use_exploded_text / hierarchy_auto_options(delete_auto_exploded_text)\n5. reassign_text\n6. replace_text\n7. replace_text_characters\n8. replace_text_characters_regex\n9. text_with_space\n10. colon_text\n11. text_with_reserved\n12. delete text with control character. See Text Strings  for more information.", "syntax": "assign_text(\nldt_list          = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},\n...},\nmilkyway          = {views       = {\"string\", ...},\nassign_text()\ncell_types  = {cell_type, ...},\nobjects = {PIN_TEXT, POLYGON_TEXT, TEXT},\nread_fill_view_from = {TOP_CELL, LOWER_CELLS}\n},                                      //optional\ndelete_text       = {{cells = {\"string\", ...},\ntext  = {\"string\", ...}}, ...},       //optional\nuse_exploded_text = {{cells = {\"string\", ...},\ntext  = {\"string\", ...}}, ...},       //optional\nopenaccess        = {objects    = {PIN_TEXT, POLYGON_TEXT, TEXT,\nTEXT_DISPLAY, TERMINAL_TEXT}},\n//optional\ngds                = {objects    = {PROPERTY_TEXT, TEXT},\nproperties = {integer, ...}},          //optional\noasis              = {objects    = {PROPERTY_TEXT, TEXT},\nproperties = {integer, ...}},          //optional\nlibraries         = {library},                              //optional\nname              = \"layer_label\",                          //optional\nndm     = {views            = {view_type, ...},\nobjects          = {object_text_type, ...},\nshape_uses       = {shape_use_type, ...},\ndesign_types     = {design_type, ...},\nmasks            = {ndm_mask, ...},\nread_from        = {assign_ndm_read_from, ...},\ninternal_designs = {ndm_internal_design_use, ...},\nread_internal_designs_from = {TOP_CELL, LOWER_CELLS}\n},                                                //optional\ntext_with_space     = TRUNCATE | KEEP,              //optional\ntext_with_reserved  = DELETE_AND_REPORT | KEEP      //optional\n);", "returns": "text layer", "arguments": {"ldt_list": "Required. Lists the layer range and datatype range pairs. The\ndata_type_range  value for each pair is optional, with a default of all datatypes.\nSee\nLayout Layer and Datatype Ranges  for information about the limits of the\nvalues.\nNote:\nYou can use the assign_layer_out_of_range  argument of the\nrun_options()  function to specify the behavior of the IC Validator\ntool when an assign function contains layer or datatype numbers\nthat are greater than the maximum allowed range of the input library\nformat.\nassign_text()\nFor NDM libraries, lists the layer range and layer purpose range pairs. The\ndata_type_range  value, which is the layer purpose, for each pair is optional,\nwith a default of all datatypes. See\nLayout Layer and Datatype Ranges  for\ninformation about the limits of the values.", "milkyway": "Optional. Controls the reading of data from a Milkyway library on a layer-\nby-layer basis. This argument works with the drc_black_box_cells  and\nlvs_black_box_cells  arguments of the\nmilkyway_options()  function. These\narguments of the milkyway_options()  function control the views on a cell-by-\ncell basis.\nNote:\nThe milkyway  argument is ignored for non-Milkyway libraries.\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer basis, from\na Milkyway library. By default, the IC Validator tool reads all views.\nNote:\nAny number of views can be referenced in the Milkyway library.\nThe maximum combined number of unique view names used in all\nassign functions in the runset is 32.\n\u2022 cell_types. Optional. Includes the specified cell types, on a layer-\nby-layer basis, when reading the Milkyway library. This argument\nworks with the cell_types  and exclude_cell_types  arguments\nof the\nmilkyway_options()  function. These arguments of the\nmilkyway_options()  function globally constrain the cell types that are read.\nYou can use the exclude_milkyway_cell_types()  function to obtain a list\nof all possible cell types except those specified by the exclude  argument. By\ndefault, the IC Validator tool reads data from all cell types. See Table 56  for a\nlist of cell types.\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading a\nMilkyway library. By default, the IC Validator tool allows all types to be read.\n\u25e6 PIN_TEXT. Assigns IC Validator automatically generated text for pins. It\ncan be a pin name or a net name depending on the runset options set in\nthe pin_text  argument of the\nmilkyway_options()  function.\n\u25e6 POLYGON_TEXT. Assigns IC Validator automatically generated text for\npolygons. The text is always a net name.\n\u25e6 TEXT. Assigns Milkyway text object from the input database.\n\u2022 read_fill_view_from. Optional. Lists the fill cells that are included on the\nspecified layer when the fill view is read. You can include the top fill cells\nassign_text()\nonly, all of the fill cells except the top cells, or all of the fill cells. By default,\nthe IC Validator tool reads all of the fill cells when the fill view is read.\n\u25e6 TOP_CELL. Includes the top fill cells.\n\u25e6 LOWER_CELLS. Includes all of the fill cells except the top cells.", "delete_text": "Optional. Lists the text deleted from specified cells. The list is additive; one list\nelement does not negate another list element. By default, the IC Validator tool\ndoes not delete text.\n\u2022 cells. Optional. Deletes text from the specified cells. String matching using\nmetacharacters is allowed. See\nString Matching  for more information. By\ndefault, the IC Validator tool deletes text from all cells.\n\u2022 text. Optional. Deletes the specified text strings. String matching using\nmetacharacters is allowed. See String Matching  for more information. By\ndefault, the IC Validator tool deletes all text strings.\nNote:\nThis delete_text  argument does not delete text that is specified\nin the edtext  argument of the\ntext_options()  function.", "use_exploded_text": "Optional. Lists the cells where text strings for the specified layer and datatype\nare retained if the cells are exploded. The list is additive; one list element does\nnot negate another list element. By default, the IC Validator tool does not retain\nthe text of exploded cells.\nNote:\nThe use_exploded_text  arguments in the assign_text(),\nassign_openaccess_text(), and text_options()  functions are\nadditive.\nUse the exploded_text_options  argument of the text_options()  function\nto control the prepending of the hierarchical path to text when the cell it is in is\nexploded.\n\u2022 cells. Optional. Specifies the cells from which text is used if these cells\nare exploded. String matching using metacharacters is allowed. See\nString\nMatching  for more information. By default, the IC Validator tool deletes the\ntext from all cells.\nassign_text()\n\u2022 text. Optional. Specifies the text strings that are used if a cell containing\nthe text is exploded. String matching using metacharacters is allowed. See\nString Matching  for more information. By default, the IC Validator tool uses all\ntext strings.", "openaccess": "Optional. Controls the reading of data from an OpenAccess database on a layer-\nby-layer basis.\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading\nan OpenAccess library. By default, the IC Validator tool allows all types to be\nread.\n\u25e6 PIN_TEXT. Assigns IC Validator automatically generated text for pins. It\ncan be a pin name or a net name depending on the runset options set in\nthe pin_text  argument of the\nopenaccess_options()  function.\n\u25e6 POLYGON_TEXT. Assigns IC Validator automatically generated text for\npolygons. The text is always a net name.\n\u25e6 TEXT. Assigns OpenAccess text object from the input database.\n\u25e6 TEXT_DISPLAY. Assigns OpenAccess text display object from the input\ndatabase.\n\u25e6 TERMINAL_TEXT. Assigns OpenAccess instance terminal objects\nfrom the input database. See the terminal_text  argument of the\nopenaccess_options()  function for more information.", "gds": "Optional. Controls the text read from a GDSII file for each assigned text layer. If\nthe generate_property_text  argument of the\ngds_options()  function is TOP\nor ALL, text objects are generated for polygons with associated properties. The\ntext is located on the polygon and has the same layer and datatype.\nNote:\nThis option overrides selections made in the text  argument of the\ngds_options()  function.\nassign_text()\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading a\nGDSII file. The default is TEXT.\n\u25e6 PROPERTY_TEXT. Assigns automatically generated text for polygons.\n\u25e6 TEXT. Assigns GDSII text points from the input database.\n\u2022 properties. Optional. Specifies the property numbers to use when the\nobjects  argument is PROPERTY_TEXT. The property numbers must be in the\nrange of 0\u2013255, inclusive. If this list is empty, no property text is assigned.", "oasis": "Optional. Controls the text read from an OASIS input library for each assigned\ntext layer. If the generate_property_text  argument of the\noasis_options()\nfunction is TOP  or ALL, text points are generated for polygons with associated\nproperties. The text is located on the polygon and has the same layer and\ndatatype.\nNote:\nThis option overrides selections made in text  argument of the\noasis_options()  function.\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading\nan OASIS library. The default is TEXT.\n\u25e6 PROPERTY_TEXT. Assigns automatically generated text for polygons.\n\u25e6 TEXT. Assigns OASIS text points from the input database.\n\u2022 properties. Optional. Specifies the property numbers to use when the\nobjects  argument is PROPERTY_TEXT. The property numbers must be in the\nrange of 0\u2013255, inclusive. If this list is empty, no property text is assigned.", "libraries": "Optional. Specifies the libraries. An assign function uses only layers from\nthis library. The library is defined by the return value of the\nlibrary()  or\nlibrary_import()  function.\nNote:\nThe list can contain multiple libraries.\nThe libraries  argument is required if you use the library_import()  function\nand the argument is prohibited if you do not use the library_import()\nfunction.\nassign_text()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "ndm": "Optional. Controls the reading of data from an NDM library on a layer-by-\nlayer basis. This ndm  argument filters data only for the given layer. The\nndm_options()  function controls which data is read globally.\nNote:\nThe ndm  argument is ignored for non-NDM libraries.\n\u2022 views. Optional. Includes the specified views, on a layer-by-layer\nbasis, when reading the NDM library. This option works with the\ndrc_black_box_cells, lvs_black_box_cells, and layout_view_cells\narguments of the\nndm_options()  function. See Table 16  in the assign()\nfunction section for a list of views. By default, the IC Validator tool reads all\nviews.\n\u2022 objects. Optional. Includes the specified objects, on a layer-by-layer basis,\nwhen reading the NDM library.\nTable 32  lists the objects. By default, the\nIC Validator tool reads all objects\nTable 32 NDM objects Options for assign_text() Function\nTEXT PIN_TEXT POLYGON_TEXT\n\u2022 shape_uses. Optional. Specifies the shape when reading the NDM library for\nthis layer. You can use the exclude_ndm_shape_uses()  function to obtain a\nlist of all possible shapes except those specified. By default, the IC Validator\ntool reads data of all shapes types. See\nTable 18  in the assign()  function\nsection for a list of shape uses.\n\u2022 design_types. Optional. Includes only data from cells with the specified\ndesign types on this layer when reading the NDM library. It does not apply to\nthe top cell.\nTable 20  in the assign()  function lists the types. By default, the\ntool reads all design types.\n\u2022 masks. Specifies the multi-patterning mask that determine the shapes that\nare read from the NDM library. The default is not to set a multi-patterning\nmask.\nTable 22  in the assign()  function section lists the mask options.\nassign_text()\n\u2022 read_from. Optional. Specifies whether data is read from design cell views\n(both design and frame), internal designs, or both. The default is no filtering\n({ }).\n\u25e6 VIEWS. Includes data from design cell views on this runset layer.\n\u25e6 INTERNAL_DESIGNS. Includes data from internal designs on this runset\nlayer.\n\u2022 internal_designs. Optional. Specifies the internal designs from which to\nread data for a given runset layer.\nTable 23  in the assign()  function section\nlists the internal_design  options. See the internal_designs  argument of\nthe ndm_options()  function for more information.\n\u2022 read_internal_designs_from. Optional. Lists the internal design cells\nthat are included on the specified layer when an internal design is read.\nYou can include the top internal design cells only, all of the internal design\ncells except the top cells, or all of the internal design cells. By default, the IC\nValidator tool reads all of the internal design cells when the internal design is\nread.\n\u25e6 TOP_CELL. Includes the top internal design cells.\n\u25e6 LOWER_CELLS. Includes all of the internal design cells except the top cells.", "text_with_space": "Optional. Specifies whether to truncate or retain text containing space\ncharacters. The default is TRUNCATE.\n\u2022 TRUNCATE. Removes leading space characters from the layout text and\ntruncates layout text at the position of the first spacing character.\n\u2022 KEEP. Retains all space characters in the text string.", "text_with_reserved": "Optional. Specifies whether to ignore or retain text containing reserved\ncharacters. The default is DELETE_AND_REPORT.\n\u2022 DELETE_AND_REPORT. Ignores layout text strings containing a reserved\ncharacter and causes a bad_text_reserved_character  error.\n\u2022 KEEP. Retains all reserved characters in the text string."}, "summary": "The assign_text()  function assigns a text-layer variable to the text found on specified\nlayers in the layout.", "function_name": "assign_text()"}
{"description": "The balance_fills()  function makes two types of polygons have same density within\nthe window layers.", "syntax": "balance_fills(\ncriteria : {\ndesign_layer1 : polygon_layer;\ndesign_layer2 : polygon_layer;\nfill_layer1 : polygon_layer;\nfill_layer2 : polygon_layer;},\nwindow_layer : polygon_layer,\ndelta_window : delta_window_s = { 0, 0 },    //optional\ndelta_x : double  = UNSPECIFIED_DOUBLE,       //optional\ndelta_y : double  = UNSPECIFIED_DOUBLE,       //optional\nboundary : density_boundary_action_e = CLIP  | ALIGN |\nIGNORE, //optional\n);", "returns": "balance_fills_result\nbalance_fill_output :{\nfill_result1 : polygon_layer;\nfill_result2 : polygon_layer;\n};", "arguments": {"window_layer": "Required. Specifies the polygon layer containing one or more polygons that\ndefine the boundaries where layers are processed for density calculations. The\nchip_extent()  and layer_extent()  functions can be used to create a window\nlayer.\n\u2022 The chip_extent()  function returns a layer containing a single rectangle\nequal to the extents of the chip. Use this function to create a single full-chip\ncheck window.\n\u2022 The layer_extent()  function returns a layer containing a single rectangle\nequal to the extents of the input layer. Use this function to create a single-\nlayer check window.\nbalance_fills()", "delta_window": "Optional. Specifies the subwindow stepped across each window layer polygon.\nThe density equations are evaluated within each subwindow. The default is the\nextents of each window layer polygon.", "delta_x": "Optional. Specifies the delta_window  subwindow step distance in the x-\ndirection. The default is the width option of the delta_window  argument.", "delta_y": "Optional. Specifies the delta_window  subwindow step distance in the y-\ndirection. The default is the height option of the delta_window  argument.", "boundary": "Optional. Specifies how to process a delta_window  subwindow that overlaps\nthe boundary of the extents of a window layer polygon. The default is CLIP.\n\u2022 CLIP. Truncates the subwindow at the limits of the window layer.\n\u2022 ALIGN. If a subwindow overlaps the right side or top edge of the window\nlayer, shifts the window left or down until it no longer overlaps the window\nlayer. The density calculation is performed after the window is shifted.\n\u2022 IGNORE. If a subwindow overlaps the right or top edges of the window\nlayer boundary, ignores the subwindow and does not output data for that\nsubwindow location.", "criteria": "Required. Specifies two types of fill layer and design layer for balancing.'\n\u2022 design_layer1\nRequired. Specifies the polygon layer containing the design polygons of first\ntype.\n\u2022 design_layer2\nRequired. Specifies the polygon layer containing the design polygons of\nsecond type.\n\u2022 fill_layer1\nRequired. Specifies the polygon layer containing the fills of first type.\n\u2022 fill_layer2\nRequired. Specifies the polygon layer containing the fills of second type.\nbalance_fills()", "balance_fill_output": "Stores the output of balance_fills().\n\u2022 fill_result1\nThe output of balanced fill result of first type.\n\u2022 fill_result2\nThe output of balanced fill result of second type.\nOptional. Specifies the delta_window  subwindow step distance in the y-\ndirection. The default is the height option of the delta_window  argument.\nbuildsub()\nbuildsub()"}, "summary": "The balance_fills()  function makes two types of polygons have same density within\nthe window layers.", "function_name": "text_origin()"}
{"description": "The buildsub()  function creates isolated substrate regions from a layer containing\nisolation\ndefinition data\nisolation regions, which are typically isolation rings.\nNote:\nThe output of the buildsub()  function must be used only as bulk polygon layer\nfor the device configuration functions and the\nconnect()  function.\nThe buildsub()  function creates a substrate-like layer by\n\u2022 Selecting polygons from the input layer that create isolation regions, including\n\u25e6 Rings\n\u25e6 Polygons that edge touch the top-level cell extents\n\u2022 Removing the selected isolation region data from the substrate to produce a set of\nisolated bulk regions.\nThe effect is similar to forming a polygon in each cell that is the size of the extents of the\ncell and then performing a NOT operation of the selected isolation data from the cell extent\ndata. The output from the buildsub()  function is not  the same as output from the\nnot()\nfunction, for example, substrate not layer.", "syntax": "buildsub(\nlayer          = polygon_layer,\noversize       = double,          //optional\nname           = \"layer_label\"    //optional\n);", "returns": "polygon layer", "arguments": {"layer": "Required. Specifies the layer that contains isolation definition data from which\nthe substrate region is created.", "oversize": "Optional. Oversizes the extents at the top cell. This oversizing prevents the\ngenerated bulk layer from being cut in two. The default is 0.0.\nbuildsub()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The buildsub()  function creates isolated substrate regions from a layer containing\nisolation\ndefinition data\nisolation regions, which are typically isolation rings.", "function_name": "buildsub()"}
{"description": "The capacitor()  function collects extraction configuration information about intentional\ncapacitors that are defined by a device body layer and two terminal layers. The\nconfiguration information, which contains device body and terminal layers, property\nextraction information, schematic device mappings, and pin handling instructions, is stored\nin the device matrix that is passed to the\nextract_devices()  function.\nA capacitor device is recognized when polygons in the device body layer interact with one\npolygon from each terminal layer and from each optional pins device layer. If an optional\npin layer has the pin_type  option set to BULK, the required relationship between the pin\nlayer polygon and the device body layer polygon is defined by the bulk_relationship\nargument. If an optional pin layer has the pin_type  option set to TERMINAL, the optional\npin layer polygon must interact with the device body layer polygon but is not required to\nenclose the device body layer polygon.\nNote:\nSee\nDevice Names  for the device_name  argument restrictions.", "syntax": "capacitor(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndevice_body            = polygon_layer,\nterminal_a             = polygon_layer,\nterminal_b             = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name = \"string\",\npin_type = TERMINAL | BULK\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\ncapacitor()\nNETLIST_SKIP_PCELL,\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nextract_shorted_device = true | false,                      //optional\narea_capval            = double,                            //optional\ncoinedge_capval        = double,                            //optional\nfringe_edge_capval     = double,                            //optional\nperim_capval           = double,                            //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false                //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use in the\nextract_devices()  function.", "device_name": "Required. Specifies the capacitor. A device name can be reused across multiple\ncalls of the capacitor()  function if all calls have\ncapacitor()\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.", "device_body": "Required. Specifies the body layer of the capacitor.", "terminal_a": "Required. Specifies the device layer that contains the first terminal of the\ncapacitor. The pin name generated by the IC Validator tool is \u201cA\u201d.", "terminal_b": "Required. Specifies the device layer that contains the second terminal of the\ncapacitor. The pin name generated by the IC Validator tool is \u201cB\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin. The default is BULK.\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named BULK.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\ncapacitor()\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  function for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultcapacitor\nThe default is\nproperties = {{\"c\"}},\n\u2022 name. Required. Specifies the property name. See \u201cPredefined Name\nMatches\u201d in Chapter 7, \u201cCompare Functions Basics\u201d of the IC Validator\nLVS User Guide  for the names and associated matches that are predefined\nduring LVS compare.\ncapacitor()\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Optional. Specifies the data type of the property. The default is\nDOUBLE.\nNote:\nThe\ncompare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation. If the lvs_user_unit  argument of the\nrun_options()\nfunction is set to METER, the tool functions as if the scale  argument is NONE.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\ncapacitor()\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\ncapacitor()\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\ncapacitor()\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the nmos() and pmos()  functions for an example.\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric properties\nfor each extracted capacitor. The default calculation is for the capacitance.\nThe default calc_capacitor_properties()  function is defined in the\ndevice_public.rh header file.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for information about the utility\nfunctions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon. The default is ENCLOSE.\ncapacitor()\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the capacitor()  function.\n- The schematic pin names do not match the standard \u201cA\u201d, \u201cB\u201d, and\n\u201cBULK\u201d pin names, in addition to optional pin names provided in\nthe optional_pins  list of structures argument of the capacitor()\nfunction.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin_name  option in the optional_pins  argument.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\ncapacitor()\nsimilar to the pin_compared  option of the optional_pins  argument of the\ncapacitor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the capacitor()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "x_card": "Optional. Specifies if the instance name prefix is replaced when\nnetlisting the device with the\nnetlist(), pex_generate_results(),\nwrite_annotation_file(), write_spice(), and write_xref_spice()\nfunctions. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with \u201cX\u201d. This option facilitates the use of SPICE SUBCKT models to\nrepresent devices in simulation.\n\u2022 false. Does not replace the default instance name prefix for the layout\nextracted device. Netlists use an instance name prefix (SPICE card) value of\n\u201cC\u201d for netlisting the extracted layout device.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  for more information.", "extract_shorted_device": "Optional. Specifies whether shorted capacitors, that is, capacitors with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted capacitors.\n\u2022 false. Reports shorted capacitors as error devices.", "area_capval": "Optional. Specifies the capacitance per unit area, either F/\u03bcm2  or F/m2. The unit\nof measure is specified by the lvs_user_unit  argument of the\nrun_options()\nfunction to either microns or meters. This value is used to calculate the parallel\nplate capacitance of the device as represented by the device body polygon. The\ndefault is 0.", "coinedge_capval": "Optional. Specifies the capacitance per unit length, either F/\u03bcm or F/m, of\nedges where the first terminal layer is coincident with the second terminal\ncapacitor()\nlayer. The unit of measure is specified by the lvs_user_unit  argument of the\nrun_options()  function to either microns or meters. The default is 0.", "fringe_edge_capval": "Optional. Specifies the capacitance per unit length, either F/\u03bcm or F/m, of the\nsecond terminal edge that is overlapped by the first terminal layer. The unit of\nmeasure is specified by the lvs_user_unit  argument of the\nrun_options()\nfunction to either microns or meters. The default is 0.", "perim_capval": "Optional. Specifies the capacitance per unit length, either F/\u03bcm or F/m, of the\ncapacitor perimeter. The unit of measure is specified by the lvs_user_unit\nargument of the\nrun_options()  function to either microns or meters. The\nperimeter constitutes edges of the overlapping area that are not otherwise\naccounted for by the coincident edge or the fringe edge.\n\u2022 When the coinedge_capval  option is 0, the coincident edges are\nconsidered part of the perimeter.\n\u2022 When the fringe_edge_capval  option is 0, the fringe edges are considered\npart of the perimeter.\nThe default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Specifies the user-derived string used by the remote property function. The\nunique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection for more information. You must ensure that the string is valid and unique\nbecause the IC Validator tool does not check the value. The default is an empty\nstring (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\ncapacitor()\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped. By default, the IC Validator tool does not\nmap swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies an ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nFor example, the list of swappable pins is\nswappable_pins = {{\"XA\",\"XB\"}},\nand the list of swappable properties is\nswappable_properties =\n{{\"XA\",{\"PA1\",\"PA2\"}},{\"XB\",{\"PB1\",\"PB2\"}}}\nWhen pins XA and XB are detected as being swapped, properties PA1 and PB1\nare swapped, as are PA2 and PB2. However, PA1 and PB2 are not swapped,\nnor are PA1 and PA2, due to inconsistent property_list  indexes.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nrunset report file. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement\ndata to external libraries. See the Dynamic-Link Library Support  chapter in\nthe IC Validator User Guide  and\nDynamic Linking Utility Functions  for more\ninformation.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\ncapacitor()\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee Table 40  for more information about the behavior of the\ntop_simulation_properties  argument."}, "summary": "The capacitor()  function collects extraction configuration information about intentional\ncapacitors that are defined by a device body layer and two terminal layers.", "function_name": "capacitor()"}
{"description": "The cell_extent()  function creates a polygon layer that consists of a rectangle in\neach of the specified cells that is equal to the extents of the cell. The extents of the\ncell are defined by all layers read from the input library and include geometric data and\nplacements.\nNote:\nThis is a methodology check function. See restriction 1 (Preserving Cells) in\nMethodology Check Functions.\nNote:\nWhen you use the size()  function with a distance greater than 0 (zero)\nand processing_mode = HIERARCHICAL  on a returned layer from the\ncell_extent()  function, only polygons in the top cell and in the cells defined in\nthe device_extraction_preserved_cells  argument are oversized.", "syntax": "cell_extent(\ncell_list                         = {\"string\", ...},\nname                              = \"layer_label\",          //optional\nkeep_cells                        = true  | false,           //optional\nextent_layers                     = USED_ASSIGN_LAYERS |\nALL_ASSIGN_LAYERS  |\nALL_LAYOUT_LAYERS,      //optional\nexclude_layers                    = {layer, ...},           //optional\nexclude_cells_with_no_used_layers = true | false,           //optional\nexclude_text_layers               = true | false            //optional\ngeometry_match                    = {baseline_cells = {\"string\", ...},\nbaseline_sources =\n{\nGOLDEN_LIBRARY,\nINPUT_LIBRARY, ...},\n}                      //optional\nexpand_text                        = true | false           //optional\n);", "returns": "polygon layer or error result", "arguments": {"cell_list": "Required. Specifies the cell names. If the list is empty, an empty layer is created.\nString matching using metacharacters is allowed. See\nString Matching  for more\ninformation.\ncell_extent()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells  list. The default is\ntrue.\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell.", "extent_layers": "Optional. Specifies the category of layers to take into account for calculating cell\nextent. The default is ALL_ASSIGN_LAYERS.\n\u2022 USED_ASSIGN_LAYERS. Specifies assign layers listed in the runset, which are\nused in by subsequent layer operations.\n\u2022 ALL_ASSIGN_LAYERS. Specifies all assign layers listed in the runset.\n\u2022 ALL_LAYOUT_LAYERS. Specifies all layers that exist in the input design.\nNote:\nThe following command-line options hinder accurate detection of\nused layers. In these use cases all assign layers are considered as\n\u201cused.\u201d\n-ndg, -nro, -disable all, -disable prune", "exclude_layers": "Optional. Specifies the layers to be discarded from the extent calculation. Note\nthat if an exclude layer is duplicated by another assign layer, then both layers\nmust be specified as exclude layers. Otherwise, there is no affect to the extent\ncalculation (as though no layer was specified).\nThe following example illustrates how duplicate assign layers can cause an\nexclude_layer to have no affect on extent calculation.\nL1 = assign({{1, 0}});\nL2 = assign({{>=0, >=0}});\ncell_extent(\u2026, exclude_layers = { L1 }, \u2026);\ncell_extent()\nExcluding L1 in this case has no effect on the extent calculation, because the L2\nassignment causes data on 1;0 to be used regardless.", "exclude_cells_with_no_used_layers": "Optional. Discards cells that contain no used layer from the extent calculation\nof ancestors. A cell is considered to be \u201cused\u201d if it or any of its children contain\nused layers. The default is false.\n\u2022 true. Discards cells that contain no used layer from the extent calculation\n\u2022 false. Does not discard cells that contain no used layer from the extent\ncalculation.\nNote:\nThe following command-line options hinder accurate detection of\nused layers. In these use cases all assign layers are considered as\n\u201cused.\u201d\n-ndg, -nro, -disable all, -disable prune", "exclude_text_layers": "Optional. Discards text layers from the extent calculation. The default is false.\n\u2022 true. Discards text layers from the extent calculation.\n\u2022 false. Does not discard text layers from the extent calculation.", "geometry_match": "Optional. Specifies how geometric matching is performed between placed cells\nfrom the original (tree0) hierarchy and unplaced cells, when the main library is\nGDSII or OASIS, or golden library cells. By default, no geometric matching is\nperformed.\nNote:\nThis argument cannot be used with the assign_openaccess(),\nassign_openaccess_edge(), or assign_openaccess_text()\nfunctions.\n\u2022 baseline_cells. Optional. Specifies a list of cell names of either unplaced\ncells or golden library cells to check for geometric matches with the original\ncell hierarchy. When you use this option, you cannot use the cells  option of\nthe select  argument.\ncell_extent()\nNote:\nFor a large design, if the IC Validator tool determines that the top\ncell might match a golden library cell, the tool displays a warning\nthat runtime and memory is high.\n\u2022 baseline_sources. Optional. Specifies whether the IC Validator tool uses\ncells from one of the golden libraries, unplaced cells, or both to perform\ngeometric matches with placed cells from the original hierarchy. The default\nis GOLDEN_LIBRARY.\n-GOLDEN_LIBRARY. Selects placed cells from the original hierarchy that\ngeometrically match any cells with a specified cell name from one of the\ngolden libraries. For example,\nL1 = assign({{31,0}},\nselect = {geometry_match={baseline_cells={\"F1*\"},\nbaseline_sources={GOLDEN_LIBRARY}}});\nInternal data that is used for geometric matching with golden libraries can\nbe cached for future runs with the same golden library and runset. The\nIC Validator tool does not cache this data by default. Setting the following\nenvironment variables enables caching.\nTo specify the full path to a directory where the golden library cache is\nstored,\nsetenv ICV_MATCH_GOLDEN_CACHE full path to cachedirectory\nThis cache directory can be shared by multiple users who use the same set\nof golden libraries and assign layers for their IC Validator runs.\nTo set the maximum allowed size for the golden layer signatures cache,\nsetenv ICV_MATCH_GOLDEN_CACHE_SIZE size in MB\nThe default size is 200 MB. The tool reports in the dp.log file whether cached\ngolden layer signatures were used in the run or if new signatures were\ncomputed and saved to the cache. The tool also displays warning messages\nif the cache path or directory cannot be created, is not readable or writable,\nor exceeds the size limit.\n- INPUT_LIBRARY. Selects placed cells from the original hierarchy that\ngeometrically match any unplaced cells with a specified cell name.", "expand_text": "Optional. Allows you to decide whether to expand 2 DBU for the cell extents in\ntext layers. The default is false.\ncell_extent()\n\u2022 true. Extracts extent per cell per layer from extent the database and checks\nwhether the layer is a text layer or other.\n\u2022 false. Does not discard text layers from the extent calculation."}, "summary": "The cell_extent()  function creates a polygon layer that consists of a rectangle in\neach of the specified cells that is equal to the extents of the cell.", "function_name": "cell_extent()"}
{"description": "The cell_extent_layer()  function creates a polygon layer that consists of a rectangle in\neach of the specified cells that is equal to the extents of the cell. The extents of the cell are\ndefined by the input layer and include geometric data and placements.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells) and\n2 (Hierarchy) in\nMethodology Check Functions.", "syntax": "cell_extent_layer(\nlayer1    = data_layer,\ncell_list = {\"string\", ...},\nname      = \"layer_label\",     //optional\nkeep_cells = true  | false      //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer from which cells are selected.", "cell_list": "Required. Specifies the cell names. If the list is empty, an empty layer is created.\nString matching using metacharacters is allowed. See\nString Matching  for more\ninformation.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the cells_list  argument. The\ndefault is true.\ncell_extent_layer()\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell."}, "summary": "The cell_extent_layer()  function creates a polygon layer that consists of a rectangle in\neach of the specified cells that is equal to the extents of the cell.", "function_name": "cell_extent_layer()"}
{"description": "The center_to_center1()  function creates polygons that consist of rectangles formed\nby distance violations between center points and center lines of the selected rectangles on\nlayer1  polygons. Nonrectangular data is ignored.\nThe output consists of rectangles that are the extents of the violations. When the violation\nis horizontal or vertical, the output rectangle is generated by expanding the violation three\ntimes the input library resolution on both sides.", "syntax": "center_to_center1(\nlayer1                   = polygon_layer,\ndistance                 = doubleconstraint,\nsides                    = {length1 = doubleconstraint,\nlength2 = doubleconstraint},    //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position         = TOUCH | HALF_WIDTH,              //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\ncenter_to_center1()", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\ncenter_to_center1()\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares, as\nshown in Figure 23.\nFigure 23 square_to_square = POINT_TO_POINT Example", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\n\u2022 NONE. Does not check any spacing between square and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square and the\ncenter of a non square polygon, as shown in\nFigure 24.\ncenter_to_center1()\nFigure 24 square_to_non_square = POINT_TO_POINT Example\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square and the\ncenterline of a non square polygon, as shown in Figure 25.\nFigure 25 square_to_non_square = POINT_TO_LINE Example", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons, as shown in\nFigure 26.\ncenter_to_center1()\nFigure 26 non_square_to_non_square = POINT_TO_POINT Example\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons, as shown in Figure 27. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180\ndegrees, as shown here:\nFigure 27 non_square_to_non_square = LINE_TO_LINE Example\ncenter_to_center1()\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180 degrees, as shown in Figure 28.\nFigure 28 non_square_to_non_square Check Zones Example", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\ncenter_to_center1()\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle, as\nshown in Figure 29.\nFigure 29 line_end_position = TOUCH Example\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge, as shown in Figure 30.\nFigure 30 line_end_position = HALF_WIDTH Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center1()  function creates polygons that consist of rectangles formed\nby distance violations between center points and center lines of the selected rectangles on\nlayer1  polygons.", "function_name": "center_to_center1()"}
{"description": "The center_to_center1_edge()  function creates edges that consist of distance\nviolations between center points and center lines of the selected layer1  rectangles.\nNonrectangular data is ignored. The orientation of the edges is nondeterministic.", "syntax": "center_to_center1_edge(\nlayer1            = polygon_layer,\ndistance          = doubleconstraint,\nsides             = {length1 = doubleconstraint,\nlength2 = doubleconstraint},           //optional\nconnectivity       = SAME_NET | DIFFERENT_NET | ALL,         //optional\nconnect_sequence  = connect_database,                       //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,              //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position        = TOUCH | HALF_WIDTH,              //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.\ncenter_to_center1_edge()", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\nSee the example for the square_to_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares.", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center1_edge()\n\u2022 NONE. Does not check any spacing between square and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square polygon\nand the center of a non square polygon.\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square and the\ncenterline of a non square polygon.", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the non_square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons.\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180\ndegrees.\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180 degrees.", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\nSee the examples for the line_end_position  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center1_edge()\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle.\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center1_edge()  function creates edges that consist of distance\nviolations between center points and center lines of the selected layer1  rectangles.", "function_name": "center_to_center1_edge()"}
{"description": "The center_to_center1_error()  function creates error layers that consist of distance\nviolations between center points and center lines of the selected layer1  rectangles.\nNonrectangular data is ignored. The orientation of the error layers is nondeterministic.", "syntax": "center_to_center1_error(\nlayer1            = polygon_layer,\ndistance          = doubleconstraint,\nsides             = {length1 = doubleconstraint,\nlength2 = doubleconstraint},           //optional\nconnectivity       = SAME_NET | DIFFERENT_NET | ALL,         //optional\nconnect_sequence  = connect_database,                       //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,              //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position        = TOUCH | HALF_WIDTH,              //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "error layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.\ncenter_to_center1_error()", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\nSee the example for the square_to_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares.", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center1_error()\n\u2022 NONE. Does not check any spacing between square and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square polygon\nand the center of a non square polygon.\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square and the\ncenterline of a non square polygon.", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the non_square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons.\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180-\ndegrees.\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180-degrees.", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\nSee the examples for the line_end_position  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center1_error()\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle.\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center1_error()  function creates error layers that consist of distance\nviolations between center points and center lines of the selected layer1  rectangles.", "function_name": "center_to_center1_error()"}
{"description": "The center_to_center2()  function creates polygons that consist of rectangles formed by\ndistance violations between center points and center lines of the selected rectangles from\nlayer1  to layer2. Nonrectangular data is ignored.\nThe output consists of rectangles that are the extents of the violations. When the violation\nis horizontal or vertical, the output rectangle is generated by expanding the violation three\ntimes the input library resolution on both sides.", "syntax": "center_to_center2(\nlayer1                   = polygon_layer,\nlayer2                   = polygon_layer,\ndistance                 = doubleconstraint,\nsides                    = {length1 = doubleconstraint,\nlength2 = doubleconstraint},    //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position         = TOUCH | HALF_WIDTH,              //optional\ntouch                    = true | false,                    //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\ncenter_to_center2()\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\nSee the example for the square_to_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares.", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\ncenter_to_center2()\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between square and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square polygon\nand the center of a non square polygon.\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square polygon\nand the centerline of a non square polygon.", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the non_square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons.\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180\ndegrees.\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180 degrees.", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\ncenter_to_center2()\nSee the examples for the line_end_position  argument of the\ncenter_to_center1()  function for more information.\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle.\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge.", "touch": "Optional. When set to true, square_to_square, square_to_non_square, and\nnon_square_to_non_square  touches are violations. The output shape for a\ntouch violation is a box with sides of 6 units for polygon output, as shown in\nFigure 35. The default is false.\nFigure 35 center_to_center2() Function Touch Violation Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center2()  function creates polygons that consist of rectangles formed by\ndistance violations between center points and center lines of the selected rectangles from\nlayer1  to layer2.", "function_name": "center_to_center2()"}
{"description": "The center_to_center2_edge()  function creates edges that consist of distance\nviolations between center points and center lines of the selected rectangles from layer1\nto layer2. Nonrectangular data is ignored. The edges are oriented from layer1  to\nlayer2.", "syntax": "center_to_center2_edge(\nlayer1                   = polygon_layer,\nlayer2                   = polygon_layer,\ndistance                 = doubleconstraint,\nsides                    = {length1 = doubleconstraint,\nlength2 = doubleconstraint},    //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position         = TOUCH | HALF_WIDTH,              //optional\ntouch                    = true | false,                    //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\ncenter_to_center2_edge()", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\nSee the example for the square_to_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares.", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\ncenter_to_center2_edge()\nSee the examples for the square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between square polygons and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square polygon\nand the center of a non square polygon.\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square polygon\nand the centerline of a non square polygon.", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the non_square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons.\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180\ndegrees.\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180 degrees.", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\nSee the examples for the line_end_position  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center2_edge()\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle.\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge.", "touch": "Optional. Specifies that when set to true, square_to_square,\nsquare_to_non_square, and non_square_to_non_square  touches are\nviolations. The output shape for a touch violation has two edges that form a\n\u201c+\u201d shape for edge output, as shown in\nFigure 39. Each edge has a length of 6\nunits. The orientation of the edges is nondeterministic. The default is false.\nFigure 39 center_to_center2_edge() Function Touch Violation Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center2_edge()  function creates edges that consist of distance\nviolations between center points and center lines of the selected rectangles from layer1\nto layer2.", "function_name": "center_to_center2_edge()"}
{"description": "The center_to_center2_error()  function creates edges that consist of distance\nviolations between center points and center lines of the selected rectangles from layer1\nto layer2. Nonrectangular data is ignored.", "syntax": "center_to_center2_error(\nlayer1                   = polygon_layer,\nlayer2                   = polygon_layer,\ndistance                 = doubleconstraint,\nsides                    = {length1 = doubleconstraint,\nlength2 = doubleconstraint},    //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nsquare_to_square         = NONE | POINT_TO_POINT,           //optional\nsquare_to_non_square     = NONE | POINT_TO_POINT  | POINT_TO_LINE,\n//optional\nnon_square_to_non_square  = NONE | POINT_TO_POINT  | LINE_TO_LINE,\n//optional\nline_end_position         = TOUCH | HALF_WIDTH,              //optional\ntouch                    = true | false,                    //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "error layer", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\ncenter_to_center2_error()", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\noption is optional, with a default of >0. See\nConstraints  for more information.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "square_to_square": "Optional. Checks center-to-center spacing between square polygons. See the\nsquare_to_non_square  and non_square_to_non_square  arguments for more\ninformation. The default is POINT_TO_POINT.\nSee the example for the square_to_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between squares.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of squares.", "square_to_non_square": "Optional. Checks center-to-centerline spacing between square and non square\npolygons. Only orthogonal data is checked. See the square_to_square  and\nnon_square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\ncenter_to_center2_error()\nSee the examples for the square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between square polygons and non square\npolygons.\n\u2022 POINT_TO_POINT. Checks spacing between the center of a square polygon\nand the center of a non square polygon.\n\u2022 POINT_TO_LINE. Checks spacing between the center of a square polygon\nand the centerline of a non square polygon.", "non_square_to_non_square": "Optional. Checks centerline-to-centerline spacing between non square\npolygons. Only orthogonal data is checked. See the square_to_square\nand square_to_non_square  arguments for more information. The default is\nPOINT_TO_POINT.\nSee the examples for the non_square_to_non_square  argument of the\ncenter_to_center1()  function for more information.\n\u2022 NONE. Does not check any spacing between non square polygons.\n\u2022 POINT_TO_POINT. Checks spacing between the centers of non square\npolygons.\n\u2022 LINE_TO_LINE. Checks spacing between the centerlines of non square\npolygons. Two types of checking are performed:\n\u25e6 Edge-to-edge spacing check.\n\u25e6 Endpoint-to-endpoint spacing check. This check is limited to outside 180\ndegrees.\nThe POINT_TO_POINT  check zone is not limited, but the LINE_TO_LINE  check\nzone is limited to 180 degrees.", "line_end_position": "Optional. Specifies the line-end position relative to the rectangle width edge that\nis used in the check region. The default is HALF_WIDTH.\nNote:\nThe line_end_position  argument is used only when the\nsquare_to_non_square  argument is POINT_TO_LINE  or the\nnon_square_to_non_square  argument is LINE_TO_LINE.\nSee the examples for the line_end_position  argument of the\ncenter_to_center1()  function for more information.\ncenter_to_center2_error()\n\u2022 TOUCH. Specifies that line ends touch the width edges of the rectangle.\n\u2022 HALF_WIDTH. Specifies that the line end is a distance of one-half of the\nrectangle width from the width edge.", "touch": "Optional. Specifies that when set to true, square_to_square,\nsquare_to_non_square, and non_square_to_non_square  touches are\nviolations. The output shape for a touch violation has two edges that form a \u201c+\u201d\nshape for edge output. Each edge has a length of 6 units. The orientation of the\nedges is nondeterministic. The default is false.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The center_to_center2_error()  function creates edges that consist of distance\nviolations between center points and center lines of the selected rectangles from layer1\nto layer2.", "function_name": "center_to_center2_error()"}
{"description": "The check_property()  function compares the values of properties between matched\nschematic and layout devices. Use the property_tolerances  argument to compare\nproperties based on a tolerance value. Use the property_function  argument to compare\nproperties based on more complex conditions.\nWhen resolving symmetry, the IC Validator tool uses properties and property\ntolerances when symmetry cannot be resolved by other means. When a user-\ndefined property_function  is used in the check_property()  function, however,\nthe IC Validator tool can no longer use property information for resolving symmetry.\nTherefore, if calculations on properties are needed before their comparison, use the\nrecalculate_property()  function to do these calculations rather than performing them\nin a check_property()  function.\nThis function should be in any typical LVS runset, and it must be called before the\ncompare()  function. See Chapter 7, \u201cCompare Functions Basics\u201d in the IC Validator LVS\nUser Guide  for more information about complementary functions and precedence rules.\nNote:\nDo not use the recognize_gate()  function when a remote function is specified\nby the property_function  argument of the check_property()  function.", "syntax": "check_property(\nstate               = compare_state,\ndevice_type         = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names        = {\"string\", ...},                      //optional\nproperty_tolerances = {{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type = RELATIVE  | ABSOLUTE},\n...},                                //optional\nproperty_function   = \"string\",                             //optional\nschematic_optional_properties = {\"string\", ...},            //optional\nequiv_cells         = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                 //optional\n);", "returns": "void\ncheck_property()", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation specified in the check_property()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices. Each device must match a device\nspecified in a device_name  argument of a device configuration function.", "property_tolerances": "Optional. Lists the properties to be compared. A maximum of 100 user-defined\nproperties can be listed. See \u201cPredefined Name Matches\u201d in Chapter 7,\n\u201cCompare Functions Basics\u201d of the IC Validator LVS User Guide  for the names\nand associated matches that are predefined during LVS compare.\nYou must use either the property_tolerances  or property_function\nargument in the check_property()  function.\nNote:\nYou can use both the property_tolerances  and\nproperty_function  arguments in the check_property()\nfunction. If you use both arguments, you must make sure that a\nproperty is not checked by both arguments. You do not need to\nlist in the property_tolerances  argument the properties that are\nreferenced by the\nlvs_get_double_property()  function. The\nlvs_get_double_property()  function is in the remote function\nspecified by the property_function  argument.\n\u2022 property. Required. Specifies the property name.\n\u2022 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies either that the\ntolerance is a percentage (default) or absolute value. The default is [-10,\n+10].\nThe minimum resolution allowed for tolerance checking is as follows:\n\u25e6 When schematic_property !=0, the minimum resolution value is\nabsolute_value(schematic_property* LVS property epsilon\nvalue)\ncheck_property()\n\u25e6 When schematic_property ==0, the minimum resolution value is\nabsolute_value(layout_property* LVS property epsilon value)\nIf the specified tolerance range is less than this minimum value, for example,\n[-0,0], the property  option is checked for violations according to the\nminimum resolution.\n\u2022 tolerance_type. Optional. Checks property tolerances based on a relative\nor absolute property difference. The default is RELATIVE.\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the\nlvs_user_unit  argument of\nthe run_options()  function.", "property_function": "Optional. Specifies the remote function that compares the specified properties.\nSee\nCompare Utility Functions  for more information about the utility functions\nyou can use to define a remote function.\nYou must use either the property_tolerances  or property_function\nargument in the check_property()  function.\nWhen you use the property_function  argument, the IC Validator tool is\nunable to use the properties to break symmetry.\nNote:\nSee the property_tolerances  argument for more information about\nusing both the property_tolerances  and property_function\narguments of the check_property()  function.", "schematic_optional_properties": "Optional. Specifies the properties, defined on schematic instances, that are not\ncompared.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which information\nspecified in the check_property()  function applies. You must specify the\nequiv_cells  pairs in the equiv_options()  function before calling the\ncheck_property()  function. If only one cell name in the pair is specified, the\nnames are assumed to be the same.\ncheck_property()\nNote:\nThe check_property()  instruction is observed only when comparing\neach listed equivalence cell pair. If an equivalence cell pair is\nexploded into the parent equivalence cell pair while comparing\nthe parent, the check_property()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The check_property()  function compares the values of properties between matched\nschematic and layout devices.", "function_name": "check_property()"}
{"description": "The check_property_off()  function disables checking of properties for specified\ndevices. For example, you can use the check_property()  function to enable property\nchecking for all NMOS devices and use the check_property_off()  function to disable\nthe property checking for nm1, a specific NMOS device.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "check_property_off(\nstate        = compare_state,\ndevice_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names = {\"string\", ...}                              //optional\nequiv_cells  = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},...}            //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation specified in the check_property_off()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices. Each device must match a device\nspecified in a device_name  argument of a device configuration function.", "equiv_cells": "Optional. Specifies a list of schematic and layout cell name pairs for which\nthe information specified in the check_property_off()  function applies. You\nmust specify the equiv_cells  pairs in the equiv_options()  function before\ncalling the check_property_off()  function. If only one cell name in the pair is\nspecified, the names are assumed to be the same.\ncheck_property_off()\nNote:\nThe check_property_off()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell pair\nis exploded into the parent equivalence cell pair while comparing the\nparent, the check_property_off()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The check_property_off()  function disables checking of properties for specified\ndevices.", "function_name": "check_property_off()"}
{"description": "The check_symmetry()  function checks the symmetry of the target layer polygons against\nthe created, mirrored context layer polygons. The function\n\u2022 Creates mirrored bodies of the original polygons (layer1) within each bounding box of\nthe context layer according to the given symmetry type.\n\u2022 Compares the original polygons against the created mirrored polygons, reports the\nexisting part in target polygons not in mirrored polygons, and vice versa.\n\u2022 Polygons in the context layer are deposited in the top cell.", "syntax": "check_symmetry(\nlayer1         = polygon_layer,\ncontext_layer  = polygon_layer,\nsymmetry       = HORIZONTAL_AXIS | VERTICAL_AXIS | ROTATE_180,\nname           = \"layer_label\"                               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is the target layer.", "context_layer": "Required. Specifies the polygon layer that is the context layer. Polygons in\nlayer1  that interact with polygons on the context layer are selected.", "symmetry": "Optional. Specifies the symmetry type of the pattern. The options are\n\u2022 HORIZONTAL_AXIS\n\u2022 VERTICAL_AXIS\n\u2022 ROTATE_180", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ncheck_symmetry()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The check_symmetry()  function checks the symmetry of the target layer polygons against\nthe created, mirrored context layer polygons.", "function_name": "check_symmetry()"}
{"description": "The chip_extent()  function creates a polygon layer that consists of a single rectangle in\nthe top cell which is equal to the extents of the top cell. The top cell extents are defined by\nall layers read from the input library. The extents of the top cell include geometric data and\nplacements.", "syntax": "chip_extent(\nname = \"layer_label\"  //optional\n);", "returns": "polygon layer", "arguments": {"name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The chip_extent()  function creates a polygon layer that consists of a single rectangle in\nthe top cell which is equal to the extents of the top cell.", "function_name": "chip_extent()"}
{"description": "Specifies dimensional checks for these approximated circles, including their diameters and\nvertices counts.", "syntax": "circles(\nlayer1           = polygon_layer,\ndiameter         = double_constraint, //optional\ntolerance        = double, //optional\nvertex_count     = intergerconstraint,  //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\"\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies a polygon layer.", "diameter": "Optional. Specifies the diameter constraints from the polygon extent center to\neach polygon vertex. See\nConstraints  for more information.\ncircles()", "tolerance": "Optional. Specifies the expansion values to the original <diameter>  constraint.", "vertex_count": "Optional. Specifies the vertices count of one polygon to be output.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Specifies the name used by the IC Validator tool for the output layer. This\nname is displayed in various output log files, such as the summary, tree, and\ndistributed processing log files. It is used only for log files; runset variables are\nnot changed. The default is the name of the layer being created."}, "summary": "Specifies dimensional checks for these approximated circles, including their diameters and\nvertices counts.", "function_name": "circles()"}
{"description": "The circle_analyze()  function analyzes how similar an input polygon is to a circle or\nan annulus, and it generates the designated shapes. For each input polygon, two circles\nconcentric with the minimum enclosing circle (MEC) of the polygon are considered by\ncalculating their radii.\nThis function also analyzes a polygon for its annular characteristics when there is only\none hole in the shape, and the hole encloses the MEC center. The output layer by default\nis a copy of the input layer and can be altered to visualize the characterizing circles. The\noutput is merged.", "syntax": "circle_analyze(\nlayer1           = polygon_layer,\nsave_properties  = {out_radius = \"string\",\nin_radius           = \"string\",\nannulus_out_radius  = \"string\",\nannulus_in_radius   = \"string\"},  // optional\noutput_type      = COPY  | CIRCLE,                     // optional\nmeasure_by       = VERTEX_OR_EDGE  | VERTEX,           // optional\nvertex_count     = integer,                           // optional\nrectangle_only   = false| true,                       // optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL           // optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer against which the four radii are calculated.", "save_properties": "Optional. Specifies the property names with which the four radii are attached\nwhen the output_type  argument is COPY. The default name of each property is\nan empty string(\u201c\u201d). Any property with an empty string specified is not saved.\n\u2022 out_radius. Specifies the name used to attach the OUT_RADIUS  of the input\npolygon.\n\u2022 in_radius. Specifies the name used to attach the IN_RADIUS  of the input\npolygon.\ncircle_analyze()\n\u2022 annulus_out_radius. Specifies the name used to attach the\nANNULUS_OUT_RADIUS  of the input polygon.\n\u2022 annulus_in_radius. Specifies the name used to attach the\nANNULUS_IN_RADIUS  of the input polygon.\nFor more information on the four radii, see Table 33  in \u201cProperties Added by\ncircle_analyze\u201d.", "output_type": "Optional. Specifies what shapes are written to the output layer. The default is\nCOPY.\n\u2022 COPY. Specifies that the output layer is a copy of the input layer. The radii are\nattached to each output polygon.\n\u2022 CIRCLE. Specifies that a circle approximation based on IN_RADIUS  is\ngenerated for each input polygon. When the measure_by  argument is\nVERTEX  and the rectangle_only  argument is true, the vertices of the\noutput shape are snapped outward from the MEC center to the closest grid.\nThe radii are not attached to the output polygons.", "measure_by": "Optional. Specifies how IN_RADIUS  and ANNULUS_IN_RADIUS  are measured.\nThe default is VERTEX_OR_EDGE.\n\u2022 VERTEX_OR_EDGE. Measures IN_RADIUS  and ANNULUS_IN_RADIUS  by the\ndistances from the MEC center to the vertices or edges of the input polygon.\n\u2022 VERTEX. Measures IN_RADIUS  and ANNULUS_IN_RADIUS  only by the\ndistances from the MEC center to the vertices of the input polygon.", "vertex_count": "Optional. Specifies how many vertices are used to output circle or ring\napproximations. The default is NULL_INTEGER.\nThe value should be a power of two between 16 and 1024. If the specified value\nis not a power of two, it is rounded up to the next power of two. If the value is the\ndefault, the function automatically determines a value based on how circular a\nshape is. The more circular or annular an input polygon is, the more vertices are\nused until it reaches 1024 vertices for circle approximation.", "rectangle_only": "Optional. Specifies whether the function analyzes only rectangles. The default is\nfalse.\ncircle_analyze()\n\u2022 false. Specifies that all shapes are analyzed.\n\u2022 true. Specifies that only rectangles orthogonal to the library axes are\nanalyzed.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The circle_analyze()  function analyzes how similar an input polygon is to a circle or\nan annulus, and it generates the designated shapes.", "function_name": "circle_analyze()"}
{"description": "The circle_analyze_unmerged()  function analyzes how similar an input polygon is to a\ncircle or an annulus, and it attaches the results to the corresponding output polygon. For\neach input polygon, two circles concentric with the minimum enclosing circle (MEC) of the\npolygon are considered by calculating their radii.\nThis function also analyzes a polygon for its annular characteristics when there is only\none hole in the shape, and the hole encloses the MEC center. The output layer by default\noutputs 2 DBU times 2 DBU squares, with its center snapped to the grid point closest to\nthe MEC center. The output is unmerged.", "syntax": "circle_analyze_unmerged(\nlayer1           = polygon_layer,\nsave_properties  = {out_radius = \"string\",\nin_radius           = \"string\",\nannulus_out_radius  = \"string\",\nannulus_in_radius   = \"string\"},  // optional\noutput_type      = CENTER  | CIRCLE |\nRING,                     // optional\nmeasure_by       = VERTEX_OR_EDGE  | VERTEX,           // optional\nvertex_count     = integer,                           // optional\nrectangle_only   = false| true,                       // optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL           // optional\n);", "returns": "unmerged polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer against which the four radii are calculated.", "save_properties": "Optional. Specifies the property names with which the four radii are attached to\neach output polygon. The default name of each property is an empty string(\u201c\u201d).\nAny property with an empty string specified is not saved.\n\u2022 out_radius. Specifies the name used to attach the OUT_RADIUS  of the input\npolygon.\n\u2022 in_radius. Specifies the name used to attach the IN_RADIUS  of the input\npolygon.\ncircle_analyze_unmerged()\n\u2022 annulus_out_radius. Specifies the name used to attach the\nANNULUS_OUT_RADIUS  of the input polygon.\n\u2022 annulus_in_radius. Specifies the name used to attach the\nANNULUS_IN_RADIUS  of the input polygon.\nFor more information on the four radii, see Table 34  in \u201cProperties Added by\ncircle_analyze_unmerged\u201d.", "output_type": "Optional. Specifies what shapes are written to the output layer. The default is\nCENTER.\n\u2022 CENTER. Specifies that for each polygon in the input layer,a 2 DBU times 2\nDBU square is generated. The center of the square is placed at the grid point\nnearest the MEC center.\n\u2022 CIRCLE. Specifies that a circle approximation based on IN_RADIUS  is\ngenerated for each input polygon. When the measure_by  argument is\nVERTEX  and the rectangle_only  argument is true, the vertices of the\noutput shape are snapped outward from the MEC center to the closest grid.\n\u2022 RING. Specifies that a ring or a circle approximation is generated for each\ninput polygon, depending on the values of the four radii.\nFor more information on the output shapes generated by the RING  options, see\nTable 35  in \u201cThe Output Shapes of the RING Option\u201d.", "measure_by": "Optional. Specifies how IN_RADIUS  and ANNULUS_IN_RADIUS  are measured.\nThe default is VERTEX_OR_EDGE.\n\u2022 VERTEX_OR_EDGE. Measures IN_RADIUS  and ANNULUS_IN_RADIUS  by the\ndistances from the MEC center to the vertices or edges of the input polygon.\n\u2022 VERTEX. Measures IN_RADIUS  and ANNULUS_IN_RADIUS  only by the\ndistances from the MEC center to the vertices of the input polygon.", "vertex_count": "Optional. Specifies how many vertices are used to output circle or ring\napproximations. The default is NULL_INTEGER.\nThe value should be a power of two between 16 and 1024. If the specified value\nis not a power of two, it is rounded up to the next power of two. If the value is\nthe default, the function automatically determines a value based on how circular\na shape is. The more circular or annular an input polygon is, the more vertices\nare used until it reaches 1024 vertices for circle approximations or 2048 for ring\napproximations.\ncircle_analyze_unmerged()", "rectangle_only": "Optional. Specifies whether the function analyzes only rectangles. The default is\nfalse.\n\u2022 false. Specifies that all shapes are analyzed.\n\u2022 true. Specifies that only rectangles orthogonal to the library axes are\nanalyzed.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The circle_analyze_unmerged()  function analyzes how similar an input polygon is to a\ncircle or an annulus, and it attaches the results to the corresponding output polygon.", "function_name": "circle_analyze_unmerged()"}
{"description": "The coincident_edge()  function selects the portion of all layer1  edges that are\ncoincident with layer2  edges. It includes inside and outside coincident.\nNOT of 2 edges\nThe complement\nof this function is the not_coincident_edge()  function.", "syntax": "coincident_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ncoincident_edge() and not_coincident_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_edge()  function selects the portion of all layer1  edges that are\ncoincident with layer2  edges.", "function_name": "not_coincident_edge()"}
{"description": "The coincident_edge()  function selects the portion of all layer1  edges that are\ncoincident with layer2  edges. It includes inside and outside coincident.\nNOT of 2 edges\nThe complement\nof this function is the not_coincident_edge()  function.", "syntax": "coincident_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ncoincident_edge() and not_coincident_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_edge()  function selects the portion of all layer1  edges that are\ncoincident with layer2  edges.", "function_name": "coincident_edge()"}
{"description": "The coincident_inside_edge()  function selects the portion of all layer1  edges\nthat are inside coincident with layer2  edges.\nNOT of 2 edges\nThe complement of this function is the\nnot_coincident_inside_edge()  function.", "syntax": "coincident_inside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_inside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ncoincident_inside_edge() and not_coincident_inside_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_inside_edge()  function selects the portion of all layer1  edges\nthat are inside coincident with layer2  edges.", "function_name": "coincident_inside_edge()"}
{"description": "The coincident_inside_edge()  function selects the portion of all layer1  edges\nthat are inside coincident with layer2  edges.\nNOT of 2 edges\nThe complement of this function is the\nnot_coincident_inside_edge()  function.", "syntax": "coincident_inside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_inside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ncoincident_inside_edge() and not_coincident_inside_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_inside_edge()  function selects the portion of all layer1  edges\nthat are inside coincident with layer2  edges.", "function_name": "not_coincident_inside_edge()"}
{"description": "The coincident_outside_edge()  function selects the portion of all layer1  edges\nthat are outside coincident with layer2  edges.\nNOT of 2 edges\nThe complement of this function is the\nnot_coincident_outside_edge()  function.", "syntax": "coincident_outside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_outside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which the edges are\nselected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ncoincident_outside_edge() and not_coincident_outside_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_outside_edge()  function selects the portion of all layer1  edges\nthat are outside coincident with layer2  edges.", "function_name": "coincident_outside_edge()"}
{"description": "The coincident_outside_edge()  function selects the portion of all layer1  edges\nthat are outside coincident with layer2  edges.\nNOT of 2 edges\nThe complement of this function is the\nnot_coincident_outside_edge()  function.", "syntax": "coincident_outside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_coincident_outside_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which the edges are\nselected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ncoincident_outside_edge() and not_coincident_outside_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The coincident_outside_edge()  function selects the portion of all layer1  edges\nthat are outside coincident with layer2  edges.", "function_name": "not_coincident_outside_edge()"}
{"description": "The color_conflict_layers()  function assigns color-layer groups. In the runset, you\nmust call this function before the\nnet_color_check()  function.", "syntax": "color_conflict_layers(\ncolor_groups = {{polygon_layer, ...}, ...}}\n);", "returns": "color database", "arguments": {"color_groups": "Required. Specifies multiple lists of layers. Each list of layers defines a group.\nEvery layer in the group represents a different color. For example {M1A, M1B}\ndefines a group; layer M1A has a different color from layer M1B.\nOne layer cannot be put in more than one group and one layer cannot be put\ntwice in the same group."}, "summary": "The color_conflict_layers()  function assigns color-layer groups.", "function_name": "color_conflict_layers()"}
{"description": "The color_conflict_layers_order()  function assigns ordered color-layer groups. In\nthe runset, you must call either this function or the\ncolor_conflict_layers()  function\nbefore the net_color_check()  function. The color_conflict_layers_order()  function\ncall is needed only for color checking on schematic device pins.", "syntax": "color_conflict_layers_order(\ncolor_groups = {{color_layers = {polygon_layer, ...},\norder = integer}, ...}\n);", "returns": "color database", "arguments": {"color_groups": "Required. Specifies multiple color groups and defines the order of each group.\nThe order is used to validate the color rules in the input color file. Only order 1\ncolor layers can be checked against schematic device pins.\n\u2022 color_layers. Required. Specifies multiple lists of layers. Each list of layers\ndefines a color group. Every layer in the group represents a different color.\nFor example {M1A, M1B} defines a group; layer M1A has a different color\nfrom layer M1B.\nOne layer cannot be put in more than one group and one layer cannot be put\ntwice in the same group.\n\u2022 order. Required. Specifies the order for the color groups. The order of a\ncolor group is a unique positive integer that labels all the color layers in the\ngroup."}, "summary": "The color_conflict_layers_order()  function assigns ordered color-layer groups.", "function_name": "color_conflict_layers_order()"}
{"description": "The color_global_options()  function controls whether code can run in QUICK  mode,\nand set the thresholds for QUICK  mode for time-consuming operations in the multi-\npatterning functions. These time-consuming operations include searching for coloring\nsolutions, conflict paths, and fix guidance.", "syntax": "color_global_options(\ntwo_color_search_mode        = NORMAL_FOR_UNSET | QUICK_FOR_UNSET  |\nNORMAL_FOR_ALL |\nQUICK_FOR_ALL,       //optional\ntwo_color_quick_mode_spec    = {1, NULL_INTEGER, 3600, 100, 1000},\nthree_color_search_mode      = NORMAL_FOR_UNSET  | QUICK_FOR_UNSET |\nNORMAL_FOR_ALL |\nQUICK_FOR_ALL,      //optional\nthree_color_quick_mode_spec  = {100000, 0.3, 0.3, 0.3, 0.3},\nfour_color_search_mode       = NORMAL_FOR_UNSET  | QUICK_FOR_UNSET |\nNORMAL_FOR_ALL |\nQUICK_FOR_ALL,      //optional\nfour_color_quick_mode_spec   = {100000, 0.3, 0.3, 0.3, 0.3}", "returns": "void", "arguments": {"two_color_search_mode": "Optional. Controls the precedence of the current function options as well as the\ntwo_color()  function and its search_mode  and quick_mode_spec  arguments.\nThe default is QUICK_FOR_UNSET.\n\u2022 NORMAL_FOR_UNSET. Specifies that the two_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode for this function is turned off; it never enters QUICK  mode or exits the\nordinary search flow.\n\u2022 QUICK_FOR_UNSET. Specifies that the two_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode is enabled, and it uses the two_color_quick_mode_spec  settings in\nthis function.\ncolor_global_options()\n\u2022 NORMAL_FOR_ALL. Specifies that all two_color()  functions turn off the QUICK\nmode.\n\u2022 QUICK_FOR_ALL. Specifies that all two_color()  functions turn on the QUICK\nmode and use the two_color_quick_mode_spec  settings in this function.", "two_color_quick_mode_spec": "Optional. Specifies the structure that stores the thresholds of QUICK  mode for\ntwo color(). This behavior is the same as the quick_mode_spec  argument\nof the two_color()  function. The default is this structure\u2019s default. See\nquick_mode_spec  argument of the two_color()  function for descriptions of the\nfollowing options.\n{\nmin_conflicts            = 1;\nmin_standard_time        = -1;\nmin_standard_search_time = 3600;\nmax_net_conflicts        = 100;\nmax_group_conflicts      = 1000;\n}", "three_color_search_mode": "Optional. Controls the precedence of the current function options as well as\nthe three_color()  function and its search_mode  and quick_mode_spec\narguments. The default is NORMAL_FOR_UNSET.\n\u2022 NORMAL_FOR_UNSET. Specifies that the three_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode for this function is turned off; it never enters QUICK  mode or exits the\nordinary search flow.\n\u2022 QUICK_FOR_UNSET. Specifies that the three_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode is enabled, and it uses the three_color_quick_mode_spec  settings\nin this function.\n\u2022 NORMAL_FOR_ALL. Specifies that all three_color()  functions turn off the\nQUICK  mode.\n\u2022 QUICK_FOR_ALL. Specifies that all three_color()  functions turn on the\nQUICK  mode and use the three_color_quick_mode_spec  settings in this\nfunction.", "three_color_quick_mode_spec": "Optional. Specifies the structure that stores the thresholds of QUICK  mode for\nthree color(). This behavior is the same as the quick_mode_spec  argument\nof the three_color()  function. The default is this structure\u2019s default. See the\ncolor_global_options()\nquick_mode_spec  argument of the three_color()  function for descriptions of\nthe following options.\n{\ngraph_nodes            = 100000;\nkn_ratio               = 0.3;\nself_loop_ratio        = 0.3;\nflatten_conflict_ratio = 0.3;\nconflict_elimination_time_ratio = 0.3;\n}", "four_color_search_mode": "Optional. Controls the precedence of the current function options as well as the\nfour_color()  function and its search_mode  and quick_mode_spec  arguments.\nThe default is NORMAL_FOR_UNSET.\n\u2022 NORMAL_FOR_UNSET. Specifies that the four_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode for this function is turned off; it never enters QUICK  mode or exits the\nordinary search flow.\n\u2022 QUICK_FOR_UNSET. Specifies that the four_color()  function uses its own\nsettings if the search_mode  argument is not UNSET. Otherwise, the QUICK\nmode is enabled, and it uses the four_color_quick_mode_spec  settings in\nthis function.\n\u2022 NORMAL_FOR_ALL. Specifies that all four_color()  functions turn off the\nQUICK  mode.\n\u2022 QUICK_FOR_ALL. Specifies that all four_color()  functions turn on the QUICK\nmode and use the four_color_quick_mode_spec  settings in this function.", "four_color_quick_mode_spec": "Optional. Specifies the structure that stores the thresholds of QUICK  mode for\nfour color(). This behavior is the same as the quick_mode_spec  argument\nof the four_color()  function. The default is this structure\u2019s default. See the\nquick_mode_spec  argument of the four_color()  function for descriptions of\nthe following options.\n{\ngraph_nodes            = 100000;\nkn_ratio               = 0.3;\nself_loop_ratio        = 0.3;\nflatten_conflict_ratio = 0.3;\nconflict_elimination_time_ratio = 0.3;\n}\ncolor_global_options()"}, "summary": "The color_global_options()  function controls whether code can run in QUICK  mode,\nand set the thresholds for QUICK  mode for time-consuming operations in the multi-\npatterning functions.", "function_name": "color_global_options()"}
{"description": "The color_stitch()  function generates a polygon layer containing stitch candidates.\nNote:\nThis function only works in case of orthogonal polygons.", "syntax": "color_stitch(\nstitch_spec  = {color_number = integer,\nconcave_spacing =  double,\nconvex_spacing =  double,\nmin_stitch_width = double,\nmax_stitch_width = double,\nstitch_length = double,\nmin_node_area = double,\nstitch_grid = double, //optional\nstitch_space_constraints =\n{{min_distance = double,\n//required\nextension =  NONE | NONE_INCLUSIVE |\nRADIAL | SQUARE | RECTANGLE | EDGE,\n//optional\nextension_distance = double //optional\n},...}  //optional\n}, //required\nnodes  =  polygon_layer, //required\nlinks  =  error_layer, //required\nkeep_out  = polygon_layer, //optional\npre_color1  = polygon_layer,   //optional\npre_color2  = polygon_layer,   //optional\npre_color3  = polygon_layer,   //optional\npre_color4  = polygon_layer\uff0c  //optional\nextra_nodes  = polygon_layer    //optional\n};", "returns": "polygon layer\ncolor_stitch()", "arguments": {"stitch_spec": "Required. Specifies the stitch specification as follows:\n\u2022 color_number. Required. Specifies whether it is for three or four color. The\nvalue must be 3 or 4.\n\u2022 concave_spacing. Required. Specifies the distance from the inside vertex of\na corner where stitch placement is prohibited.\n\u2022 convex_spacing. Required. Specifies the distance from the outside vertex of\na corner where stitch placement is prohibited.\n\u2022 min_stitch_width. Required. Specifies the minimum width of the generated\nstitch candidate.\n\u2022 max_stitch_width. Required. Specifies the maximum width of the\ngenerated stitch candidate.\n\u2022 stitch_length. Required. Specifies the length of the generated stitch\ncandidate.\n\u2022 min_node_area. Required. Specifies the smallest allowable area of any node\nresult from stitching.\n\u2022 stitch_grid. Optional. Specifies the grid for stitch placement. The default\nis 0 which means that it uses 2*internal_resolution. If it is not set to\na proper value (negative or less than working resolution), code forces it to\n2*internal_resolution.\n\u2022 stitch_space_constraints. Optional. Specifies a list of distance check\nrules from stitch to stitch. The default is empty which means that there is no\ndistance check between stitches.\n\u25e6 min_distance. Required. Specifies the check distance from stitch to\nstitch. The value must be nonnegative. The command ensures that the\ndistance between any two stitches it generates is equal to or greater than\nthis value, or in another words, no other stitches are placed in the region\nwhere the distance to any stitch < min_distance.\n\u25e6 extension. Optional. Specifies the extension of the check region, beyond\nthe endpoints of the edge being checked. The value can be NONE |\nNONE_INCLUSIVE | RADIAL | SQUARE | RECTANGLE | EDGE. The\ndefault is RADIAL.\n\u25e6 extension_distance. Optional. Specifies the check region extension\ndistance when the extension argument is RECTANGLE  or EDGE. The value\nmust be nonnegative. The default is 0.\ncolor_stitch()", "nodes": "Required. Specifies a polygon layer that contains the polygons targeted to\ngenerate stitch candidates.", "links": "Required. Specifies connection status of nodes. This input must be an error\nlayer.", "keep_out": "Optional. Specifies the area where stitches cannot be placed. The default is\nempty.", "pre_color1": "Optional. Specifies pre-color polygon with color 1. Stitches cannot touch them.\nThe default is empty.", "pre_color2": "Optional. Specifies pre-color polygons with color 2. Stitches cannot touch them.\nThe default is empty.", "pre_color3": "Optional. Specifies pre-color polygons with color 3. Stitches cannot touch them.\nThe default is empty.", "pre_color4": "Optional. Specifies pre-color polygons with color 4. Stitches cannot touch them.\nThe default is empty.", "extra_nodes": "Optional. Specifies an additional polygon layer targeted to generate stitch\ncandidates. The default is empty."}, "summary": "The color_stitch()  function generates a polygon layer containing stitch candidates.", "function_name": "three_color()"}
{"description": "The compare()  function starts the netlist comparison. The function returns a handle to be\nused by the\nwrite_xref_spice()  function.\nCall the check_property()  function, which makes the basic declarations as to which\nproperties are compared, before calling the compare()  function in the runset.\nNote:\nThe compare()  function cannot be called more than one time in a runset.", "syntax": "compare(\nstate                     = compare_state,\nschematic                 = schematic_netlist_file_handle,\nlayout                    = layout_netlist_file_handle,\nuser_functions_file       = \"string\",                       //optional\ncase_sensitive            = {DEVICE_NAME,NET_PORT,PROPERTY},\n//optional\npush_down_pins            = true  | false,                   //optional\nmemory_array_compare       = true  | false,                   //optional\nremove_dangling_net       = LAYOUT_UNTEXTED  | ALL | NONE,   //optional\ndelete_schematic_cells     = {\"string\", ...},        //optional\ndelete_layout_cells       = {\"string\", ...},        //optional\nprint_messages            = {message = true | false,\ncomplete_device_setting_table  =\ntrue | false\n...},\n//optional\nprint_devices_per_net_max = integer,                //optional\nprint_detail      = {property   = NONE | ONLY_COORDINATES |\nCOORDINATES_AND_DEVICE_TYPES | ALL,\nxref_pin   = NONE | UNMATCHED_PINS | ALL,\ndevice_pin = NONE | ALL},              //optional\nwrite_equiv_netlists       = FAILED | ALL | NONE | FAILED_REDUCED,\n//optional\nignore_equiv_file         = \"string\",                       //optional\nblack_box_file            = \"string\",                       //optional\nopen_net_names_checking    = USE_ORIGINAL | USE_ICV_RENAMED,\n//optional\nschematic_top_cell        = \"string\",                       //optional\nlayout_top_cell           = \"string\",                       //optional\naction_on_error           = EXPLODE | NO_EXPLODE,           //optional\nresolve_duplicate_equivs               = true | false,      //optional\ncheck_property_for_failed_equiv         = true | false,      //optional\nmultiply_width                         = true  | false,      //optional\nignore_equivs_with_devices_leveled_out  = true | false,      //optional\nexplode_imbalanced_equivs  = true  | false,                   //optional\ncompare()\ntop_cell_ports_static      = NAME_MATCHED  | ALL,             //optional\nerror_limit_per_check      = integer,                        //optional\ntexted_zero_connection_ports = IGNORE  | KEEP_ALL |\nKEEP_SCHEMATIC_AND_NAME_MATCHED |\nKEEP_LAYOUT_AND_NAME_MATCHED |\nKEEP_NAME_MATCHED |\nKEEP_TOP_SCHEMATIC_AND_NAME_MATCHED |\nKEEP_TOP_ALL_NONTOP_IGNORE,\n//optional\nblack_box_static_ports      =  NONE  | TEXTED,               //optional\ndefine_empty_cell_as_device =  NONE  | BOTH,                 //optional\nwrap_print_message_text =      true  | false,                //optional\ndefine_global_nets_as_top_ports  = true  | false              //optional\n);", "returns": "xref_database_handle or error result\nxref_database_handle", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "schematic": "Required. Specifies the schematic netlist database handle. The netlist must be\ndefined by the\nschematic()  function.", "layout": "Required. Specifies the layout netlist database handle. The netlist must be\ndefined by the\nnetlist()  function.", "user_functions_file": "Optional. Specifies the file that contains the remote functions. See Compare\nUtility Functions  for more information about the utility functions you can use to\ndefine a remote function.\nThe structure of the user function file is:\n\uff0cinclude <icv_compare.rh>\nfunction_name1 : entrypoint function (void) returning void {\n/* PXL utility functions */\n/* to build functionality */\n}\nfunction_name2 : entrypoint function (void) returning void {\n. . .\ncompare()\n}\n. . .\nNote:\nThe\nentrypoint qualifier\nentry point qualifier designates the remote functions. All functions\nin the user functions file that are directly referenced in the main\nrunset file must be designated as remote functions.", "case_sensitive": "Optional. Lists the case-sensitive settings. The default is {DEVICE_NAME,\nNET_PORT, PROPERTY}.\n\u2022 DEVICE_NAME. Specifies that device names comparisons are case-sensitive.\n\u2022 NET_PORT. Specifies that comparisons of all net names and port names are\ncase-sensitive, except for port names on primitive devices.\nNote:\nPort matching considers geometry first. The case-sensitive setting\naffects only those cases where ports are symmetrical.\n\u2022 PROPERTY. Specifies that string property comparisons are case-sensitive.", "push_down_pins": "Optional. Specifies if hierarchically connected pins are pushed down. The\ndefault is true.\n\u2022 true. Specifies that hierarchically connected pins are pushed down.\n\u2022 false. Specifies that hierarchically connected pins are not pushed down.\nPower and ground nets are not pushed down when they are shorted. Use the\nlayout_ground  and layout_power  arguments of the\ntext_options()  function\nto specify the power and ground nets.\nFor a schematic/layout equivalence cell pair, hierarchically connected pins are\nnot pushed down for the pair when\n\u2022 The pair participates in a multiple equivalence point (that is, multiple\nschematic cells paired with one layout cell or vice versa), and\n\u2022 The schematic/layout pair has the same port count and the same port\nnames.", "memory_array_compare": "Optional. Specifies if arrayed memories are compared faster and with less\nmemory. The default is true.\ncompare()\n\u2022 true. Specifies that arrayed memories are compared faster and with less\nmemory.\n\u2022 false. Specifies that comparison of arrayed memories is not optimized.\nNote:\nThe StarRC tool cannot be run using an LVS database that was\ngenerated using this argument set to true.", "remove_dangling_net": "Optional. Specifies if the input netlists are preprocessed to find all cases where\na port net in a cell never connects to any extracted device throughout the\nhierarchy. The net dangles outside the cell from which it originates and does not\nneed to be a port net in the cell. The IC Validator tool removes all such dangling\nnets throughout the hierarchy and changes the net in the originating cell from a\nport net to an internal net. The default is LAYOUT_UNTEXTED.\n\u2022 LAYOUT_UNTEXTED. Removes only untexted dangling nets in the layout.\n\u2022 ALL. Removes all dangling nets within the schematic and layout.\n\u2022 NONE. Does not remove dangling nets.", "delete_schematic_cells": "Optional. Specifies the schematic cells to delete from the netlist. String matching\nusing metacharacters is allowed. See\nString Matching  for more information.", "delete_layout_cells": "Optional. Specifies the layout cells to delete from the netlist. String matching\nusing metacharacters is allowed. See\nString Matching  for more information.", "print_messages": "Optional. Specifies the messages to output. Table 36  lists the messages and the\ndefault settings. Except as noted, the comparison messages are written to the\nrun_details/compare/cell/sum.cell.cell  file.\nNote:\nA maximum of 1000 error messages are written for each diagnostic\ntype.\nTable 36 Netlist Comparison Messages\nMessage Definition Default\nequated_nets_list Lists in alphabetical order the net names used as initial match\nreference points as specified by the equate_nets  argument\nof the equiv_options()  function.", "true": "", "matched_devices_unmatche": "", "d_nets": "Lists matched devices connected to unmatched schematic\nor layout nets. This side-by-side device listing facilitates the\ndebugging of unmatched cells.", "referenced_merged_devi": "", "ces": "Many messages refer to device instances that do not exist\nin the original netlist description of a cell. These devices\nare created as a result of merging operations. Any of these\ndevices that are referenced earlier in the equivalence\nsummary file are listed in terms of their component members.\nThese listings are used to determine which physical devices\nhave been used to formulate a merged or composite device.", "false": "", "complete_device_setting_": "", "table": "Lists all non-equiv specific device setting with respect to\ndevice types into LVS_ERRORS file, including devices not in\ndesign.", "print_devices_per_net_max": "Optional. Limits the information output for unmatched nets. The default is 10.\ncompare()", "print_detail": "Optional. Specifies the level of detail written to the LVS_ERRORS file.\n\u2022 property. The default is COORDINATES_AND_DEVICE_TYPES.\n\u25e6 NONE\n\u25e6 ONLY_COORDINATES\n\u25e6 COORDINATES_AND_DEVICE_TYPES\n\u25e6 ALL\n\u2022 xref_pin. The default is NONE.\n\u25e6 NONE\n\u25e6 UNMATCHED_PINS\n\u25e6 ALL\n\u2022 device_pin. The default is ALL.\n\u25e6 NONE\n\u25e6 ALL", "write_equiv_netlists": "Optional. Specifies when\nequivalence netlists, when to output\nequivalence netlists are output. The default is\nFAILED_REDUCED.\n\u2022 FAILED. Writes out only those equivalence netlists that have failed due to an\nunmatched device or a net. Equivalence netlists are not output for other error\ntypes, such as property errors or text mismatch errors.\n\u2022 ALL. Writes out netlists for all equivalences.\n\u2022 NONE. Does not output netlists.\n\u2022 FAILED_REDUCED. Writes out only those equivalence netlists that have\nfailed due to an unmatched device or net. Only partial devices, which are\nrelated to unmatched devices or nets, are written to the equivalence netlist.\nEquivalence netlists are not output for other error types, such as property\nerrors or text mismatch errors.", "ignore_equiv_file": "Optional. Specifies the file where\nequiv_options()  function call entries,\nin which the ignore  option is true  for unmatched equiv_cells  pairs, is\ngenerated. This equiv_options()  function call can be used by subsequent\ncompare runs to ignore equiv_cells  pairs that do not match. Not rechecking\ncompare()\nthese equiv_cells  pairs reduces runtime. This functionality is useful in cases\nwhere the top cell has compared successfully, and unmatched intermediate\nequiv_cells  pairs can be ignored. If the file already exists, the content of the\nfile is overwritten. By default, the IC Validator tool does not create a file.", "black_box_file": "Optional. Specifies the equivalence file where the generated\nlvs_generate_database()  function calls are saved. These black-box entries\nare created for all matched cells and can be used by subsequent compare\nruns to avoid recomparing those cells. By default, the IC Validator tool does not\ncreate a file.", "open_net_names_checking": "Optional. When set to USE_ORIGINAL, compare()  uses user-defined port name\nfor port checking. The default is USE_ICV_RENAMED  and it uses the renamed port\nname for port checking.", "schematic_top_cell": "Optional. Specifies the top level\ntop cellschematic netlist, setting\nof the schematic for comparison purposes.\nThe default schematic top-level cell is derived from the pairing of a schematic\ncell name to the layout top-level cell in the equiv_cells  argument of the\nequiv_options()  function. If no equiv_cells  pair containing the layout top-\nlevel cell name is explicitly provided in the runset, the default schematic top-level\ncell name is equivalent to the layout top-level cell name.\nNote:\nThe -stc  command-line option overrides this name. See the IC\nValidator Command-Line Options  section in the \u201cIC Validator Basics\u201d\nchapter of the IC Validator User Guide  for more information.", "layout_top_cell": "Optional. Specifies the top level\ntop celllayout netlist, setting\nof the layout for comparison purposes. The\ndefault top-level cell is specified by the cell  argument of the library()\nfunction.\nNote:\nThe -c  command-line option overrides this name. See the IC\nValidator Command-Line Options  section in the \u201cIC Validator Basics\u201d\nchapter of the IC Validator User Guide  for more information.", "action_on_error": "Optional. Specifies the action taken on failed equivalence cell pairs. The default\nis NO_EXPLODE.\ncompare()\nNote:\nThe default behavior changes for cases when the action_on_error\nargument is NO_EXPLODE. In certain instances, user-intended\nequivalence cell pairings are still exploded when: both schematic and\nlayout cells are missing, both are empty, or one is empty and one is\nmissing.\n\u2022 EXPLODE. Explodes the equivalence cell pairings that have errors upward\ninto their parent equivalence cells, and then the netlist comparison\ncontinues. However, if the no_explode_condition  argument of the\nmatch()  function is PROPERTY_ERRORS_ONLY, PORT_TOPOLOGY_MATCHED,\nor PORT_TEXT_MATCHED, then equivalence cell pairs consistent with the\nno_explode_condition  setting of the match()function are not exploded.\nInstead, instances of these failed equivalence cells are compared in the\nparent equivalence cell according to the no_explode_condition  setting of\nthe match()  function.\n\u2022 NO_EXPLODE. Preserves rather than explodes user-intended equivalence cell\npairings that have errors, and it compares instances of failed user-intended\nchild equivalence cells inside the parent equivalence cell. The setting of the\nno_explode_condition  argument of the match()  function is ignored.\nUnlike the EXPLODE  option, the NO_EXPLODE  option does not explode failed\nchild equivalence cells into the parent based on the assumption that such\nerrors can be resolved higher in the hierarchy. If the equivalence pair\nproduces a failed result, you must investigate the equivalence errors for that\nspecific equivalence pair.\nFailed equivalence points are handled as follows when the\naction_on_error  argument is NO_EXPLODE:\n\u25e6 If a user-intended equivalence point fails the compare operation, that\nequivalence point is not exploded into the parent. Instead, the error is\nreported for the failed equivalence point using the IC Validator standard\nequivalence point outputs. When the parent equivalence cell pairing is\ncompared later, it generates its own pass or fail status that is independent\nof the child cell status.\n\u25aa Child cell non-port errors. If the child cell suffers an error that does\nnot affect the matching of cell ports, the IC Validator tool compares\ninstances of the failed child equivalence pair inside the parent\nequivalence pair based on port matching information derived during\nthe comparison of the child equivalence cell pair. Examples of non-\nport errors include device property errors and topology error related to\ninternal nets. These errors do not affect the matching of ports for the\npaired child cells.\ncompare()\n\u25aa Child cell port topology errors. If the child cell suffers a topology error\nthat affects the cell ports, the IC Validator tool compares instances\nof the failed child equivalence pair inside the parent equivalence pair\nbased on port matching information derived during the comparison\nof the child equivalence cell. For ports that do not have any matching\ninformation, the IC Validator tool matches like-named ports between\nthe schematic and layout netlists. Ports for which neither matching\ninformation nor like-named port pairings exist are disregarded during\nthe compare operation.\n\u25e6 System-generated equivalences that fail the compare operation are\ntreated by the IC Validator tool as if the equivalence cell pairing had never\nbeen made. Therefore, you do not see the failure of any equivalence\npoint that you did not explicitly intend to exist. As a result,\n\u25aa Failed system-generated equivalence cell pairs are not reported in the\ncell.LVS_ERRORS file nor in the VUE LVS Errors tab.\n\u25aa The equivalence point is exploded into the parent.\n\u25aa No subdirectory for the equivalence point exists in the compare\ndirectory.\nSee the\nlvs_options()  function for a discussion of user-intended and\nsystem-generated equivalence cell pairings.", "resolve_duplicate_equivs": "Optional. Specifies if the IC Validator tool attempts to resolve duplicate\nequivalence points after it detects them. The default is false.\n\u2022 true. Attempts to resolve detected duplicate equivalence points\nautomatically. When set to true, the tool attempts to explode some of them\nto see if the parent equivalence points match.\n\u2022 false. Does not attempt to resolve LVS failures caused by these duplicate\nequivalence points.", "check_property_for_failed_equiv": "Optional. Specifies if the properties of failed equivalences are checked. The\ndefault is false.\n\u2022 true. Checks the properties of failed equivalences.\n\u2022 false. Does not check the properties of failed equivalences.", "multiply_width": "Optional. Specifies if the width is multiplied. The default is true.\ncompare()\n\u2022 true. Multiplies the width property by the multiplication factor property M for\nall standard, non-generic device types.\n\u2022 false. Does not multiply the width.\nStandard properties that are derived from the width property are also affected,", "including": "\u2022 RESISTOR: r\n\u2022 CAPACITOR: c\n\u2022 NP/PN: area, pj\n\u2022 NPN/PNP: area", "ignore_equivs_with_devices_leveled_out": "Optional. Controls if the user-intended equivalence cells with leveled devices are\nignored for compare. If the cells are not considered, the compare function is not\nperformed on these cells, and they are exploded into the parent equivalences.\nThe default is false.\n\u2022 When the ignore_equivs_with_devices_leveled_out  argument is true\nand the action_on_error  argument is either EXPLODE  or NO_EXPLODE:\n\u25e6 Compare function does not consider the equivalence cells with leveled\ndevices unless all of the leveled devices are filtered by filtering options\nXXX_0  from the filter_options  argument. In this case, all devices are\nfiltered. See\nTable 37  in the filter()  function for more information.\n\u25e6 Compare function is not performed on equivalence cells with leveled\ndevices. Therefore, no equivalence subdevices exist in the compare\ndirectory or the summary file.\n\u25e6 A message for this ignored equivalence is written in the LVS_ERROR\nfile, and the equivalence is classified as an invalid equivalence with the\nreason: Devices leveled out of layout cell during device extraction.\n\u2022 When the ignore_equivs_with_devices_leveled_out  argument is false:\n\u25e6 Compare preserves the equivalence cells with leveled devices when the\naction_on_error  argument is either EXPLODE  or NO_EXPLODE.\n\u25e6 If the compare result is FAIL on a device-leveled equivalence cell,\n- The cell is exploded and compared upward when the action_on_error\nargument is EXPLODE.\ncompare()\n- The cell is not  exploded when the action_on_error  argument is\nNO_EXPLODE.\n\u25e6 An invalid equivalence message for the device-leveled equivalence cell\nis not written in the LVS-related output files when the action_on_error\nargument is either EXPLODE  or NO_EXPLODE.", "explode_imbalanced_equivs": "Optional. Specifies if all imbalanced equivalences are automatically exploded.\nAn imbalanced equivalence is one that has an unequal number of placements\nbetween the schematic and layout. The default is true.\n\u2022 true. LVS checking explodes all imbalanced equivalences.\n\u2022 false. LVS checking does not explode the imbalanced equivalences, but\ncompares the missing cell instances as devices.", "top_cell_ports_static": "Optional. Specifies that top-cell port nets are static; that is, the layout and\nschematic port nets cannot be merged. The default is NAME_MATCHED.\n\u2022 NAME_MATCHED. Specifies that only top-cell port nets with matching names\nare static.\n\u2022 ALL. Specifies that all top-cell port nets are static.", "error_limit_per_check": "Optional. Specifies the maximum number of times that a condition is reported in\nthe Error Information and Warning Information sections of the sum.cell.cell  files\nor in the cell.LVS_ERRORS file. The default is 1000.\nNote:\nSelect the conditions to report using the match_condition  argument\nof the\nmatch()  function.", "texted_zero_connection_ports": "Optional. Determines how the compare()  function treats texted zero connection\nports. The default is IGNORE.\nA texted zero connection port is a port on a net in a cell that has text but no\nconnections to any devices after netlist preprocessing. Examples of netlist\npreprocessing functions include filter(), short_equivalent_nodes(),\nmerge_series(), and so forth. Ports in the schematic netlist are always treated\nas texted ports.\ncompare()\n\u2022 IGNORE. Specifies that texted zero connection ports are ignored, which\nmeans the pin connections to these ports are not checked.\n\u2022 KEEP_ALL. Specifies that all texted zero connection ports are kept so that\nthe pin connections to these ports can be checked. Unmatched texted zero\nconnection ports cause the LVS comparison result to fail. Only texted zero\nconnection ports are matched; untexted zero connection ports are ignored.\n\u2022 KEEP_SCHEMATIC_AND_NAME_MATCHED. Specifies that all schematic texted\nzero connection ports and layout texted zero connection ports with the same\nname port in the schematic netlist are kept for comparison. Layout zero\nconnection ports without the same name port in the schematic netlist are\nignored.\n\u2022 KEEP_LAYOUT_AND_NAME_MATCHED. Specifies that the tool keeps all layout\ntexted zero connection ports and schematic name-matched texted zero\nconnection ports for comparison.\n\u2022 KEEP_NAME_MATCHED. Specifies that all schematic and layout texted zero\nconnection ports with the same names are kept for comparison. Schematic\n(layout) texted zero connection ports without the same name port in the\nlayout (schematic) netlist are ignored.\n\u2022 KEEP_TOP_SCHEMATIC_AND_NAME_MATCHED. Specifies that top schematic\nand layout texted zero connection ports with the same name port in the\nschematic netlist, and non-top schematic and layout texted zero connection\nports with the same names, are kept for comparison. Top layout zero\nconnection ports without the same name port in the schematic netlist, and\nnon-top schematic (layout) texted zero connection ports without the same\nname port in the layout (schematic) netlist are ignored.\n\u2022 KEEP_TOP_ALL_NONTOP_IGNORE. Specifies that all non-top texted zero\nconnection ports are ignored, which means the pin connections to these\nports are not checked.", "black_box_static_ports": "Optional. Specifies that black-box cell port nets are static, that is, the layout and\nschematic port nets cannot be merged. The default is NONE.\n\u2022 NONE. Specifies that no black-box cell port net is static.\n\u2022 TEXTED. Specifies that only black-box cell texted port nets are static.", "define_empty_cell_as_device": "Optional. Specifies whether empty cells (X-card instances) are ignored or\nrecognized as GENDEV primitive devices. For an empty cell to be treated\ncompare()\nsuccessfully as a device, the IC Validator tool must be able to equate it\nautomatically between the schematic and layout netlists. The default is NONE.\n\u2022 NONE. Ignores empty cells.\n\u2022 BOTH. Recognizes empty cells as GENDEV primitive devices in both the\nschematic and layout netlists provided that all of the following required\nconditions are met:\n\u25e6 The empty cell name must not be in a black-box, equivalent, or delete-cell", "statement": "\u25e6 The empty cell name must not be declared in a device function, such as\nnmos(), or a map_*()  function\n\u25e6 The empty cell must be able to be equated automatically between the\nschematic and layout netlists\nIf pins exist, they must have the same name; no multiple equates to other\ndevice types are allowed.\nWhen all of these conditions are met, empty cells are automatically mapped\nto each other if they exist in both the schematic and layout netlists. Empty\ncells that do not exist in both netlists are reported as unmatched devices.", "wrap_print_message_text": "Optional. Controls line wrapping of the messages in the LVS diagnostic\nsummary (for both the schematic and layout), the .LVS_ERRORS file, and the\nrun_details/compare/cell/sum.cell.cell  file. The default is true.\n\u2022 true. Specifies that lines are wrapped.\n\u2022 false. Specifies that lines are not wrapped.", "define_global_nets_as_top_ports": "Optional. Specifies if the global nets of the top cell should be treated as top\nports. The default is true.\n\u2022 true. Enables top ports creation for global nets.\n\u2022 false. Disables top ports creation for global nets."}, "summary": "The compare()  function starts the netlist comparison.", "function_name": "compare()"}
{"description": "The compatibility_options()  function specifies settings for compatibility with third-\nparty tools.", "syntax": "compatibility_options(\nargument_diagnostics = WARNING  | NOTE | QUIET,            //optional\ndrc                  = {\nspacing = {orphan_edge_membership =\nINTERACTION  | NONE,\nmerge_spacing_violations =\ntrue |\nfalse,\npoint_touch =\nMEASURE_EDGES |\nMARK_POINT,\ncombine_edge_pair_violations =\ntrue |\nfalse,\nskip_invalid_voltage_net =\ntrue |\nfalse     //optional\n}\nboolean_ancestry =\nAUTO  | CONSTRUCTOR,\nremove_opposite_edges = true | false,\nfixed_violation_width = true | false\n},                              //optional\ndevice_extraction  =   {preprocess_same_body_layers =\ntrue | false,\nrequire_processing_layers =\ntrue |\nfalse} //optional\n);", "returns": "void", "arguments": {"argument_diagnostics": "Optional. Controls the severity of the messages for non-fatal conditions of\nargument validation. These argument settings are conflicting, where one or\nmore values is ignored or overridden. The default is WARNING.\n\u2022 WARNING. Specifies diagnostic messages that contain a warning.\n\u2022 NOTE. Specifies diagnostic messages that contain a note.\n\u2022 QUIET. Specifies suppression of non-fatal argument validation messages.\ncompatibility_options()", "drc": "Optional. Specifies global settings for DRC compatibility.\n\u2022 spacing. Specifies global settings applicable to spacing checks.\n\u25e6 orphan_edge_membership. Specifies the processing of polygon\nmembership for orphan edge layers (an edge layer with no ancestry).\nSingle layer internal and external spacing checks are required to\nrecognize polygon membership.\nFor edge layers, polygon membership is determined by layer ancestry.\nIf the edge layer has an ancestor, polygon membership for the edges is\ndefined by the polygons from which they were selected. If layer ancestry\nis not available, polygon membership is determined by this setting. The\ndefault is INTERACTION.\n- INTERACTION. Specifies that polygon membership is defined solely\nby interaction. Edges that interact in any way are on the same polygon.\nDisjointed edges are on different polygons.\n- NONE. Specifies that polygon membership is ignored and all edges are\nmeasured.\n\u25e6 point_touch. Specifies global settings for how the external1(),\nexternal2(), internal1(), internal2(), and enclose()  functions\nprocess relational = {POINT_TOUCH}. The default is MARK_POINT.\n- MARK_POINT. Highlights only the point-touch position. The format of\nthe violation is determined by the point_touch_shape  and shape_size\narguments.\n- MEASURE_EDGES. Processes spacing checks for all edges passing\nthrough a point-touching point by intersecting_angle = < 180.\n\u25e6 merge_spacing_violations. Merges output error shapes to reduce the\nsize of violation output. The default is false.\n- true. Merges output errors from dimensional functions sch as\nexternal(), internal(), and enclose().\n- false. Writes each error out separately, even if they overlap.\n\u25e6 combine_edge_pair_violations. Changes the violation shape of\nspacing functions, such as external(), internal(), and enclose().\nThis option specifies whether the spacing violations formed by each\npair of non-parallel, non-intersecting, or parallel, non-projecting checked\nedges are merged. The default is false.\ncompatibility_options()\n- true. Takes effect only when look_thru = ALL  or NOT_ADJACENT,\nprojection_length >= 0  (the default), look_thru_count >= 0  (the\ndefault), and spacing_edge = ALL  (default for *_edge  functions). For\neach pair of checked edges, that is, edge 1 and edge 2, the violation\nshape is formed by violation edges, which are discovered by check region\nfrom edge 1 to edge 2, from edge 2 to edge 1, and the connection of the\nviolation edges\u2019 endpoints.\n- false. Specifies that for each pair of checked edges, that is, edge 1\nand edge 2, the violations are created by edge 1 to edge 2, and edge 2 to\nedge 1, separately.\n\u25e6 skip_invalid_voltage_net. Skips spacing check for nets that have\ninvalid voltages. The default is false.\n- true. When this argument is set to true, nets with LV > HV  are\nclassified as exception nets and are skipped in the spacing check.\n- false. The tool performs external checks for all nets in connect\ndatabase without any exception.\n\u2022 boolean_ancestry. Optional. Specifies ancestry behavior for Boolean\noperations. Functions such as and(), not(), or(), and xor()  are hybrid\nfunctions, which can operate as both selectors and creators depending on\nthe context of the operation. See\nHybrid Polygon Functions  and Hybrid Edge\nFunctions  for more information. The default is AUTO.\n\u25e6 AUTO. Specifies that if the inputs to the Boolean operations have the same\nancestry, the operation is treated as a selector and the result inherits\nancestry.\n\u25e6 CONSTRUCTOR. Specifies that Boolean operations are treated as a\nconstructor and the result has no ancestry.\n\u2022 remove_opposite_edges. Optional. Specifies the processing of overlapping,\nopposite edges in the or_edge()  function. The default is false.\n\u25e6 true. Specifies that the overlapping section of the opposite edge is\nremoved.\n\u25e6 false. Specifies that the overlapping section of opposite edges is copied\nto the output.\n\u2022 fixed_violation_width. Optional. Specifies the width when expanding\ncertain edge violations into rectangles. The default is false.\ncompatibility_options()\n\u25e6 true. Specifies the setting of the global default violation width to four\ntimes the database units for non-centerline violations.\n\u25e6 false. Specifies the current IC Validator violation width behavior for non-\ncenterline violations.", "device_extraction": "Optional. Specifies the handling of device functions, which have the same body\nlayers. The default is false.\n\u2022 preprocess_same_body_layers. When set to true, specifies the suitable\nbody layers for those device functions with the same body layers.\n\u2022 require_processing_layers. Turns on the processing layer check for\ndevices."}, "summary": "The compatibility_options()  function specifies settings for compatibility with third-\nparty tools.", "function_name": "compatibility_options()"}
{"description": "The connect()  function creates a\nconnect database\nconnect database that defines electrical connectivity for\nthe specified layers. For each entry within the connect_items  argument, connectivity is\nindependently established from each layer in the layers  list to the layer specified with the\nby_layer  option. The resulting connect database is untexted.", "syntax": "connect(\nconnect_items = {{layers        = {polygon_layer, ...},\nby_layer      = polygon_layer,\ninclude_touch = NONE | EDGE,\nby_layer_connection = ALL  | SHIELDED_OVERLAP,\ninter_die     = true | false\n},\n...}                                     //optional\n);", "returns": "connect database", "arguments": {"connect_items": "Required. Lists the connection specifications.\n\u2022 layers. Required. Specifies a list of the polygon layers to connect.\n\u2022 by_layer. Optional. Specifies the polygon layer by which the layers specified\nin the layers  argument are connected. By default, these layers connect\ndirectly with each other; they are not connected through a by layer.\nIn the following example, the layers are all connected to each other without a\nby layer.\nFigure 45  illustrates this example.\nconnect(connect_items = {{{layer1, layer2, layer3,\nlayer4}}} );\nconnect()\nFigure 45 Layers Connected Without a By Layer\n\u2022 include_touch. Optional. Specifies whether polygons with only an outside\ntouch interaction form an electrical connection. The default is EDGE.\n\u25e6 NONE. Specifies that outside touch does not form an electrical connection.\n\u25e6 EDGE. Specifies that outside touch forms an electrical connection.\n\u2022 by_layer_connection. Optional. Specifies whether polygons must share\nan overlap touch interaction in a common area with the by layer to form an\nelectrical connection. The default is ALL.\n\u25e6 ALL. Specifies that a common overlap touch between all three layers\nis not required to form an electrical connection and that shielding is\nnot taken into account. All the layers specified in the layers  argument\nconnect to the by layer.\n\u25e6 SHIELDED_OVERLAP. Specifies that a common overlap touch between\nall three layers is required to form an electrical connection and that\nshielding is taken into account. Both the first layer specified in the layers\nargument and the by layer must be present to form the three-layer\nconnection.\nIn the following example, a by layer connects layer1 to layer2, and layer1\nis not connected to layer3 or layer4 because they are shielded by layer2.\nFigure 46  illustrates this example.\nconnect(connect_items = {{{layer1, layer2, layer3, layer4},\nby_layer = by_layer, include_touch = NONE,\nby_layer_connection = SHIELDED_OVERLAP }} );\nconnect()\nAlternatively, if by_layer_connection = ALL, then layer1, layer2, layer3,\nand layer4 are connected to the by layer.\nFigure 46 Layers Shielded by Overlaps\n\u2022 inter_die. Optional. Used in the 3DIC inter-die LVS flow to perform inter-die\nconnectivity checks and avoid inter-die text shorts. The default is false.\n\u25e6 true. Specifies that the -inter_die  command-line option must be used\nif inter_die_error_report=true.\n\u25aa There must be only one layer in layers  and it must be a port marker\nlayer.\n\u25aa The corresponding by_layer  must be the routing layer.\n\u25e6 false. Follows the traditional LVS flow."}, "summary": "The connect()  function creates a\nconnect database\nconnect database that defines electrical connectivity for\nthe specified layers.", "function_name": "connect()"}
{"description": "The contains()  function selects polygons that are large enough to fully enclose (contain)\nthe specified rectangle. The complement of this function is the not_contains()  function.", "syntax": "contains(\nlayer1          = polygon_layer,\ndimensions      = {double, double},\nrotate          = NONE  | FORTY_FIVE,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ndirection        = X_BY_Y| ALL                  //optional\n);\nnot_contains(\nlayer1          = polygon_layer,\ndimensions      = {double, double},\nrotate          = NONE  | FORTY_FIVE,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ndirection        = X_BY_Y| ALL                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "dimensions": "Required. Specifies the dimensions of the rectangle that must be contained.", "rotate": "Optional. Specifies whether the rectangle is checked for containment at different\norientations. The default is NONE.\n\u2022 NONE. Does not rotate the rectangle.\n\u2022 FORTY_FIVE. Checks the rectangle not rotated and rotated 45 degrees.\ncontains() and not_contains()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "direction": "Optional. Specifies how the constraints in the dimensions  argument apply to\nrectangle used for selection. The default is ALL.\n\u2022 X_BY_Y. Specifies that the first length in the sides  argument applies in the x-\ndirection, and the second length applies in the y-direction. The argument is\navailable only when rotate=NONE.\n\u2022 ALL. Specifies that the lengths of the dimensions  argument apply to the\nsides of the rectangle, one per side without fixed directions."}, "summary": "The contains()  function selects polygons that are large enough to fully enclose (contain)\nthe specified rectangle.", "function_name": "contains()"}
{"description": "The copy()  function creates a copy of a polygon layer. The new layer has no ancestry and\nno connectivity.\nUse the copy()  function to\n\u2022 Remove ancestry and connectivity.\n\u2022 Direct a layer to the error database.", "syntax": "copy(\nlayer1  = polygon_layer,\nname   = \"layer_label\",    //optional\nancestry  = true | false    //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is copied.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "ancestry": "Optional. Specifies if ancestry information is propagated to the output. The\ndefault is false.\n\u2022 true. Propagates the ancestry information to the output. Therefore, the\noutput has polygon membership information.\n\u2022 false. Does not propagate the ancestry information to the output. Therefore,\nthe output does not have polygon membership information."}, "summary": "The copy()  function creates a copy of a polygon layer.", "function_name": "copy()"}
{"description": "The copy_by_cells()  function creates a layer by copying the specified layer from the\nspecified list of cells.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells) and\n2 (Hierarchy) in\nMethodology Check Functions.", "syntax": "copy_by_cells(\nlayer1  = polygon_layer,\ncells  = {\"string\", ...},\ndepth  = CELL_LEVEL | DESCENDANTS | ALL,  //optional\nname   = \"layer_label\",                   //optional\nkeep_cells = true  | false                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the layer to be copied from cells.", "cells": "Required. Specifies the cells from which the layer is copied. If the list is empty,\nan empty layer is created. String matching using metacharacters is allowed. See\nString Matching  for more information.\nNote:\nThe \u201c!\u201d metacharacter takes precedence when depth is DESCENDANTS\nor ALL. For a cell to be copied, its parent must not be excluded.", "depth": "Optional. Specifies the depth of the cell hierarchy included in the copy. The\ndefault is ALL.\ncopy_by_cells()\n\u2022 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 DESCENDANTS. Includes only data in the descendants of a cell, recursively. No\ncell-level data is included unless the cell is a descendant of a cell in the cells\nlist.\n\u2022 ALL. Includes all data in the cell and below.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells list. The default is\ntrue.\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell."}, "summary": "The copy_by_cells()  function creates a layer by copying the specified layer from the\nspecified list of cells.", "function_name": "copy_by_cells()"}
{"description": "The copy_by_cells_edge()  function creates an edge layer by copying the specified layer\nfrom the specified list of cells.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells) and\n2 (Hierarchy) in\nMethodology Check Functions.", "syntax": "copy_by_cells_edge(\nlayer1     = edge_layer,\ncells      = {\"string\", ...},\ndepth      = CELL_LEVEL | DESCENDANTS | ALL,  //optional\nname       = \"layer_label\",                   //optional\nkeep_cells = true  | false                     //optional\n);", "returns": "edge layer or void", "arguments": {"layer1": "Required. Specifies the edge layer to be copied.", "cells": "Required. Specifies the cells from which the layer is copied. If the list is empty,\nan empty layer is created. String matching using metacharacters is allowed. See\nString Matching  for more information.\nNote:\nThe \u201c!\u201d metacharacter takes precedence when depth is DESCENDANTS\nor ALL. For a cell to be copied, its parent must not be excluded.", "depth": "Optional. Specifies the depth of the cell hierarchy included in the copy. The\ndefault is ALL.\ncopy_by_cells_edge()\n\u2022 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 DESCENDANTS. Includes only data in the descendants of a cell, recursively. No\ncell-level data is included unless the cell is a descendant of a cell in the cells\nlist.\n\u2022 ALL. Includes all data in the cell and below.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells list. The default is\ntrue.\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell."}, "summary": "The copy_by_cells_edge()  function creates an edge layer by copying the specified layer\nfrom the specified list of cells.", "function_name": "copy_by_cells_edge()"}
{"description": "The copy_by_cells_error()  function creates an error layer by copying the specified\nlayer from the specified list of cells.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells) and\n2 (Hierarchy) in\nMethodology Check Functions.", "syntax": "copy_by_cells_error(\nlayer1     = error_layer,\ncells      = {\"string\", ...},\ndepth      = CELL_LEVEL | DESCENDANTS | ALL,  //optional\nname       = \"layer_label\",                   //optional\nkeep_cells = true  | false                     //optional\n);", "returns": "error layer or void", "arguments": {"layer1": "Required. Specifies the error layer to be copied.", "cells": "Required. Specifies the cells from which the layer is copied. If the list is empty,\nan empty layer is created. String matching using metacharacters is allowed. See\nString Matching  on page 3353 for more information.\nNote:\nThe \u201c!\u201d metacharacter takes precedence when depth is DESCENDANTS\nor ALL. For a cell to be copied, its parent must not be excluded.", "depth": "Optional. Specifies the depth of the cell hierarchy included in the copy. The\ndefault is ALL.\ncopy_by_cells_error()\n\u2022 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 DESCENDANTS. Includes only data in the descendants of a cell, recursively. No\ncell-level data is included unless the cell is a descendant of a cell in the cells\nlist.\n\u2022 ALL. Includes all data in the cell and below.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells list. The default is\ntrue.\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell."}, "summary": "The copy_by_cells_error()  function creates an error layer by copying the specified\nlayer from the specified list of cells.", "function_name": "copy_by_cells_error()"}
{"description": "The copy_by_cells_unmerged()  function creates an unmerge polygon layer by copying\nthe specified list of cells from the specified layer.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells) and\n2 (Hierarchy) in\nMethodology Check Functions.", "syntax": "copy_by_cells_unmerged(\nlayer1     = error_layer,\ncells      = {\"string\", ...},\ndepth      = CELL_LEVEL | DESCENDANTS | ALL,  //optional\nname       = \"layer_label\",                   //optional\nkeep_cells  = true  | false                     //optional\n);", "returns": "unmerged polygon layer or void", "arguments": {"layer1": "Required. Specifies the unmerged polygon layer to be copied.", "cells": "Required. Specifies the cells from which the layer is copied. If the list is empty,\nan empty layer is created. String matching using metacharacters is allowed. See\nString Matching  on page 3353 for more information.\nNote:\nThe \u201c!\u201d metacharacter takes precedence when depth is DESCENDANTS\nor ALL. For a cell to be copied, its parent must not be excluded.", "depth": "Optional. Specifies the depth of the cell hierarchy included in the copy. The\ndefault is ALL.\ncopy_by_cells_unmerged()\n\u2022 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 DESCENDANTS. Includes only data in the descendants of a cell, recursively. No\ncell-level data is included unless the cell is a descendant of a cell in the cells\nlist.\n\u2022 ALL. Includes all data in the cell and below.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells list. The default is\ntrue.\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell. The exploded data is not\nmerged with the hierarchically overlapped data in the parent."}, "summary": "The copy_by_cells_unmerged()  function creates an unmerge polygon layer by copying\nthe specified list of cells from the specified layer.", "function_name": "copy_by_cells_unmerged()"}
{"description": "The copy_by_layout_equiv_cells()  function creates a layer by copying the\nspecified layer from the layout equivalence cells that are either identified using the\nequiv_options()  function, or automatically generated by the generate_user_equivs\nargument of the lvs_options()  function.\nThe copy_by_layout_equiv_cells()  function is identical to the combined steps of\ncreating a list of equivalence cells and using this list with copy_by_cells()  function.", "syntax": "copy_by_layout_equiv_cells(\nlayer1  = polygon_layer,\ndepth  = CELL_LEVEL | DESCENDANTS | ALL,  //optional\nname   = \"layer_label\"                    //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the layer to be copied from cells.", "depth": "Optional. Specifies the depth of the cell hierarchy included in the copy. The\ndefault is ALL.\n\u2022 CELL_LEVEL. Includes only the geometric data in the cell; no descendants\nare included unless they are also in the cells list.\n\u2022 DESCENDANTS. Includes only data in the descendants of a cell, recursively. No\ncell-level data is included unless the cell is a descendant of a cell in the cells\nlist.\n\u2022 ALL. Includes all data in the cell and below.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\ncopy_by_layout_equiv_cells()"}, "summary": "The copy_by_layout_equiv_cells()  function creates a layer by copying the\nspecified layer from the layout equivalence cells that are either identified using the\nequiv_options()  function, or automatically generated by the generate_user_equivs\nargument of the lvs_options()  function.", "function_name": "copy_by_layout_equiv_cells()"}
{"description": "The copy_edge()  function creates a copy of an edge layer. Use the copy_edge()\nfunction to\n\u2022 Remove ancestry.\n\u2022 Direct a layer to the error database.", "syntax": "copy_edge(\nlayer1    = edge_layer,\nname     = \"layer_label\",  //optional\nancestry  = true | false    //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer that is copied.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "ancestry": "Optional. Specifies if ancestry information is propagated to the output. The\ndefault is false.\n\u2022 true. Propagates the ancestry information to the output. Therefore, the\noutput has polygon membership information.\n\u2022 false. Does not propagate the ancestry information to the output. Therefore,\nthe output does not have polygon membership information."}, "summary": "The copy_edge()  function creates a copy of an edge layer.", "function_name": "copy_edge()"}
{"description": "The copy_error()  function creates a copy of the geometric data in an error layer. The\nnew layer has no ancestry and no connectivity, and therefore, no polygon membership\ninformation.\nUse the copy_error()  function to\n\u2022 Remove ancestry.\n\u2022 Direct a layer to the error database.", "syntax": "copy_error(\nlayer1  = error_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the error layer that is copied.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The copy_error()  function creates a copy of the geometric data in an error layer.", "function_name": "copy_error()"}
{"description": "The covered_by()  function checks multiple enclosure specifications for rectangles using\na spacing check. The function selects rectangles from the layer1  polygon layer that fit\nenclosure specifications within the layer2  polygon layer. This function is the complement\nof the\nnot_covered_by()  function.\nBy performing spacing checks of edges that oppose each other, the covered_by()\nfunction checks whether a layer1  polygon is enclosed by the layer2  polygon.\nRegardless of the endpoint extension mode selected by the extension  argument, spacing\nis not checked between the following edge pairs:\n\u2022 Between collinear edges; that is, edges along the same line. See Figure 51  for an\nexample.\nFigure 51 Collinear Edges\n\u2022 Between perpendicular edges, or any edges forming an angle greater than 90 degrees.\nSee\nFigure 52  for an example.\ncovered_by()\nFigure 52 Perpendicular Edges\n\u2022 Between a layer1  edge and any outside edge of the layer2  polygon. See Figure 53\nfor an example.\nFigure 53 Outside Edge\nFor any extension  setting other than NONE, a point touch satisfies only a distance of 0.\nSee Figure 54  for an example.\ncovered_by()\nFigure 54 Point Touch\nMore information about selection rules and check region examples are shown in the\nExamples section for the\nnot_covered_by()  function.", "syntax": "covered_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "polygon layer or error result\ncovered_by()", "arguments": {"layer1": "Required. Specifies the polygon layer.", "layer2": "Required. Specifies the enclosing polygon layer.", "distances": "Required. Lists the distances and extensions for check regions. The distances\ncan be applied in either clockwise or counterclockwise order. That is, a rectangle\nfits the specification if the four minimum distances can be satisfied in at least\none of the eight possible permutations: four possible rotations, in forward or\nreverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the minimum\nenclosure values, one for each side of the layer1  rectangle. The distances\nspecify the minimum distance from the outside of the layer1  polygon to\nthe inside of the layer2  polygon. The distances must be positive values. A\ndistance of 0 indicates that the layers can be touching.\nNote:\nFor the covered_by()  function, the distances must be greater\nthan or equal to (>=) the values.\n\u2022 extension. Optional. Specifies the endpoint extension for the check\nregion. See the extension definition in the distances  argument of the\nnot_covered_by()  function for more information. The default is NONE.\n\u25e6 NONE. Does not extend the check region; measures only layer1  and\nlayer2  edges with a positive perpendicular projection between them.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the layer1  edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the layer1\nedges using the extension_distance  value with a rectangle. The\nboundary of the check region is inclusive or exclusive depending on the\nconstraint of the distance value. See the diagram for the extension\nargument of the\nenclose()  function for more information.\ncovered_by()\nFigure 467  illustrates using the various extension  argument settings.\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  argument is RECTANGLE. The value must be\nnonnegative. The default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The covered_by()  function checks multiple enclosure specifications for rectangles using\na spacing check.", "function_name": "covered_by()"}
{"description": "The create_ports()  function creates ports\ntop-level ports, creating\nfor the specified connect database. The\nresulting connect database contains newly created ports. This function retains text.\nThe create_ports()  function creates a new port only if a marker_layer  polygon is\nlocated inside the same cell as the corresponding connected_layer  polygon.\n\u2022 If more than one marker interacts on a single net, an arbitrary choice is made for\ncreating the port and indicating the coordinates in the report. Extra markers are\nunused.\n\u2022 If a single marker interacts with more than one net, only one port is created. The result\nis arbitrary.\n\u2022 If a marker_layer  polygon is located in a different cell from its corresponding\nconnected_layer  polygon, no port is created.\nNote:\nPorts are persistent through the incremental_connect(), stamp(), and\ntext_net()  functions. That is, ports are retained after they are added to a\nconnect database.\nYou must make sure that the polygon hierarchy does not change. That is, the\nmarker_layer  polygon and the corresponding connected_layer  polygon must be\nlocated in the same cell. if a polygon in an input layer is in cell A, then the derived output\npolygon must also be in the same cell A.\nThe following example shows correct runset code because the processing_mode\nargument of the and()  function is CELL_LEVEL, and therefore the hierarchy does not\nchange.\nM3TEXT_mark = text_origin(M3TEXT,\ncells = {\"*\"},text = {\"*\"},\nshape_size = 0.005\n);\nM3_pin = and(M3TEXT_mark, M3,\nprocessing_mode = CELL_LEVEL   // Do not set to HIERARCHY\n);\ncdb = create_ports(connect_sequence = cdb,\nport_items = {{M3_pin,M3TEXT_mark}, ...},\n...\n);", "syntax": "create_ports(\nconnect_sequence = connect_database,\ncreate_ports()\nport_items       = {{connected_layer = polygon_layer,\nmarker_layer    = polygon_layer},\n...},\nreport           = {CREATED_PORTS, UNUSED_MARKERS},         //optional\nport_text_items   = {{connected_layer = polygon_layer,\nmarker_layer    = text_layer}, ...},   //optional\ncell_list         = {\"string\", ...},                         //optional\nprocessing_mode   = CELL_LEVEL  | HIERARCHICAL,               //optional\nuse_text          = TEXT_FROM_CELL  |\nTEXT_FROM_CELL_AND_TEXT_DEPTH            //optional\n);", "returns": "connect database", "arguments": {"connect_sequence": "Required. Specifies the connect database that contains the connected layers.", "port_items": "Optional. Lists the port specifications for polygon layers.\nNote:\nIf both the port_items  and port_text_items  arguments are empty\nlists, then no ports are created.\n\u2022 connected_layer. Specifies a layer that is in the connect database.\n\u2022 marker_layer. Specifies the polygon layer where the ports are created.\nPorts are not created for cells that are not listed by the cell_list  argument.", "report": "Optional. Specifies what is reported in the error database. The default is\nUNUSED_MARKERS.\n\u2022 CREATED_PORTS. Reports newly created ports.\n\u2022 UNUSED_MARKERS. Reports polygons on the marker layer that do not create a\nnew port.\ncreate_ports()", "port_text_items": "Optional. Lists the port specifications for text layers.\nNote:\nIf both the port_items  and port_text_items  arguments are empty\nlists, then no ports are created.\n\u2022 connected_layer. Specifies a layer that is in the connect database.\n\u2022 marker_layer. Specifies the text layer where the ports are created. Ports\nare not created for cells that are not listed by the cell_list  argument.\nWhen the same marker layer is used for more than one connected layer, text\nis applied in a priority order relative to the order of the port_text_items  list.\nText that overlaps polygons from more than one connected layer is applied\nto the first connected layer in the list. Each text object is used only one time,\nand text is reported as unused only when it is not used by any connected\nlayer in the port_text_items  list.", "cell_list": "Optional. Specifies the cells on which ports are created. The default ({ }) means\nto create ports for only the top cell.\nTo create ports for all cells, use\ncell_list = {\"*\"}\nThis example creates ports only for cell \"A\", \"B\" and \"C\":\ncell_list = {\"A\", \"B\", \"C\"}", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is CELL_LEVEL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "use_text": "Optional. Specifies the kinds of texts that are used to create ports. The default is\nTEXT_FROM_CELL.\n\u2022 TEXT_FROM_CELL. Specifies texts from used cells.\n\u2022 TEXT_FROM_CELL_AND_TEXT_DEPTH. Specifies text from used cells\nand copied text from child cells in text_options(text_depth).\ncreate_ports()\nWhen you use the TEXT_FROM_CELL_AND_TEXT_DEPTH  setting, set\nprocessing_mode=HIERARCHICAL  so that ports can be generated by texts\ninteracting with polygons from the child cell."}, "summary": "The create_ports()  function creates ports\ntop-level ports, creating\nfor the specified connect database.", "function_name": "create_ports()"}
{"description": "The critical_areas()  function creates a list of polygon layers that represent critical\nareas of layout for short and open circuits, associated with defects of a specific size.", "syntax": "critical_areas(\nlayer = polygon_layer,\ndefect_radiuses = {double, ...},\nmode  = CA_OPEN | CA_SHORT,\nconnect_sequence = connect_database    //optional)\n);", "returns": "list of polygon layers", "arguments": {"layer": "A required polygon_layer  that specifies the layer to be processed.", "defect_radiuses": "A required list of positive doubles that specifies the defect sizes to modeled.\nThere is a one-to-one relationship between the defect_radiuses  list and the\nreturned list of polygon layers.", "mode": "A required enumerator that specifies the type of failure for which areas are\noutput.\ncritical_areas()\n\u2022 CA_SHORT. Identifies critical areas for short circuits between two different nets\non the input layer.\n\u2022 CA_OPEN. Identifies critical areas for open circuits on the input layer.\nFigure 55 Critical Area by Defect Types", "connect_sequence": "Optional. A connect_database that specifies the connectivity for the input layer\nfor the CA_SHORT  mode. Required for CA_SHORT, ignored for CA_OPEN  mode."}, "summary": "The critical_areas()  function creates a list of polygon layers that represent critical\nareas of layout for short and open circuits, associated with defects of a specific size.", "function_name": "text_net()"}
{"description": "The cutting()  function selects data from layer1  polygons that cuts (intersects) data\nfrom layer2  polygons. A count specifies the number of layer2  polygons that must be\ncut in order for a layer1  polygon to be selected. The complement of this function is the\nnot_cutting()  function.", "syntax": "cutting(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount              = integerconstraint,          //optional\ninclude_enclosing  = true  | false,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);\nnot_cutting(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount              = integerconstraint,          //optional\ninclude_enclosing  = true  | false,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.\ncutting() and not_cutting()", "count": "Optional. Specifies the number of layer2  polygons that must be cut by a\nlayer1  polygon for the layer1  polygon to be selected. See Constraints  for\nmore information. The default is >0.\nFigure 56  shows the effect of the count  argument settings with the cutting()\nfunction.\nFigure 56 count Argument Example With cutting() Function\nFigure 57  shows the effect of the count  argument settings with the\nnot_cutting()  function.\nFigure 57 count Argument Example With not_cutting() Function", "include_enclosing": "Optional. Specifies whether layer1  polygons that enclose layer2  polygons are\nincluded in the output. The default is true.\ncutting() and not_cutting()\nFigure 58  shows the effect of the include_enclosing  argument settings with\nthe cutting()  function.\nFigure 58 include_enclosing Argument Example With cutting() Function\nFigure 59  shows the effect of the include_enclosing  argument settings with\nthe not_cutting()  function.\nFigure 59 include_enclosing Argument Example With not_cutting() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ncutting() and not_cutting()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and the count_parity  argument is EVEN,\nthe layer1  polygons that interact with four, six, or eight layer2  polygons are\nselected.\nFigure 60  shows an example of two interacting layers.\nFigure 60 count_parity Argument Example\nFor the following command, the result is shown in Figure 61.\ncutting(L1, L2, count_parity = ODD)\ncutting() and not_cutting()\nFigure 61 Result of count_parity Argument Example", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\n\u2022 NET. Selects a layer1  polygon if it cuts with distinct nets on the layer2  layer\nthe number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it cuts the layer2  layer the number of\ntimes specified by the count  argument.\nRefer to Figure 62  for the following examples.\nFigure 62 count_by Argument Example\ncutting() and not_cutting()\nThe following commands select polygon A of layer L1.\n\u2022 Only net 1 is cut by layer L1, but net 2 is also considered because the default\nof the include_enclosing  argument is true. Each net is counted one time\nbecause the count_by  argument is NET. Therefore, polygon A meets the\ncount=2  restriction.\ncutting (L1, L2, count==2, count_by=NET, connect_sequence=cdb)\n\u2022 Only net 1 is cut by layer L1, but net 2 is also considered because the default\nof the include_enclosing  argument is true. Each net is counted two times.\nTherefore, polygon A meets the count=4  restriction.\ncutting(L1, L2, count==4)\n\u2022 Only net 1 is cut by layer L1. Net 2 is not considered because\ninclude_enclosing  argument is false. Nets 1 is counted one time\nbecause the count_by  argument is NET. Therefore, polygon A meets the\ncount=1  restriction.\ncutting(L1, L2, count==1, include_enclosing=false,\ncount_by=NET,\nconnect_sequence=cdb)\n\u2022 Only net 1 is cut by layer L1. Net 2 is not considered because\ninclude_enclosing  argument is false. Nets 1 is counted two times.\nTherefore, polygon A meets the count=2  restriction.\ncutting(L1, L2, count==2, include_enclosing=false)", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The cutting()  function selects data from layer1  polygons that cuts (intersects) data\nfrom layer2  polygons.", "function_name": "cutting()"}
{"description": "The cutting()  function selects data from layer1  polygons that cuts (intersects) data\nfrom layer2  polygons. A count specifies the number of layer2  polygons that must be\ncut in order for a layer1  polygon to be selected. The complement of this function is the\nnot_cutting()  function.", "syntax": "cutting(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount              = integerconstraint,          //optional\ninclude_enclosing  = true  | false,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);\nnot_cutting(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount              = integerconstraint,          //optional\ninclude_enclosing  = true  | false,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.\ncutting() and not_cutting()", "count": "Optional. Specifies the number of layer2  polygons that must be cut by a\nlayer1  polygon for the layer1  polygon to be selected. See Constraints  for\nmore information. The default is >0.\nFigure 56  shows the effect of the count  argument settings with the cutting()\nfunction.\nFigure 56 count Argument Example With cutting() Function\nFigure 57  shows the effect of the count  argument settings with the\nnot_cutting()  function.\nFigure 57 count Argument Example With not_cutting() Function", "include_enclosing": "Optional. Specifies whether layer1  polygons that enclose layer2  polygons are\nincluded in the output. The default is true.\ncutting() and not_cutting()\nFigure 58  shows the effect of the include_enclosing  argument settings with\nthe cutting()  function.\nFigure 58 include_enclosing Argument Example With cutting() Function\nFigure 59  shows the effect of the include_enclosing  argument settings with\nthe not_cutting()  function.\nFigure 59 include_enclosing Argument Example With not_cutting() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ncutting() and not_cutting()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and the count_parity  argument is EVEN,\nthe layer1  polygons that interact with four, six, or eight layer2  polygons are\nselected.\nFigure 60  shows an example of two interacting layers.\nFigure 60 count_parity Argument Example\nFor the following command, the result is shown in Figure 61.\ncutting(L1, L2, count_parity = ODD)\ncutting() and not_cutting()\nFigure 61 Result of count_parity Argument Example", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\n\u2022 NET. Selects a layer1  polygon if it cuts with distinct nets on the layer2  layer\nthe number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it cuts the layer2  layer the number of\ntimes specified by the count  argument.\nRefer to Figure 62  for the following examples.\nFigure 62 count_by Argument Example\ncutting() and not_cutting()\nThe following commands select polygon A of layer L1.\n\u2022 Only net 1 is cut by layer L1, but net 2 is also considered because the default\nof the include_enclosing  argument is true. Each net is counted one time\nbecause the count_by  argument is NET. Therefore, polygon A meets the\ncount=2  restriction.\ncutting (L1, L2, count==2, count_by=NET, connect_sequence=cdb)\n\u2022 Only net 1 is cut by layer L1, but net 2 is also considered because the default\nof the include_enclosing  argument is true. Each net is counted two times.\nTherefore, polygon A meets the count=4  restriction.\ncutting(L1, L2, count==4)\n\u2022 Only net 1 is cut by layer L1. Net 2 is not considered because\ninclude_enclosing  argument is false. Nets 1 is counted one time\nbecause the count_by  argument is NET. Therefore, polygon A meets the\ncount=1  restriction.\ncutting(L1, L2, count==1, include_enclosing=false,\ncount_by=NET,\nconnect_sequence=cdb)\n\u2022 Only net 1 is cut by layer L1. Net 2 is not considered because\ninclude_enclosing  argument is false. Nets 1 is counted two times.\nTherefore, polygon A meets the count=2  restriction.\ncutting(L1, L2, count==2, include_enclosing=false)", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The cutting()  function selects data from layer1  polygons that cuts (intersects) data\nfrom layer2  polygons.", "function_name": "not_cutting()"}
{"description": "The data_filter()  function outputs a specific number of polygons from the input layer\nthat are connected to each net. The selection of polygons that are output is random for\neach net, and the polygons can come from anywhere in the input net\u2019s hierarchy. Because\noutput is random for each net, the result can differ from run to run.", "syntax": "data_filter(\nconnect_sequence     = connect_database,\nlayer1               = polygon_layer,\npolygons_per_net     = integer,                    //optional\nthreshold            = integer,                    //optional\nprocessing_mode     = CELL_LEVEL | HIERARCHICAL,  //optional\nname                = \"layer_label\",              //optional\ninside_of_layer      = polygon_layer                //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "layer1": "Required. Specifies the layer that is analyzed for the specified number of\npolygons on each net. This layer must be in the connect database.", "polygons_per_net": "Optional. Specifies the number of polygons from each net that are output. The\ndefault is 1.", "threshold": "Optional. Specifies the threshold value. Polygons from each net are output\nonly if the total number of polygons in the net is greater than or equal to the\nthreshold. The default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ndata_filter()\nNote:\nIf the input has contacts or vias without hierarchical overlap, set the\nprocessing mode to CELL_LEVEL for better performance. Otherwise,\nset the HIERARCHICAL to resolve hierarchical issues.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "inside_of_layer": "Optional. By default, if inside_of_layer  is not specified, it outputs a\nspecific number of layer1  polygons per net. If specified, it supports\nonly these default options: polygons_per_net=1, threshold=0, and\nprocessing_mode=HIERARCHICAL. It outputs one layer1  polygon per net inside\neach inside_of_layer  polygon. For example:\ncdb = connect( {{{blue}, black}} );\nred = data_filter(connect_sequence = cdb, layer1 = blue,\ninside_of_layer = green);"}, "summary": "The data_filter()  function outputs a specific number of polygons from the input layer\nthat are connected to each net.", "function_name": "data_filter()"}
{"description": "The data_limit()  function partially copies layer1  polygons based on a specified limit.\nData is copied in a bottom-up hierarchical cell order.", "syntax": "data_limit(\nlayer1          = polygon_layer,\nlimit           = integer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "limit": "Required. Specifies the number of polygons to output. The hierarchical count", "hierarchical": "", "count": "of polygons in the output layer equals this value. The flat count\nflat count\nof the number\nof polygons in the output layer, however, depends on the number of instances\nthere are for each cell that contains data.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The data_limit()  function partially copies layer1  polygons based on a specified limit.", "function_name": "data_limit()"}
{"description": "The data_limit_edge()  function partially copies layer1  edges based on a specified\nlimit. Data is copied in a bottom-up hierarchical cell order.", "syntax": "data_limit_edge(\nlayer1          = edge_layer,\nlimit           = integer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "limit": "Required. Specifies the number of polygons to output. The hierarchical count\nof polygons in the output layer equals this value. The flat count of the number\nof polygons in the output layer, however, depends on the number of instances\nthere are for each cell that contains data.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The data_limit_edge()  function partially copies layer1  edges based on a specified\nlimit.", "function_name": "data_limit_edge()"}
{"description": "The debug_options()  function controls the early exits of supported external and DRC\nfeatures utility functions.", "syntax": "debug_options(\nstop_check_at_error_limit  = true | false             //optional\n);", "returns": "void", "arguments": {"stop_check_at_error_limit": "Optional. Specifies to limit the output of void and non-void returning functions.\nThe default is false.\n\u2022 true. Specifies that supported void and non-void returning functions stop\nwhen they reach the error_limit_per_check  argument.\nNote:\nThe output of any layer operation in a\nsupported function is incomplete due to the\ndebug_options(stop_check_at_error_limit=true)  setting.\nThe result of any rule dependent on this output is invalid and\nunpredictable.\n\u2022 false. Specifies that supported void and non-void returning functions do\nnot attempt to exit early when they reach the error_limit_per_check\nargument."}, "summary": "The debug_options()  function controls the early exits of supported external and DRC\nfeatures utility functions.", "function_name": "debug_options()"}
{"description": "The delta_edge()  function selects edges that meet the specified delta-x and delta-\ny constraints. See\nFigure 67  for an example. The complement of this function is the\nnot_delta_edge()  function.\nTypically, the input layer for this function is the output from an external edge function. Use\nthe delta_edge()  function to determine design violations based on the delta distance of\nall angle edge data.\nFigure 67 Delta Edge\nNote:\nUsing the delta_edge()  function with both delta_x  and delta_y  values equal\nto the default of >=0  performs a copy_edge()  function.\nUsing the not_delta_edge()  function with delta_x  and delta_y  values equal\nto the default of >=0  returns an empty layer.", "syntax": "delta_edge(\nlayer1          = data_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_delta_edge(\nlayer1          = data_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\ndelta_edge() and not_delta_edge()", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "delta_x": "Optional. Specifies the delta-x distance. The default is >=0.", "delta_y": "Optional. Specifies the delta-y distance. The default is >=0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The delta_edge()  function selects edges that meet the specified delta-x and delta-\ny constraints.", "function_name": "delta_edge()"}
{"description": "The delta_edge()  function selects edges that meet the specified delta-x and delta-\ny constraints. See\nFigure 67  for an example. The complement of this function is the\nnot_delta_edge()  function.\nTypically, the input layer for this function is the output from an external edge function. Use\nthe delta_edge()  function to determine design violations based on the delta distance of\nall angle edge data.\nFigure 67 Delta Edge\nNote:\nUsing the delta_edge()  function with both delta_x  and delta_y  values equal\nto the default of >=0  performs a copy_edge()  function.\nUsing the not_delta_edge()  function with delta_x  and delta_y  values equal\nto the default of >=0  returns an empty layer.", "syntax": "delta_edge(\nlayer1          = data_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_delta_edge(\nlayer1          = data_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\ndelta_edge() and not_delta_edge()", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "delta_x": "Optional. Specifies the delta-x distance. The default is >=0.", "delta_y": "Optional. Specifies the delta-y distance. The default is >=0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The delta_edge()  function selects edges that meet the specified delta-x and delta-\ny constraints.", "function_name": "not_delta_edge()"}
{"description": "The delta_error()  function selects errors that meet the specified delta-x and delta-y\nconstraints for error distance. The complement of this function is the not_delta_error()\nfunction.", "syntax": "delta_error(\nlayer1          = error_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_delta_error(\nlayer1          = error_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the error layer from which errors are selected.", "delta_x": "Optional. Specifies the delta-x distance. The default is >=0.", "delta_y": "Optional. Specifies the delta-y distance. The default is >=0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ndelta_error() and not_delta_error()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The delta_error()  function selects errors that meet the specified delta-x and delta-y\nconstraints for error distance.", "function_name": "not_delta_error()"}
{"description": "The delta_error()  function selects errors that meet the specified delta-x and delta-y\nconstraints for error distance. The complement of this function is the not_delta_error()\nfunction.", "syntax": "delta_error(\nlayer1          = error_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_delta_error(\nlayer1          = error_layer,\ndelta_x         = doubleconstraint,           //optional\ndelta_y         = doubleconstraint,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the error layer from which errors are selected.", "delta_x": "Optional. Specifies the delta-x distance. The default is >=0.", "delta_y": "Optional. Specifies the delta-y distance. The default is >=0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ndelta_error() and not_delta_error()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The delta_error()  function selects errors that meet the specified delta-x and delta-y\nconstraints for error distance.", "function_name": "delta_error()"}
{"description": "The density()  function checks the layout density based on user-programmable density\nequations.\nThe density()  function calls a remote function for each check-region boundary or\neach delta_window  subwindow. The remote function can call various utility functions\nthat operate on the current boundary or subwindow to produce error output and density\nstatistics.\nThe density()  function can move the delta_window  subwindow in\n\u2022 Fixed increments that are specified by the delta_x  and delta_y  arguments.\n\u2022 Smartsteps that are multiples of the delta_x  and delta_y  values, for faster\nprocessing. To move the subwindow in smartsteps, add the density utility function\nden_generate_next_step()  at the end of the remote function.", "syntax": "density(\nwindow_layer             = polygon_layer,\nlayer_hash               = {\"string\" => polygon_layer, ...},\nwindow_function          = function,\ndelta_window             = {width = double, height = double},\n//optional\ndelta_x                  = double,                          //optional\ndelta_y                  = double,                          //optional\nresize_delta_xy          = true | false,                    //optional\nx_edge_process_amount    = double,                          //optional\ny_edge_process_amount    = double,                          //optional\narea_clip_delta_percent  = double,                          //optional\nstatistics_files         = {density_statistics_file_handle, ...},\n//optional\nstatistics_file_modes    = {OVERWRITE  | APPEND, ...},       //optional\ncentered_square_size     = double,                          //optional\nboundary                  = CLIP  | ALIGN | IGNORE |\nREPLICATE_WINDOW | BACKUP        //optional\noutput_type               = DELTA_WINDOW  | CLIPPED_DELTA_WINDOW |\nCENTER | CLIPPED_CENTER,         //optional\noutput_center_dimensions = {width = double, height = double},\n//optional\ndelta_window_sizes       = {{north = double, south = double,\neast = double, west = double},\n...},                           //optional\nprocess_delta_windows     = OVERLAPPING  | ALL,               //optional\nname                     = \"layer_label\",                   //optional\nmerge_errors             = true | false,                    //optional\npydb_output              = true | false,                    //optional\ndensity()\ntraverse_boundary        = POLYGON_EXTENT  |\nVERTICAL_TRAPEZOID_EXTENTS |\nHORIZONTAL_TRAPEZOID_EXTENTS     //optional\nmerge_errors_output      = EXTENTS  | POLYGONS               //optional\nstatistics_file_error_names= {\"string\"},  // optional\nstatistics_file_window_limit  = integer // optional\n);", "returns": "polygon layer or error result", "arguments": {"window_layer": "Required. Specifies the polygon layer containing one or more polygons that\ndefine the boundaries where layers are processed for density calculations.\nThe chip_extent()  and layer_extent()  functions can be used to create a\nwindow layer. Call these functions before the density()  function.\n\u2022 The chip_extent()  function returns a layer containing a single rectangle\nequal to the extents of the chip. Use this function to create a single full-chip\ncheck window. See the\nchip_extent()  function for more information.\n\u2022 The layer_extent()  function returns a layer containing a single rectangle\nequal to the extents of the input layer. Use this function to create a single-\nlayer check window. See the\nlayer_extent()  function for more information.\nNote:\nIf the window_layer  is an empty layer, the density()  function\nreturns an empty layer. No density measurements are made and\nthe remote function is not called.", "layer_hash": "Required. Specifies a hash of string to polygon layer that is processed for\ndensity calculations. Data in the hash is accessible via the hash key within\nthe remote window function. When referencing data in hash from within the\nwindow function, only the portion of the layer within the current delta_window\nsubwindow or the current window layer polygon is seen.", "window_function": "Required. Specifies the remote function that calculates the density. See the\nLayout Density Utility Functions  for more information about the utility functions\nyou can use to define a remote function.\ndensity()", "delta_window": "Optional. Specifies the subwindow stepped across each window layer polygon.\nThe density equations are evaluated within each subwindow. The default is the\nextents of each window layer polygon.", "delta_x": "Optional. Specifies the delta_window  subwindow step distance in the x-\ndirection. The default is the width  option of the delta_window  argument.", "delta_y": "Optional. Specifies the delta_window  subwindow step distance in the y-\ndirection. The default is the height  option of the delta_window  argument.", "resize_delta_xy": "Optional. Specifies whether the delta_x  and delta_y  argument values are\nrecalculated if the delta_window  subwindow stepping does not end flush with\nthe right and top borders of the current boundary. The default is false.\n\u2022 true. Recalculates the delta_x  and delta_y  values based on the current\nwindow layer polygon extents and the input delta_x  and delta_y  values so\nthat the delta_window  subwindow ends flush with the right and top borders\nof the current boundary. The subwindow is stepped across each window\nlayer polygon using the new values.\nNote:\nThere could be a small fractional overlap of the boundary\nlayer. If you require no overlap, use this argument with the\nx_edge_process_amount  and y_edge_process_amount\narguments set to 0.\n\u2022 false. Does not recalculate the delta_x  and delta_y  values.", "x_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the right edge of\nthe boundary by the specified value or more, specifies to shift the current\nsubwindow left to make it flush with the right edge of the current boundary.", "y_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the top edge of the\nboundary by the specified value or more, specifies to shift the current\nsubwindow down to make it flush with the top edge of the current boundary.", "area_clip_delta_percent": "Optional. Ignores the current delta_window  subwindow if the density ratio of the\nwindow layer material inside the current subwindow is less than the specified\ndensity()\nvalue. By default, the IC Validator tool ignores any subwindow with a window\nlayer density of 0.", "statistics_files": "Optional. Specifies the handles of the files written to by\nden_window_statistics()  utility functions included in the specified remote\nwindow function. Do not specify the same file more than one time. These files\nare defined using the\ndensity_statistics_file()  function.", "statistics_file_modes": "Optional. Specifies the action taken when the file already exists for each\nstatistics file of the density()  function. If only one mode is specified, it is used\nfor all files. The default is OVERWRITE.\n\u2022 OVERWRITE. Overwrites the previous statistics file. That is, the statistics file\ncontains only statistics from this function.\n\u2022 APPEND. Appends the new data to the previous statistics file. That is, the\nstatistics file contains the statistics from previous density functions along with\nthe new statistics from this function.", "centered_square_size": "Optional. Specifies that squares centered on polygons inside the window layer\nare used as the windows for density calculations. The default is 0.0.\n\u2022 The value must be greater than or equal to 0.\n\u2022 If the value is 0, the density()  function does not output centered squares.\nIf the value is greater than 0, then the IC Validator tool performs the following\nsteps:\n1. For each polygon of the window layer, find the rectangular extent.\n2. Find the center point of the rectangular extent, whose coordinates are (x,y).\n3. Set\nX1 = x - centered_square_size/2\nY1 = y - centered_square_size/2\nX2 = x + centered_square_size/2\nY2 = y + centered_square_size/2\ndensity()\nNote:\nIf the values are not on grid, they are rounded up to the next grid\nvalue.\n4. Perform all normal density operations with X1, Y1, X2, Y2 defining the\nwindow layer.\nFor example,\ndensity(\nwindow_layer = metal1_extent,\nlayer_hash = { \"layer1\" => metal1 },\nwindow_function = my_density_function,\ncentered_square_size = 15\n);\nThe window is defined by\nX1 = x - 15/2\nY1 = y - 15/2\nX2 = x + 15/2\nY2 = y + 15/2\nPerforming the normal density operations, the generated window layer is defined\nas shown in\nFigure 68.\nFigure 68 Generation of Centered Square\ndensity()", "boundary": "Optional. Specifies how to process a delta_window  subwindow that overlaps\nthe boundary of the extents of a window layer polygon. The default is CLIP.\n\u2022 CLIP. Truncates the subwindow at the limits of the window layer.\nif the x_edge_process_amount  or y_edge_process_amount  argument is not\nequal to -1 when the boundary  argument is CLIP, then\n\u25e6 If the overhang is less than the x_edge_process_amount  or\ny_edge_process_amount  value, a clip is performed.\n\u25e6 If the overhang is equal to or greater than the x_edge_process_amount\nor y_edge_process_amount  value, an align is performed.\n\u25e6 If the overhang in the horizontal direction is less than the\nx_edge_process_amount  value, then clip the subwindow along the\nwindow layer.\n\u25e6 If the overhang in the horizontal direction is equal to or greater than\nthe x_edge_process_amount  value, then align the subwindow with the\nwindow layer.\n\u25e6 If the overhang in the vertical direction is less than\ny_edge_process_amount  value, then clip the subwindow along the\nwindow layer.\n\u25e6 If the overhang in the vertical direction is equal or more than\ny_edge_process_amount  value, then align the subwindow with the\nwindow layer.\ndensity()\nFigure 69  shows how a subwindow is clipped.\nFigure 69 boundary = CLIP Example\n\u2022 ALIGN. If a subwindow overlaps the right side or top edge of the window\nlayer, shifts the window left or down until it no longer overlaps the window\nlayer. The density calculation is performed after the window is shifted.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is ALIGN.\nFigure 70  shows how a subwindow is aligned.\nFigure 70 boundary = ALIGN Example\ndensity()\n\u2022 IGNORE. If a subwindow overlaps the right or top edges of the window\nlayer boundary, ignores the subwindow and does not output data for that\nsubwindow location.\nNote:\nBoth x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is IGNORE.\nFigure 71  shows when the subwindow is ignored.\nFigure 71 boundary = IGNORE Example\n\u2022 REPLICATE_WINDOW. To simulate density measurements on a die, replicates\nthe input layers to properly measure density at the boundary of the chip. If\na window overlaps the right or top edges of the window layer polygons, the\nwindow layer extent and its data is duplicated and added to the right or top\nside of the original bounding box. The density measurement on the boundary\nsubwindow is calculated considering the original data and the duplicated\ndata.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is\nREPLICATE_WINDOW.\ndensity()\nFigure 72  shows a replicated subwindow.\nFigure 72 boundary = REPLICATED Example\n\u2022 BACKUP. Shifts the overlapping subwindow the same way the ALIGN  option\nshifts it. See ALIGN  for more details.", "output_type": "Optional. Specifies the type of output generated. The default is DELTA_WINDOW.\n\u2022 DELTA_WINDOW. Outputs the delta window subwindow saved by the\nden_save_window()  utility function.\n\u2022 CLIPPED_DELTA_WINDOW. Outputs the intersection between the subwindow\nand the window layer polygon. This intersection is performed after window\nfunction calculations. This option ensures all output subwindows are inside\nthe boundaries of nonrectangular window layer polygons.\n\u2022 CENTER. Outputs the rectangle placed at the center of the subwindow\nsaved by the den_save_window()  utility function. The dimensions of the\nrectangle are specified by the output_center_dimensions  argument.\ndensity()\nAn error is given when the output_type  argument is CENTER  and\noutput_center_dimensions  argument is {0, 0}.\n\u2022 CLIPPED_CENTER. Outputs the intersection between the rectangle placed at\nthe center of the subwindow and the window layer polygon. This intersection\nis performed after window function calculations are completed. This option\nensures that all center subwindows are inside the boundaries of the window\nlayer polygons.", "output_center_dimensions": "Optional. Specifies the dimensions of the rectangle output when the\noutput_type  argument is CENTER.\nNote:\nAn error is reported if only one of the two\noutput_center_dimensions  values is a nonzero value.\nAn error is reported if output_center_dimensions  values are\nspecified and the output_type  argument is not CENTER.", "delta_window_sizes": "Optional. Specifies a list of sized delta_window  subwindow values. Each group\nof north, south, east, and west  values represents one sized subwindow. The\nvalues can be a mix of negative and positive values.\nThe north  value is in the up direction relative to the top cell. The south  value is\nin the down direction relative to the top cell, and so forth for the east  and west\nvalues. The resulting oversized subwindow is rectangular.\n\u2022 north. Sizes in the up direction relative to the top cell.\n\u2022 south. Sizes in the down direction relative to the top cell.\n\u2022 east. Sizes in the right direction relative to the top cell.\n\u2022 west. Sizes in the left direction relative to the top cell.", "process_delta_windows": "Optional. Controls the handling of delta_window  subwindow processing within\nthe extents of a window layer polygon. The default is OVERLAPPING.\n\u2022 OVERLAPPING. Specifies to process only subwindows that overlap the window\nlayer polygon.\n\u2022 ALL. Specifies to process all subwindows that fall within the extent of the\nwindow layer polygon.\ndensity()\nWhen using the ALL  option,\n\u25e6 Do not set the output_type  argument to CLIPPED_DELTA_WINDOW  or\nCLIPPED_CENTER.\n\u25e6 Do not use the area_clip_delta_percent  argument.\nIn the following example, the remote function named den_func outputs\nsubwindows for densities less than 0.6. In the remote function, m1 is not clipped\nby windowLayer.\nFigure 73  shows the results of the density()  function for each\nof the process_delta_windows  argument settings.\nresult = density(windowLayer, {\"layer1\" => m1}, den_func,\ndelta_window = {15, 15},\nprocess_delta_windows = ... );\nFigure 73 process_delta_windows Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\ndensity()", "merge_errors": "Optional. Specifies to report errors as a single error or individual errors. The\ndefault is false.\nNote:\nThis argument applies only when the output of density()  function\ngoes to the LAYOUT_ERRORS file.\n\u2022 true. Merges overlapping and abutting errors, and reports each group of\nmerged errors as a single error. For each merged error group, minimum\nvalue, maximum value, and average value for each error statistic are\nreported.\n\u2022 false. Reports individual errors unmerged.", "pydb_output": "Optional. Enables a layer-producing density function to output error violations to\nthe error database (PYDB) to be viewed in VUE. The default is false.\n\u2022 true. Layer-producing density function outputs both a polygon result and\nviolations to the error database (PYDB).\n\u2022 false. Layer-producing density function outputs only a polygon result.", "traverse_boundary": "Optional. Specifies the type of delta_window  subwindow traversal to be\nperformed. The default is POLYGON_EXTENT.\n\u2022 POLYGON_EXTENT. Specifies that the extents of the current window_layer\npolygon define the boundary in which the delta windows are traversed. The\ntraversal starts at the left-bottom corner of the current window layer polygon\nextent and ends at the right-top corner of the polygon extent.\n\u2022 VERTICAL_TRAPEZOID_EXTENTS. Specifies that each vertically fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each vertical trapezoid extent and ends at the right-top corner of the\ntrapezoid extent.\n\u2022 HORIZONTAL_TRAPEZOID_EXTENTS. Specifies that each horizontally fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each horizontal trapezoid extent and ends at the right-top corner of the\ntrapezoid extent.\ndensity()", "merge_errors_output": "Optional. Specifies the output type for the merged errors when the\nmerge_errors  argument is true. The default is EXTENTS.\n\u2022 EXTENTS. Specifies that the errors are merged into rectangles, which\nrepresent the extents of the merged errors.\n\u2022 POLYGONS. Specifies that the errors are merged into polygons, which have\nthe same characteristics as unmerged errors.", "statistics_file_error_names": "Optional. Specifies statistics file keywords name for statistics to be written to\nfile. This is used for the more compressed tabular format where the names\nare listed once in the header as opposed to every window entry having a\nkeyword=value. This reduces the disk space required for the statistics file. See\nden_window_statistics_table()  utility function for writing entries in the table\nformat.", "statistics_file_window_limit": "Optional. Specifies a limit for window entries in the density statistics file. The\ndefault is 500000000."}, "summary": "The density()  function checks the layout density based on user-programmable density\nequations.", "function_name": "density()"}
{"description": "The density_global_options()  function overwrites all corresponding settings in\ndensity()  functions in the runset.", "syntax": "density_global_options(\nmerge_error                    =  {override = true | false,  value =\ntrue | false}, //optional\nmerge_errors_output            = EXTENTS | POLYGONS | UNSET\n//optional\nstatistics_file_window_limit   = integer\n);", "returns": "void", "arguments": {"merge_error": "Optional. Overwrites all merge_errors  settings of the density()  function in the\nrunset.\n\u2022 override. Optional. Enables the overwriting mechanism. The default is\nfalse.\n\u2022 value. Optional. Specifies the value to overwrite all merge_errors  settings\nof the density()  function in the runset when override is true. The default is\nfalse.", "merge_errors_output": "Optional. Overwrites all merge_errors_output  settings of the density()\nfunction in the runset. The default is UNSET, which does not overwrite.", "statistics_file_window_limit": "Optional. Overwrites all statistics_file_window_limit  settings of the\ndensity()  function in the runset. The default is UNSPECIFIED_INTEGER, which\ndoes not overwrite.\ndensity_global_options()"}, "summary": "The density_global_options()  function overwrites all corresponding settings in\ndensity()  functions in the runset.", "function_name": "density_global_options()"}
{"description": "The density_statistics_file()  function defines a statistics file. This file is\nspecified in the statistics_files  argument of the density functions,\ndensity()  and\ngradient_density().\nNote:\nThe density_statistics_file()  function cannot be called more than one\ntime with the same file argument. The result, however, can be used in more\nthan one density function.", "syntax": "density_statistics_file(\nfile = \"string\"\n);", "returns": "density_statistics_file_handle\ndensity_statistics_file_handle", "arguments": {"file": "Required. Specifies the density statistics file name. See the\ndensity()  and\ngradient_density()  functions for more information."}, "summary": "The density_statistics_file()  function defines a statistics file.", "function_name": "density_statistics_file()"}
{"description": "The dev_dlink_library_close()  function closes the dynamic-link library. See the\nDynamic-Link Library Support chapter in the IC Validator User Guide  for more information.", "syntax": "dev_dlink_library_close(\ndev_dlink_library_handle  = dev_dlink_library_handle\n);", "returns": "void", "arguments": {"dev_dlink_library_handle": "Required. Specifies the handle of the dynamic-link library."}, "summary": "The dev_dlink_library_close()  function closes the dynamic-link library.", "function_name": "dev_dlink_library_close()"}
{"description": "The dev_dlink_library_open()  function opens the dynamic-link library. It must be\nopened before being used by the\ndev_dlink()  function. See the Dynamic-Link Library\nSupport chapter in the IC Validator User Guide  for more information.", "syntax": "dev_dlink_library_open(\nlibrary_name  = \"string\"\n);", "returns": "dev_dlink_library_handle", "arguments": {"library_name": "Required. Specifies the dynamic-link library."}, "summary": "The dev_dlink_library_open()  function opens the dynamic-link library.", "function_name": "dev_dlink_library_open()"}
{"description": "The device_connected_to()  function selects polygons from devices that are\nconnected to nets with the specified text. The complement of this function is the\ndevice_not_connected_to()  function.", "syntax": "device_connected_to(\ndevice_db       = device_database,\ntext            = {\"string\", ...},\ndevices         = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                        //optional\ntexted_at       = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL                 //optional\n);\ndevice_not_connected_to(\ndevice_db       = device_database,\ntext            = {\"string\", ...},\ndevices         = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                        //optional\ntexted_at       = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.\ndevice_connected_to() and device_not_connected_to()", "text": "Required. Specifies the text used for selection of device body polygons from\ndevices that are connected to nets with the specified text. String matching using\nmetacharacters is allowed. See\nString Matching  for more information.", "devices": "Optional. Lists the devices and terminal layers that determine if a net is\nconnected to a device. The default is all devices.\n\u2022 device_name. Required. Specifies the device name, which must be defined\nin the device database specified in the device_db  argument.\n\u2022 device_layers. Optional. Specifies the layers that must be defined for a\nparticular device. When the layer list is empty, all terminal layers are used.\n\u2022 device_type. Optional. Specifies the device type. The default is ALL.", "texted_at": "Optional. Specifies where to look for the text specified with the text  argument.\nThe default is ANY_LEVEL.\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text.\nNote:\nWith this setting, the device_not_connected_to()  function is not\nthe complement of the device_connected_to()  function; both\nfunctions select only polygons from top cell nets.\n\u2022 TOP_OF_NET. Looks at all cells on the highest hierarchical level on the net\nfor the specified text. The tool selects the net whose text on the highest\nlevel matches the specified text; the net does not have higher hierarchical\nlevels. This option is not available when the processing_mode  argument is\nCELL_LEVEL.\n\u2022 ANY_LEVEL. Looks at all cells on the net for the specified text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\ndevice_connected_to() and device_not_connected_to()\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The device_connected_to()  function selects polygons from devices that are\nconnected to nets with the specified text.", "function_name": "device_not_connected_to()"}
{"description": "The device_connected_to()  function selects polygons from devices that are\nconnected to nets with the specified text. The complement of this function is the\ndevice_not_connected_to()  function.", "syntax": "device_connected_to(\ndevice_db       = device_database,\ntext            = {\"string\", ...},\ndevices         = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                        //optional\ntexted_at       = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL                 //optional\n);\ndevice_not_connected_to(\ndevice_db       = device_database,\ntext            = {\"string\", ...},\ndevices         = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                        //optional\ntexted_at       = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.\ndevice_connected_to() and device_not_connected_to()", "text": "Required. Specifies the text used for selection of device body polygons from\ndevices that are connected to nets with the specified text. String matching using\nmetacharacters is allowed. See\nString Matching  for more information.", "devices": "Optional. Lists the devices and terminal layers that determine if a net is\nconnected to a device. The default is all devices.\n\u2022 device_name. Required. Specifies the device name, which must be defined\nin the device database specified in the device_db  argument.\n\u2022 device_layers. Optional. Specifies the layers that must be defined for a\nparticular device. When the layer list is empty, all terminal layers are used.\n\u2022 device_type. Optional. Specifies the device type. The default is ALL.", "texted_at": "Optional. Specifies where to look for the text specified with the text  argument.\nThe default is ANY_LEVEL.\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text.\nNote:\nWith this setting, the device_not_connected_to()  function is not\nthe complement of the device_connected_to()  function; both\nfunctions select only polygons from top cell nets.\n\u2022 TOP_OF_NET. Looks at all cells on the highest hierarchical level on the net\nfor the specified text. The tool selects the net whose text on the highest\nlevel matches the specified text; the net does not have higher hierarchical\nlevels. This option is not available when the processing_mode  argument is\nCELL_LEVEL.\n\u2022 ANY_LEVEL. Looks at all cells on the net for the specified text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\ndevice_connected_to() and device_not_connected_to()\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The device_connected_to()  function selects polygons from devices that are\nconnected to nets with the specified text.", "function_name": "device_connected_to()"}
{"description": "The device_net_count()  function selects polygons from devices that have the specified\nnet count. The selected polygons are merged.", "syntax": "device_net_count(\ndevice_db        = device_database,\ncount           = integer,                                  //optional\ndevices         = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                        //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.", "count": "Optional. Specifies the number of unique nets to which a device must be\nconnected for the device to be selected. This value must be positive. See\nConstraints  for more information. The default is 1.\n\u2022 If count = 0, a device is selected if there are no nets connected to the\ndevice. (It is a floating device.)\n\u2022 If count = 1, a device is selected if there is only one net connected to the\ndevice. (It is a one-connection device.)", "devices": "Optional. Lists the devices and terminal layers that determine if a net is\nconnected to a device. The default is all devices.\ndevice_net_count()\n\u2022 device_name. Required. Specifies the device name, which must be defined\nin the device database specified in the device_db  argument.\n\u2022 device_layers. Optional. Specifies the layers that must be defined for a\nparticular device. When the layer list is empty, all terminal layers are used.\n\u2022 device_type. Optional. Specifies the device type. The default is ALL.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The device_net_count()  function selects polygons from devices that have the specified\nnet count.", "function_name": "device_net_count()"}
{"description": "The dfm_features()  function provides access to aggregate geometric data on multiple\nlayers of all types in the context of a specified window. One or more remote functions are\nused to specify arithmetic conditions in terms of geometric characteristics and properties\nto choose windows for output.", "syntax": "dfm_features(\nlayer_ids           = {\"string\" => geometry_layer, ...},\ndfm_function        = function,\naggregate_functions = {\"string\" => {\naggregate_function = function,\nlayer_id           = \"string\",\nop                 = MIN | MAX | SUM  | PRODUCT           //optional\n}},                                                       //optional\ncontext             = TOP  | BY_CELL,                        //optional\nboundary            = {\ntype  = {CHIP_EXTENT | BOX | INPUT_LAYERS_EXTENT |\nPOLYGON_EXTENTS},                               //optional\nbox   = {{left = double,  bottom = double,\nright = double, top = double}, ...},           //optional\nlayer = polygon_layer                                    //optional\n},                                                        //optional\nwindows             = {\ndelta_window = {width = double, height = double},        //optional\ndelta_x      = double,                                   //optional\ndelta_y      = double,                                   //optional\nboundary     =\nCLIP  | BACKUP,                            //optional\noutput_type  = DELTA_WINDOW  | CENTER,                    //optional\noutput_center_dimensions = {width  = double,\nheight = double},            //optional\n},                                                        //optional\ncells               = {\nchild_data = LEVEL_CHILD_DATA  | FLATTEN_CHILD_DATA |\nIGNORE_CHILD_DATA,                          //optional\nmerge      =\ntrue  | false,                               //optional\n},                                                        //optional\nfiles                = {ascii_file_handle, ...}              //optional\n);", "returns": "polygon layer or error result\ndfm_features()", "arguments": {"layer_ids": "Required. Specifies the hash of string to geometry layers. The strings are used\nby the remote function to access composite characteristics of the given layer.\nThe layers can be of type error, polygon, or edge.", "dfm_function": "Required. Specifies the remote function that calculates the final value for the\nspecified window and reports the results. This function is executed one time per\nwindow, after the completion of any aggregate functions. For information about\nthe utility functions you can use to define a remote function, see\nDFM Features\nUtility Functions.\nNote:\nThe DFM features utility functions are exclusive to dfm_function.", "aggregate_functions": "Optional. An optional hash of string to structure that specifies the functions and\narguments to be used for calculating aggregate values for the window. These\nfunctions are executed one time per window, before the function specified by\nthe dfm_function  argument. The results of these functions are passed to the\ndfm_function  argument by the dfm_aggregate()  utility function, using the\nappropriate hash key. Use this hash when the aggregate value of an expression\nis required.\nNote:\nThis list of aggregate functions can cause performance degradation\nand should be used only when necessary.\n\u2022 aggregate_function. Required. Specifies a function with no arguments that\nreturns a double. This function defines the value that is calculated for each\ndata item in the window. In addition to the standard PXL library, the following\nutility functions are defined in the context of this aggregate function:\n\u25e6 dfm_area()\n\u25e6 dfm_perimeter()\n\u25e6 dfm_length()\n\u25e6 dfm_projection_length()\n\u25e6 dfm_distance()\n\u25e6 dfm_get_double_property()\ndfm_features()\nThese utility functions are exclusive to this context.\n\u2022 layer_id. Required. Specifies the string that identifies the layer from the\nlayer_ids  list. are used by the aggregate function to access composite\ncharacteristics of the layers. This string must appear in the layer_ids  hash.\n\u2022 op. Optional. Specifies the operation to be performed on the result of the\naggregate function to determine the result. Because aggregate functions do\nnot provide access to individual data, they are evaluated only in the context\nof the specified operation. The default operation is SUM.\n\u25e6 SUM\n\u25e6 MIN\n\u25e6 MAX\n\u25e6 PRODUCT", "context": "Optional. Specifies an optional enumerator that identifies where the operation\ntakes place. The default is TOP.\n\u2022 TOP. Operates in the context of the top cell. All hierarchical overlap is\nresolved. The boundary can be defined in the boundary  argument, and delta\nwindows can be defined in the windows  argument.\n\u2022 BY_CELL. Specifies that the extents of each cell is a boundary and cells are\nprocessed individually. The processing is defined by the cells  argument.\nDelta windows and boundary control are not available.\nNote:\nAlthough efforts are made to maintain the most efficient hierarchy,\nthe hierarchical location of geometric data in derived layers is\nnot guaranteed. Layer operations can move data up or down the\nhierarchy to facilitate their implementation.", "boundary": "Optional. Defines the geometric extents of the operation when context = TOP.\n\u2022 type. Optional. Specifies an enumerator that defines the type of boundary.\nThe default is CHIP_EXTENT.\n\u25e6 CHIP_EXTENT. The extents of all layers in the assign section\n\u25e6 BOX. The boundary is defined by boundary.box\ndfm_features()\n\u25e6 INPUT_LAYERS_EXTENT. The extents of all layers in layer_ids\n\u25e6 POLYGON_EXTENTS. One or more boundaries are defined by the polygonal\nextents of the polygons in boundary.layer\n\u2022 box. Optional. Specifies a structure of four doubles used when\nboundary.type = BOX. The four doubles define the opposing corners of a\nbox. The coordinates are in the coordinate system of the top block. A box\nwith no area results in no output.\n\u2022 layer. Optional. Specifies a polygon layer used when boundary.type =\nPOLYGON_EXTENTS. An empty layer results in no output.\nWhen type = BOX  or type = POLYGON_EXTENTS, the input data might require\nclipping based on the layer type:\n\u2022 Polygons are clipped at the boundary like an and()  operation.\n\u2022 Edges are clipped at the boundary like an and_edge()  operation, which\nincludes inside coincidence.\n\u2022 Errors are not clipped. All errors that interact with the boundary, except\ntouches, are included.", "windows": "Optional. Defines the delta windows when context = TOP.\n\u2022 delta_window. Optional. Defines the width and height of the delta window.\nBoth values must be positive. The default is {0,0}, which means delta\nwindows are not used.\n\u2022 delta_x. Optional. Specifies the delta_window  subwindow step distance in\nthe x-direction. The default is delta_window  width value. Nonpositive values\nare ignored.\n\u2022 delta_y. Optional. Specifies the delta_window  subwindow step distance\nin the y-direction. The default is delta_window  height value. Nonpositive\nvalues are ignored.\n\u2022 boundary. Optional. Specifies an enumerator the defines the behavior when\na delta window exceeds the boundary. The default is CLIP.\n\u25e6 CLIP. Truncates the delta window at the boundary.\n\u25e6 BACKUP. Shifts the delta window to coincide with the boundary.\n\u2022 output_type. Optional. Specifies the type of output generated. The default\nis DELTA_WINDOW.\ndfm_features()\n\u25e6 DELTA_WINDOW. Specifies the delta window.\n\u25e6 CENTER. Outputs the rectangle placed at the center of the\nsubwindow. The dimensions of the rectangle are specified by the\noutput_center_dimensions  argument. The CENTER  argument enables\nthe storage of user-defined properties on the derived output layer.\n\u2022 output_center_dimensions. Optional. Specifies the dimensions of the\nrectangle output when the output_type  argument is CENTER.\nThe windows are in the top block. The starting point is the lower-left corner of\nthe boundary. Measurements of data is based on the layer type:\n\u2022 For polygons, the measurement includes the portion of the active area that\nfalls in the window.\n\u2022 For edges, the measurement includes the portion of the length that falls in\nthe window or is inside coincident with the window.\n\u2022 For errors, given the polygon formed by connecting the edges of the error:\nfor each window that shares active area with that polygon, the measurement\nof each window includes the error distance and the complete projection\nlength.", "cells": "Optional. Defines the processing when context = BY_CELL.\n\u2022 child_data. Optional. Specifies what happens with the data in the\nplacement of the current cell. The default is LEVEL_CHILD_DATA.\n\u25e6 LEVEL_CHILD_DATA. Includes hierarchically interacting data in the\nmeasurements of the current cell.\n\u25e6 FLATTEN_CHILD_DATA. Includes all child data in the measurements of the\ncurrent cell.\n\u25e6 IGNORE_CHILD_DATA. ignores placements in the current cell.\n\u2022 merge. Optional. Controls how the IC Validator tool treats hierarchically-\nformed geometries (polygons, edges, or errors). The default is true. This\noption is used only when child_data != IGNORE_CHILD_DATA.\ndfm_features()\n\u25e6 true. Promotes hierarchically-formed geometries to a common point in\nthe hierarchy, and merges them into a single geometry.\nNote:\nAlthough the tool attempts to maintain the most efficient\nhierarchy, the resulting location of promoted geometries is not\nguaranteed.\n\u25e6 false. Leaves hierarchically-formed geometries as is. Measurements can\ninclude redundant data.", "files": "Optional. Specifies the ASCII files that the\ndfm_fnote()  utility function can\nwrite to. The order of the files determines the index for accessing the files in the\nremote functions; the first file listed has an index of 0 (zero)."}, "summary": "The dfm_features()  function provides access to aggregate geometric data on multiple\nlayers of all types in the context of a specified window.", "function_name": "dfm_features()"}
{"description": "The dissect_by_corner_edge()  function cuts the input edges and polygons into several\nedge segments by creating the dissection points generated from the corners of input itself.", "syntax": "dissect_by_corner_edge(\nlayer1            = data_layer,\nmain_layer        = polygon_layer,\nangle1            = corner_constraint,\nangle2            = corner_constraint,\nlength            = positive_constraint,\nadjacent_length1  = positive_constraint,\nadjacent_length2  = positive_constraint,\ndissect_when_no_remaining_edge  = true  | false,\ndissect_values    = {doubleconstraint, ...},         //optional\ncorner1_dissect_values   = {doubleconstraint, ...},  //optional\ncorner2_dissect_values   = {doubleconstraint, ...},  //optional\nmin_remainder : double,                             //optional\ndissect_conflict_adjust  = DISCARD  | MERGE | BOTH_MOVE |\nCORNER1_MOVE | CORNER2_MOVE,\n//optional\nripple_conflict_adjust   = DISCARD  | MERGE | BOTH_MOVE |\nCORNER1_MOVE | CORNER2_MOVE\n//optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the data or segment layer to be dissected.", "main_layer": "Required. Specifies the data layer which is the original layer of the layer1\nsegment layer. If layer1  is not the segment layer, then min_layer  should be\nthe same as layer1.", "angle1": "Required. Specifies the end of the selected edge with the angle in the specific\nangle range.\ndissect_by_corner_edge()", "angle2": "Required. Specifies the other end of the selected edge with the angle in the\nspecific angle range.", "length": "Required. Specifies the selected edge with the length in a specific length range.", "adjacent_length1": "Required. Specifies the selected edge with the length of an adjacent edge to\ncorner1  in a specific length range.", "adjacent_length2": "Required. Specifies the selected edge with the length of an adjacent edge to\ncorner2  in a specific length range. For example:", "dissect_when_no_remaining_edge": "Required. Switches the dissection mode to enable or disable the dissection if the\nvector length remains a length exactly matching the summation of the dissection\nlength from both corners. This argument affects corner and ripple dissection\nat simultaneously. The default is true, which means exact match dissection is\ndisabled. For example:", "dissect_values": "Optional. Specifies the distance range between the dissection point and corner\nor previous dissection points starting in order from both corners. If there is no\nconflict, the distance is the maximum length of the range. Only the first items\nto dissect from the corner are dissection points. The middle points are ripple\npoints. The dissection always starts from the corner of main layer, even if the\ninput is a segment layer. The valid constraints are <=, ==, and [].\ndissect_by_corner_edge()\nIf the angle range of angle1  and angle2  overlaps and the adjacent_length1\nand adjacent_length2  ranges overlap, this parameter is a must, and it\noverwrites corner1_dissect_values  and corner2_dissect_values.\nWhen the dissected edge length is equal or smaller than maximum length of\ncorner1_dissect_values, segmentation on this edge is unexpected no matter\nwhich conflict method is applied. For example:\ndissect_values = {[a, b], [c, d], [e, f]}", "corner1_dissect_values": "Optional. Specifies the distance range between the dissection point and\ncorner or previous dissection points starting in order from corner1. If there is\nno conflict, the distance is the maximum length of the range. This argument\noverwrites the dissect_values  setting for dissection points created from\ncorner1. The dissection always starts from corner of main layer even if the\ninput is segment layer. The valid constraints are <=, ==, and []. If the angle\nrange of angle1  and angle2  overlaps and the adjacent_length1  and\nadjacent_length2  ranges overlap, this parameter is overwritten by parameter\ndissect_values.", "corner2_dissect_values": "Optional. Specifies the distance range between the dissection point and\ncorner or previous dissection points starting in order from corner2. If there is\nno conflict, the distance is the maximum length of the range. This argument\noverwrites the dissect_values  setting for dissection points created from\ncorner2. The dissection always starts from the corner of the main layer, even\nif the input is a segment layer. The valid constraints are <=, ==, and [].If the\nangle range of angle1  and angle2  overlaps and the adjacent_length1  and\nadjacent_length2  ranges overlap, this parameter is overwritten by parameter\ndissect_values.", "min_remainder": "Optional. Specifies the minimum length between all dissection points. The\nremaining value affects both of the dissection points and the ripple points.\nThe remaining value can be larger than dissect_min  (the minimum value\nof the constraint). When two dissection or ripple points are smaller than\nmin_remainder  value, two points are moved based on the method specified in\ndissect_point_conflict_adjust  or ripple_conflict_adjust.\ndissect_by_corner_edge()", "dissect_conflict_adjust": "Optional. Specifies the movement method of dissection points, in which the\ndistance between is smaller than what remains. After adjustment, the distance\nof dissection points is recalculated and discarded if the distance of the post-\nadjusted dissection point does not meet the dissection constraint. However,\nwhen the remaining distance is 0, meaning that there is exactly one dissection\npoint available, none of the adjustment methods affect the dissection point.\n\u2022 DISCARD: Discards the points.\n\u2022 MERGE: Specifies tjat two dissection points are merged into middle of the\ndissection points. If one of dissected segment length is smaller than the\nminimum value of the given constraint after the merge adjustment, the\nDISCARD  behavior is used.\ndissect_by_corner_edge()\n\u2022 BOTH_MOVE. Specifies that two dissection points move apart from each\nother equally to make the distance between equal. If the movement makes\nthe distance between the previous dissection points smaller than specific\ndissection distance range, discard this point.\n\u2022 CORNER1_MOVE. Moves the dissection point generated from corner1  away\nfrom another dissection point to make the distance between them equal to\nmin_remainder. If the movement make the distance between the previous\ndissection point smaller than specific dissection distance range, discard this\npoint. In other words, corner1  must have a lower priority than corner2  in the\nadjustment method. An error occurs if the adjustment set with this value and\ngiven corner criteria for corner1  and corner2  are overlap.\n\u2022 CORNER2_MOVE. Moves the dissection point generated from corner2  away\nfrom another dissection point to make the distance between them equal to\nmin_remainder. If the movement make the distance between the previous\ndissection point smaller than the specific dissection distance range, discard\nthis point. In other words, corner2  must have a lower priority than corner1\nin the adjustment method. An error occurs if the adjustment set with this\ndissect_by_corner_edge()\nvalue and given corner criteria for corner1  and corner2  are overlap. For\nexample:", "ripple_conflict_adjust": "Optional. Specifies the movement method of ripple points in which the distance\nbetween is smaller than min_remainder. The available parameters are the\nsame as they are for dissect_conflict_adjust."}, "summary": "The dissect_by_corner_edge()  function cuts the input edges and polygons into several\nedge segments by creating the dissection points generated from the corners of input itself.", "function_name": "dissect_by_corner_edge()"}
{"description": "The dissect_by_length_edge()  function cuts the input edges and polygons into several\nedge segments by creating the dissection points based on the edge length and specific\nmode.", "syntax": "dissect_by_length_edge(\nlayer1      = data_layer,\nmain_layer  = polygon_layer,\nmax_length  = double,    //optional\nmin_length  = double,    //optional\nmode        = MAX | AVERAGE |\nMIXED               //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the data or segment layer to be dissected.", "main_layer": "Required. Specifies the data layer, which is the original layer of the layer1\nsegment layer. If layer1  is not segment layer, this layer should be the same\nas layer1. The purpose of main_layer  is to reference the jog for the layer1\nsegment to distinguish from a partial segment selected after the segment", "operation": "", "max_length": "Optional. Specifies the maximum length of each output unmerged edge\n(segment). When the input data or segment length is greater than this value, this\nargument performs dissection based on the mode method.", "min_length": "Optional. Specifies the minimum length of each output unmerged edge\n(segment). When applying mode=MAX  and the remaining segment length is\nsmaller than this value, there is an ADAPT  adjustment on dissection points. The\ndefault is the dissection_min  setting in the dissection_options.\ndissect_by_length_edge()", "mode": "Optional. Determines the method for dissection on the input data or segment\nwhen the length is greater than max_length.\n\u2022 AVERAGE. Dissects the remaining segment length with rest_length  equally\ninto the segment length, which is the maximum length smaller than the\nmax_length  that each length of segment is. If rest_length  cannot be\nexactly divided by max_length, a new segment length is calculated, as\nshown here:\n(rest_length/max\u2061_length)+1  new_length=\nrest_length/((int)(rest_length/max\u2061_length)+1)\nThe exact length of segments is the new_length+1  for the center\nof rest_length/new_length  segments and new_length  for other\nsegments. An error occurs if the value is smaller than two times that of\ndissection_min.\n\u2022 MAX. Dissects the distance of max_length  from both ends of the data\nor segment. If the segment length is less than the dissection_min\ndetermined in dissection_options, dissection points with conflict perform\nan ADAPT  adjustment as shown in . If the segment length is greater than the\nmax_length, but less than two times the max_length, the dissection point\nis placed in the middle of the remaining segment, as shown in the following\nfigure.\nThe following figure shows more examples of MAX mode results for different\ninput:\ndissect_by_length_edge()\nThe algorithm is as the follows:\n1. If length<=max_length, do not dissect.\n2. If max_length<length<=2*max_length, dissect in the middle of the\nremaining segment.\n3. If length>2*max_length, dissect the segment from both ends\nby length==max_length  until the remaining segment is length<\n2*max_length.\na. If remain_length < min_length, adapt behavior. This center\nsegment length = min_length. The two neighboring segments\nlength is (max - (min-remaining)/2). If (min-remaining)  is odd,\nthe segment close to input starting point is 1dbu longer.\nb. If remain_length <= max_length, done.\nc. If max_length<remain_length<=2*max_length, dissect in the middle\nof the remaining segment.\nif max_length<2*min_length, add three behavior adaption changes as\nshown here:\n1. If max_length<length<2*min_length, do not dissect.\n2. If length>2*max_length, dissect the segment from both ends\nby length==max_length  until the remaining segment length is <\n2*max_length.\n\u25ba If max_length<remain_length<=2*min_length, dissect in the middle\nof the remaining segment and adapt the neighbor segments for center\nrest segments to meet the length equal to min_length.\ndissect_by_length_edge()\n3. If the yield behavior results make the neighbor segment length smaller\nthan min_length 3-1,\na. If the total segment count is odd, merge the center three segments\ninto two segments, which are dissected in half.\nb. If the total segment count is even, do not dissect the center two\nsegments.\n\u2022 MIXED. Dissects the remaining segment length with length rest_length.\nEach segment length is determined by the amounts of segments to be\ngenerated. This mode is like MAX  mode except for that when center segment\nlength < 3*max_length, dissect equally on the center segment."}, "summary": "The dissect_by_length_edge()  function cuts the input edges and polygons into several\nedge segments by creating the dissection points based on the edge length and specific\nmode.", "function_name": "dissect_by_length_edge()"}
{"description": "The dissect_by_projection_edge()  function cuts the input edges and polygons into\nseveral edge segments by creating the dissection points projected by line-end or corner of\ndissection layers.", "syntax": "dissect_by_projection_edge(\nlayer1                = data_layer,\nmain_layer            = polygon_layer,\ndissecting_layers     = polygon_layer,\nmain_space_layer      = polygon_layer,\nexclude_layer         = edge_layer,\nprojection_distance_range   = doubleconstraint,\nprojection_look_thru_count  = integerconstraint,\nprojection_direction  =  INWARD | OUTWARD | BOTH, //optional\nprojection_shift      = double,\nmin_corner_distance   = double,\nmin_convex_corner_distance   = double,\nmin_concave_corner_distance  = double,\nmin_corner_adjust     = DISCARD  | MOVE,          //optional\ndissect_min_remainder        = double,\ndissect_conflict_adjust      = DISCARD  | MOVE |\nMERGE,\n//optional\nripple_count          = integer,\nripple_length         = doubleconstraint,\nripple_min_remainder         = double,\nripple_conflict_adjust       = DISCARD  | MOVE |\nMERGE\n//optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the data or segment layer to be dissected.", "main_layer": "Required. Specifies the data layer, which is original layer of the layer1  segment\nlayer. If layer1  is not a segment layer, main_layer  should be the same as\nlayer1. The purpose of main_layer  is to reference the corner for the layer1\ndissect_by_projection_edge()\nsegment to distinguish from a partial segment selected after the segment\noperation.", "dissecting_layers": "Required. Specifies the list of data layer, which iteratively dissects the main\nlayer. When generated dissection or ripple points conflict with any of the\npoints (including dissection and ripple points) generated previously, discard\nthe points to be generated in this iteration. If there is no main layer in the\ndissecting_layers  list, there is also a projection result from layer1\nincluding the INWARD  and OUTWARD  direction dissection before projection\ndissection created from the layers listed in dissecting_layers. If a layer\nin dissecting_layers  list is a segment layer, skip it and continue to make\nprojection dissection with the remaining layers in the dissecting_layers  list.\nFor dissecting_layers  projection, there is only OUTWARD  projection to layer1,\nwhere the corner of dissecting_layers  must be outside of the main_layer.\ndissect_by_projection_edge()", "main_space_layer": "Specifies the data layer which is partially coincident with layer1. If layer1\nsegments are touched by main_space_layer, then main_space_layer  projects\nto layer1  by projection_look_thru_count<1. If segments of layer1are not\ntouched by main_space_layer, then main_space_layer  projects to layer1  by\nprojection_look_thru_count <3. Use main_space_layer  only for outward\nprojection. You do not need to specify projection_look_thru_count  when\nmain_space_layer  is provided. In addition, main_space_layer  does not\nsupport dissecting_layers  and exclude_layer.\nIn the preceding example, the purple layer represents main_space_layer\nand the orange area represents the overlapped area of main_layer\nand main_space_layer. In the preceding figure, the dissected\npoints in the purple circle are projected from main_space_layer  by\nprojection_look_thru_count<1  because this edge of layer1  is touched by\nmain_space_layer.\nThe dissected point in the yellow circle is projected from main_space_layer  by\nprojection_look_thru_count<3  because this edge of layer1  is not touched\nby main_space_layer.", "exclude_layer": "Specifies the layer of edges that are excluded from dissecting_layers.\nNote:\nThe exclude_layer  is a partial exclusion of dissecting_layers\nthat one corner can still project to layer1  if the edge of\ndissecting_layers  does not coincident to the exclude_layer.", "projection_distance_range": "Specifies a required value that determines the distance range to make an outer\nprojection from dissecting_layers  to layer1, and creates dissection points\ndissect_by_projection_edge()\nfrom the extension of the line-end or inner projection from layer1  and creates\ndissection points from the extension of the concave corner. The results of the\ndissection points meet this criteria.", "projection_look_thru_count": "Optional. Determines the look-thru projection edges of layer1  from\ndissecting_layers. The range must not indicate that the dissection count\nwithin a range is selected.", "projection_direction": "Determines that the projection direction is inner, outer or both.\n\u2022 INWARD: Executes the inner projection, and only layer1  does the INWARD\nprojection.\n\u2022 OUTWARD. Executes the outer projection.\n\u2022 BOTH. Executes the inner and outer projections.\ndissect_by_projection_edge()", "projection_shift": "Determines the movement of dissection points leaving of line-end or corner.\nWhen projection_shift>0, the dissected point shifts from the direction\nfarthest from the projecting line-end or corner. When projection_shift<0, the\ndirection of the shift is closest to the projecting line-end or corner.\nThe following example shows one non-orthogonal case projection.\nHowever, when projection_look_thru_count=0  and shift=0, the non-\northogonal projection includes INWARD  projection for angle<180+angle<180  and\nOUTWARD  projection for angle>180+angle>180  or angle>180+angle<180. If the\nprojecting line cannot be perpendicular to the dissected edge, it does not create\nany dissected point.", "min_corner_distance": "Determines the minimum distance from the corner to the dissection or ripple\npoints. If there are dissection or ripple points which make the distance from the\ndissect_by_projection_edge()\ncorner smaller than this value, those points are adjusted by the method specified\nin min_corner_adjust.", "min_convex_corner_distance": "Determines the minimum distance from the convex corner to the dissection or\nripple points. If there are dissection or ripple points which make the distance\nfrom the corner smaller than this value, those points are adjusted by the method\nspecified in min_corner_adjust. When min_convex_corner_distance  and\nmin_corner_distance  are specified at the same time, the minimum distance\nfor dissected points is determined from the maximum of these two values.", "min_concave_corner_distance": "Determines the minimum distance from the concave corner to the dissection\nor ripple points. If there are dissection or ripple points which make the distance\nfrom the corner smaller than this value, those points are adjusted by the method\nspecified in min_corner_adjust. When min_convex_corner_distance  and\nmin_corner_distance  are specified at the same time, the minimum distance\nfor dissected points is determined from the maximum of these two values.", "min_corner_adjust": "Determines the adjustment method for dissection points or ripple points\nwhose distance to the corner is smaller than min_corner_distance,\nmin_convex_corner_distance, and min_concave_corner_distance.\n\u2022 DISCARD: Discards those points.\nNote:\nIf a dissection point is removed, there are no ripple points\ngenerated based on this dissection point.\n\u2022 MOVE: Moves those points to keep their distance to the corner equal\nto min_corner_distance, min_convex_corner_distance, or\nmin_concave_corner_distance.\ndissect_by_projection_edge()", "dissect_min_remainder": "Determines the minimum length of segments between two dissection points.\nWhen the distance between two dissection points is smaller than this value,\nthe two dissection points are moved based on the method specified in\ndissect_conflict_adjust.", "dissect_conflict_adjust": "Determines the movement method of dissection points whose in-between\ndistance is smaller than dissect_min_remainder.\n\u2022 DISCARD: Discards the lower priority dissection point, or discards both\ndissection points if their priorities are the same.\nNote:\nIf a dissection point is removed, there are no ripple points\ngenerated based on this dissection point.\n\u2022 MOVE: Moves apart the dissection points from each other with a lower priority,\nor moves apart two dissection points from each other equally if their priorities\nare the same, to ensure the distance between them is equal to the distance\nfor dissect_min_remainder. The priorities are defined as the factor of the\nDISTANCE  (smaller is higher), PENETRATE  (smaller is higher), CORNER_AVOID\n(larger is higher), PROJECTION, or WIDTH.\ndissect_by_projection_edge()\n\u2022 MERGE: Specifies that two dissection points are merged into the middle of the\ndissection point.", "ripple_count": "Determines the maximum pair count of ripple points that ripple from the\ndissection points.", "ripple_length": "Determines the maximum or minimum distance needed to generate ripple points\nin a pair, as shown in the preceding illustration. There is no relationship between\nripple_length  and ripple_min_remainder. The valid constraints are <=, ==,\nand [].", "ripple_min_remainder": "Determines the minimum distance between two ripple points. When there is a\nsmaller distance between two ripple points than this value, the two ripple points\nare moved based on the method specified in ripple_conflict_adjust.", "ripple_conflict_adjust": "Determines the movement method of ripple points whose in-between distance\nis smaller than ripple_min_remainder. The available options for this argument\nare the same as for the dissect_conflict_adjust  argument. However, when\nthe segment length is equal to two times the upper bound of ripple_length,\ndissect_by_projection_edge()\nwhich means that there is exactly one ripple point available, none of the\nadjustment methods affect the ripple point.\ndissect_options()\ndissect_options()"}, "summary": "The dissect_by_projection_edge()  function cuts the input edges and polygons into\nseveral edge segments by creating the dissection points projected by line-end or corner of\ndissection layers.", "function_name": "dissect_by_projection_edge()"}
{"description": "The dissect_by_corner_edge()  function defines the minimum length of edge segments\napplied to all dissection functions.", "syntax": "dissect_options(\ndissect_min  = double\n);", "returns": "void", "arguments": {"dissect_min": "Required. Specifies the minimum length of edge segments applied to all\ndissection functions.\ndonut_holes()\ndonut_holes()"}, "summary": "The dissect_by_corner_edge()  function defines the minimum length of edge segments\napplied to all dissection functions.", "function_name": "dissect_options()"}
{"description": "The donut_holes()  function creates polygons that define the holes in any donut-shaped\ndata on the specified input layer.", "syntax": "donut_holes(\nlayer1                      = polygon_layer,\nholes                       = ALL  | INNER | EMPTY,           //optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\narea                       = doubleconstraint,              //optional\nname                       = \"layer_label\",                 //optional\nouter_boundary_point_touch  = OPEN_OUTER_BOUNDARY  |\nCLOSED_OUTER_BOUNDARY |\nONE_OR_MORE_POLYGONS           //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "holes": "Optional. Specifies the types of holes that generate polygons. The default is\nALL.\n\u2022 ALL. Specifies that all holes generate polygons.\n\u2022 INNER. Specifies that only holes which do not contain another hole generate\npolygons.\n\u2022 EMPTY. Specifies that only completely empty holes generate polygons.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ndonut_holes()", "area": "Optional. Specifies that holes are checked for this area. The default is >0.0.\n\u2022 When the holes  argument is ALL  and the outer_boundary_point_touch\nargument is not ONE_OR_MORE_POLYGONS, the area is checked for unmerged\nholes. Otherwise, when the holes  argument is INNER  or EMPTY, or the\nouter_boundary_point_touch  argument is ONE_OR_MORE_POLYGONS, the\narea is checked for merged holes.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "outer_boundary_point_touch": "Optional. Controls if an outer boundary point-touch case is treated as a hole.\nThe default is OPEN_OUTER_BOUNDARY.\n\u2022 OPEN_OUTER_BOUNDARY. Does not treat an outer boundary point-touch case\nas a hole.\n\u2022 CLOSED_OUTER_BOUNDARY. Treats an outer boundary point-touch case from a\nsingle polygon as a hole.\n\u2022 ONE_OR_MORE_POLYGONS. Treats an outer boundary point-touch case from\none or more polygons as a hole."}, "summary": "The donut_holes()  function creates polygons that define the holes in any donut-shaped\ndata on the specified input layer.", "function_name": "donut_holes()"}
{"description": "The donuts()  function selects layer1  polygons that contain one or more holes. An\noptional constraint allows you to specify the required number of holes. The complement of\nthis function is the not_donuts()  function.", "syntax": "donuts(\nlayer1          = polygon_layer,\ncount            = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_donuts(\nlayer1          = polygon_layer,\ncount            = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "count": "Optional. Specifies the number of holes a polygon must contain for it to be\nselected. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ndonuts() and not_donuts()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The donuts()  function selects layer1  polygons that contain one or more holes.", "function_name": "donuts()"}
{"description": "The drc_black_box_options()  function provides the capability to restrict what is read\nfrom the layout for certain cells designated as black-box cells or black-box region cells.", "syntax": "drc_black_box_options(\nblack_box_cells = {\n{cells = {\"string\", ...},\nldt_list = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...\n},                                                 //optional\nlayer_purpose_list = {\n{\nlayer_names = {\"string\", ...},\npurpose_names = {\"string\", ...}\n}, ...\n}                                                  //optional\n}, ...\n},                                                         //optional\nblack_box_region_cells = {\n{cells = {\"string\", ...},                              //optional\nblack_box_region_layer =\n{\nldt_list = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...\n},                                             //optional\nlayer_purpose_list = {\n{\nlayer_names = {\"string\", ...},\npurpose_names = {\"string\", ...}\n}, ...\n},                                             //optional\nambit = {left=double, bottom=double,\nright=double, top=double},            //optional\nkeepout_ambit = {left=double, bottom=double,\nright=double, top=double},    //optional\n},\nclip_region =\ntrue  | false,                        //optional\nkeep_layers = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...\n},                                                 //optional\nkeep_layer_purposes = {\n{\nlayer_names = {\"string\", ...},\npurpose_names = {\"string\", ...}\ndrc_black_box_options()\n}, ...\n},                                                 //optional\nclassify_errors = {\n{violation_comments = {\"string\", ...},\nclassification = \"string\",\nclassification_comment = \"string\",         //optional\nambit = {left=double, bottom=double,\nright=double, top=double},        //optional\nrelationship = ENCLOSE |\nINTERACT  |\nNOT_ENCLOSE | NOT_INTERACT,            //optional\ninclude_touch = NONE | EDGE |\nALL           //optional\n}, ...\n},                                                 //optional\nsuppress_errors = {\n{violation_comments = {\"string\", ...},\nambit = {left=double, bottom=double,\nright=double, top=double},        //optional\nrelationship = ENCLOSE |\nINTERACT  |\nNOT_ENCLOSE | NOT_INTERACT,            //optional\ninclude_touch = NONE | EDGE |\nALL           //optional\n}, ...\n}                                                  //optional\n}, ...                                                 //optional\n},\nkeepout_layers_check    = true | false,\nkeepout_violation_comment  = \"string\"\n);", "returns": "void", "arguments": {"black_box_cells": "Optional. Specifies the black-box cells and cell-level layers to retain. String\nmatching with wildcard characters is supported.\n\u2022 cells. Specifies cells to be designated as DRC black-box cells. All subcell\ninstances are discarded from these cells, and only the listed cell-level layers\nare retained. String matching with wildcard characters is supported.\n\u2022 ldt_list. Specifies a list of cell-level layer and datatype ranges, which are\nretained for the black-box cells specified by the cells  argument.\n\u2022 layer_purpose_list. For OpenAccess layouts, specifies a list of cell-\nlevel layer and purpose names, which are retained for the black-box cells\nspecified by the cells  argument.\ndrc_black_box_options()", "black_box_region_cells": "Optional. Specifies the cells to be designated as DRC black-box region cells.\nThe exclude region is defined using a cell-level layout layer from the black-box\nregion cell. All data within the cell and hierarchically underneath it, that falls\nwithin the exclude region is discarded. Data that falls outside of the exclude\nregion is retained. String matching with wildcard characters is supported.\n\u2022 cells. Specifies a list of cells that are considered DRC black-box region\ncells. The exclude region is defined by the black_box_region_layer\nargument.\n\u2022 black_box_region_layer. Defines the exclude region for the specified\nDRC black-box region cells. The exclude region is defined using cell level\nlayout layers in the black-box region cell, and is applied to layout data in the\ncell and all of its subcells.\n\u25e6 ldt_list. Specifies a list of cell-level layout layers in the DRC black-box\nregion cells that are used to define the exclude region for the specified\nDRC black-box region cells.\n\u25e6 layer_purpose_list. For OpenAccess layouts, specifies a list of cell-\nlevel layout layer and purpose names that are used to define the exclude\nregion for the specified DRC black-box region cells.\n\u25e6 ambit. Specifies the amount by which the polygons on the region layers\nspecified by ldt_list  and layer_purpose_list  are shrunk (cell-level)\nto define the exclude region for the specified DRC black-box region cells.\nThe values of top, bottom, left, and right  are in relation to the black-\nbox cell's own coordinate system irrespective of the orientation of that\ncells placements in the design. The default is 0.\n\u25e6 keepout_ambit. Specifies an ambit for each item in the\nblack_box_region_cells  list. The default is ambit. For example:\ndescendant cell of \"B\"\nA cell, \"D\", is a descendant of \"B\" if it exists in the\nhierarchy tree\nrooted at \"B\".\nAncestor cell of \"B\"\nA cell, \"A\", is an ancestory of \"B\" if \"B\" is a descendant\nof \"A\"\nSibling cell of \"B\"\nA cell, \"S\", which has an ancestor cell in common with \"B\"\nIn the DRC black-box regions flow, you use a black-box region to exclude\npolygons in a black-box cell and its descendants. This methodology\nassumes that this exclusion operation is sufficient for ensuring that no\npolygon overlaps the black-box region. However, this assumption fails\ndrc_black_box_options()\nif the black-box region interacts with a polygon in an ancestor cell or a\nsibling cell. Therefore, you can check for these types of interactions and\nreport errors where they occur.\nThis check is performed for every assign layer, except when\nexclude_from_keepout_check_in_drc_black_box = true  is specified\nin the assign operation. If the keepout_ambit  value is specified, you\ncan shrink the black-box region using this value before you check for\ninteractions with ancestor and sibling cells. The ambit value is still used\nfor all other purposes.\nThis option is turned on when\ndrc_black_box_options(keepout_layer_check=true).\n\u2022 clip_region. Specifies whether polygons that intersect the exclude region\nare kept in their entirety or clipped by the exclude region. The default is true.\n\u2022 keep_layers. Specifies a list of layers which are kept in their entirety for the\nspecified DRC black-box region cells and their subcells. These layers are not\naffected by the exclude region.\n\u2022 keep_layer_purposes. For OpenAccess layouts, specifies a list of layer\nand purpose names which are kept in their entirety for the specified DRC\nblack-box region cells and their subcells. These layers are not affected by the\nexclude region.\n\u2022 classify_errors. Optional. Specifies error classifications to be applied\nbased on polygon shapes.\nNote:\nTo classify errors for an OpenAccess input database, use layer\nmapping to map layer names and purpose names to layer number\nand datatype numbers.\n\u25e6 violation_comments. Required. Specifies a list of violation comments\nfor which this particular error classification is applied. String matching with\nmetacharacters is supported.\n\u25e6 classification. Required. Specifies the error classification to be\napplied to error shapes that interact with classification shapes.\nThe valid classifications for this option are: Ignore, Waive, Watch, and\nFixed.\n\u25e6 classification_comment. Optional. Specifies the comment to be used\nfor error classification. The default is that no comment is used.\n\u25e6 ambit. Optional. Specifies the amount by which the polygons on the\nregion layers specified by ldt_list  are shrunk (cell-level) to define\ndrc_black_box_options()\nthe region over which errors are classified. Notice that while the shrink\nis cell-level, the resulting layer is used to classify errors that interact\nhierarchically with this layer. This does not affect the exclude region\ndescribed earlier over which data is excluded. The values of top, bottom,\nleft, and right  are in relation to the black-box cell's own coordinate\nsystem irrespective of the orientation of that cells placements in the\ndesign. The default is 0.\nNote:\nYou cannot mix negative and positive values in the ambit\noption for classify_errors.\n\u25e6 relationship. Optional. Specifies the type of polygon interactions to\nconsider for classification. The default is INTERACT.\n- ENCLOSE. Specifies that the error shape must be fully enclosed by the\nclassification shape for classification to be applied.\n- INTERACT. Specifies that the interaction between the error shape and\nthe classification shape determines the classification to be applied. The\ninclude_touch  argument specifies the level of interaction that applies\nclassification in the case of outside touches.\n- NOT_ENCLOSE. Specifies that the violations which are not enclosed by\nthe classification layer polygons are suppressed.\n- NOT_INTERACT. Specifies that the violations which do not interact with\nthe classification layer polygons are suppressed.\n\u25e6 include_touch. Optional. Specifies the outside touches that are included\nin the interaction check when applying classification. The default is ALL.\n- NONE. Includes neither point touch or line touch.\n- EDGE. Includes edge touch.\n- ALL. Includes all touches (edge and point).\n\u2022 suppress_errors. Specifies error suppressions to be applied based on\npolygon shapes.\n\u25e6 violation_comments. Required. Specifies a list of violation comments\nfor which the error suppression is applied. String matching with\nmetacharacters is supported.\n\u25e6 ambit. Optional. Specifies the amount by which the polygons on the\nregion layers specified by ldt_list  are shrunk (cell-level) to define the\nregion over which errors are suppressed. Notice that while the shrink\nis cell-level, the resulting layer is used to suppress errors that interact\ndrc_black_box_options()\nhierarchically with this layer. This does not affect the exclude region\ndescribed earlier over which data is excluded. The values of top, bottom,\nleft, and right  are in relation to the black-box cell's own coordinate\nsystem irrespective of the orientation of that cells placements in the\ndesign. The default is 0.\nNote:\nYou cannot mix negative and positive values in the ambit\noption for suppress_errors.\n\u25e6 relationship. Optional. Specifies the type of polygon interactions to\nconsider for suppression. The default is INTERACT.\n- ENCLOSE. Specifies that the error shape must be fully enclosed by the\nsuppression region for suppression to be applied.\n- INTERACT. Specifies that the interaction between the error shape and\nthe suppression region determines the suppression to be applied. The\ninclude_touch  argument specifies the level of interaction that applies\nsuppression in the case of outside touches.\n- NOT_ENCLOSE. Specifies that the violations which are not enclosed by\nthe suppression region are suppressed.\n- NOT_INTERACT. Specifies that the violations which do not interact with\nthe suppression region are suppressed.\n\u25e6 include_touch. Optional. Specifies the outside touches that are included\nin the interaction check when applying suppression. The default is ALL.\n- NONE. Includes neither point touch or line touch.\n- EDGE. Includes edge touch.\n- ALL. Includes all touches (edge and point).\nNote:\nTo suppress errors for an OpenAccess input database, use a layer\nmapping to map layer names and purpose names to layer number\nand datatype numbers.", "keepout_layers_check": "Optional. When set to true, and_overlap  checking is performed. The default is\nfalse.\nIf cell \u201cB\u201d is a black-box region cell, then data in cell \u201cB\u201d and its descendants are\nremoved or cut to ensure that there is no interaction with the black-box region\nlayer (sized by the specified ambit). Typically, you assume that there is no data\ndrc_black_box_options()\noutside of the \u201cB\u201d hierarchy tree that interacts with, or comes too close to, the\nsized black-box region layer. This option performs an and_overlap  check to\nreport these interactions as errors.", "keepout_violation_comment": "Optional. Used within the violation comment and performs and_overlap\nchecking."}, "summary": "The drc_black_box_options()  function provides the capability to restrict what is read\nfrom the layout for certain cells designated as black-box cells or black-box region cells.", "function_name": "drc_black_box_options()"}
{"description": "The drc_features()  function provides access to geometric data on multiple layers\nbased on the interaction of the secondary layer with the primary layer. A remote function\nis used to specify arithmetic conditions in terms of geometric characteristics and to choose\npolygons for output.", "syntax": "drc_features(\nprimary_layer         = geometry_layer,\nsecondary_layers      = {\"string\" => geometry_layer, ...},\ndrc_function          = function,\noutput_from_layer      = polygon_layer,\ninclude_touch         = NONE | EDGE  | ALL,              //optional\nerror_shape           = EDGES  | REGION,                 //optional\nprocessing_mode       = CELL_LEVEL | HIERARCHICAL,      //optional\nname                  = \"layer_label\",                  //optional\nfiles                  = {ascii_file_handle, ...}        //optional\nclipping               = true | false,                   //optional\nconnect_sequence      = connect_database,               //optional\ncombine_errors        = NONE | OPPOSING,                //optional\nsplit_errors           = NONE | PRIMARY |\nSECONDARY | ALL,                 //optional\ncluster_mode           = INTERACT  | EXACT               // optional\n);", "returns": "polygon layer or error result", "arguments": {"primary_layer": "Required. Specifies the layer that is the basis for the collection of geometric\ncharacteristics.", "secondary_layers": "Required. Specifies the hash of string to geometry layers. The strings are\nused by the remote function to access composite characteristics of the given\nsecondary layer. The secondary layers can be of type error, polygon, or edge.", "drc_function": "Required. Specifies the remote function that is called one time for each\ngeometry in the primary layer. The function has access to the characteristics of\nthe secondary layers that interact with the given geometry. It is used to select\nthe output based on those characteristics. See\nDRC Features Utility Functions\ndrc_features()\nfor more information about the utility functions you can use to define a remote\nfunction.", "output_from_layer": "Required. Specifies the layer from which polygons are selected.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "files": "Optional. Specifies the ASCII files that the\ndf_fnote()  function can write\nto. The files are defined using the fopen()  function. The order of the files\ndrc_features()\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "clipping": "Optional. Specifies whether secondary layer polygons are clipped by the primary\npolygon layer. The default is false.\n\u2022 false. Specifies that, for a given primary layer polygon, the full secondary\nlayer polygons that interact with it are considered by the drc_function\nargument.\n\u2022 true. Clips secondary layer polygons by performing an AND  operation of\nsecondary layer polygons with primary layer polygons they interact with. The\nremote functions used in the drc_function  argument apply to the clipped\nsecondary layer polygons. The primary layer polygons are unchanged. When\noutput_from_layer  is the secondary layer, the drc_features()  function\noutputs the clipped secondary layer polygons.\nNote:\nWhen clipping = true, all layers must be polygon layers.\nOtherwise, the IC Validator tool returns an error.", "connect_sequence": "Optional. Specifies the connect database for these net-based utility\nfunctions: df_nets_in_sync(), df_get_*_net_double_property(),\ndf_get_edge_net_list_of_double_property(), and\ndf_get_edge_net_string_property().\nThis database must be a valid connect database, specifically derived from\nthe property_to_net()  function, when any net-based utilities appear in the\ndrc_function  argument.\nNote:\nClipping must be false when using net-based utilities.", "combine_errors": "Optional. Specifies how to combine unique errors that are considered duplicate\nor redundant. The default is NONE.\n\u2022 NONE. Specifies that errors are not combined.\n\u2022 OPPOSING. Specifies that errors which are opposing in direction are\ncombined.\nIn\nFigure 85, the external2_error()  function outputs two redundant errors:\none error projects from the red edge to the green polygon and the other error\nprojects from the green polygon to the red edge. For this case, the projection\ndrc_features()\ndirection of the two errors are opposing and the errors share violation edges\nfrom different layers. When this option is set, the drc_features()  function\ncombines the errors before cluster formation. This option changes the\ndrc_features()  function from a selector to a creator.\nexternal2_error(red, green, distance < 0.08, extension=NONE,\nlook_thru=COINCIDENT);\nFigure 85 Example of OPPOSING Option", "split_errors": "Optional. Specifies whether to split an error in the error layer by other layers.\nThe default is NONE. When split_errors  is not NONE, output_from_layer\nmust be primary_layer. When split_errors is ALL  or PRIMARY, the primary layer\nmust be an error layer.\n\u2022 NONE. Does not split any error.\n\u2022 PRIMARY. Splits the primary error layer by the secondary layers\n\u2022 SECONDARY. Splits the secondary error layers by the primary layer.\n\u2022 ALL. First, splits the primary error layer by the secondary layer, then splits the\nsecondary error layers by the primary layer.\nAn error is split by data vertex (corner of a polygon, endpoint of an edge, or error\nedge), or at the point where the error and other edge or error edges intersect.\nWhen an error consists of multiple error edges, where one error edge of an error\nis split, the other error edges are split based on the projection of the original split\npoint.\nIf the projection does not interact with the other error edge, choose the error\nedge point closest to the projection. For example,\ndrc_features(green, {\"err\" => red}, split_errors=SECONDARY)\nThe red edge-to-edge error is split into three edge-to-edge errors, as shown in\nFigure 86.\ndrc_features()\nFigure 86 Example of split_errors\nOnly edge-to-edge errors are split. If an edge-to-edge error is split by an\nerror layer, it is only be split by the edge-to-edge errors. Currently, only errors\nconsisting of orthogonal error edges are split. If the split errors are saved as\noutput, those errors are merged. If the df_report_*  or df_save_*_property\nutility functions are used, when multiple errors are merged into one error, they\narbitrarily choose a report or property from one of the errors for the merged\nresult.", "cluster_mode": "Optional. Specifies constraint on clustering. The default is INTERACT.\n\u2022 INTERACT. Includes all secondary data satisfying clustering condition like\ninclude_touch.\n\u2022 EXACT. Includes only secondary data that are an exact duplicate of the\nprimary shape. When cluster_mode = EXACT, all secondary_layers\nand output_from_layer  must be on the same type as primary_layer, and\nerror_shape  must be EDGES."}, "summary": "The drc_features()  function provides access to geometric data on multiple layers\nbased on the interaction of the secondary layer with the primary layer.", "function_name": "drc_features()"}
{"description": "The drc_features_edge()  function provides access to geometric data on multiple layers\nbased on the interaction of the secondary layer with the primary layer. A remote function is\nused to specify arithmetic conditions in terms of geometric characteristics and to choose\nedges for output.", "syntax": "drc_features_edge(\nprimary_layer     = geometry_layer,\nsecondary_layers  = {\"string\" => geometry_layer, ...},\ndrc_function      = function,\noutput_from_layer = geometry_layer,\ninclude_touch     = NONE | EDGE  | ALL,               //optional\nerror_shape       = EDGES  | REGION,                  //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,       //optional\nname              = \"layer_label\",           //optional\nfiles              = {ascii_file_handle, ...}, //optional\nconnect_sequence  = connect_database,        //optional\ncombine_errors    = NONE | OPPOSING                 //optional\nderivation        = NONE | EDGE                     //optional\ncluster_mode       = INTERACT  | EXACT               // optional\n);", "returns": "edge layer or error result", "arguments": {"primary_layer": "Required. Specifies the layer that is the basis for the collection of geometric\ncharacteristics.", "secondary_layers": "Required. Specifies the hash of string to geometry layers. The strings are\nused by the remote function to access composite characteristics of the given\nsecondary layer. The secondary layers can be of type error, polygon, or edge.", "drc_function": "Required. Specifies the remote function that is called one time for each\ngeometry in the primary layer. The function has access to the characteristics of\nthe secondary layers that interact with the given geometry. It is used to select\nthe output based on those characteristics. See\nDRC Features Utility Functions\ndrc_features_edge()\nfor more information about the utility functions you can use to define a remote\nfunction.", "output_from_layer": "A required geometry layer. Specifies the layer from which errors are selected or\nderived. If derivation is NONE, this must be an edge layer, otherwise this must be\na polygon layer.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\ndrc_features_edge()", "files": "Optional. Specifies the ASCII files that the df_fnote()  function can write\nto. The files are defined using the fopen()  function. The order of the files\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "connect_sequence": "Optional. Specifies the connect database for these net-based utility\nfunctions: df_nets_in_sync(), df_get_*_net_double_property(),\ndf_get_edge_net_list_of_double_property(), and\ndf_get_edge_net_string_property().\nThis database must be a valid connect database, specifically derived from\nthe property_to_net()  function, when any net-based utilities appear in the\ndrc_function  argument.\nNote:\nClipping must be false when using net-based utilities.", "combine_errors": "Optional. Specifies how to combine unique errors that are considered duplicate\nor redundant. The default is NONE.\n\u2022 NONE. Specifies that errors are not combined.\n\u2022 OPPOSING. Specifies that errors which are opposing in direction are\ncombined.\nSee\nFigure 88  for an example of the OPPOSING  option.", "derivation": "Optional. An optional enumerator that specifies what type derivation is required\nfor the output.\n\u2022 NONE. There is no derivation, the output_from_layer is used as is.\n\u2022 EDGE. Converts the polygons of the output_from_layer to individual edges.", "cluster_mode": "Optional. Specifies constraint on clustering. The default is INTERACT.\ndrc_features_edge()\n\u2022 INTERACT. Includes all secondary data satisfying clustering condition like\ninclude_touch.\n\u2022 EXACT. Includes only secondary data that are an exact duplicate of the\nprimary shape. When cluster_mode = EXACT, all secondary_layers\nand output_from_layer  must be of the same type as primary_layer, and\nerror_shape  must be EDGES."}, "summary": "The drc_features_edge()  function provides access to geometric data on multiple layers\nbased on the interaction of the secondary layer with the primary layer.", "function_name": "drc_features_edge()"}
{"description": "The drc_features_error()  function provides access to geometric data on multiple\nlayers based on the interaction of the secondary layer with the primary layer. A remote\nfunction is used to specify arithmetic conditions in terms of geometric characteristics and\nto choose errors for output.", "syntax": "drc_features_error(\nprimary_layer       = geometry_layer,\nsecondary_layers    = {\"string\" => geometry_layer, ...},\ndrc_function        = function,\noutput_from_layer   = data_layer,\ninclude_touch       = NONE | EDGE  | ALL,                    //optional\nerror_shape         = EDGES  | REGION,                       //optional\nprocessing_mode     = CELL_LEVEL | HIERARCHICAL,            //optional\nname                = \"layer_label\",                        //optional\nfiles                = {ascii_file_handle, ...},             //optional\ncorner_pruning      = NONE  | ORTHOGONAL,                    //optional\ncontributing_layers = {layer1 = polygon_layer,\nlayer2 = polygon_layer},             //optional\nconnect_sequence    = connect_database,                     //optional\ncombine_errors      = NONE | OPPOSING                       //optional\nderivation          = NONE  | EDGE_ERROR | EXTENT_ERROR     //optional\ncluster_mode         = INTERACT  | EXACT                     // optional\n);", "returns": "error layer or error result", "arguments": {"primary_layer": "Required. Specifies the layer that is the basis for the collection of geometric\ncharacteristics.", "secondary_layers": "Required. Specifies the hash of string to geometry layers. The strings are\nused by the remote function to access composite characteristics of the given\nsecondary layer. The secondary layers can be of type error, polygon, or edge.", "drc_function": "Required. Specifies the remote function that is called one time for each\ngeometry in the primary layer. The function has access to the characteristics of\nthe secondary layers that interact with the given geometry. It is used to select\ndrc_features_error()\nthe output based on those characteristics. See DRC Features Utility Functions\nfor more information about the utility functions you can use to define a remote\nfunction.", "output_from_layer": "A required geometry layer. Specifies the layer from which errors are selected or\nderived. If derivation is NONE/EDGE_ERROR, this must be an error layer, otherwise\nthis must be a polygon/edge/error layer.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\ndrc_features_error()", "files": "Optional. Specifies the ASCII files that the df_fnote()  function can write\nto. The files are defined using the fopen()  function. The order of the files\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "corner_pruning": "Optional. Controls whether the IC Validator tool prunes the primary error layer\nby removing one of the errors for each pair of corner-to-corner errors formed by\northogonal corners. The default is NONE.\n\u2022 NONE. The primary error layer is not pruned.\n\u2022 ORTHOGONAL. For each pair of corner-to-corner errors formed by orthogonal\ncorners, the corner error with the larger area is kept and the corner error with\nthe smaller area is pruned. All other errors stay the same.\nNote:\nWhen the ORTHOGONAL  option is specified, the secondary_layers\nargument must be empty.", "contributing_layers": "Optional. Identifies the secondary layers that contribute to the primary error\nlayer. Only those polygons that might cause a primary error are identified. This\nargument is valid only when the\n\u2022 primary layer is an error layer.\n\u2022 primary layer is derived from the enclose_error(), external2_error(),\ninternal2_error(), or external_corner2_error()  function.\n\u2022 two layers are in the secondary layer list.\n\u2022 two layers are both be specified or unspecified.\nThe contributing_layers  argument provides constraints on what should be in\nthe cluster, in addition to the constraints it provides to the include_touch  and\nerror_shape  arguments.\nWhen you identify a secondary layer as a layer1  layer, it is included in the\ncluster only if\n\u2022 It is coincident with the layer1  side of the error.\n\u2022 The direction of coincidence is consistent with the layer1  side of the error.\nWhen you identify a secondary layer as a layer2  layer, it is included in the\ncluster only if\ndrc_features_error()\n\u2022 It is coincident with the layer2  side of the error.\n\u2022 The direction of coincidence is consistent with the layer2  side of the error.", "connect_sequence": "Optional. Specifies the connect database for these net-based utility\nfunctions: df_nets_in_sync(), df_get_*_net_double_property(),\ndf_get_edge_net_list_of_double_property(), and\ndf_get_edge_net_string_property().\nThis database must be a valid connect database, specifically derived from\nthe property_to_net()  function, when any net-based utilities appear in the\ndrc_function  argument.\nNote:\nClipping must be false when using net-based utilities.", "combine_errors": "Optional. Specifies how to combine unique errors that are considered duplicate\nor redundant. The default is NONE.\n\u2022 NONE. Specifies that errors are not combined.\n\u2022 OPPOSING. Specifies that errors which are opposing in direction are\ncombined.\nIn\nFigure 88, the external2_error()  function outputs two redundant errors:\none error projects from the red edge to the green polygon and the other error\nprojects from the green polygon to the red edge. For this case, the projection\ndirection of the two errors are opposing and the errors share violation edges\nfrom different layers. When this option is set, the drc_features()  function\ncombines the errors before cluster formation. This option changes the\ndrc_features()  function from a selector to a creator.\ndrc_features_error()\nexternal2_error(red, green, distance < 0.08, extension=NONE,\nlook_thru=COINCIDENT);\nFigure 88 Example of OPPOSING Option", "derivation": "Optional. An enumerator that specifies what type of derivation is required for the\noutput. The default is NONE.\n\u2022 NONE. There is no derivation, the output_from_layer  is used as is.\n\u2022 EDGE_ERROR. Converts the errors of the output_from_layer  to edges\ndefining the violation edges of each error. The result is one edge per error.\n\u2022 EXTENT_ERROR. Converts the data of the output_from_layer  to edges\ndefining the bounding boxes of each individual object. The result is one edge\nper error. Errors that degenerate to a point are dropped.", "cluster_mode": "Optional. Specifies constraint on clustering. The default is INTERACT.\n\u2022 INTERACT. Includes all secondary data satisfying clustering condition like\ninclude_touch.\n\u2022 EXACT. Includes only secondary data that are an exact duplicate of the\nprimary shape. When cluster_mode = EXACT, all secondary_layers\nand output_from_layer  must be of the same type as primary_layer, and\nerror_shape  must be EDGES."}, "summary": "The drc_features_error()  function provides access to geometric data on multiple\nlayers based on the interaction of the secondary layer with the primary layer.", "function_name": "drc_features_error()"}
{"description": "The drc_features_unmerged()  function provides access to geometric data on multiple\nlayers based on the interaction of the secondary layer with the primary layer. A remote\nfunction is used to specify arithmetic conditions in terms of geometric characteristics and\nto choose edges for output. The result is an unmerged polygon layer.", "syntax": "drc_features_unmerged(\nprimary_layer    = geometry_layer,\nsecondary_layers  = {\"string\" => geometry_layer, ...},\ndrc_function    =function,\noutput_from_layer  = geometry_layer,\ninclude_touch    = NONE | EDGE  | ALL,            //optional\nerror_shape     =EDGES  | REGION,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,   //optional\nname         = \"layer_label\",        //optional\nfiles         =\u202f{ascii_file_handle, ...},    //optional\nclipping       = true | false,        //optional\nconnect_sequence  =connect_database, \u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202f//optional\ncombine_errors   =NONE\u202f|  OPPOSING,        //optional\nsplit_errors       = NONE\u202f|  PRIMARY | SECONDARY | ALL      //optional\nderivation         = EXTENT                       // optional\ncluster_mode       = INTERACT  | EXACT            // optional\n);", "returns": "unmerged polygon layer or error result", "arguments": {"primary_layer": "Required. Specifies the layer that is the basis for the collection of geometric\ncharacteristics.", "secondary_layers": "Required. Specifies the hash of string to geometry layers. The strings are\nused by the remote function to access composite characteristics of the given\nsecondary layer. The secondary layers can be of type error, polygon, or edge.", "drc_function": "Required. Specifies the remote function that is called one time for each\ngeometry in the primary layer. The function has access to the characteristics of\nthe secondary layers that interact with the given geometry. It is used to select\nthe output based on those characteristics. See\nDRC Features Utility Functions\ndrc_features_unmerged()\nfor more information about the utility functions you can use to define a remote\nfunction.", "output_from_layer": "A required geometry layer. Specifies the layer from which polygons are derived.\nThis must be an edge/polygon/error layer.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "files": "Optional. Specifies the ASCII files that the\ndf_fnote()  function can write\nto. The files are defined using the fopen()  function. The order of the files\ndrc_features_unmerged()\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "corner_pruning": "Optional. Controls whether the IC Validator tool prunes the primary error layer\nby removing one of the errors for each pair of corner-to-corner errors formed by\northogonal corners. The default is NONE.\n\u2022 NONE. The primary error layer is not pruned.\n\u2022 ORTHOGONAL. For each pair of corner-to-corner errors formed by orthogonal\ncorners, the corner error with the larger area is kept and the corner error with\nthe smaller area is pruned. All other errors stay the same.\nNote:\nWhen the ORTHOGONAL  option is specified, the secondary_layers\nargument must be empty.", "contributing_layers": "Optional. Identifies the secondary layers that contribute to the primary error\nlayer. Only those polygons that might cause a primary error are identified. This\nargument is valid only when the\n\u2022 primary layer is an error layer.\n\u2022 primary layer is derived from the enclose_error(), external2_error(),\ninternal2_error(), or external_corner2_error()  function.\n\u2022 two layers are in the secondary layer list.\n\u2022 two layers are both be specified or unspecified.\nThe contributing_layers  argument provides constraints on what should be in\nthe cluster, in addition to the constraints it provides to the include_touch  and\nerror_shape  arguments.\nWhen you identify a secondary layer as a layer1  layer, it is included in the\ncluster only if\n\u2022 It is coincident with the layer1  side of the error.\n\u2022 The direction of coincidence is consistent with the layer1  side of the error.\nWhen you identify a secondary layer as a layer2  layer, it is included in the\ncluster only if\n\u2022 It is coincident with the layer2  side of the error.\n\u2022 The direction of coincidence is consistent with the layer2  side of the error.\ndrc_features_unmerged()", "clipping": "Optional. Specifies whether secondary layer polygons are clipped by the primary\npolygon layer. The default is false.\n\u2022 false. Specifies that, for a given primary layer polygon, the full secondary\nlayer polygons that interact with it are considered by the drc_function\nargument.\n\u2022 true. Clips secondary layer polygons by performing an AND  operation of\nsecondary layer polygons with primary layer polygons they interact with. The\nremote functions used in the drc_function  argument apply to the clipped\nsecondary layer polygons. The primary layer polygons are unchanged. When\noutput_from_layer  is the secondary layer, the drc_features()  function\noutputs the clipped secondary layer polygons.\nNote:\nWhen clipping = true, all layers must be polygon layers.\nOtherwise, the IC Validator tool returns an error.", "connect_sequence": "Optional. Specifies the connect database for these net-based utility\nfunctions: df_nets_in_sync(), df_get_*_net_double_property(),\ndf_get_edge_net_list_of_double_property(), and\ndf_get_edge_net_string_property().\nThis database must be a valid connect database, specifically derived from\nthe property_to_net()  function, when any net-based utilities appear in the\ndrc_function  argument.\nNote:\nClipping must be false when using net-based utilities.", "combine_errors": "Optional. Specifies how to combine unique errors that are considered duplicate\nor redundant. The default is NONE.\n\u2022 NONE. Specifies that errors are not combined.\n\u2022 OPPOSING. Specifies that errors which are opposing in direction are\ncombined.\nIn\nFigure 89, the external2_error()  function outputs two redundant errors:\none error projects from the red edge to the green polygon and the other error\nprojects from the green polygon to the red edge. For this case, the projection\ndirection of the two errors are opposing and the errors share violation edges\nfrom different layers. When this option is set, the drc_features()  function\ndrc_features_unmerged()\ncombines the errors before cluster formation. This option changes the\ndrc_features()  function from a selector to a creator.\nexternal2_error(red, green, distance < 0.08, extension=NONE,\nlook_thru=COINCIDENT);\nFigure 89 Example of OPPOSING Option", "split_errors": "Optional. Specifies whether to split an error in the error layer by other layers.\nThe default is NONE. When split_errors  is not NONE, output_from_layer\nmust be primary_layer. When split_errors is ALL  or PRIMARY, the primary layer\nmust be an error layer.\n\u2022 NONE. Does not split any error.\n\u2022 PRIMARY. Splits the primary error layer by the secondary layers\n\u2022 SECONDARY. Splits the secondary error layers by the primary layer.\n\u2022 ALL. First, splits the primary error layer by the secondary layer, then splits the\nsecondary error layers by the primary layer.\nAn error is split by data vertex (corner of a polygon, endpoint of an edge, or error\nedge), or at the point where the error and other edge or error edges intersect.\nWhen an error consists of multiple error edges, where one error edge of an error\nis split, the other error edges are split based on the projection of the original split\npoint.\nIf the projection does not interact with the other error edge, choose the error\nedge point closest to the projection. For example,\ndrc_features(green, {\"err\" => red}, split_errors=SECONDARY)\nThe red edge-to-edge error is split into three edge-to-edge errors, as shown in\nFigure 90.\ndrc_features_unmerged()\nFigure 90 Example of split_errors\nOnly edge-to-edge errors are split. If an edge-to-edge error is split by an\nerror layer, it is only be split by the edge-to-edge errors. Currently, only errors\nconsisting of orthogonal error edges are split. If the split errors are saved as\noutput, those errors are merged. If the df_report_*  or df_save_*_property\nutility functions are used, when multiple errors are merged into one error, they\narbitrarily choose a report or property from one of the errors for the merged\nresult.", "derivation": "Optional. An enumerator that specifies what type of derivation is required for the\noutput. Currently only supports EXTENT.\n\u2022 EXTENT. Converts the data of the output_from_layer  to polygons defining\nthe bounding boxes of each individual object. The resultant polygons are\nnot merged. Degenerate bounding boxes are not returned. Specifically,\nhorizontal, and vertical edges are dropped.", "cluster_mode": "Optional. Specifies constraint on clustering. The default is INTERACT\n\u2022 INTERACT. Includes all secondary data satisfying clustering condition like\ninclude_touch.\n\u2022 EXACT. Includes only secondary data that are an exact duplicate of the\nprimary shape. When cluster_mode = EXACT, all secondary_layers\nand output_from_layer  must be of the same type as primary_layer, and\nerror_shape  must be EDGES."}, "summary": "The drc_features_unmerged()  function provides access to geometric data on multiple\nlayers based on the interaction of the secondary layer with the primary layer.", "function_name": "drc_features_marker()"}
{"description": "The drc_space1_edge()  function measures spacing between the edges of one layer\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is an edge layer.", "syntax": "drc_space1_edge(\nlayer1       = data_layer,\ndistance     = doubleconstraint,\nmeasurement  = EXTERNAL | INTERNAL | ENCLOSE | ALL, //optional\ndirection    = HORIZONTAL | VERTICAL | BOTH,         //optional\nlook_thru_count   = integerconstraint,\n//optional\nconnectivity      = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence  = connect_database,                //optional\nname         = \"layer_label\"                         //optional", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the input edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "measurement": "Optional. Specifies\n\u2022 EXTERNAL. Measures outside to outside distance.\n\u2022 INTERNAL. Measures inside to inside distance\n\u2022 ENCLOSE. Measures outside to inside distance.\n\u2022 ALL. Measures both sides of all angles.\ndrc_space1_edge()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the x-axis.\n\u2022 VERTICAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the y-axis.\n\u2022 BOTH. Specifies that the direction of a projecting edge\u2019s check zone is parallel\nto the x- and y-axis.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The drc_space1_edge()  function measures spacing between the edges of one layer\nbased on the specified distance.", "function_name": "drc_space1_edge()"}
{"description": "The drc_space1_error()  function measures spacing between the edges of one layer\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is unmerged errors.", "syntax": "drc_space1_error(\nlayer1       = data_layer,\ndistance     = doubleconstraint,\nmeasurement  = EXTERNAL | INTERNAL | ENCLOSE | ALL, //optional\ndirection    = HORIZONTAL | VERTICAL | BOTH,         //optional\nlook_thru_count   = integerconstraint,\n//optional\nconnectivity      = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence  = connect_database,                //optional\nname         = \"layer_label\"                         //optional", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the input edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "measurement": "Optional. Specifies\n\u2022 EXTERNAL. Measures outside to outside distance.\n\u2022 INTERNAL. Measures inside to inside distance\n\u2022 ENCLOSE. Measures outside to inside distance.\n\u2022 ALL. Measures both sides of all angles.\ndrc_space1_error()", "direction": "Optional. Specifies the direction of the spacing check. The\nspecification refers to the perpendicular projection being measured.\nThe default is ALL.\n\u2022 HORIZONTAL. Specifies that the direction of a projecting edge\u2019s\ncheck zone is parallel to the x-axis.\n\u2022 VERTICAL. Specifies that the direction of a projecting edge\u2019s check\nzone is parallel to the y-axis.\n\u2022 BOTH. Specifies that the direction of a projecting edge\u2019s check zone\nis parallel to the x- and y-axis.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ndrc_space1_error()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The drc_space1_error()  function measures spacing between the edges of one layer\nbased on the specified distance.", "function_name": "drc_space1_error()"}
{"description": "The drc_space2_edge()  function measures spacing between the edges of two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is an edge layer.", "syntax": "drc_space2_edge(\nlayer1       = data_layer,\nlayer2       = data_layer,\ndistance     = doubleconstraint,\nmeasurement  = EXTERNAL | INTERNAL | ENCLOSE | ALL,\ndirection    = HORIZONTAL | VERTICAL | BOTH,             //optional\noutput_layer          = LAYER1  | LAYER2,                 //optional\nedge_containment      = BY_MEASUREMENT  | ALL,            //optional\nlook_thru_count       = integerconstraint,               //optional\nlook_thru_from_layer  = LAYER1 | LAYER2\n| ALL,           //optional\nconnectivity          = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence      = connect_database,                //optional\nname        = \"layer_label\"                              //optional", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the first input edge or polygon layer.", "layer2": "Required. Specifies the second input edge or polygon layer. Notice that layer\norder is only meaningful in the context of measurement=ENCLOSE, which\nmeasures the outside of layer1  to the inside of layer2.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "measurement": "Required. Specifies which distances to measure.\ndrc_space2_edge()\n\u2022 EXTERNAL. Measures outside to outside distance.\n\u2022 INTERNAL. Measures inside to inside distance.\n\u2022 ENCLOSE. Measures the outside of layer1  to the inside of layer2.\n\u2022 ALL. Measures both sides of all edges.", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the x-axis.\n\u2022 VERTICAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the y-axis.\n\u2022 BOTH. Specifies that the direction of a projecting edge\u2019s check zone is parallel\nto the x- and y-axis.", "output_layer": "Optional.\n\u2022 LAYER1. Specifies .\n\u2022 LAYER2. Specifies .", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\n\u2022 BY_MEASUREMENT. Specifies that edge containment is set in the context of a\ngiven measurement:.\n\u25e6 EXTERNAL. See edge_containment=OUTSIDE  of\nexternal2().\n\u25e6 ENCLOSE. See edge_containment=INSIDE_TO_OUTSIDE  of enclose().\n\u25e6 INTERNAL. See edge_containment=INSIDE  of internal1().\n\u25e6 ALL. Specifies that edges are not filtered.\n\u2022 ALL. Specifies that edges are not filtered.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\ndrc_space2_edge()\nincluded in the count. The value must be nonnegative. See Constraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The drc_space2_edge()  function measures spacing between the edges of two layers\nbased on the specified distance.", "function_name": "drc_space2_edge()"}
{"description": "The drc_space2_error()  function measures spacing between the edges of two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is unmerged errors.", "syntax": "drc_space2_error(\nlayer1       = data_layer,\nlayer2       = data_layer,\ndistance     = doubleconstraint,\nmeasurement  = EXTERNAL | INTERNAL | ENCLOSE | ALL,\ndirection    = HORIZONTAL | VERTICAL | BOTH,            //optional\nedge_containment      = BY_MEASUREMENT  | ALL,           //optional\nlook_thru_count       = integerconstraint,              //optional\nlook_thru_from_layer  = LAYER1 | LAYER2 | ALL,          //optional\nconnectivity          = SAME_NET | DIFFERENT_NET | ALL, //optional\nconnect_sequence      = connect_database,               //optional\nname         = \"layer_label\"                            //optional", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the first input edge or polygon layer.", "layer2": "Required. Specifies the second input edge or polygon layer. Notice that layer\norder is only meaningful in the context of measurement=ENCLOSE, which\nmeasures the outside of layer1  to the inside of layer2.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "measurement": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\ndrc_space2_error()\n\u2022 EXTERNAL. Measures outside to outside distance.\n\u2022 INTERNAL. Measures inside to inside distance.\n\u2022 ENCLOSE. Measures the outside of layer1  to the inside of layer2.\n\u2022 ALL. Measures both sides of all edges.", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the x-axis.\n\u2022 VERTICAL. Specifies that the direction of a projecting edge\u2019s check zone is\nparallel to the y-axis.\n\u2022 BOTH. Specifies that the direction of a projecting edge\u2019s check zone is parallel\nto the x- and y-axis.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\n\u2022 BY_MEASUREMENT. Specifies that edge containment is set in the context of a\ngiven measurement:\n\u25e6 EXTERNAL. See edge_containment=OUTSIDE  of\nexternal2().\n\u25e6 ENCLOSE. See edge_containment=INSIDE_TO_OUTSIDE  of enclose().\n\u25e6 INTERNAL. See edge_containment=INSIDE  of internal1().\n\u25e6 ALL. Specifies that edges are not filtered.\n\u2022 ALL. Specifies that edges are not filtered.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.\ndrc_space2_error()", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The drc_space2_error()  function measures spacing between the edges of two layers\nbased on the specified distance.", "function_name": "drc_space2_error()"}
{"description": "The dv_error_voltage_source()  function finds the voltage sources of the nets that\ncause errors. This function outputs the input errors attached with voltage information to\ncheck if the voltages are assigned correctly.", "syntax": "dv_error_voltage_source(\ndv_error                  = error_layer,\nproperties                = {\"string\", ...},\nconnect_sequence          = connect_database,\nlayer1                     = data_layer,\nlayer2                     = data_layer,                   //optional\nlayer2_voltage_from       = CONNECT_DATABASE  | USER_DEFINED |\nLAYER,                        //optional\nmax_coordinates_per_layer = integer,                      //optional\nlayer1_voltage_from        = CONNECT_DATABASE  | USER_DEFINED |\nLAYER                         //optional\n);", "returns": "error result", "arguments": {"dv_error": "Required. Specifies the errors to investigate. Voltage source information is\nattached for the nets that cause these errors.", "properties": "Required. Specifies the properties from which this function finds its voltage\nsources. The properties represent the voltage, and the number of properties\nmust be greater than or equal to 1 and less than or equal to 2.", "connect_sequence": "Required. Specifies the connect database that contains the layers which cause\nthe errors. This database must come directly from the property_to_net()\nfunction.", "layer1": "Required. Specifies the connected layer that causes the errors. The layer1\nargument must be the original layer that is passed to the property_to_net()\nfunction.\ndv_error_voltage_source()", "layer2": "Optional. Specifies the connected layer from which the layer2  layer is\nused for two-layer spacing errors. The layer2  argument can be connected\nor unconnected depending on the layer2_voltage_from  argument.\nIf it is connected, it also must be the original layer that is passed to the\nproperty_to_net()  function. For more information, see the voltage_filter\nargument of the\nexternal1_error()  and external2_error()  functions.", "layer2_voltage_from": "Optional. Specifies how layer2  data obtains voltage information. The default is\nCONNECT_DATABASE.\n\u2022 CONNECT_DATABASE. Specifies that layer2  data obtains voltage from its net.\nEach net has associated voltage information in the connect database. When\nyou use this option, layer2  must be in the connect database.\n\u2022 USER_DEFINED. Specifies that layer2  data obtains voltage from user-defined\nvalues. When you use this option, layer2  does not need to be in the connect\ndatabase.\n\u2022 LAYER. Specifies that layer2  data obtains voltage from properties stored on\nitself. The drc_features()  and annotate_by_property()  functions can\nstore properties on data. When you use this option, layer2  does not need to\nbe in the connect database.", "max_coordinates_per_layer": "Optional. Controls the maximum number of voltage source coordinates reported\nfor the layer under each (net, property) pair. It must be larger than 0.", "layer1_voltage_from": "Specifies how layer1  data obtains voltage information. The default is\nCONNECT_DATABASE.\n\u2022 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from its net.\nEach net has associated voltage information in the connect database. When\nyou use this option, layer1  must be in the connect database.\n\u2022 USER_DEFINED. Specifies that layer1  data obtains voltage from user-defined\nvalues. When you use this option, layer1  does not need to be in the connect\ndatabase.\n\u2022 LAYER. Specifies that layer1  data obtains voltage from properties stored on\nitself. The drc_features()  and annotate_by_property()  functions can\nstore properties on data. When you use this option, layer1  is not required in\nthe connect database.\ndv_error_voltage_source()"}, "summary": "The dv_error_voltage_source()  function finds the voltage sources of the nets that\ncause errors.", "function_name": "dv_error_voltage_source()"}
{"description": "The dv_interacting1()  function selects primary_layer  polygons that interact with\nexactly 2 nets on layer1, and the nets match the voltage_filter  constraint.", "syntax": "dv_interacting1(\nprimary_layer    = polygon_layer,\nlayer1           = geometry_layer,\nvoltage_filter   = {delta_voltage = doubleconstraint,\ndelta_method  = HIGH_LOW_MAX  |\nSAME_TYPE_MAX |\nSYNC_NET,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\",\noverride_by_net_pair_property = true |\nfalse,\nerror_limit                   = integer,\noverride_by_net_pair_property_criteria =\nALWAYS  |\nLESS_THAN_EQUAL},\nlayer1_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer1_high_voltage        = double,\nlayer1_low_voltage         = double,\n},                            //optional\nconnect_sequence  = connect_database,                     // optional\ninclude_touch     = NONE | EDGE,                          // optional\nname              = \"layer_label\"                         // optional\n);", "returns": "polygon layer or error result", "arguments": {"primary_layer": "Required. Specifies the polygon layer from which polygons are selected.", "layer1": "Required. The layer1  polygons or errors interacting with the primary_layer\npolygon are used to check the voltage_filter  constraint. If layer1  is\nerror_layer, the error must contain net id property since connect_database\ndoes not contain error.\ndv_interacting1()", "voltage_filter": "Required. The primary polygon is selected if its interacting layer1  data meets\nthe voltage constraints.\n\u2022 delta_voltage. Specifies with a nonnegative value delta voltage to satisfy\nthe constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage. The default is\nHIGH_LOW_MAX.\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1 -VL2, VH2\n-VL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1\n-VH2),abs(VL1 -VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW_MAX.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nslow voltage.\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets is overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information. The default is false.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property (the default).\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated delta voltage when there is\na net-pair property and its value is smaller than or equal to the calculated\ndelta voltage.\ndv_interacting1()\n\u2022 layer1_voltage_from. Specifies how layer1  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When you use this option, layer1  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer1  data obtains voltage from user-\ndefined values. When you use this option, layer1  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer1  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When you use this option, layer1  is not\nrequired in the connect database.\n\u2022 layer1_high_voltage. Specifies the high voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.\n\u2022 layer1_low_voltage. Specifies the low voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.", "connect_sequence": "Optional. Specifies the connect database for voltage_filter  check.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nwith the primary layer. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The dv_interacting1()  function selects primary_layer  polygons that interact with\nexactly 2 nets on layer1, and the nets match the voltage_filter  constraint.", "function_name": "dv_interacting1()"}
{"description": "The dv_interacting2()  function selects primary_layer  polygons that interact with\nexactly 1 net on the layer1  and exactly 1 net on layer2, and the nets match the\nvoltage_filter  constraint.", "syntax": "dv_interacting2(\nprimary_layer    = polygon_layer,\nlayer1           = geometry_layer,\nlayer2           = geometry_layer,\nvoltage_filter   = {delta_voltage = doubleconstraint,\ndelta_method  = HIGH_LOW_MAX  |\nSAME_TYPE_MAX | SYNC_NET |\nHIGH_LOW,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\",\nlayer2_voltage_from = CONNECT_DATABASE |\nUSER_DEFINED,\nlayer2_high_voltage = double,\nlayer2_low_voltage  = double,\noverride_by_net_pair_property = true |\nfalse,\nerror_limit         = integer,\noverride_by_net_pair_property_criteria =\nALWAYS  |\nLESS_THAN_EQUAL},\nconnect_sequence  = connect_database,                     // optional\ninclude_touch     = NONE | EDGE,                          // optional\nname              = \"layer_label\"                         // optional\n);", "returns": "polygon layer or error result", "arguments": {"primary_layer": "Required. Specifies the polygon layer from which polygons are selected.", "layer1": "Required. The layer1  polygons or errors interacting with the primary_layer\npolygon are used to check the voltage_filter  constraint. If layer1  is\nerror_layer, the error must contain net id property since connect_database\ndoes not contain error.\ndv_interacting2()", "layer2": "Required. The layer2  polygons/errors interacting with the primary_layer\npolygon are used to check voltage_filter  constraint. If layer2  is\nerror_layer, the error should contain net id property since connect_database\ndoes not contain error.", "voltage_filter": "Required. The primary polygon is selected if its interacting layer1  data meets\nthe voltage constraints.\n\u2022 delta_voltage. Specifies with a nonnegative value delta voltage to satisfy\nthe constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage. The default is\nHIGH_LOW_MAX.\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1 -VL2, VH2\n-VL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1\n-VH2),abs(VL1 -VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW_MAX.\n\u25e6 HIGH_LOW. The option is not supported. It specifies the voltage of VH1\n-VL2, where 1 means layer1  and 2 means layer2.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nslow voltage.\n\u2022 layer2_voltage_from. Specifies how layer2  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer2  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When this option is used, layer2  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. The option is not supported.\n\u2022 layer2_high_voltage. This option is not supported.\n\u2022 layer2_low_voltage. This option is not supported.\ndv_interacting2()\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets is overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information. The default is false.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property (the default).\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated delta voltage when there is\na net-pair property and its value is smaller than or equal to the calculated\ndelta voltage.", "connect_sequence": "Optional. Specifies the connect database for voltage_filter  check.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nwith the primary layer. The default is EDGE.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The dv_interacting2()  function selects primary_layer  polygons that interact with\nexactly 1 net on the layer1  and exactly 1 net on layer2, and the nets match the\nvoltage_filter  constraint.", "function_name": "dv_interacting2()"}
{"description": "The dv_polygon_voltage_source()  function attaches the net voltage information\nand layer name of the voltage source on each polygon and outputs it to the\nblock.LAYOUT.ERRORS. file. The coordinate of voltage source polygons corresponding to\neach output shape is also saved in the error database (PYDB).", "syntax": "dv_polygon_voltage_source(\ndv_polygon                = polygon_layer,\nproperties                = {\"string\", ...},\nconnect_sequence          = connect_database,\nlayer1                    = data_layer,\nlayer2                    = data_layer,                   //optional\nlayer2_voltage_from       = CONNECT_DATABASE  | USER_DEFINED |\nLAYER,                        //optional\nmax_coordinates_per_layer  = integer,                      //optional\nlayer1_voltage_from        = CONNECT_DATABASE  | USER_DEFINED |\nLAYER                         //optional\n);", "returns": "error result", "arguments": {"dv_polygon": "Required. Specifies the output of the\ndv_interacting1()  or\ndv_interacting2()  functions.", "properties": "Required. Specifies the properties from which this function finds its voltage\nsources. The properties represent the voltage, and the number of properties\nmust be greater than or equal to 1 and less than or equal to 2.", "connect_sequence": "Required. Specifies the connect database that contains the layers which cause\nthe errors. This database must come directly from the\nproperty_to_net()\nfunction.", "layer1": "Required. Specifies the connected layer that causes the errors. The layer1\nargument must be the original layer that is passed to the property_to_net()\nfunction.\ndv_polygon_voltage_source()", "layer2": "Optional. Specifies the connected layer from which the layer2  layer is\nused for two-layer spacing errors. The layer2  argument can be connected\nor unconnected depending on the layer2_voltage_from  argument.\nIf it is connected, it also must be the original layer that is passed to the\nproperty_to_net()  function. For more information, see the voltage_filter\nargument of the\nexternal1_error()  and external2_error()  functions.", "layer2_voltage_from": "Optional. Specifies how layer2  data obtains voltage information. The default is\nCONNECT_DATABASE.\n\u2022 CONNECT_DATABASE. Specifies that layer2  data obtains voltage from its net.\nEach net has associated voltage information in the connect database. When\nyou use this option, layer2  must be in the connect database.\n\u2022 USER_DEFINED. Specifies that layer2  data obtains voltage from user-defined\nvalues. When you use this option, layer2  does not need to be in the connect\ndatabase.\n\u2022 LAYER. Specifies that layer2  data obtains voltage from properties stored on\nitself. The\ndrc_features()  and annotate_by_property()  functions can\nstore properties on data. When you use this option, layer2  does not need to\nbe in the connect database.", "max_coordinates_per_layer": "Optional. Controls the maximum number of voltage source coordinates reported\nfor the layer under each (net, property) pair. It must be larger than 0.", "layer1_voltage_from": "Specifies how layer1  data obtains voltage information. The default is\nCONNECT_DATABASE.\n\u2022 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from its net.\nEach net has associated voltage information in the connect database. When\nyou use this option, layer1  must be in the connect database.\n\u2022 USER_DEFINED. Specifies that layer1  data obtains voltage from user-defined\nvalues. When you use this option, layer1  does not need to be in the connect\ndatabase.\n\u2022 LAYER. Specifies that layer1  data obtains voltage from properties stored on\nitself. The\ndrc_features()  and annotate_by_property()  functions can\nstore properties on data. When you use this option, layer1  is not required in\nthe connect database.\ndv_polygon_voltage_source()"}, "summary": "The dv_polygon_voltage_source()  function attaches the net voltage information\nand layer name of the voltage source on each polygon and outputs it to the\nblock.", "function_name": "dv_polygon_voltage_source()"}
{"description": "The dv_trace_error_nets()  function traces a net from the delta voltage error to\nthe voltage sources, which assign the net voltages. This function can be called only\none time in the runset. When you specify this function in the runset, IC Validator\nautomatically collects layers specified in the\ndv_error_voltage_source()  and\ndv_polygon_voltage_source()  functions with the same connect_sequence, and traces\nthe nets from the error site to the voltage source.", "syntax": "dv_trace_error_nets(\nconnect_sequence      = connect_database\n);", "returns": "error result", "arguments": {"connect_sequence": "Required. Specifies the connect database that contains the layers to form the\nerrors. This database must come directly from the\nproperty_to_net()  function."}, "summary": "The dv_trace_error_nets()  function traces a net from the delta voltage error to\nthe voltage sources, which assign the net voltages.", "function_name": "dv_trace_error_nets()"}
{"description": "The edge_extents()  function creates rectangles from the extents of the layer1  edges.\nThe rectangles are merged in the result.\nNote:\nThe extents polygon is generated using 45-degree edges rather than\northogonal edges if the orthogonal extents would have 0 area.", "syntax": "edge_extents(\nlayer1          = edge_layer,\ncorners          = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "corners": "Optional. Specifies how corners are processed. The default is IGNORE.\nNote:\nA corner is a point where the start of exactly one edge is coincident\nwith the end of exactly one edge, and the edges are not collinear.\n\u2022 CONNECT. Connects the edges at corners and uses their total extents box.\n\u2022 IGNORE. Ignores corners. Each edge is processed individually.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nedge_extents()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edge_extents()  function creates rectangles from the extents of the layer1  edges.", "function_name": "edge_extents()"}
{"description": "The edge_features_edge()  function creates an edge layer from user-defined geometries\nbased on the characteristics of the input layer edges. Edges are defined as a pair of\nxy coordinates. The two points are ordered with the active area on the right. The created\nedges are merged; redundant data points are removed.", "syntax": "edge_features_edge(\nlayer1          = edge_layer,\nedge_function    = function,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "edge_function": "Required. Specifies the remote function for edge processing and output. This\nfunction is called one time for each individual layer1  edge. See\nEdge Features\nEdge Utility Functions  for more information about the utility functions you can\nuse to define a function.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes edges only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes edges within the context of the lowest cell that\ncontains the complete hierarchical edge.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nedge_features_edge()"}, "summary": "The edge_features_edge()  function creates an edge layer from user-defined geometries\nbased on the characteristics of the input layer edges.", "function_name": "edge_features_edge()"}
{"description": "The edge_grow()  function creates polygons from the input layer that are oversized in\nthe specified directions by the specified distances. If the north, south, east, and west\narguments are all 0 (zero) then the output is an empty layer.\nEach edge is classified according to the outside direction it faces. Edges can have one or\ntwo direction components. A horizontal edge facing south grows only if the south value is\ngreater than zero. A diagonal edge facing south east grows if either the east value or the\nsouth value or both are greater than zero. All values must be greater than or equal to zero.", "syntax": "edge_grow(\nlayer1           = data_layer,\nnorth            = double,                         //optional\nsouth            = double,                         //optional\neast             = double,                         //optional\nwest             = double,                         //optional\ncorner_extension = INTERSECTION | NONE,            //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,      //optional\nname             = \"layer_label\"                   //optional\n);", "returns": "data layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "north": "Optional. Specifies the oversize distance in the northern direction. The default is\n0.", "south": "Optional. Specifies the oversize distance in the southern direction. The default is\n0.", "east": "Optional. Specifies the oversize distance in the eastern direction. The default is\n0.\nedge_grow()", "west": "Optional. Specifies the oversize distance in the western direction. The default is\n0.", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The default is NONE.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 NONE. Does not extend corners.\nNote:\nFor edge layers, a corner is a point where the start of exactly one\nedge is coincident with the end of exactly one edge, and the edges\nare not collinear.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edge_grow()  function creates polygons from the input layer that are oversized in\nthe specified directions by the specified distances.", "function_name": "edge_grow()"}
{"description": "The edge_shrink()  function creates polygons from the input layer that are undersized\nin the specified directions by the specified distances. If the north, south, east, and west\narguments are all 0 (zero) then the output is an empty layer.\nSee the\nedge_grow()  function for information about how edges are classified.", "syntax": "edge_shrink(\nlayer1           = data_layer,\nnorth            = double,                          //optional\nsouth            = double,                          //optional\neast             = double,                          //optional\nwest             = double,                          //optional\ncorner_extension = INTERSECTION | NONE,             //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,       //optional\nname             = \"layer_label\"                    //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the data layer.", "north": "Optional. Specifies the undersize distance in the northern direction. The default\nis 0.", "south": "Optional. Specifies the undersize distance in the southern direction. The default\nis 0.", "east": "Optional. Specifies the undersize distance in the eastern direction. The default is\n0.", "west": "Optional. Specifies the undersize distance in the western direction. The default\nis 0.\nedge_shrink()", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The default is NONE.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 NONE. Does not extend corners.\nNote:\nFor edge layers, a corner is a point where the start of exactly one\nedge is coincident with the end of exactly one edge, and the edges\nare not collinear.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edge_shrink()  function creates polygons from the input layer that are undersized\nin the specified directions by the specified distances.", "function_name": "edge_shrink()"}
{"description": "The edge_size()  function creates rectangles from edges by expanding the edges inward\nand outward. If there is neither inward or outward expansion (that is, both values are 0),\nthe output layer is empty.", "syntax": "edge_size(\nlayer1            = data_layer,\ninside            = double,                                 //optional\noutside           = double,                                 //optional\ncorner_extension  = INTERSECTION | NONE,                    //optional\nclip_acute        = BISECTOR | ORTHOGONAL | OCTAGONAL | NONE,\n//optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,              //optional\ninside_by_factor   = double,                                 //optional\noutside_by_factor  = double,                                 //optional\nname              = \"layer_label\"                           //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "inside": "Optional. Specifies the absolute distance that the edge is expanded toward the\ninside of the edge. The distance must be a nonnegative value, and a value of 0\nspecifies no expansion. The default is 0.\nNote:\nFor lines (an edge that has no direction), expansion is always the\nsame on both sides. The outward expansion value is used and the\ninward expansion value is ignored. The output is empty if the outward\nexpansion value is 0.", "outside": "Optional. Specifies the absolute distance that the edge is expanded toward the\noutside of the edge. The distance must be a nonnegative value, and a value of 0\nspecifies no expansion. The default is 0.\nedge_size()", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The default is NONE.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 NONE. Does not extend corners.\nNote:\nFor edge layers, a corner is a point where the start of exactly one\nedge is coincident with the end of exactly one edge, and the edges\nare not collinear.", "clip_acute": "Optional. When the corner_extension  argument is INTERSECTION, this\nargument specifies the type of clipping that occurs when an acute interior angle\nis oversized, or an acute exterior angle is undersized. The default is NONE.\n\u2022 BISECTOR. Clips acute angles with an edge perpendicular to the angle\nbisector at (sqrt(2) x distance) from the original corner.\n\u2022 ORTHOGONAL. When one edge is orthogonal, clips the angle perpendicular to\nthat edge at the specified distance from the original corner. Otherwise, clips\nthe angle with an edge perpendicular to the angle bisector at the specified\ndistance away from the original corner.\n\u2022 OCTAGONAL. Clips acute angles with two edges at the specified distance from\nthe original corner, perpendicular to each of the edges forming the corner.\n\u2022 NONE. Does not clip acute angles.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "inside_by_factor": "Optional. Specifies the factor of the edge length by which an edge is expanded\ntoward the inside. The expansion value is calculated for each edge. The\ninside_by_factor  value must be positive. The default is 0.0; that is, no\nexpansion.\nedge_size()\nNote:\nBoth inside_by_factor  and inside  arguments cannot be nonzero\nvalues.\nWhen the value of inside_by_factor  argument is nonzero, the\ncorner_extension  argument must be NONE.\nThe minimum expansion value is one working resolution\nunit. See the working_resolution_factor  argument of the\nresolution_options()  function for more information.", "outside_by_factor": "Optional. Specifies the factor of the edge length by which an edge is expanded\ntoward the outside. The expansion value is calculated for each edge. The\noutside_by_factor  value must be positive. The default is 0.0; that is, no\nexpansion.\nNote:\nBoth the outside_by_factor  and outside  arguments cannot be\nnonzero values.\nWhen the value of the outside_by_factor  argument is nonzero, the\ncorner_extension  argument must be NONE.\nThe minimum expansion value is one working resolution\nunit. See the working_resolution_factor  argument of the\nresolution_options()  function for more information.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edge_size()  function creates rectangles from edges by expanding the edges inward\nand outward.", "function_name": "edge_size()"}
{"description": "The edge_size_by_property()  function creates rectangles from edges by expanding\nedges inward and outward, extending edges, and shifting edges. Edges are processed\none-by-one with different values. The operations of this function are edge-based; therefore\npolygons and violations are converted to edges before manipulations.\nIn the edge_size_by_property()  function,\n\u2022 All input, including paths and polygons, is converted to a group of edges, and then,\neach edge is processed separately.\n\u2022 The operations are edge-based; therefore polygons and violations are converted to\nedges before manipulations.\n\u2022 The inside_property  and inside_value  arguments cannot be used together.\n\u2022 The outside_property  and outside_value  arguments cannot be used together.\n\u2022 The extend_property  and extend_value  arguments cannot be used together.\n\u2022 The shift_property  and shift_value  arguments cannot be used together.\n\u2022 If there is no inward or outward edge expansion, the output is empty. Extension and\nshift cannot be used standalone, without edge expansions.\n\u2022 An edge can be sized only in one direction if a shift option is used. Either an inside or\nan outside option must be specified, but not both at the same time.\n\u2022 Shift values are not applicable to lines.\n\u2022 For lines (an edge that has no direction), expansion is always the same on both sides.\nThe outward expansion value is used and the inward expansion value is ignored. There\nis no edge expansion if the outward expansion value is 0.\n\u2022 Any edge with no valid expansion value is dropped.\n\u2022 If the precision of a value is larger than the precision of the internal resolution, then the\ndistance is rounded.\n\u2022 Edges with a length of 0 (that is, a point) are ignored.", "syntax": "edge_size_by_property(\nlayer1            = geometry_layer,\ninside_property   = \"string\",                               //optional\noutside_property  = \"string\",                               //optional\nextend_property   = \"string\",                               //optional\nedge_size_by_property()\nshift_property    = \"string\",                               //optional\ninside_value      = double,                                 //optional\noutside_value     = double,                                 //optional\nextend_value      = double,                                 //optional\nshift_value       = double,                                 //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,              //optional\nname              = \"layer_label\"                           //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the layer, which can be an error, edge, or polygon layer. The\nproperties of the input data is attached from preceding functions. If data of this\nlayer is not an edge, the data is converted into edges.", "inside_property": "Optional. Specifies a property with a distance that the edge is expanded toward\nthe inside of the edge. The distance must be nonnegative, and a value of 0 or\nnegative specifies no expansion. If input data does not have this property, then\nthe distance is 0.0.", "outside_property": "Optional. Specifies a property with a distance that the edge is expanded toward\nthe outside of the edge. The distance must be nonnegative, and a value of 0 or\nnegative specifies no expansion. If input data does not have this property, then\nthe distance is 0.0.", "extend_property": "Optional. Specifies a property with a distance that the edge is extended in both\nedge end directions. The distance can be a positive or negative value, and a\nvalue of 0 specifies no extension. A positive value means extend the edge in\nboth end directions. A negative value means to shrink the edge in both end\ndirections. If input data does not have this property, then the distance is 0.0.", "shift_property": "Optional. Specifies a property with a distance that the edge is shifted in the\ndirection of edge sizing. The value of 0 specifies no shift. The distance must be\nnonnegative, and a value of 0 or negative specifies no shift. If input data does\nnot have this property, then the distance is 0.0\nedge_size_by_property()", "inside_value": "Optional. Specifies a constant distance that the edge is expanded toward the\ninside of the edge. The distance must be nonnegative, and a value of 0 or\nnegative specifies no expansion. The default is 0.0.", "outside_value": "Optional. Specifies a constant distance that the edge is expanded toward the\noutside of the edge. The distance must be nonnegative, and a value of 0 or\nnegative specifies no expansion. The default is 0.0.", "extend_value": "Optional. Specifies a constant distance that the edge is extended in both edge\nend directions. The distance can be a positive or negative value, and a value\nof 0 specifies no extension. A positive value means extend in both edge end\ndirections. A negative value means shrink in both edge end directions. The\ndefault is 0.0.", "shift_value": "Optional. Specifies a constant distance that the edge is shifted in the direction of\nedge sizing. A value of 0 specifies no shift. The distance must be nonnegative,\nand a value of 0 or negative specifies no shift. The default is 0.0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edge_size_by_property()  function creates rectangles from edges by expanding\nedges inward and outward, extending edges, and shifting edges.", "function_name": "edge_size_by_property()"}
{"description": "The edges()  function creates edges in the top cell using specified coordinates. The\nfunction can generate multiple edges. Intersecting edges are merged.", "syntax": "edges(\ncoordinates = {{{x = double, y = double}, ...}, ...},\nname        = \"layer_label\"                            //optional\n);", "returns": "edge layer or error result", "arguments": {"coordinates": "Required. Lists xy coordinate pairs. These coordinates are scaled by the\nmagnification_factor  argument of the\nlibrary()  function. Each list must\nspecify at least two coordinates.\nNote:\nEdges with zero length are ignored.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The edges()  function creates edges in the top cell using specified coordinates.", "function_name": "edges()"}
{"description": "The edtext_file()  function defines an Edtext file handle. This handle is used by the\ntext_layer_items  argument of the\ntext_net()  function.\nNote:\nThe edtext_file()  function cannot be called more than one time with the\nsame file argument. The result, however, can be used more than one time.", "syntax": "edtext_file(\nfile = \"string\"\n);", "returns": "edtext_file_handle\nedtext_file_handle", "arguments": {"file": "Required. Specifies the Edtext output file name. See the\ntext_net()  function\nfor more information."}, "summary": "The edtext_file()  function defines an Edtext file handle.", "function_name": "edtext_file()"}
{"description": "The empty_layer()  function creates an empty polygon layer.", "syntax": "empty_layer(\nname = \"layer_label\"  //optional\n);", "returns": "polygon layer", "arguments": {"name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The empty_layer()  function creates an empty polygon layer.", "function_name": "empty_layer()"}
{"description": "The empty_layer_edge()  function creates an empty edge layer.", "syntax": "empty_layer_edge(\nname = \"layer_label\"  //optional\n);", "returns": "edge layer", "arguments": {"name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The empty_layer_edge()  function creates an empty edge layer.", "function_name": "empty_layer_edge()"}
{"description": "The empty_layer_marker()  function creates an empty marker layer.", "syntax": "empty_layer_marker(\nname = \"layer_label\"  //optional\n);", "returns": "marker layer", "arguments": {"name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. The name is used only for log files; runset\nvariables are not changed. The default is the name of the layer being created."}, "summary": "The empty_layer_marker()  function creates an empty marker layer.", "function_name": "empty_layer_marker()"}
{"description": "The empty_layer_unmerged()  function creates an empty unmerged polygon layer.", "syntax": "empty_layer_unmerged(\nname  = \"layer_label\"  //optional\n);", "returns": "unmerged polygon layer", "arguments": {"name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. The name is used only for log files; runset\nvariables are not changed. The default is the name of the layer being created."}, "summary": "The empty_layer_unmerged()  function creates an empty unmerged polygon layer.", "function_name": "empty_layer_unmerged()"}
{"description": "The empty_violation()  function creates an empty violation.", "syntax": "empty_violation();", "returns": "violation", "arguments": {}, "summary": "The empty_violation()  function creates an empty violation.", "function_name": "empty_violation()"}
{"description": "The enclose()  function creates polygons that are formed by pairs of violation edges. It\nmeasures outside-to-inside spacing on two layers based on the specified distance. The\narguments define various geometric conditions for measuring the distance between the\nlayer edges.", "syntax": "enclose(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\nrelational_type         = EXPANDED_EDGE  | POLYGON,           //optional\npoint_touch_shape       = EXTENTS  | SQUARE,                  //optional\nshape_size              = double,                            //optional\noutput_type             = REGION  | CENTERLINE | EXTENTS,     //optional\nwidth                   = double,                            //optional\nenclose()\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nline_touch_shape       = OUTSIDE  | INSIDE | BOTH,           //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint,                //optional\nrelational_expand_direction  = INSIDE | OUTSIDE               //optional\norientation_angle       = doubleconstraint,                //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\nFigure 102  shows the effect of the distance  argument settings.\nenclose()\nFigure 102 distance Argument Example", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of\nthe check region are inclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  argument\nvalue. When the projection  argument includes the ON  setting and the\nprojection_length  argument contains 0, the NONE_INCLUSIVE  setting\ngenerates point-to-point violations whose edges have no length. See the\ndescription of the output_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a radial curve. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a square. The boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  argument value with a rectangle. The boundary of\nenclose()\nthe check region is inclusive or exclusive depending on the constraint of the\ndistance  value.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance  argument value, and creating right-angle boundaries\nat the extended endpoints based on the distance  constraint. The right-angle\nboundaries of the check region are exclusive. The far boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nFigure 103  is an example of extension = RECTANGLE, with distance =\n[.4,.5]  and extension_distance =.8.\nFigure 103 extension = RECTANGLE Example\nFigure 104  is an example of extension = EDGE, with distance = [.4,.5]\nand extension_distance =.8.\nenclose()\nFigure 104 extension = EDGE Example\nIn the conceptual diagram shown in Figure 105, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 105 Check Region Extension\nFigure 106  shows the effect of the extension  argument settings.\nFigure 106 extension Argument Example\nenclose()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 107  shows the effect of the extension  argument settings when the\nextension  argument is EDGE.\nFigure 107 extension_distance Argument With extension = EDGE Example\nFigure 108  shows the effect of the extension  argument settings when the\nextension  argument is RECTANGLE.\nFigure 108 extension_distance Argument With extension = RECTANGLE Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\nenclose()\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nFigure 109  shows the effect of the connectivity  argument settings.\nFigure 109 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 110  shows the effect of the orientation  argument settings.\nenclose()\nFigure 110 orientation Argument Example\nFigure 111  shows the effect of the obtuse  argument setting.\nFigure 111 obtuse Argument Example", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where the outside of the enclosed layer touches\nthe inside of the enclosing layer. There is no measurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFigure 112  shows the effect of the intersecting  argument settings.\nenclose()\nFigure 112 intersecting Argument Example", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn\nFigure 113, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nenclose()\nFigure 113 Example of Projection Region\nenclose()\nFigure 114  shows the effect of the projection  argument settings.\nFigure 114 projection Argument Example", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\nenclose()\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\nFigure 115  shows the effect of the orthogonal  argument settings.\nenclose()\nFigure 115 orthogonal Argument Example", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nenclose()\nSee Figure 116  for an example of the direction  argument.\nFigure 116 direction Measurements\nFor the following examples,", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges create check regions.\nenclose()\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nSee Figure 117  for an example of the from_layer  argument.\nFigure 117 from_layer Measurements", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if\n\u25e6 The two edges are parallel and do not project.\n\u25e6 The layer1  edge is on a convex, right-angle corner.\n\u25e6 The layer2  edge is on a concave, right-angle corner.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if\nenclose()\n\u25e6 One edge falls on a convex, right-angle corner of a layer1  edge or a\nconcave, right-angle corner of a layer2  edge.\n\u25e6 The two edges are nonparallel and project.\n\u25e6 The line bisecting the corner intersects the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee\nFigure 118  for an example of the corner_configuration  argument.\nFigure 118 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\n\u2022 OUTSIDE. Looks outside the layer2, enclosing layer.\nenclose()\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. A projection is contained when any of the following\nare true:\n\u25e6 A layer1  edge is inside coincident to a projecting layer2  edge.\n\u25e6 A layer1  polygon overlaps a projecting layer2  edge. If layer1  is an\nedge layer, this contain does not apply.\n\u25e6 The projection is inside a layer2  polygon. If layer2  is an edge layer, this\ncontain does not apply.\nFigure 119  shows an example of using the NOT_CONTAINED  option.\nenclose(gray, purple, look_thru = NOT_CONTAINED);\nFigure 119 look_thru = NOT_CONTAINED Example\n\u2022 ALL. Looks through all edges.\nFigure 120  shows an example of the edges that a spacing check looks through\nfor various look_thru  argument settings.\nenclose()\nProjections look_thru  argument setting\n1, 2 NONE\n1, 2, 3, 4 INSIDE\n1, 2, 3, 4, 5 ALL\nFigure 120 Example of look_thru Projections\nFigure 121  shows another example of the edges that a spacing check looks\nthrough for various look_thru  argument settings.\nProjections look_thru  argument setting\n1 NONE\n1, 2 COINCIDENT\n1, 2, 3 OUTSIDE\n1, 2, 3, 4, 5 ALL\nenclose()\nFigure 121 Example of look_thru Projections", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nenclose()\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 122  for an example of the extension_obstructions  argument.\nenclose()\nFigure 122 Example of extension_obstructions", "relational": "Optional. Specifies the additional violations that the check outputs. By default,\nthe IC Validator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-inside point\ntouch. The format of the violation is determined by the point_touch_shape\nand shape_size  arguments. Connectivity is considered.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Reports as violations the layer2  edges that are inside layer1.\nApplies only when layer1  is a polygon layer. Connectivity is considered.\n\u2022 OUTSIDE. Reports as violations the layer1  edges that are outside layer2.\nWhen layer2  is an edge layer, this argument reports outside coincidence.\nConnectivity is not  considered for this argument.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross.\nApplies only when layer1  and layer2  are polygon layers. Connectivity is\nconsidered. When this argument is specified, the intersection_angle\nargument is ignored.\nFigure 123  shows the effect of the relational  argument settings.\nenclose()\nFigure 123 relational Argument Example", "relational_type": "Optional. Specifies how OUTSIDE  relational violations are reported. The default is\nEXPANDED_EDGE.\n\u2022 EXPANDED_EDGE. Reports violations as individual edges expanded to the\noutside by width.\n\u2022 POLYGON. Reports violations as closed polygons (applies only when both\ninputs are polygons).\nFigure 124  shows the effect of the relational_type  argument settings.\nFigure 124 relational_type Argument Example\nenclose()", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of the\nspacing distance. The value must be positive. It is rounded to the nearest even\nmultiple of the internal resolution, with a minimum value of twice the internal\nresolution.", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Reports violations as an expanded line at the center of the\nprojection region. The midpoints of the sides of the violation region form a\nline that is expanded in both directions by width/2. When the output_type\nargument is CENTERLINE, only parallel spacing and intersection angles are\nsupported.\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when the extension  argument is\nRADIAL  or SQUARE.\nenclose()\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  value on both\nsides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  value. Violations are oriented along the line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nFor the following examples,\nIn the following example,\ngreen = enclose(blue, red, <= 1.0, RADIAL,\noutput_type = REGION);\nenclose()\nIn the following example,\ngreen = enclose(blue, red, <= 1.0, RADIAL,\norientation = {PARALLEL}, intersecting = {},\noutput_type = CENTERLINE);\nIn the following example,\ngreen = enclose(blue, red, <= 1.0, RADIAL,\noutput_type = EXTENTS);", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nenclose()\nargument is the internal resolution. The internal_resolution  argument of\nthe resolution_options()  function sets the internal resolution. The default\nis .001.\nFor the following examples,\nIn the following example,\ngreen = enclose(blue, red, < 0, RADIAL,\nrelational = {INSIDE}, width = 2.0);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\nenclose()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "line_touch_shape": "Optional. Specifies how to expand a line-touch edge violation into a polygon.\nThe default is OUTSIDE.\n\u2022 OUTSIDE. Outputs a line-touch polygon outside of the dimensional function\nlayer1  polygon. The output polygon size equals the value of the width\noption.\n\u2022 INSIDE. Outputs a line-touch polygon inside of layer1. The output polygon\nsize equals the value of the width  option.\n\u2022 BOTH. Outputs a line touch polygon inside and outside of the layer1. The\ntotal output size is 2*width  option.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Accumulates the projection length for interacting violations that\nproject from the same edge. A given violation can contribute to more than\none unique accumulated projection length.\nFigure 125  shows how the cumulative projection length is measured for the\nSAME_EDGE  option. There are a total of four projection lengths.\nFigure 125 SAME_EDGE Projection Length Measurement Example\nenclose()\n\u2022 JOGGING_EDGE. Accumulates the projection length for interacting violations\nthat project from the same edge or a jogging edge. A given violation can\ncontribute to more than one unique accumulated projection length.\nNote:\nA jogging edge is a group of parallel edges with the same\ndirection that are separated only by perpendicular edges. These\nperpendicular edges have one angle at 90 degrees and the other\nat 270 degrees.\nFigure 126  shows how the cumulative projection length is measured for\nJOGGING_EDGE.\nenclose()\nFigure 126 JOGGING_EDGE Projection Length Measurement Example\nFigure 127  shows the difference between a jogging edge and a non-jogging\nedge.\nFigure 127 Jogs Not Included in a JOGGING_EDGE Projection Length\nMeasurement", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE\nenclose()\nor NONE_INCLUSIVE, and compatibility_options(drc = {spacing =\n{combine_edge_pair_violations = false}}). The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\n\u25e6 When the extension  argument is EDGE  and\ncompatibility_options(drc = {spacing =\n{combine_edge_pair_violations = true}}),\nSYMMETRIC_NON_INTERSECTING  can be specified. The behavior is the\nsame as SYMMETRIC  to measure both projections from orthogonal and\nnonorthogonal edges. There is no output violation with a single point error\nedge.", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\nenclose()", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments\nare ignored for the intersection_angle  checks. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 128  shows an example of using the intersection_angle  argument.\ngreen = enclose(blue, red, distance < 1.0, extension = RADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nFigure 128 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nenclose()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL, the break_edges\nargument is forced to true.\n\u2022 INSIDE_TO_OUTSIDE. Includes the following measurements:\n\u25e6 For layer1  edges,\nIf layer2  is a polygon, edges on the layer2  polygon measure those\nlayer1  edges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside\nof any layer2  polygon.\nIf layer2  is an edge, those layer1  edges that are neither inside\ncoincident nor outside coincident with layer2  are included in the\nmeasurements.\n\u25e6 For layer2  edges,\nIf layer1  is a polygon, only those layer2  edges that are outside and\noutside coincident with layer1  are included in the measurements.\nIf layer1  is an edge, those layer2  edges that are not inside coincident\nwith layer1  are included in the measurements.\nNote:\nEdges that are inside coincident with the other layer are included\nin the measurement for touch violations.\nIn\nFigure 129, the dash lines are filtered out before the measurement. The\nsyntax is\nenclose(layer1 = orange, layer2 = blue, ...)\nenclose()\nFigure 129 Example of Edge Containment for the enclose() Functions\n\u2022 COINCIDENT. Includes layer1  edges that are outside coincident.\n\u2022 ALL. Does not filter edges.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks. The\nsegments resulting from the edge breaking are processed individually by the\nedge filters and spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior. Edges are broken into individual\nsegments as follows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.\nenclose()\nFigure 130  shows the break_edges  argument for a two-layer polygon. If the\nother layer is an edge layer, there is no inside or outside with the other edge\nlayer.\nFigure 130 Example of break_edges Argument for a Two-Layer Polygon", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "relational_expand_direction": "Optional. Controls the expanded direction of the selected edges. The default is\nOUTSIDE.\n\u2022 INSIDE. Controls the inside of the expanded direction of the selected edges.\n\u2022 OUTSIDE. Controls the outside of the expanded direction of the selected\nedges.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nenclose()\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The enclose()  function creates polygons that are formed by pairs of violation edges.", "function_name": "enclose()"}
{"description": "The enclose_corner()  function creates polygons that are formed by pairs of violation\ncorners. It measures the outside of the layer1  layer to the inside of the layer2  layer. The\narguments define various geometric conditions for measuring the point-to-point distance\nbetween the corners.\nThe output consists of rectangles that are the extents of the point-to-point violations. In\nthe case where the violation is horizontal or vertical, the output rectangle is generated by\nexpanding the violation three times the input library resolution on both sides.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner. Also, a portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the enclose_corner()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\nenclose_corner()", "syntax": "enclose_corner(\nlayer1            = data_layer,\nlayer2            = data_layer,\ndistance          = doubleconstraint,\ntype              = {CONVEX_TO_CONCAVE, CONVEX_TO_CONVEX,\nCONVEX_TO_EDGE, CONCAVE_TO_CONCAVE,\nCONCAVE_TO_EDGE, EDGE_TO_CONCAVE, EDGE_TO_CONVEX,\nPARALLEL_POINT_PROJECTION},             //optional\nangle             = ALL  | RIGHT,                             //optional\nregion           = RADIAL  | SQUARE,                         //optional\nboundary          = EXCLUSIVE  | INCLUSIVE,                   //optional\nconvex_to_concave_boundary   = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints   = CORNER | ALL,                            //optional\nconnectivity      = SAME_NET | DIFFERENT_NET | ALL,          //optional\nconnect_sequence = connect_database,                        //optional\nlook_thru         = NONE  | COINCIDENT | INSIDE | OUTSIDE |\nALL,                                     //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,               //optional\nname             = \"layer_label\"                            //optional\nrelational  = {POINT_TOUCH}                         // optional\nshape_size  = double                         // optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing checked on layer1\nand layer2, respectively. For example, CONCAVE_TO_EDGE  checks between\nenclose_corner()\nconcave corners on layer1  and edges on layer2. By default, the IC Validator\ntool selects all types.\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the boundary  argument.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 EDGE_TO_CONCAVE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 EDGE_TO_CONVEX. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and boundary  arguments\nare ignored. The edge endpoints and all angle corners are always\nmeasured; edge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\nenclose_corner()\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner; one edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.", "boundary": "Optional. For convex-to-convex and concave-to-concave measurements,\nspecifies whether the corner check-zone boundaries are exclusive or inclusive.\nThe default is EXCLUSIVE.", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nenclose_corner()", "connect_sequence": "Optional. Specifies the connect database. This database must be a valid\nconnect database when the connectivity  argument is SAME_NET  or\nDIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\n\u2022 OUTSIDE. Looks outside layer2, the enclosing layer.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the\nenclose()  function for\nmore information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "relational": "Optional. Specifies the additional violations that the check outputs. By default,\nthe IC Validator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is a point touch interaction for\nthe selected type argument except CONCAVE_TO_EDGE  and EDGE_TO_CONVEX.\nThe format of the violation is SQAURE  of shape_size  argument. The\nPOINT_TOUCH  argument is not available for edge input.\nenclose_corner()", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\nrelational={POINT_TOUCH}. The default is twice the maximum of the spacing\ndistance. The value must be positive. It is rounded to the nearest even multiple\nof the internal resolution, with a minimum value of twice the internal resolution."}, "summary": "The enclose_corner()  function creates polygons that are formed by pairs of violation\ncorners.", "function_name": "enclose_corner()"}
{"description": "The enclose_corner_edge()  function creates edges that consist of pairs of violation\ncorners. It measures the outside of the layer1  layer to the inside of the layer2  layer. The\narguments define various geometric conditions for measuring the point-to-point distance\nbetween the corners.\nThe output consists of pairs of violation edges.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner. Also, a portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the enclose_corner_edge()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\nenclose_corner_edge()", "syntax": "enclose_corner_edge(\nlayer1            = data_layer,\nlayer2            = data_layer,\ndistance          = doubleconstraint,\ntype              = {CONVEX_TO_CONCAVE, CONVEX_TO_CONVEX,\nCONVEX_TO_EDGE, CONCAVE_TO_CONCAVE,\nCONCAVE_TO_EDGE, EDGE_TO_CONCAVE,\nEDGE_TO_CONVEX, PARALLEL_POINT_PROJECTION},\n//optional\nangle             = ALL  | RIGHT,                             //optional\nregion           = RADIAL  | SQUARE,                         //optional\nboundary          = EXCLUSIVE  | INCLUSIVE,                   //optional\nconvex_to_concave_boundary = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints   = CORNER  | ALL,                            //optional\nconnectivity      = SAME_NET | DIFFERENT_NET | ALL,          //optional\nconnect_sequence = connect_database,                        //optional\nlook_thru         = NONE  | COINCIDENT | INSIDE | OUTSIDE |\nALL,                                     //optional\noutput_layer     = LAYER1  | LAYER2,                         //optional\noutput_type      = FAIL  | POINT_TO_POINT,                   //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,               //optional\nname             = \"layer_label\"                            //optional\nrelational  = {POINT_TOUCH}                         // optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing checked on layer1\nand layer2, respectively. For example, CONCAVE_TO_EDGE  checks between\nenclose_corner_edge()\nconcave corners on layer1  and edges on layer2. By default, the IC Validator\ntool selects all types.\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the boundary  argument.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 EDGE_TO_CONCAVE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 EDGE_TO_CONVEX. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and boundary  arguments\nare ignored. The edge endpoints and all angle corners are always\nmeasured; edge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\nenclose_corner_edge()\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.", "boundary": "Optional. For convex-to-convex and concave-to-concave measurements,\nspecifies whether the corner check-zone boundaries are exclusive or inclusive.\nThe default is EXCLUSIVE.", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nenclose_corner_edge()", "connect_sequence": "Optional. Specifies the connect database. This database must be a valid\nconnect database when the connectivity  argument is SAME_NET  or\nDIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\n\u2022 OUTSIDE. Looks outside layer2, the enclosing layer.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the\nenclose()  function for\nmore information.", "output_layer": "Optional. Specifies the layer whose edges are output for the violations. The\ndefault is LAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. Edge endpoints are ordered from\nlayer1  to layer2. POINT_TO_POINT  creates an orphan edge layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nenclose_corner_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "relational": "Optional. Specifies the additional violations that the check outputs. By default,\nthe IC Validator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is a point touch interaction for\nthe selected type argument except CONCAVE_TO_EDGE  and EDGE_TO_CONVEX.\nThe length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the resolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input."}, "summary": "The enclose_corner_edge()  function creates edges that consist of pairs of violation\ncorners.", "function_name": "enclose_corner_edge()"}
{"description": "The enclose_edge()  function selects the portion of layer1  and layer2  edges that\nviolates the spacing constraints. It measures outside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The complement of this function is the\nnot_enclose_edge()  function.", "syntax": "enclose_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,          //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,        //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nenclose_edge() and not_enclose_edge()\noutput_type            = FAIL  | CENTERLINE,\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\n);\nnot_enclose_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER,                        //optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nenclose_edge() and not_enclose_edge()\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle = doubleconstraint                   //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Optional. Specifies the check distance. See\nConstraints  for more information.\nThe default is 0.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with\nright-angle boundaries at the edge endpoints. The right-angle boundaries\nof the check region are inclusive. The far boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance\nvalue. When the projection  argument includes ON, the NONE_INCLUSIVE\nsetting generates point-to-point violations whose edges have no length.\nenclose_edge() and not_enclose_edge()\nThe edges reported have a length equal to the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a radial curve. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a square. The boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  argument value with a rectangle. The boundary of\nthe check region is inclusive or exclusive depending on the constraint of the\ndistance  value.\nFigure 131  and Figure 132  show the effect of the extension  argument\nsettings.\nFigure 131 extension Argument Example\nFigure 132 extension Argument Example\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance  argument value, and creating right-angle boundaries\nat the extended endpoints based on the distance  constraint. The right-angle\nenclose_edge() and not_enclose_edge()\nboundaries of the check region are exclusive. The far boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nFigure 133  shows the effect of the connectivity  argument settings.\nFigure 133 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.\nenclose_edge() and not_enclose_edge()", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 134  shows the effect of the orientation  argument settings.\nFigure 134 orientation Argument Example", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where the outside of the enclosed layer touches\nthe inside of the enclosing layer. There is no measurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFigure 135  shows the effect of the intersecting  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 135 intersecting Argument Example", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nFigure 136  shows the effect of the projection  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 136 projection Argument Example", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\nenclose_edge() and not_enclose_edge()\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The extension  argument must be NONE.\n\u2022 The projection  argument must contain IN.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\nFigure 137  shows the effect of the orthogonal  argument settings.\nFigure 137 orthogonal Argument Example\nenclose_edge() and not_enclose_edge()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFigure 138  shows the effect of the direction  argument settings.\nFigure 138 direction Argument Example", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\nenclose_edge() and not_enclose_edge()\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nFigure 139  shows the effect of the from_layer  argument settings.\nFigure 139 from_layer Argument Example", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if\n\u25e6 The two edges are parallel and do not project.\n\u25e6 The layer1  edge is on a convex, right-angle corner.\n\u25e6 The layer2  edge is on a concave, right-angle corner.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if\nenclose_edge() and not_enclose_edge()\n\u25e6 One edge falls on a convex, right-angle corner of a layer1  edge or a\nconcave, right-angle corner of a layer2  edge.\n\u25e6 The two edges are nonparallel and project.\n\u25e6 The line bisecting the corner intersects the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 140  shows the effect of the corner_configuration  argument settings.\nThe red outlines highlight the selected boundaries.\nFigure 140 corner_configuration Argument Example", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\nenclose_edge() and not_enclose_edge()\n\u2022 OUTSIDE. Looks outside the layer2, enclosing layer.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the enclose()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nFigure 141  shows the effect of the look_thru  argument settings.\nFigure 141 look_thru Argument Example", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nenclose_edge() and not_enclose_edge()\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\nFigure 142  shows the effect of the look_thru_from_layer  argument settings.\nFigure 142 look_thru_from_layer Argument Example\nenclose_edge() and not_enclose_edge()", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 143  shows the effect of the extension_look_past  argument settings.\nFigure 143 extension_look_past Argument Example", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 144  shows the effect of the extension_obstructions  argument\nsettings.\nenclose_edge() and not_enclose_edge()\nFigure 144 extension_obstructions Argument Example", "relational": "Optional. Specifies additional violations for the check outputs. By default, the IC\nValidator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. Connectivity is considered.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Reports as violations the layer2  edges that are inside layer1.\nApplies only when layer1  is a polygon layer. Connectivity is considered.\n\u2022 OUTSIDE. Reports as violations the layer1  edges that are outside layer2.\nWhen layer2  is an edge layer, this argument reports outside coincidence.\nConnectivity is not  considered for this argument.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross.\nApplies only when layer1  and layer2  are polygon layers. Connectivity is\nconsidered. When this argument is specified, the intersection_angle\nargument is ignored.\nFigure 145  shows the effect of the relational  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 145 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nFigure 146  shows the effect of the output_layer  argument settings.\nFigure 146 output_layer Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\nenclose_edge() and not_enclose_edge()\nSee the cumulative_projection_length  argument of the enclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\nFigure 147  shows the effect of the cumulative_projection_lengthargument\nsettings.\nFigure 147 cumulative_projection_length Argument Example", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_enclose_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.\nFigure 148  shows the effect of the output_typeargument settings.\nenclose_edge() and not_enclose_edge()\nFigure 148 output_type Argument Example", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\nFigure 149  shows the effect of the projection_modeargument settings.\nFigure 149 projection_mode Argument Example", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\nenclose_edge() and not_enclose_edge()\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\nFigure 150  shows the effect of the projection_filterargument settings.\nFigure 150 projection_filter Argument Example", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nenclose_edge() and not_enclose_edge()\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 151  shows an example of using the intersection_angle  argument.\ngreen = enclose_edge(blue, red, distance < 1.0, extension =\nRADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nFigure 151 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nenclose_edge() and not_enclose_edge()\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL, the break_edges\nargument is forced to true.\n\u2022 INSIDE_TO_OUTSIDE. Includes the following measurements:\n\u25e6 For layer1  edges,\nIf layer2  is a polygon, edges on the layer2  polygon measure those\nlayer1  edges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside\nof any layer2  polygon.\nIf layer2  is an edge, those layer1  edges that are neither inside\ncoincident nor outside coincident with layer2  are included in the\nmeasurements.\n\u25e6 For layer2  edges,\nIf layer1  is a polygon, only those layer2  edges that are outside and\noutside coincident with layer1  are included in the measurements.\nIf layer1  is an edge, those layer2  edges that are not inside coincident\nwith layer1  are included in the measurements.\nNote:\nEdges that are inside coincident with the other layer are included\nin the measurement for touch violations.\nSee\nFigure 129  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are outside coincident.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nenclose_edge() and not_enclose_edge()\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFigure 152  shows the results when the direction  argument is HORIZONTAL. For\nexample,\nResult = external2_edge(green, gray, extension = NONE,\ndirection = HORIZONTAL, output_side = ALL);\nFigure 152 output_side Argument Examples When direction Argument is\nHORIZONTAL\nFigure 153  shows the results when the direction  argument is VERTICAL. For\nexample,\nResult = external2_edge(green, gray, extension = NONE,\ndirection = VERTICAL, output_side = ALL);\nenclose_edge() and not_enclose_edge()\nFigure 153 output_side Argument Examples When direction Argument is\nVERTICAL\nFigure 154  shows the results when projection_mode  argument is ASYMMETRIC\nand the direction  argument is HORIZONTAL. For example,\nResult = external2_edge(green, gray, extension = NONE,\nprojection_mode = ASYMMETRIC, direction = VERTICAL,\noutput_side = ALL);\nFigure 154 output_side Argument Examples When projection_mode Argument is\nASYMMETRIC and direction Argument is HORIZONTAL\nFigure 155  shows the results when projection_mode  argument is ASYMMETRIC\nand the direction  argument is VERTICAL. For example,\nResult = external2_edge(green, gray, extension = NONE,\nprojection_mode = ASYMMETRIC, direction = VERTICAL,\noutput_side = ALL);\nenclose_edge() and not_enclose_edge()\nFigure 155 output_side Argument Examples When projection_mode Argument is\nASYMMETRIC and direction Argument is VERTICAL", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks. The\nsegments resulting from the edge breaking are processed individually by the\nedge filters and spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior. Edges are broken into individual\nsegments as follows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.\nSee\nFigure 130  for an example.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({}).\nenclose_edge() and not_enclose_edge()"}, "summary": "The enclose_edge()  function selects the portion of layer1  and layer2  edges that\nviolates the spacing constraints.", "function_name": "not_enclose_edge()"}
{"description": "The enclose_edge()  function selects the portion of layer1  and layer2  edges that\nviolates the spacing constraints. It measures outside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The complement of this function is the\nnot_enclose_edge()  function.", "syntax": "enclose_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,          //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,        //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nenclose_edge() and not_enclose_edge()\noutput_type            = FAIL  | CENTERLINE,\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\n);\nnot_enclose_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER,                        //optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nenclose_edge() and not_enclose_edge()\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle = doubleconstraint                   //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Optional. Specifies the check distance. See\nConstraints  for more information.\nThe default is 0.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with\nright-angle boundaries at the edge endpoints. The right-angle boundaries\nof the check region are inclusive. The far boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance\nvalue. When the projection  argument includes ON, the NONE_INCLUSIVE\nsetting generates point-to-point violations whose edges have no length.\nenclose_edge() and not_enclose_edge()\nThe edges reported have a length equal to the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a radial curve. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  argument value with a square. The boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  argument value with a rectangle. The boundary of\nthe check region is inclusive or exclusive depending on the constraint of the\ndistance  value.\nFigure 131  and Figure 132  show the effect of the extension  argument\nsettings.\nFigure 131 extension Argument Example\nFigure 132 extension Argument Example\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance  argument value, and creating right-angle boundaries\nat the extended endpoints based on the distance  constraint. The right-angle\nenclose_edge() and not_enclose_edge()\nboundaries of the check region are exclusive. The far boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nFigure 133  shows the effect of the connectivity  argument settings.\nFigure 133 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.\nenclose_edge() and not_enclose_edge()", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 134  shows the effect of the orientation  argument settings.\nFigure 134 orientation Argument Example", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where the outside of the enclosed layer touches\nthe inside of the enclosing layer. There is no measurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFigure 135  shows the effect of the intersecting  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 135 intersecting Argument Example", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nFigure 136  shows the effect of the projection  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 136 projection Argument Example", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\nenclose_edge() and not_enclose_edge()\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The extension  argument must be NONE.\n\u2022 The projection  argument must contain IN.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\nFigure 137  shows the effect of the orthogonal  argument settings.\nFigure 137 orthogonal Argument Example\nenclose_edge() and not_enclose_edge()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFigure 138  shows the effect of the direction  argument settings.\nFigure 138 direction Argument Example", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\nenclose_edge() and not_enclose_edge()\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nFigure 139  shows the effect of the from_layer  argument settings.\nFigure 139 from_layer Argument Example", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if\n\u25e6 The two edges are parallel and do not project.\n\u25e6 The layer1  edge is on a convex, right-angle corner.\n\u25e6 The layer2  edge is on a concave, right-angle corner.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if\nenclose_edge() and not_enclose_edge()\n\u25e6 One edge falls on a convex, right-angle corner of a layer1  edge or a\nconcave, right-angle corner of a layer2  edge.\n\u25e6 The two edges are nonparallel and project.\n\u25e6 The line bisecting the corner intersects the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 140  shows the effect of the corner_configuration  argument settings.\nThe red outlines highlight the selected boundaries.\nFigure 140 corner_configuration Argument Example", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\nenclose_edge() and not_enclose_edge()\n\u2022 OUTSIDE. Looks outside the layer2, enclosing layer.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the enclose()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nFigure 141  shows the effect of the look_thru  argument settings.\nFigure 141 look_thru Argument Example", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nenclose_edge() and not_enclose_edge()\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\nFigure 142  shows the effect of the look_thru_from_layer  argument settings.\nFigure 142 look_thru_from_layer Argument Example\nenclose_edge() and not_enclose_edge()", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 143  shows the effect of the extension_look_past  argument settings.\nFigure 143 extension_look_past Argument Example", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 144  shows the effect of the extension_obstructions  argument\nsettings.\nenclose_edge() and not_enclose_edge()\nFigure 144 extension_obstructions Argument Example", "relational": "Optional. Specifies additional violations for the check outputs. By default, the IC\nValidator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. Connectivity is considered.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Reports as violations the layer2  edges that are inside layer1.\nApplies only when layer1  is a polygon layer. Connectivity is considered.\n\u2022 OUTSIDE. Reports as violations the layer1  edges that are outside layer2.\nWhen layer2  is an edge layer, this argument reports outside coincidence.\nConnectivity is not  considered for this argument.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross.\nApplies only when layer1  and layer2  are polygon layers. Connectivity is\nconsidered. When this argument is specified, the intersection_angle\nargument is ignored.\nFigure 145  shows the effect of the relational  argument settings.\nenclose_edge() and not_enclose_edge()\nFigure 145 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nFigure 146  shows the effect of the output_layer  argument settings.\nFigure 146 output_layer Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\nenclose_edge() and not_enclose_edge()\nSee the cumulative_projection_length  argument of the enclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\nFigure 147  shows the effect of the cumulative_projection_lengthargument\nsettings.\nFigure 147 cumulative_projection_length Argument Example", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_enclose_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.\nFigure 148  shows the effect of the output_typeargument settings.\nenclose_edge() and not_enclose_edge()\nFigure 148 output_type Argument Example", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\nFigure 149  shows the effect of the projection_modeargument settings.\nFigure 149 projection_mode Argument Example", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\nenclose_edge() and not_enclose_edge()\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\nFigure 150  shows the effect of the projection_filterargument settings.\nFigure 150 projection_filter Argument Example", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nenclose_edge() and not_enclose_edge()\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 151  shows an example of using the intersection_angle  argument.\ngreen = enclose_edge(blue, red, distance < 1.0, extension =\nRADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nFigure 151 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nenclose_edge() and not_enclose_edge()\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL, the break_edges\nargument is forced to true.\n\u2022 INSIDE_TO_OUTSIDE. Includes the following measurements:\n\u25e6 For layer1  edges,\nIf layer2  is a polygon, edges on the layer2  polygon measure those\nlayer1  edges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside\nof any layer2  polygon.\nIf layer2  is an edge, those layer1  edges that are neither inside\ncoincident nor outside coincident with layer2  are included in the\nmeasurements.\n\u25e6 For layer2  edges,\nIf layer1  is a polygon, only those layer2  edges that are outside and\noutside coincident with layer1  are included in the measurements.\nIf layer1  is an edge, those layer2  edges that are not inside coincident\nwith layer1  are included in the measurements.\nNote:\nEdges that are inside coincident with the other layer are included\nin the measurement for touch violations.\nSee\nFigure 129  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are outside coincident.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nenclose_edge() and not_enclose_edge()\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFigure 152  shows the results when the direction  argument is HORIZONTAL. For\nexample,\nResult = external2_edge(green, gray, extension = NONE,\ndirection = HORIZONTAL, output_side = ALL);\nFigure 152 output_side Argument Examples When direction Argument is\nHORIZONTAL\nFigure 153  shows the results when the direction  argument is VERTICAL. For\nexample,\nResult = external2_edge(green, gray, extension = NONE,\ndirection = VERTICAL, output_side = ALL);\nenclose_edge() and not_enclose_edge()\nFigure 153 output_side Argument Examples When direction Argument is\nVERTICAL\nFigure 154  shows the results when projection_mode  argument is ASYMMETRIC\nand the direction  argument is HORIZONTAL. For example,\nResult = external2_edge(green, gray, extension = NONE,\nprojection_mode = ASYMMETRIC, direction = VERTICAL,\noutput_side = ALL);\nFigure 154 output_side Argument Examples When projection_mode Argument is\nASYMMETRIC and direction Argument is HORIZONTAL\nFigure 155  shows the results when projection_mode  argument is ASYMMETRIC\nand the direction  argument is VERTICAL. For example,\nResult = external2_edge(green, gray, extension = NONE,\nprojection_mode = ASYMMETRIC, direction = VERTICAL,\noutput_side = ALL);\nenclose_edge() and not_enclose_edge()\nFigure 155 output_side Argument Examples When projection_mode Argument is\nASYMMETRIC and direction Argument is VERTICAL", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks. The\nsegments resulting from the edge breaking are processed individually by the\nedge filters and spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior. Edges are broken into individual\nsegments as follows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.\nSee\nFigure 130  for an example.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({}).\nenclose_edge() and not_enclose_edge()"}, "summary": "The enclose_edge()  function selects the portion of layer1  and layer2  edges that\nviolates the spacing constraints.", "function_name": "enclose_edge()"}
{"description": "The enclose_error()  function measures outside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is unmerged errors.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nErrors output to the error database consist of pairs of violation edges.", "syntax": "enclose_error(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER,                        //optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | OUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nenclose_error()\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE_TO_OUTSIDE | COINCIDENT | ALL,\n//optional\nbreak_edges            = true | false,                      //optional\nrelational              = {POINT_TOUCH, INSIDE, OUTSIDE, CROSS},\n//optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle = doubleconstraint                   //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the enclosed input edge or polygon layer.", "layer2": "Required. Specifies the enclosing edge or polygon layer against which the\nlayer1  layer is checked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nenclose_error()\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.\nenclose_error()", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nSee the examples for the orientation  argument of the\nenclose()  function for\nmore information.", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where the outside of the enclosed layer touches\nthe inside of the enclosing layer. There is no measurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nSee the examples for the intersecting  argument of the\nenclose()  function for\nmore information.", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\nenclose_error()\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nSee the examples for the projection  argument of the enclose()  function for\nmore information.", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\nSee the examples for the orthogonal  argument of the\nenclose()  function for\nmore information.\nenclose_error()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nSee the examples for the direction  argument of the\nenclose()  function for\nmore information.", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nSee the examples for the from_layer  argument of the\nenclose()  function for\nmore information.", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nenclose_error()\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the vertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if\n\u25e6 The two edges are parallel and do not project.\n\u25e6 The layer1  edge is on a convex, right-angle corner.\n\u25e6 The layer2  edge is on a concave, right-angle corner.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if\n\u25e6 One edge falls on a convex, right-angle corner of a layer1  edge or a\nconcave, right-angle corner of a layer2  edge.\n\u25e6 The two edges are nonparallel and project.\n\u25e6 The line bisecting the corner intersects the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee the examples for the corner_configuration  argument of the\nenclose()\nfunction for more information.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through outside coincident edges from layer2, the\nenclosing layer.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\nenclose_error()\n\u2022 INSIDE. Looks inside layer1, the enclosed layer.\n\u2022 OUTSIDE. Looks outside the layer2, enclosing layer.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the enclose()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the enclose()function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\nenclose_error()", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee the examples for the extension_obstructions  argument of the\nenclose()  function for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\nenclose_error()\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nenclose_error()\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nSee the intersection_angle  argument of the enclose()  and\nenclose_edge() and not_enclose_edge()  functions for examples.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL, the break_edges\nargument is forced to true.\n\u2022 INSIDE_TO_OUTSIDE. Includes the following measurements:\n\u25e6 For layer1  edges,\nIf layer2  is a polygon, edges on the layer2  polygon measure those\nlayer1  edges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside\nof any layer2  polygon.\nIf layer2  is an edge, those layer1  edges that are neither inside\ncoincident nor outside coincident with layer2  are included in the\nmeasurements.\nenclose_error()\n\u25e6 For layer2  edges,\nIf layer1  is a polygon, only those layer2  edges that are outside and\noutside-coincident with layer1  are included in the measurements.\nIf layer1  is an edge, those layer2  edges that are not inside-coincident\nwith layer1  are included in the measurements.\nNote:\nEdges that are inside-coincident with the other layers are included\nin the measurement for touch violations.\nSee\nFigure 129  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are outside coincident.\n\u2022 ALL. Does not filter edges.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks. The\nsegments resulting from the edge breaking are processed individually by the\nedge filters and spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior. Edges are broken into individual\nsegments as follows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.\nSee\nFigure 130  for an example.", "relational": "Optional. Specifies additional violations for the check outputs. By default, the IC\nValidator tool does not report additional violations.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. Connectivity is considered.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nenclose_error()\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Reports as violations the layer2  edges that are inside layer1.\nApplies only when layer1  is a polygon layer. Connectivity is considered.\n\u2022 OUTSIDE. Reports as violations the layer1  edges that are outside layer2.\nWhen layer2  is an edge layer, this argument reports outside coincidence.\nConnectivity is not  considered for this argument.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross.\nApplies only when layer1  and layer2  are polygon layers. Connectivity is\nconsidered. When this argument is specified, the intersection_angle\nargument is ignored.\nFigure 156  shows the effect of the relational  argument settings.\nFigure 156 relational Argument Example", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({}).\nenclose_error()"}, "summary": "The enclose_error()  function measures outside-to-inside spacing between two layers\nbased on the specified distance.", "function_name": "enclose_error()"}
{"description": "The enclosing()  function selects layer1  polygons that fully enclose layer2  polygons.\nThe complement of this function is the not_enclosing()  function.", "syntax": "enclosing(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = POINT | ALL,                //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);\nnot_enclosing(\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = POINT | ALL,                //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "count": "Optional. Specifies the number of layer2  polygons that must be enclosed. See\nConstraints  for more information. The default is >0.\nenclosing() and not_enclosing()\nFigure 157  and Figure 158  show the effect of the count  argument settings for\nthe enclosing()  and not_enclosing()  functions.\nFigure 157 count Argument Example Result for enclosing()\nFigure 158 count Argument Example Result for not_enclosing()", "include_touch": "Optional. Specifies the inside touches that are included in the definition of fully\nenclosed for layer2  polygons. The default is ALL.\n\u2022 POINT. Considers point touch as enclosed.\n\u2022 ALL. Considers all touches (edge and point) as enclosed.\nFigure 159  and Figure 160  show the effect of the include_touch  argument\nsettings for the enclosing()  and not_enclosing() functions.\nFigure 159 include_touch Argument Example for enclosing()\nenclosing() and not_enclosing()\nFigure 160 include_touch Argument Example for not_enclosing()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and count_parity  is EVEN, the layer1\npolygons that interact with four, six, or eight layer2  polygons are selected.\nFigure 161  shows an example of two interacting layers.\nenclosing() and not_enclosing()\nFigure 161 count_parity Argument Example\nFor the following commands, the result is shown in Figure 162.\nenclosing(L1, L2, count = [2, 4], count_parity = EVEN)\nFigure 162 Result of count_parity Argument Example", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\n\u2022 NET. Selects a layer1  polygon if it encloses with distinct nets on the layer2\nlayer the number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it encloses the layer2  layer the number\nof times specified by the count  argument.\nRefer to Figure 163  for the following examples.\nenclosing() and not_enclosing()\nFigure 163 count_by Argument Example\nThe following commands select polygon A of layer L1.\n\u2022 Only net 2 is fully enclosed by layer L1. It is counted one time because\nthe count_by  argument is NET. Therefore, polygon A meets the count=1\nrestriction.\nenclosing(L1, L2, count==1, count_by=NET,\nconnect_sequence=cdb)\n\u2022 Only net 2 is fully enclosed by layer L1. It is counted two times. Therefore,\npolygon A meets the count=2  restriction.\nenclosing(L1, L2, count==2)", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The enclosing()  function selects layer1  polygons that fully enclose layer2  polygons.", "function_name": "enclosing()"}
{"description": "The equiv_options()  function specifies user-intended pairings of cells in the schematic\nand layout netlists for comparison. Additional arguments specify instances to be deleted,\nnets to be equated, static nets and devices, as well as schematic swappable ports.\nNote:\nYou can use a -e  command-line option to add equivalence options that you\nhave defined in a separate file. See the Command-Line Options section in\nthe \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more\ninformation.\nThe equiv.run file\nequiv.run file\n, which is written by IC Validator, lists the equivalence cells that were\nused during the run. See Equivalence Files in the \u201cOutput Files\u201d chapter of the IC Validator\nUser Guide  for more information.\nThis function, or a \uff0cinclude  directive pointing to a file containing this function, must be\ncalled before assign functions.", "syntax": "equiv_options(\nequiv_cells                = {{schematic_cell = \"string\",\nlayout_cell    = \"string\",\nignore         = true | false,\nflatten        = true | false,\npreserve_equiv = {DEVICES_LEVELED_OUT,\nIMBALANCED_EQUIV}},\n...},\ndelete_layout_instances     = {\"string\", ...},               //optional\ndelete_schematic_instances  = {\"string\", ...},               //optional\nequate_nets                = {{schematic_net = \"string\",\nlayout_net    = \"string\"},\n...},                         //optional\nschematic_static_devices   = {\"string\", ...},               //optional\nschematic_static_nets      = {\"string\", ...},               //optional\nlayout_static_devices      = {\"string\", ...},               //optional\nlayout_static_nets         = {\"string\", ...},               //optional\nstatic_ports               = NONE  | ALL_PORTS,              //optional\nschematic_swappable_ports  = {{\"string\", ...}, ...}         //optional\nmetacharacter_match_mode    = FULL_NAME | ALL                 //optional\n);", "returns": "void\nequiv_options()", "arguments": {"equiv_cells": "Required. Specifies a list of schematic and layout cell name pairs either used or\nignored as equivalence points for comparison.\n\u2022 schematic_cell  and layout_cell. Specifies a user-intended equivalence\ncell pairing. See the\nlvs_options()  function for a description of user-\nintended versus system-generated equivalence cell pairings.\nIf only the schematic_cell  option name is specified, both cell names are\nassumed to be the same. String matching using metacharacters is allowed\nfor the cell names. See\nString Matching  for more information.\n\u25e6 If ignore = true, non-metacharacters are not required in the\nschematic_cell  and corresponding layout_cell  names.\n\u25e6 If ignore = false, at least one non-metacharacter is required in the\nschematic_cell  and corresponding layout_cell  names.\n\u2022 ignore. Specifies whether the equiv_cells  pair should be used as an\nequivalence point for comparison. The default is false.\n\u25e6 true. Ignores the equiv_cells  pair as an equivalence point for\ncomparison, regardless of whether the pair is explicitly specified\nor automatically generated by the generate_user_equivs  and\ngenerate_system_equivs  arguments of the lvs_options()  function.\n\u25e6 false. Uses the equiv_cells  pair as an equivalence point for\ncomparison.\n\u2022 flatten. Specifies whether the equiv_cells  pair should be flattened for\ncomparison. The default is false.\n\u25e6 true. Forces all child user equivalence and system equivalences under\nequiv_cells  to explode during comparison.\n\u25e6 false. Does not force all child user equivalence and system\nequivalences under equiv_cells  to explode during comparison.\n\u2022 preserve_equiv. Preserves imbalanced equivalence cells from being\nexploded and equivalences with devices leveled out from being ignored.\n\u25e6 DEVICES_LEVELED_OUT. Specifies that the equivalence is not ignored if it\nhas a device that is leveled out. Comparison is preserved.\n\u25e6 IMBALANCED_EQUIV. Specifies that the equivalence is not exploded if it is\nimbalanced.\nequiv_options()", "delete_layout_instances": "Optional. Specifies the ignored instances in the layout netlist. For each instance\nname in the list, that instance and all data hierarchically beneath it are deleted.", "delete_schematic_instances": "Optional. Specifies the ignored instances in the schematic netlist. For each\ninstance name in the list, that instance and all data hierarchically beneath it are\ndeleted.", "equate_nets": "Optional. Specifies a list of the net names in the schematic cell to equate with\nnet names in the layout cell.", "schematic_static_devices": "Optional. Specifies the schematic devices that are neither merged nor filtered.", "schematic_static_nets": "Optional. Specifies the schematic nets for which neither merging nor filtering is\nperformed if it would cause the nets to be removed.", "layout_static_devices": "Optional. Specifies the layout devices that are neither merged nor filtered.", "layout_static_nets": "Optional. Specifies the layout nets for which neither merging nor filtering is\nperformed if it would cause the nets to be removed.", "static_ports": "Optional. Specifies whether the ports are static for cells below the top cell. Ports\non the top cell are always static. The default is NONE.\n\u2022 NONE. Uses the settings of the push_down_pins  and remove_dangling_net\narguments of the\ncompare()  function to determine whether the ports of\nthe equivalences specified by the equiv_cells  argument are merged or\nremoved.\n\u2022 ALL_PORTS. Does not use the settings of the push_down_pins  and\nremove_dangling_net  arguments of the compare()  function to determine\nwhether the ports of the equivalences specified by the equiv_cells\nargument are merged or removed. That is, all ports of the equivalences\nspecified by the equiv_cells  argument are static and neither merged nor\nremoved.\nequiv_options()", "schematic_swappable_ports": "Optional. Specifies a list of the port names that are treated as being logically\nequivalent for comparison purposes at higher levels of the design hierarchy.", "metacharacter_match_mode": "Optional. Specifies the required matching mode. The default is ALL.\n\u2022 FULL_NAME. Specifies the name-matched equivalence pairs based on a given\nwildcard name.\n\u2022 ALL. Specifies the names of multiple equivalence pairs."}, "summary": "The equiv_options()  function specifies user-intended pairings of cells in the schematic\nand layout netlists for comparison.", "function_name": "equiv_options()"}
{"description": "The error_merge()  function converts an error layer to a polygon layer.", "syntax": "error_merge(\nlayer1              = error_layer,\noutput_type         = REGION  | CENTERLINE | EXTENTS,         //optional\nwidth              = double,                                //optional\nline_touch_shape   = OUTSIDE  | INSIDE | BOTH,               //optional\nname               = \"layer_label\",                         //optional\npoint_touch_shape   = EXTENTS  | SQUARE,                      //optional\nshape_size          = double                                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the error layer from which polygons are selected.", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Outputs spacing violations as an expanded line at the center of\nthe projection region. The midpoints of the sides of the violation region form\na line that is expanded in both directions by width/2. When the output_type\nargument is CENTERLINE, only parallel spacing and intersection angles are\nsupported.\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when the extension  argument is\nRADIAL  or SQUARE.\nerror_merge()\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  argument value\non both sides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  argument value. Violations are oriented along\nthe line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nSee the examples for the output_type  argument of the\nenclose()  function for\nmore information.", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nargument is the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default\nis .001.\nSee the examples for the width  argument of the enclose()  function for more\ninformation.", "line_touch_shape": "Optional. Specifies how to expand a line-touch edge violation into a polygon.\nUse the line_touch_shape  argument only with error layers that come from a\ntwo-layer spacing check. The default is OUTSIDE.\n\u2022 OUTSIDE. Outputs a line-touch polygon outside of the dimensional function\nlayer1  polygon. The output polygon size equals the value of the width\nargument.\n\u2022 INSIDE. Outputs a line-touch polygon inside of the layer1  layer. The output\npolygon size equals the value of the width  argument.\n\u2022 BOTH. Outputs a line touch polygon inside and outside of the layer1  layer.\nThe total output size is 2*width.\nerror_merge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance  constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of\nthe spacing distance. This value must be positive. It is rounded to the\nnearest even multiple of the internal resolution, with a minimum value of\ntwice the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution."}, "summary": "The error_merge()  function converts an error layer to a polygon layer.", "function_name": "error_merge()"}
{"description": "The error_merge_edge()  function converts an error layer to an edge layer.", "syntax": "error_merge_edge(\nlayer1                    = error_layer,\noutput_layer              = LAYER1  | LAYER2,                 //optional\noutput_type              = FAIL  | POINT_TO_POINT,           //optional\nedge_to_edge_output_type = FAIL  | CENTERLINE,               //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the error layer from which polygons are selected.", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nNote:\nWhen the layer1  error layer is from a one layer spacing check,\nsetting the output_layer  argument to LAYER2  produces an empty\nlayer.\nSee the examples for the output_layer  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions for more information.", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\nNote:\nThe output_type  argument is applicable only to corner errors, that\nis, those errors that come from a *corner_error()  function.\nerror_merge_edge()\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. Edge endpoints are ordered from\nlayer1  to layer2. POINT_TO_POINT  creates an orphan edge layer.", "edge_to_edge_output_type": "Optional. Specifies the type of output generated. The default is FAIL.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Specifies that spacing violations are output as a line at the\ncenter of the projection region. A line is two points connected with no specific\norder. The midpoints of the sides of the violation region are used to create\nthe lines.\nOnly parallel spacing and intersection angles are supported, and those\nerrors must come from external1_error(), external2_error(),\ninternal1_error(), internal2_error(), or enclose_error().", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The error_merge_edge()  function converts an error layer to an edge layer.", "function_name": "error_merge_edge()"}
{"description": "The error_merge_list()  function creates a polygon layer by converting and merging a\nlist of error layers.", "syntax": "error_merge_list(\nlayers                    = {error_layer, ...},\nname                     = \"layer_label\"           //optional\n);", "returns": "polygon layer or void", "arguments": {"layers": "Required. Specifies the error layers to be converted.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The error_merge_list()  function creates a polygon layer by converting and merging a\nlist of error layers.", "function_name": "error_merge_list()"}
{"description": "The error_merge_list_edge()  function creates an edge layer by converting and\nmerging a list of error layers.", "syntax": "error_merge_list_edge(\nlayers                    = {error_layer, ...},\noutput_type               = EDGE  | CENTERLINE\nSHORTEST_LINK | CENTER_LINK |\nCENTERLINE_EDGE,                 //optional\nname                     = \"layer_label\"                    //optional\n);", "returns": "edge layer or void", "arguments": {"layers": "Required. Specifies the error layers to be converted.", "output_type": "Optional. Specifies how the errors are converted to edges. The default is EDGE.\n\u2022 EDGE. Specifies if the violation edge pair is output.\n\u2022 CENTERLINE. Creates a single line at the center of the projection region. A\nline is two points connected with no specific order. The midpoints of the sides\nof the violation region are used to create the line.\n\u2022 SHORTEST_LINK. Creates a single line that connects the shortest distance\nbetween the violation edge pair.\n\u2022 CENTER_LINK. Creates a single line that connects the center points of the\nviolation edge pair.\n\u2022 CENTERLINE_EDGE. Creates a single edge at the center of the projection\nregion. The direction of the edge is arbitrary. The midpoints of the sides of\nthe violation region are used to create the edge.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nerror_merge_list_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The error_merge_list_edge()  function creates an edge layer by converting and\nmerging a list of error layers.", "function_name": "error_merge_list_edge()"}
{"description": "The error_options()  function specifies the error output for the design being verified.\nIf you are classifying DRC errors, use these arguments:\nmatch_errors\nmustfix_errors\ncomment_match_delimiter\nSee the DRC Error Classification chapter in the IC Validator User Guide  for more\ninformation.", "syntax": "error_options(\nerror_limit_per_check        = integer,                     //optional\ndb_path                      = \"string\",                    //optional\npcell_list                   = {\"string\", ...},             //optional\ncreate_vue_output            = true | false,                //optional\ncomment_match_delimiter      = \"string\",                    //optional\nmatch_errors   = {{db_name                 = \"string\",\ndb_path                 = \"string\",\nsuppress_matched_errors = {\"string\", ...},\nreport_unmatched_errors = true | false,\nmissing_db              = ERROR  | IGNORE},\n...},                                     //optional\nmustfix_errors               = {{violation_comments = {\"string\", ...},\ncells = {\"string\", ...}},\n...},                       //optional\nreport_layout_errors          = {HIERARCHICAL, TOP},         //optional\nreport_empty_violations      = true | false,                //optional\nreport_flat_violation_count  = true | false,                //optional\nclean_classifications        = {\"string\", ...},             //optional\nmatch_errors_processing_mode = CELL_LEVEL | HIERARCHICAL,   //optional\ncreate_lvs_short_output       = true | false,                //optional\ndemagnify_errors              = true | false,                //optional\nviolation_options        = {{violation_comments = {\"string\", ...},\nmatch_errors_processing_mode =\nCELL_LEVEL | HIERARCHICAL |\nUNSPECIFIED,         //optional\nmatch_errors_tolerance = double,         /\n/optional\nerror_limit_per_check\n= integer,         //optional\nerror_sampling_per_check\n= integer,         //optional\n...},                            //optional\nerror_options()\nrule_name_delimiter      = {search_string = \"string\",\nignore_case = true | false},     //optional\nreport_error_details         = true  | false,                //optional\nflatten_violations           = {\"string\", ...},             //optional\nflatten_violations_limit     = integer,                     //optional\nmatch_errors_tolerance       = double,                      //optional\nmatch_renamed_cells          = USE_NEW_NAME  | USE_ORIGINAL_NAME,\n//optional\nclassify_by_layer = {{violation_comments     = {\"string\", ...},\nclassification         = \"string\",\nclassification_comment = \"string\",    //optional\ncells                  = {\"string\", ...},\n//optional\nldt_list               = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...},\n//optional\nambit                  = double,      //optional\nhalo                   = {outside = double,\ninside  = double},\n//optional\nrelationship           =  ENCLOSE |\nINTERACT\n|\nNOT_ENCLOSE |\nNOT_INTERACT,\n//optional\ninclude_touch          = NONE | EDGE |\nALL,\n//optional\ndirectional_ambit = {north         = double,\nsouth         = double,\neast          = double,\nwest          = double,\n//optional\ndirectional_halo  = {outside_north = double,\ninside_north  = double,\noutside_south = double,\ninside_south  = double,\noutside_east  = double,\ninside_east   = double,\noutside_west  = double,\ninside_west   = double},\n//optional\nlibraries         = {library,...}      //optional\n}},\nsuppress_by_layer = {{violation_comments     = {\"string\", ...},\ncells                  = {\"string\", ...},\n//optional\nldt_list               = {\n{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint}, ...},\n//optional\nambit                  = double,      //optional\nerror_options()\nhalo                   = {outside = double,\ninside  = double},\n//optional\nrelationship           = ENCLOSE |\nINTERACT  |\nNOT_ENCLOSE |\nNOT_INTERACT,\n//optional\ninclude_touch          = NONE | EDGE |\nALL,\n//optional\ndirectional_ambit = {north         = double,\nsouth         = double,\neast          = double,\nwest          = double},\n//optional\ndirectional_halo  = {outside_north = double,\ninside_north  = double,\noutside_south = double,\ninside_south  = double,\noutside_east  = double,\ninside_east   = double,\noutside_west  = double,\ninside_west   = double},\n//optional\nlibraries         = {library, ...}     //optional\n}},\npartially_exploded_cells = KEEP | EXPLODE,                  //optional\nerror_sampling_per_check = integer,                         //optional\noutput_violation_shapes  = {NET_POLYGON, DEVICE_BODY},      //optional\nheat_map_cells           = {\"string\", ...},                 //optional\nexplode_violations        = {\"string\", ...},                 //optional\nstop_check_at_error_limit  = true  | false,                   //optional\nmerge_spacing_violations   = true | false,                   //optional\npolygon_limit_per_net      = integer,                        //optional\ndatabase_error             = WARN  | ABORT,                   //optional\nreport_error_details_limit_per_check  = 100000,              //optional\nlayout_error_files         = {\n{file_suffix = \"string\",\nlabel = \"string\",\nviolation_comments = {\"string\", ...},\nviolation_names = {\"string\", ...}\n}\n},       //optional\nprimary_layout_errors_file_label  = \"string\",    //optional\nperc_vue_reclassify_file         = \"string\"     //optional\n);", "returns": "void\nerror_options()", "arguments": {"error_limit_per_check": "Optional. Specifies the\nerrorsreporting allerrorsmaximum number ofERROR_LIMIT_MAXerror limitlimiting errorsreporting all errors\nmaximum number of errors, per function, stored in\nthe error database and the LAYOUT_ERRORS file. Setting this argument to\nERROR_LIMIT_MAX  causes all errors up to a tool-defined maximum limit to be\nstored. The limit can be set above the tool-defined maximum limit by giving a\nspecific number. However, setting the limit above the tool-defined maximum\nmight result in decreased performance and increased disk usage for large\nnumbers of errors, and therefore is not recommended. Setting it to 0  suppresses\nstorage of all errors. The default is 100.\nNote:\nIf error_limit_per_check = 0  and errors were found during the\nrun, the LAYOUT_ERRORS file notes that errors were found but error\noutput was suppressed.\nNote:\nSee the error_sampling_per_check  argument for a more\neven distribution of errors that are selected across the chip. The\nerror_sampling_per_check  argument takes precedence over the\nerror_limit_per_check  argument if both are set.", "db_path": "db_path, settingerror databaselocationerror databasenamePYDB, see error database\nOptional. Specifies the location where the error database (PYDB) is stored. The\ndefault is \"run_details/pydb\". To change the run_details directory, use the\n-rd  command-line option.\nThe error database file name is PYDB_top-cell.", "pcell_list": "Optional. Specifies the list of pcell cell names.", "pcell": "Use this argument when\nrunning on a streamout file from OpenAccess, where the error output is viewed\nrelative to the OpenAccess database. Cells are exploded into their parent\nso that no errors are reported in parameterized cells. String matching using\nmetacharacters is allowed. See\nString Matching  for more information.", "create_vue_output": "Optional. Specifies if output for VUE is generated. When the\ncreate_vue_output  argument is true, the IC Validator tool generates all output\ndata required to run VUE. You can also enable generation of VUE output with\nthe -vue  command-line option. The default is false.\nerror_options()", "comment_match_delimiter": "Optional. Specifies a delimiter string for violation comment matching in imported\nerror classification databases. If a delimiter string is specified, a violation\ncomment from the runset is considered equivalent to any violation in the error\nclassification database that matches up to the first occurrence of the delimiter\nstring.", "match_errors": "Optional. Lists the error classification databases to import for DRC error\nclassification matching. The order of this list specifies the match precedence. By\ndefault, the IC Validator tool does not import any error classification databases.\nNote:\nEach error classification database that is specified requires its own\nserver process. Therefore, you must ensure that your shell process\nlimit is high enough. Enter \u201climit maxproc\u201d in your UNIX shell to obtain\nthe maximum number of processes for the shell. A guideline is to\nensure that the maximum process limit is three times the number of\nthe error classification databases used in the run.\nSee the Database Naming Conventions section in the DRC Error Classification\nchapter of the IC Validator User Guide  for more information.\n\u2022 db_name. Required. Specifies the error classification database name.\n\u2022 db_path. Required. Specifies the error classification database path.\n\u2022 suppress_matched_errors. Optional. Specifies if errors that are classified\nfrom this error classification database are to be suppressed. This argument\naccepts a list of strings that represent the error classifications which are to\nbe suppressed. String matching using metacharacters is allowed. See\nString\nMatching  for more information. By default, the IC Validator tool does not\nsuppress matched errors.\nFor example, to suppress all errors that match Waive or Ignore classifications\nfrom this error classification database:\nsuppress_matched_errors = {\"Waive\",\"Ignore\"}\nTo suppress all errors from this error classification database:\nsuppress_matched_errors = {\"*\"}\nThe default is that no errors are suppressed.\n\u2022 report_unmatched_errors. Optional. Specifies if the IC Validator tool\ncreates a new violation. When set to true, the IC Validator tool creates a\nnew violation for any errors that exist in this error classification database\nerror_options()\nbut are not produced during the run. This behavior applies only to violations\nand cells that are part of the run. The resulting errors are classified as\nUnmatched. The default is false.\n\u2022 missing_db. Optional. Specifies the behavior when the IC Validator tool\ndoes not find the specified error classification database. The default is\nERROR.\n\u25e6 ERROR. Stops the IC Validator run with an error if the tool cannot find the\nerror classification database.\n\u25e6 IGNORE. Continues the IC Validator run if the tool cannot find the error\nclassification database.", "mustfix_errors": "Optional. Lists the violations and cells that must be fixed. Any errors that occur\nin a must-fix violation or cell cannot be classified as Waive or Ignore. By default,\nno violations or cells are must-fix.\n\u2022 violation_comments. Optional. Specifies the strings for the violation\ncomments that are must-fix. String matching using metacharacters is\nallowed. See\nString Matching  for more information. By default, all violations\nmust be fixed.\n\u2022 cells. Optional. Specifies the strings for the cell names that are must-fix.\nString matching using metacharacters is allowed. See String Matching  for\nmore information. By default, all cells must be fixed.", "report_layout_errors": "Optional.\nLAYOUT_ERRORS report, options affectingTOP_LAYOUT_ERRORS report, options affecting\nSpecifies the layout error reports that are generated at the end of the\nrun. The default is HIERARCHICAL, which generates only the hierarchical report.\nIf you want to generate both files, list both options:\nreport_layout_errors = {HIERARCHICAL, TOP} //Creates\nLAYOUT_ERRORS and\n//TOP_LAYOUT_ERRORS", "reports": "If you do not want either file, use an empty list:\nreport_layout_errors = {}  //Creates neither LAYOUT_ERRORS nor\n//TOP_LAYOUT_ERRORS reports\n\u2022 HIERARCHICAL. Generates the hierarchical cell.LAYOUT_ERRORS\ncell.LAYOUT_ERRORS, generating\nreport.\nCoordinates are reported at the cell level.\n\u2022 TOP. Generates the cell.TOP_LAYOUT_ERRORS\ncell.TOP_LAYOUT_ERRORS, generating\nreport. Coordinates are\nreported in the top cell of the design.\nerror_options()\nNote:\nTOP  is not a flat reporting option. Instead of reporting errors one\ntime inside a lower-level cell, errors are reported one time in the\ntop cell over a single instance of the lower-level cell. Errors are not\nreported for all instances of a lower-level cell.", "report_empty_violations": "Optional.\nzero errors, reportingerrors, reporting zeroviolations, reporting zero\nSpecifies if the ERROR SUMMARY section of the LAYOUT_ERRORS\nfile includes rules that produced zero errors as well as rules that were not\nexecuted. The following command-line options can cause rules to not execute:\n-il, -iln, -svn, -svc, -uvn, -uvc, -sfn, -ufn, and -ro. The default is false.\n\u2022 true. Specifies that the ERROR SUMMARY section of the\nLAYOUT_ERRORS file reports rules that have zero violations as well as\nrules that were not executed.\nNote:\nRules with zero violations are reported only if there is a runset-\ndefined violation comment.\n\u2022 false. Does not report rules that have zero violations.\nFor example,\n952  Rule1\n953    external2 ................................. 0 violations\nfound.\n954    and ....................................... 0 violations\nfound.\n956  Rule2\n957    internal1 ................................. 0 violations\nfound.\n959  Rule3                                         Not executed.\n961  Rule4                                         Not executed.\n963  Rule5                                         Not executed.", "report_flat_violation_count": "Optional. Specifies if the ERROR SUMMARY section of the LAYOUT_ERRORS\nfile includes a flat count\nflat count\nof the violations. The default is false.\nThe flat count is the number of errors in a cell multiplied by the number of flat\nplacements of that cell. The flat count in the LAYOUT_ERRORS report is the\ncount before the error limit per check is applied.\nerror_options()\nNote:\nThis does not flatten any of the error coordinates.\n\u2022 true. Specifies that the ERROR SUMMARY section of the\nLAYOUT_ERRORS file reports the flat count.\n\u2022 false. Does not report the flat count.", "clean_classifications": "Optional. Determines how error classification affects the clean status of the\nlayout reported in the LAYOUT_ERRORS file. If all reported errors are of the\nclassifications in this list, the LAYOUT_ERRORS file reports the layout as clean.\nIf there are any unclassified errors or if there are any errors whose classification\nis not in this list, the layout is not reported as clean.\nThis argument does not affect how errors are listed in the LAYOUT_ERRORS\nfile; it affects only the clean status of the layout. The default is an empty list,\nwhich means that any reported error causes an error result.\nThe classifications are:\nIgnore\nWaive\nWatch\nFixed\nUnmatched\nNote:\nThese classifications are the same as those listed in the Error\nClassifications  table in the IC Validator VUE User Guide, except that\nError is not valid as a clean classification.\nThis list of classifications applies to all errors including those reported from", "the": "library()  or library_import()  function.\nerror_options()\nNote:\nThe list must contain only one library.\nThe libraries  option is required if you use the library_import()  function\nand the option is prohibited if you do not use the library_import()\nfunction.", "match_errors_processing_mode": "Optional. Specifies if the IC Validator tool uses cell level or hierarchical\nprocessing to match classified violations in an error classification database. The\ndefault is HIERARCHICAL.\n\u2022 CELL_LEVEL. Matches individual errors from the IC Validator run with\nclassified errors from the cPYDB at the cell level.\nNote:\nThe CELL_LEVEL  mode puts restrictions on hierarchy optimization.\nIn particular, cells with classified errors in the cPYDB are\nmarked as no explode. Also, setting the flow  argument of the\nhierarchy_auto_options()  function to ERROR_CLASSIFICATION\nis recommended for this mode. This setting further restricts\nhierarchy optimization to ensure the best chance of matching\nerrors.\n\u2022 HIERARCHICAL. Hierarchically matches errors from the IC Validator run with\nclassified errors from the cPYDB. This mode puts no restrictions on hierarchy\noptimization. Cells that have classified errors in the cPYDB are allowed to\nexplode. This is the default.\nNote:\nSetting the partially_exploded_cells  argument of the\nerror_options()  function to EXPLODE  is recommended for\nHIERARCHICAL  error classification, especially for the initial\nIC Validator run used to create the error classification database.\nUsing this argument ensures that errors are reported in cells\nfor which the IC Validator tool has kept all placements from the\noriginal design hierarchy.\nAn error is considered a match for a classified error from the cPYDB if\nthe complete hierarchically-formed shape of the errors produced by the\nIC Validator tool exactly overlaps the complete hierarchically-formed shape of\nerrors from the cPYDB with the same classification.\nErrors can also be matched individually when possible. That is, when a\nsingle error, rather than the complete hierarchically-formed shape consisting\nof multiple errors, exactly overlaps a corresponding single error in the\ncPYDB, it is considered a match.\nerror_options()\nConflicts when an error matches multiple cPYDB errors are resolved as\nfollows:\n\u25e6 A match within the same cell takes priority over a match from a different\nlevel of hierarchy.\n\u25e6 A match from a cPYDB specified in the match_errors  argument list\ntakes priority over one from a cPYDB, which is specified later.\n\u25e6 A match in a non-suppressed class takes priority over a match in a\nsuppressed class. See the suppress_matched_errors  option of the\nmatch_errors  argument.\n\u25e6 Any further conflict resolution is arbitrary.", "create_lvs_short_output": "Optional. Enables the generation of interactive LVS short finder output. A\nmaximum of 200 shorts are reported. The default is false. See the IC Validator\nVUE User Guide  for more information about LVS Short Finder.\nThe -create_lvs_short_output  command-line option also creates LVS short\nfinder output. With the command-line option you can specify to report only a\nset number of shorts or all shorts. See the Command-Line Options section\nin the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more\ninformation.\nA cellname.vue file is created. The output is in the ./run_details/short_out_db\ndirectory.", "demagnify_errors": "Optional. Specifies if the input library magnification factor is reversed for error\ncoordinates in the LAYOUT_ERRORS file. (See the magnification_factor\nargument of the\nlibrary()  function.) The default is false.\n\u2022 true. Divides the error coordinates in the LAYOUT_ERRORS file by the\ninput library magnification factor. That is, the errors are found at the runset\nmagnification, but written to the LAYOUT_ERRORS file at the input library\nmagnification.\n\u2022 false. Does not divide the error coordinates in the LAYOUT_ERRORS file\nby the input library magnification factor. That is, errors are found at the runset\nmagnification and also written to the LAYOUT_ERRORS file at the runset\nmagnification.", "violation_options": "Optional. Allows global settings from the error_options()  function to be\noverridden for specified violation comments.\nerror_options()\n\u2022 violation_comments. Required. Lists the violations that these settings\napply to. String matching using metacharacters is allowed. See String\nMatching  for more information.\n\u2022 match_errors_processing_mode. Optional. Specifies how errors are\nmatched for DRC error classification for the specified violation comments.\nSee the\nmatch_errors_processing_mode  argument for more information\nabout the two modes. The default is CELL_LEVEL.\n\u25e6 CELL_LEVEL. Matches individual errors from the IC Validator run with\nclassified errors from the cPYDB at the cell level.\n\u25e6 HIERARCHICAL. Hierarchically matches errors from the IC Validator run\nwith classified errors from the cPYDB.\n\u25e6 UNSPECIFIED. Uses the value of the match_errors_processing_mode\nargument of the error_options()  function. This is the default.\n\u2022 match_errors_tolerance. Optional. Specifies a tolerance to be used when\nmatching error shapes for DRC error classification. The default is to use the\nmatch_errors_tolerance  argument of the error_options()  function.\n\u2022 error_limit_per_check. Optional. Overrides the setting of error_options\nfor the specified violation comments. The default is to use the value of\nerror_options.\n\u2022 error_sampling_per_check. Optional. Overrides the setting of\nerror_options  for the specified violation comments. The default is to use\nthe value of error_options.", "rule_name_delimiter": "Optional. Defines a delimiter for rule names. Use this argument to display the\nrule name rather than the full violation comment in the verbose results file and\nin VUE. The violation comment is truncated at the first instance of this delimiter.\nIf the delimiter is not matched, the entire violation comment is displayed. The\nviolation comment might be truncated for length; the maximum length of a\nviolation comment is 1024 characters.\n\u2022 search_string. Specifies the delimiter. The search string must be a GNU\nextended regular expression. The default is\n\"[[:space:]]+:|[[:space:]]*:[[:space:]]\"\nThat is, the default is one of the following:\n\u25e6 One or more white space characters followed by a colon.\n\u25e6 Zero or more white space characters followed by a colon followed by one\nwhite space character.\nerror_options()\n\u2022 ignore_case. Specifies if the character case in the violation comment is\nconsidered when matching the delimiter. The default is false.\n\u25e6 true. The search is case-sensitive.\n\u25e6 false. The search is not case-sensitive.", "report_error_details": "Optional. Specifies if violation details are reported to the LAYOUT_ERRORS\nand TOP_LAYOUT_ERRORS files. The default is true.\n\u2022 true. Reports violation details to the LAYOUT_ERRORS and\nTOP_LAYOUT_ERRORS files.\n\u2022 false. Does not report violation details to the LAYOUT_ERRORS and\nTOP_LAYOUT_ERRORS files. The information is still stored in the error\ndatabase (PYDB), but only the violation summary section is written to the\nLAYOUT_ERRORS file.\nNote:\nYou can also use the -ned  command-line option to set the value to\nfalse. See the Command-Line Options section in the \u201cIC Validator\nBasics\u201d chapter of the IC Validator User Guide  for more information.", "flatten_violations": "Optional. Flattens the violation output under the specified cells into the specified\ncells. String matching using metacharacters is allowed. See\nString Matching\nfor more information. By default, the IC Validator tool does not flatten violation\noutput.\nNote:\nThe flatten_violations  argument can place limitations on\nautomatic hierarchy optimizations, which can affect performance.\nAvoid wildcard usage, which might select more cells than necessary.", "flatten_violations_limit": "Optional. Specifies that if flattening violation output for a particular function,\naccording to the flatten_violations  argument, increases the violation count\nby more than this limit, no violation flattening is performed for that function, and\na warning is reported. The default is 1000000.", "match_errors_tolerance": "Optional. Specifies a tolerance in microns to be used when matching interacting\nclassified error shapes from the cPYDB to error shapes generated by the current\nIC Validator run. The default is 0  (zero), which means that the shapes must\nmatch exactly for the classifications to be applied.\nerror_options()", "match_renamed_cells": "Optional. When the IC Validator tool renames cells while reading Milkyway,\nNDM, or OpenAccess layouts to avoid conflicts between cells of the same name\nin different libraries, this argument specifies whether to use the original layout\nname or the new unique name when searching error classification databases for\nclassified errors, and when exporting classified errors using pydb_export. The\ndefault is USE_NEW_NAME.\n\u2022 USE_NEW_NAME. For renamed cells, the new unique name given by the tool is\nused for error classification.\n\u2022 USE_ORIGINAL_NAME. For renamed cells, the original layout name is used for\nerror classification.\nNote:\nEnsure that the contents of the cells are identical before using this\nargument.", "classify_by_layer": "Optional. Specifies error classifications to be applied based on polygon shapes.\n\u2022 violation_comments. Required. Specifies a list of violation comments\nfor which this particular error classification is applied. String matching with\nmetacharacters is supported.\n\u2022 classification. Required. Specifies the error classification to be applied to\nerror shapes that interact with classification shapes.\nThe valid classifications for this option are:\nIgnore\nWaive\nWatch\nFixed\n\u2022 classification_comment. Optional. Specifies the comment to be used for\nerror classification. The default is that no comment is used.\n\u2022 cells. Optional. Specifies a list of cells from which the classification shapes\nare derived. The default is all cells. If the ldt_list  option is specified, the\nlayout shapes are used only from the cells listed, and at cell level. Otherwise,\nthe cell data extents of the cells listed are used to derive the classification\nshapes.\nerror_options()\n\u2022 ldt_list. Optional. Specifies a list of layer and datatype ranges that specify\na drawn layer to be used for classification shapes. The default is to use cell\ndata extents to derive classification shapes.\n\u2022 ambit. Optional. Specifies that classification shapes are oversized or\nundersized by the specified amount. The default is no ambit. Only one of the\nambit, halo, directional_ambit, or directional_halo  arguments can be\nspecified.\n\u2022 halo. Optional. Specifies that classification shapes are used to derive a halo\nor ring using the specified inside or outside distances. The default is no halo.\nOnly one of the ambit, halo, directional_ambit, or directional_halo\narguments can be specified.\n\u25e6 inside. Specifies that classification shapes derive a halo or ring using\nthe specified inside distance.\n\u25e6 outside. Specifies that classification shapes derive a halo or ring using\nthe specified outside distance.\n\u2022 relationship. Optional. Specifies the type of polygon interactions to\nconsider for classification. The default is INTERACT.\n\u25e6 ENCLOSE. Specifies that the error shape must be fully enclosed by the\nclassification shape for classification to be applied.\n\u25e6 INTERACT. Specifies that the interaction between the error shape and\nthe classification shape determines the classification to be applied. The\ninclude_touch  argument specifies the level of interaction that applies\nclassification in the case of outside touches.\n\u25e6 NOT_ENCLOSE. Specifies that the violations which are not enclosed by the\nclassification layer polygons are suppressed.\n\u25e6 NOT_INTERACT. Specifies that the violations which do not interact with the\nclassification layer polygons are suppressed.\n\u2022 include_touch. Optional. Specifies the outside touches that are included in\nthe interaction check when applying classification. The default is ALL.\n\u25e6 NONE. Includes neither point touch or line touch.\n\u25e6 EDGE. Includes edge touch.\n\u25e6 ALL. Includes all touches (edge and point).\n\u2022 directional_ambit. Optional. Specifies that classification shapes are\noversized or undersized by the specified amount in the specified directions.\nThe default is no ambit. Only one of the ambit, halo, directional_ambit,\nor directional_halo  arguments can be specified.\nerror_options()\nNote:\nThe grow()  and shrink()  functions are used to derive the\ndirectional ambit, so any behavior of these functions also applies\nto the derivation of the directional_ambit  argument.\n\u25e6 north. Specifies that the classification shapes are oversized or\nundersized in the north direction by the specified amount.\n\u25e6 south. Specifies that the classification shapes are oversized or\nundersized in the south direction by the specified amount.\n\u25e6 east. Specifies that the classification shapes are oversized or undersized\nin the east direction by the specified amount.\n\u25e6 west. Specifies that the classification shapes are oversized or undersized\nin the west direction by the specified amount.\n\u2022 directional_halo. Optional. Specifies that classification shapes are used\nto derive a halo or ring using the specified inside or outside distances in the\nspecified directions. The default is no halo. Only one of the ambit, halo,\ndirectional_ambit, or directional_halo  arguments can be specified.\nNote:\nThe grow()  and shrink()  functions are used to derive the\ndirectional ambit, so any behavior of these functions also applies\nto the derivation of the directional_ambit  argument.\n\u25e6 outside_north. Specifies that classification shapes derive a halo or ring\nusing the specified outside distance in the north direction.\n\u25e6 inside_north. Specifies that classification shapes derive a halo or ring\nusing the specified inside distance in the north direction.\n\u25e6 outside_south. Specifies that classification shapes derive a halo or ring\nusing the specified outside distance in the south direction.\n\u25e6 inside_south. Specifies that classification shapes derive a halo or ring\nusing the specified inside distance in the south direction.\n\u25e6 outside_east. Specifies that classification shapes derive a halo or ring\nusing the specified outside distance in the east direction.\n\u25e6 inside_east. Specifies that classification shapes derive a halo or ring\nusing the specified inside distance in the east direction.\nerror_options()\n\u25e6 outside_west. Specifies that classification shapes derive a halo or ring\nusing the specified outside distance in the west direction.\n\u25e6 inside_west. Specifies that classification shapes derive a halo or ring\nusing the specified inside distance in the west direction.\n\u2022 libraries\nOptional. Specifies the libraries. The library is defined by the return value of", "suppress_by_layer": "Optional. Specifies error suppressions to be applied based on polygon shapes.\n\u2022 violation_comments. Required. Specifies a list of violation comments\nfor which this particular error suppression is applied. String matching with\nmetacharacters is supported.\n\u2022 cells. Optional. Specifies a list of cells from which the suppression shapes\nare derived. The default is all cells. If the ldt_list  option is specified, the\nlayout shapes are used only from the cells listed, and at cell level. Otherwise,\nthe cell data extents of the cells listed are used to derive the suppression\nshapes.\n\u2022 ldt_list. Optional. Specifies a list of layer and datatype ranges that specify\na drawn layer to be used for suppression shapes. The default is to use cell\ndata extents to derive suppression shapes.\n\u2022 ambit. Optional. Specifies that suppression shapes are oversized or\nundersized by the specified amount. The default is no ambit. Only one of the\nambit, halo, directional_ambit, or directional_halo  arguments can be\nspecified.\n\u2022 halo. Optional. Specifies that suppression shapes are used to derive a halo\nor ring using the specified inside or outside distances. The default is no halo.\nOnly one of the ambit, halo, directional_ambit, or directional_halo\narguments can be specified.\nerror_options()\n\u25e6 inside. Specifies that suppression shapes derive a halo or ring using the\nspecified inside distance.\n\u25e6 outside. Specifies that suppression shapes derive a halo or ring using\nthe specified outside distance.\n\u2022 relationship. Optional. Specifies the type of polygon interactions to\nconsider for suppression. The default is INTERACT.\n\u25e6 ENCLOSE. Specifies that the error shape must be fully enclosed by the\nsuppression shape for the error to be suppressed.\n\u25e6 INTERACT. Specifies that the interaction between the error shape\nand the suppression shape causes the error to be suppressed.\nThe include_touch  argument specifies the level of interaction that\nsuppresses errors in the case of outside touches.\n\u25e6 NOT_ENCLOSE. Specifies that the violations which are not enclosed by the\nclassification layer polygons are suppressed.\n\u25e6 NOT_INTERACT. Specifies that the violations which do not interact with the\nclassification layer polygons are suppressed.\n\u2022 include_touch. Optional. Specifies the outside touches that are included in\nthe interaction check when suppressing errors. The default is ALL.\n\u25e6 NONE. Includes neither point touch or line touch.\n\u25e6 EDGE. Includes edge touch.\n\u25e6 ALL. Includes all touches (edge and point).\n\u2022 directional_ambit. Optional. Specifies that suppression shapes are\noversized or undersized by the specified amount in the specified directions.\nThe default is no ambit. Only one of the ambit, halo, directional_ambit,\nor directional_halo  arguments can be specified.\nNote:\nThe grow()  and shrink()  functions are used to derive the\ndirectional ambit, so any behavior of these functions also applies\nto the derivation of the directional_ambit  argument.\n\u25e6 north. Specifies that the suppression shapes are oversized or\nundersized in the north direction by the specified amount.\n\u25e6 south. Specifies that the suppression shapes are oversized or\nundersized in the south direction by the specified amount.\nerror_options()\n\u25e6 east. Specifies that the suppression shapes are oversized or undersized\nin the east direction by the specified amount.\n\u25e6 west. Specifies that the suppression shapes are oversized or undersized\nin the west direction by the specified amount.\n\u2022 directional_halo. Optional. Specifies that suppression shapes are used\nto derive a halo or ring using the specified inside or outside distances in the\nspecified directions. The default is no halo. Only one of the ambit, halo,\ndirectional_ambit, or directional_halo  arguments can be specified.\nNote:\nThe grow(), shrink(), and not()  functions are used to derive\nthe directional halo, so any behavior of these functions also\napplies to the derivation of the directional_halo  argument.\n\u25e6 outside_north. Specifies that suppression shapes derive a halo or ring\nusing the specified outside distance in the north direction.\n\u25e6 inside_north. Specifies that suppression shapes derive a halo or ring\nusing the specified inside distance in the north direction.\n\u25e6 outside_south. Specifies that suppression shapes derive a halo or ring\nusing the specified outside distance in the south direction.\n\u25e6 inside_south. Specifies that suppression shapes derive a halo or ring\nusing the specified inside distance in the south direction.\n\u25e6 outside_east. Specifies that suppression shapes derive a halo or ring\nusing the specified outside distance in the east direction.\n\u25e6 inside_east. Specifies that suppression shapes derive a halo or ring\nusing the specified inside distance in the east direction.\n\u25e6 outside_west. Specifies that suppression shapes derive a halo or ring\nusing the specified outside distance in the west direction.\n\u25e6 inside_west. Specifies that suppression shapes derive a halo or ring\nusing the specified inside distance in the west direction.\n\u2022 libraries\nOptional. Specifies the libraries. The library is defined by the return value of", "partially_exploded_cells": "Optional. Specifies where to report errors found in cells for which the\nIC Validator tool has kept only some placements in the hierarchy. The default is\nEXPLODE.\n\u2022 KEEP. Specifies that errors found in partially exploded cells are kept in the\ncell in which they are found.\n\u2022 EXPLODE. Specifies that errors found in partially exploded cells are reported\nat a higher level in the hierarchy, in a cell from the original hierarchy that has\nnot been modified by hierarchy optimization.\nNote:\nThe EXPLODE  setting is recommended for HIERARCHICAL  mode-\nerror classification flows, including the initial IC Validator run used\nto generate the error classification database.", "error_sampling_per_check": "Optional. Enables error sampling across the chip and sets the sampling\ntarget per function. With error sampling, details for a selection of errors\nare stored for each function and evenly distributed based on the total error\ncount produced by the function. The actual number of error details that\nare retained might vary, but it is near the same order of magnitude as the\nerror_sampling_per_check  target value. For example, if a function creates\n10,000 errors and error_sampling_per_check=1000, the error details are\nstored for nearly 1 in every 10 errors (10,000/1000).\nNote:\nThe error_sampling_per_check  argument takes precedence over\nthe error_limit_per_check  argument if both are set.\nThe error_sampling_per_check  argument requires the Elite, or Base\nlicensing scheme. See the Licensing and Resource Requirements  chapter in the\nIC Validator User Guide  for more information.", "output_violation_shapes": "Optional. Specifies the functions that output polygon shapes instead of points.\nThe default is no output polygon shapes.\nerror_options()\n\u2022 NET_POLYGON. Outputs polygon shapes instead of points for violations on net\npolygons for the following functions:\nnet_device_count()\nnet_path_check()\nnet_select()  (error_net_output = ONE  or ALL)\nnet_polygon_select()\nnet_property_select()  (error_net_output = ONE  or ALL)\nnet_select_inside_of_layer()\n\u2022 DEVICE_BODY. Outputs polygon shapes instead of points for violations on\ndevice body polygons for the following functions:\ndevice_connected_to()\ndevice_not_connected_to()\ndevice_net_count()\ngendev_select()\nmos_select()\nres_select()", "heat_map_cells": "Optional. Specifies a list of cells to be used for the generation of violation heat\nmaps. If any specified cell is exploded due to performance optimization, the heat\nmap is not generated for that cell.\nNote:\nThe IC Validator tool attempts to keep the listed cells in the hierarchy\nbut might explode certain cells during hierarchical preprocessing to\nensure optimal performance. If a cell in this list is exploded by the\ntool, the heat map for that cell is not available.\nNote:\nThe -hm  command-line option must also be provided for any heat\nmaps to be generated.\nThe heat_map_cells  argument requires the Elite, or Base licensing\nscheme. See the Licensing and Resource Requirements  chapter in\nthe IC Validator User Guide  for more information.\nerror_options()", "explode_violations": "Optional. Specifies a list of cell names (strings) for which violations are\nexploded.", "stop_check_at_error_limit": "Optional. Specifies to limit the output of the void-returning functions. The default\nis true.\n\u2022 true. Specifies that supported void-returning functions stop when they reach\nthe error_limit_per_check  argument.\nNote:\nThe effectiveness of this feature is implementation-dependent and\nis not applicable to all functions.\n\u2022 false. Specifies that supported void-returning functions do not attempt to\nexit early when they reach the error_limit_per_check  argument.\nThe following functions do not support\nerror_options(stop_check_at_error_limit = true):\nadjacent_edge, and_edge, and_overlap, aspect_ratio,\ncell_extent, check_symmetry, contained_by, contains, copy,\ncopy_by_cells, copy_by_cells_edge,\ncopy_by_cells_error, copy_by_cells_unmerged,\ncopy_by_layout_equiv_cells, copy_edge,copy_error,\ncopy_unmerged, data_filter, data_limit,data_limit_edge,\ndelta_error, density, dfm_features, donut_holes, donuts,\ndrc_space1_edge, drc_space1_error, drc_space2_edge,\ndrc_space2_error, dv_error_voltage_source,\ndv_polygon_voltage_source, edge_extents, edge_features_edge,\nedge_grow, edges, edge_shrink, edge_size_by_property,\nenclose_corner, enclose_corner_edge,\nenclosed_by, error_merge, error_merge_edge, error_merge_list,\nerror_merge_list_edge, extend_edge, extent, flatten_by_cells,\ngradient_density, grouped_by,\ninside_hole, inside_point_touching_edge,\ninternal_corner1, internal_corner1_edge, internal_corner2,\ninternal_corner2_edge, layer_extent, layer_extent_list,\nmagnitude_density, marker_merge, milkyway_route_directives,\nmove, move_edge, negate, negate_in_window, net_color_check,\nnet_interact, net_not_texted_with,\nnet_polygon_select, net_property_select, net_select,\nnet_select_error, net_select_inside_of_layer,\nnet_texted_with, not_adjacent_edge, not_aspect_ratio,\nnot_contained_by, not_contains, not_delta_error,\nnot_donuts, not_enclosed_by, not_extent, not_inside_hole,\nnot_inside_point_touching_edge,\nerror_options()\nnot_outside_point_touching_edge, not_point_touching_edge,\nnot_rectangles, not_rectangles_interacting,\nnot_rectangle_spacing1, not_rectangle_spacing2,\nnot_texted_with, not_text_interact, not_vertices,\nnot_vertices_edge., off_grid,off_grid_directional_edge,\noff_grid_directional_error,\nor, or_edge, or_list, or_list_edge, or_list_error,\nor_list_property, outside_point_touching_edge, pattern_learn,\npattern_match,\npattern_predict, pattern_predict_marker, point_touching_edge,\npolygon_centers, polygon_extents, polygon_features,\npolygon_merge,\npolygons, property_by_net, property_by_net_edge,\nproperty_merge, rectangle_overlap, rectangles,\nrectangles_interacting, rectangle_spacing1,\nrectangle_spacing2, replace_angled_edges, route_directives,\nshift_symmetry, size_inside, size_outside,\nsize_overlap, soft_check, soft_connect_check,\ntexted_with, text_interact, text_net, text_origin,\ntext_to_double_property, text_to_property_unmerged,\ntext_to_string_property, two_color, vertices, vertices_edge,\nwide_edge, write_ascii, xor, xor_edge", "merge_spacing_violations": "Optional. Merges output error shapes to reduce the size of violation output. The\ndefault is false.\n\u2022 true. Merges output errors from dimensional functions such as\nexternal1(), external2(), internal1(), internal2(), and enclose().\n\u2022 false. Writes each error separately, even if they overlap.", "polygon_limit_per_net": "Optional. Specifies the polygon limit per net for net highlighting information,\nwhich is output by functions such as net_polygon_select()  and\nnet_select(). The default is 2500000.", "database_error": "Optional. Specifies the tool behavior when an error is encountered during\ndatabase processing, which would prevent full results from being written to the\nerror database. The default is WARN.\n\u2022 WARN. Issues a warning when database processing errors occur, but continue\nthe run to produce partial results. The warning is visible in the icv.log  file,\nBLOCK.RESULTS  file, BLOCK.LAYOUT_ERRORS  file, and the VUE DRC\nerror summary tab.\n\u2022 ABORT. Exits the tool immediately when database processing errors occur.\nPartial results might still be available.\nerror_options()", "report_error_details_limit_per_check": "Optional. Specifies the detail limit applied to each check in the violation details\nsection of the LAYOUT_ERRORS file created by the tool at the end of a job. It\nhas no effect on what is stored in PYDB. A full LAYOUT_ERRORS file can be\ngenerated with the pydb_report  utility. The default is 100000.\nNote:\nTo generate a report that includes all available error details, the\npydb_report  utility can be run as follows:\npydb_report -pydb_path ./run_details -pydb_name\nPYDB_AD4FUL -le <file.LAYOUT_ERRORS>", "layout_error_files": "Optional. Allows for additional layout error files to be specified that contain errors\nfor specified rules. The default is a single BLOCK.LAYOUT_ERRORS  file.\n\u2022 file_suffix. Required. Provides the suffix to use for the file.\n<block>.<file_suffix>. The separating period must not be included in the\nfile suffix. If a top layout errors file is generated then the top layout errors file\nname is <block>.TOP_<file_suffix>.\n\u2022 label. Required. The label used in the file status line of the\nLAYOUT_ERRORS  file and the summary in the RESULTS  file.\n\u2022 violation_comments. Lists the violations comments (rules) that go to this\nfile. Violation comments are the string specified after @. String matching using\nmetacharacters is allowed. See\nString Matching  for more information.\n\u2022 violation_names. Lists the violations names (rules) that go to this file.\nViolation names are to the left of @=  construct. String matching using\nmetacharacters is allowed. See String Matching  for more information.", "primary_layout_errors_file_label": "Optional. Provides a label for the default LAYOUT_ERRORS  file used\nin LAYOUT_ERRORS  and RESULTS  file. Rules not split using the\nlayout_error_files  argument go to the primary LAYOUT_ERRORS  file.", "perc_vue_reclassify_file": "Optional. Specifies the CRVDB reclassifier file path. When the reclassifier file\npath is specified, a new .VUE  file entry is generated. The default is an empty\nstring. If the path is not specified, no new entry is created in the .VUE  file."}, "summary": "The error_options()  function specifies the error output for the design being verified.", "function_name": "error_options()"}
{"description": "The error_to_link_edge()  creates an edge layer from an error layer by forming links\nbetween error edge pairs.", "syntax": "error_to_link_edge(\nlayer1            = error_layer,\nname             = \"layer_label\",                           //optional\nshift_min_length = double,                                  //optional\nshift_ratio      = double,                                  //optional\nshift_mode       = {SHORTEST, CENTER, CENTER_ALL_ANGLE,\nOPPOSITE, ERROR_CENTER, ...}            //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the error layer from which polygons are selected.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "shift_min_length": "Optional. Specifies the link shifting threshold. A link is shifted only when its\nlength is equal to or greater than this value. The default is 0 (zero).", "shift_ratio": "Optional. Defines the ratio of the shift segment to the overlap segment. This\nratio must be a value from 0.0 to 1.0. For example, if the overlap segment for\nan error pair is 100 microns and this value is set to 0.1, the shift segment is 10\nmicrons. The shifted link is within this segment. The default is 1.", "shift_mode": "Optional. Specifies the mode used to generate the link, which can be a subset of\nall modes. The default is SHORTEST.\nerror_to_link_edge()\n\u2022 SHORTEST. Uses the shortest distance between error pairs to generate a link.\n\u2022 CENTER. Uses center points of the error pair to generate a link. This mode is\napplicable only when the run length is less than or equal to 0 (zero) and the\nlink derived by the default shift mode is orthogonal.\n\u2022 CENTER_ALL_ANGLE. Uses center points of the error pair to generate a link.\nThis mode is applicable only when the error pair run length is less than or\nequal to 0 (zero).\n\u2022 OPPOSITE. Shifts two endpoints of the generated link in opposite directions\nwith respect to the shift ratio. This mode is applicable only when the shift\nrange is positive, which means the run length is greater than 0 (zero), the\nlink length is greater than or equal to the shift threshold, and the shift ratio is\ngreater than 0 (zero).\n\u2022 ERROR_CENTER. Uses center points of the error pair to generate a link.\nNote:\nWhen you select the ERROR_CENTER  option to generate a link, all\nof the other modes are disabled."}, "summary": "The error_to_link_edge()  creates an edge layer from an error layer by forming links\nbetween error edge pairs.", "function_name": "error_to_link_edge()"}
{"description": "The exclude_milkyway_cell_types()  function returns a list of Milkyway cell types\nthat are not specified in the exclude  argument. You can use this function to exclude\ncell types when reading in a Milkyway library. See the cell_types  argument of the\nmilkyway_options()  function and the milkyway  argument of assign functions for more\ninformation.", "syntax": "exclude_milkyway_cell_types(\nexclude = {cell_type, ...}\n);", "returns": "list of Milkyway cell types", "arguments": {"exclude": "Required. Specifies the Milkyway cell types that are excluded from the returned\nlist of cell types. See\nTable 56  for a list of cell types."}, "summary": "The exclude_milkyway_cell_types()  function returns a list of Milkyway cell types\nthat are not specified in the exclude  argument.", "function_name": "exclude_milkyway_cell_types()"}
{"description": "The exclude_milkyway_net_types()  function returns a list of Milkyway net types\nthat are not specified in the exclude  argument. You can use this function to exclude\nnet types when reading in a Milkyway library. See the net_types  argument of the\nmilkyway_options()  function and the milkyway  argument of assign functions for more\ninformation.", "syntax": "exclude_milkyway_net_types(\nexclude = {net_type, ...}\n);", "returns": "list of Milkyway net types", "arguments": {"exclude": "Required. Specifies the Milkyway net types that are excluded from the returned\nlist of net types. See\nTable 57  for the list of net types."}, "summary": "The exclude_milkyway_net_types()  function returns a list of Milkyway net types\nthat are not specified in the exclude  argument.", "function_name": "exclude_milkyway_net_types()"}
{"description": "The exclude_milkyway_route_guide_layers()  function returns a list of Milkyway\nroute guides that are not specified in the exclude  argument. You can use this function to\nexclude route guides when reading in a Milkyway library. See the route_guide_layers\nargument of the\nmilkyway_options()  function and the milkyway  argument of assign\nfunctions for more information.", "syntax": "exclude_milkyway_route_guide_layers(\nexclude = {layer_type, ...}\n);", "returns": "list of Milkyway route guides", "arguments": {"exclude": "Required. Specifies the Milkyway route guides that are excluded from the\nreturned list of route guides. See\nTable 58  for a list of route guide layers."}, "summary": "The exclude_milkyway_route_guide_layers()  function returns a list of Milkyway\nroute guides that are not specified in the exclude  argument.", "function_name": "exclude_milkyway_route_guide_layers()"}
{"description": "The exclude_milkyway_route_types()  function returns a list of Milkyway route types\nthat are not specified in the exclude  argument. You can use this function to exclude\ncell types when reading in a Milkyway library. See the route_types  argument of the\nmilkyway_options()  function and the milkyway  argument of assign functions for more\ninformation.", "syntax": "exclude_milkyway_route_types(\nexclude = {route_type, ...}\n);", "returns": "list of Milkyway route types", "arguments": {"exclude": "Required. Specifies the Milkyway route types that are excluded from the\nreturned list of route types. See\nTable 59  for a list of route types."}, "summary": "The exclude_milkyway_route_types()  function returns a list of Milkyway route types\nthat are not specified in the exclude  argument.", "function_name": "exclude_milkyway_route_types()"}
{"description": "The exclude_ndm_blockage_types()  function returns a list of NDM blockage types that\nare not specified in the exclude  argument. You can use this function to easily exclude\nblockage types when reading in an NDM library. See the blockage_types  option for the\nndm  argument of assign functions for more information.", "syntax": "exclude_ndm_blockage_types(\nexclude = {blockage_type, ...}\n);", "returns": "list of NDM blockage types", "arguments": {"exclude": "Required. Specifies the NDM blockage types that are excluded from the\nreturned list of blockage types.\nTable 21  lists the blockage types."}, "summary": "The exclude_ndm_blockage_types()  function returns a list of NDM blockage types that\nare not specified in the exclude  argument.", "function_name": "exclude_ndm_blockage_types()"}
{"description": "The exclude_ndm_design_types()  function returns a list of NDM design types that\nare not specified in the exclude  argument. You can use this function to easily exclude\ndesign types when reading in an NDM library. See the design_types  argument of the\nndm_options()  function and the design_types  option for the ndm  argument of assign\nfunctions for more information.", "syntax": "exclude_ndm_design_types(\nexclude = {design_type, ...}\n);", "returns": "list of NDM design types", "arguments": {"exclude": "Required. Specifies the NDM design types that are excluded from the returned\nlist of design types.\nTable 20  in the assign()  function lists the device types."}, "summary": "The exclude_ndm_design_types()  function returns a list of NDM design types that\nare not specified in the exclude  argument.", "function_name": "exclude_ndm_design_types()"}
{"description": "The exclude_ndm_net_types()  function returns a list of NDM net types that are not\nspecified in the exclude  argument. You can use this function to easily exclude net types\nwhen reading in an NDM library. See the net_types  option for the ndm  argument of assign\nfunctions for more information.", "syntax": "exclude_ndm_net_types(\nexclude = {net_type, ...}\n);", "returns": "list of NDM net types", "arguments": {"exclude": "Required. Specifies the NDM net types that are excluded from the returned list\nof net types. The\nTable 19  table lists the net types."}, "summary": "The exclude_ndm_net_types()  function returns a list of NDM net types that are not\nspecified in the exclude  argument.", "function_name": "exclude_ndm_net_types()"}
{"description": "The exclude_ndm_shape_uses()  function returns a list of NDM shape uses that are not\nspecified in the exclude  argument. You can use this function to easily exclude shape\nuses when reading in an NDM library. See the shape_uses  option for the ndm  argument of\nassign functions for more information.", "syntax": "exclude_ndm_shape_uses(\nexclude = {shape_use, ...}\n);", "returns": "list of NDM shape uses", "arguments": {"exclude": "Required. Specifies the NDM shape uses that are excluded from the returned\nlist of shape uses. See\nTable 18  for the list of shape uses."}, "summary": "The exclude_ndm_shape_uses()  function returns a list of NDM shape uses that are not\nspecified in the exclude  argument.", "function_name": "exclude_ndm_shape_uses()"}
{"description": "The extend_edge()  function creates an edge from an edge by extending or shortening\nthe endpoints.\nThe endpoints of an edge are uniquely identified as the start and end. The endpoints are\nordered such that the inside, or material side, of the edge is on the right. See\nedge  in the\nGlossary  for more information.", "syntax": "extend_edge(\nlayer1           = edge_layer,\nstart            = double,                     //optional\nend              = double,                     //optional\ncorners          = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nstart_by_factor  = double,                     //optional\nend_by_factor   = double,                     //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "start": "Optional. Specifies the distance the endpoint is adjusted at the start of the edge.\nA positive value extends the edge; a negative value shortens it. When set to 0,\nthe distance at the start is not changed. The default is 0.", "end": "Optional. Specifies the distance the endpoint is adjusted at the end of the edge.\nA positive value extends the edge, a negative value shortens it. When set to 0,\nthe distance at the end is not changed. The default is 0.", "corners": "Optional. Specifies how corners are processed. The default is IGNORE.\nextend_edge()\n\u2022 CONNECT. Connects the edges end to end at the corners, extending only the\nfirst and last edge of the chain. Closed chains are unchanged.\n\u2022 IGNORE. Ignores corners. Each edge is extended individually.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "start_by_factor": "Optional. Specifies the amount of extension at the start of the edge in terms\nof the edge length. The product of a positive start_by_factor  value and the\nedge length specifies the amount to extend startpoints of the edge. The product\nof a negative start_by_factor  value and the edge length specifies the amount\nto retract the startpoints of an edge. The default is 0.\nNote:\nThe minimum expansion values for the start_by_factor  argument\nis one working resolution unit.\nEither the start  argument or the start_by_factor  argument must be a\nnonzero value. Otherwise, an edge is not output.\nSee the Examples section for more information.", "end_by_factor": "Optional. Specifies the amount of extension at the end of the edge in terms of\nthe edge length. The product of a positive end_by_factor  value and the edge\nlength specifies the amount to extend the endpoints of the edge. The product of\na negative end_by_factor  value the edge length specifies the amount to retract\nthe endpoints of an edge. The default is 0.\nNote:\nThe minimum expansion values for the end_by_factor  argument is\none working resolution unit.\nEither the end  argument or the end_by_factor  argument must be a nonzero\nvalue. Otherwise, an edge is not output.\nSee the Examples section for more information.\nextend_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The extend_edge()  function creates an edge from an edge by extending or shortening\nthe endpoints.", "function_name": "extend_edge()"}
{"description": "The extent()  function selects polygons whose extents fit the specified dimensions. The\ncomplement of this function is the not_extent()  function.", "syntax": "extent(\nlayer1           = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\"                  //optional\n);\nnot_extent(\nlayer1           = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\"                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "sides": "Required. Specifies the dimensions of the extents of polygons that are selected\nusing two lengths, one per side. The dimensions must be greater than 0. The\nlength2  option is optional, with a default of >0. See\nConstraints  for more\ninformation.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nextent() and not_extent()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The extent()  function selects polygons whose extents fit the specified dimensions.", "function_name": "extent()"}
{"description": "The external_corner1()  function creates polygons that are formed by pairs of violation\ncorners. It measures outside-to-outside spacing on layer1  based on the distance\nspecified. The arguments define various geometric conditions for measuring the point-to-\npoint distance between the corners.\nThe output consists of rectangles that are the extents of the point-to-point violations. In\nthe case where the violation is horizontal or vertical, the output rectangle is generated by\nexpanding the violation three times the input library resolution on both sides.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the external_corner1()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\nexternal_corner1()", "syntax": "external_corner1(\nlayer1                      = data_layer,\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONCAVE, CONVEX_TO_CONVEX,\nCONVEX_TO_EDGE,\nPARALLEL_POINT_PROJECTION},   //optional\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database,              //optional\nmembership                 = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nlook_thru                  = NONE  | ALL,                    //optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\nexternal_corner1()\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.\nFigure 173  shows the effect of the type  argument settings.\nFigure 173 type Argument Example", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.\nexternal_corner1()\nFigure 174  shows the effect of the angle  argument settings.\nFigure 174 angle Argument Example", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 175  shows the effect of the region  argument settings.\nFigure 175 region Argument Example\nexternal_corner1()", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nFigure 176  shows the effect of the convex_to_concave_boundary  argument\nsettings.\nFigure 176 convex_to_concave_boundary Argument Example", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.\nFigure 177  shows the effect of the convex_to_convex_boundary  argument\nsettings.\nexternal_corner1()\nFigure 177 convex_to_convex_boundary Argument Example", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when the input layer is an edge layer.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 178  shows the effect of the edge_endpoints  argument settings.\nFigure 178 edge_endpoints Argument Example\nexternal_corner1()", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 179  shows the effect of the connectivity  argument settings.\nFigure 179 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "membership": "Optional. Specifies how to check between corners that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is ALL.\n\u2022 ALL. Checks all corners regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only corners that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only corners that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nexternal_corner1()\nFigure 180  shows the effect of the membership  argument settings.\nFigure 180 membership Argument Example", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the\nexternal1()  function for\nmore information.\nFigure 181  shows the effect of the look_thru  argument settings.\nexternal_corner1()\nFigure 181 look_thru Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The external_corner1()  function creates polygons that are formed by pairs of violation\ncorners.", "function_name": "external_corner1()"}
{"description": "The external_corner1_edge()  function creates edges that consist of pairs of violation\ncorners. It measures outside-to-outside spacing on layer1  based on the distance\nspecified. Other arguments define various geometric conditions for measuring the point-to-\npoint distance between the corners.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the external_corner1_edge()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.", "syntax": "external_corner1_edge(\nlayer1                      = data_layer,\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONCAVE, CONVEX_TO_CONVEX,\nCONVEX_TO_EDGE,\nPARALLEL_POINT_PROJECTION},   //optional\nexternal_corner1_edge()\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database,              //optional\nmembership                 = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nlook_thru                  = NONE  | ALL,                    //optional\noutput_type                 = FAIL  | POINT_TO_POINT,         //optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nexternal_corner1_edge()\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.\nFigure 182  shows the effect of the type  argument settings.\nFigure 182 type Argument Examples", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.\nFigure 183  shows the effect of the angle  argument settings.\nexternal_corner1_edge()\nFigure 183 angle Argument Examples", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 184  shows the effect of the region  argument settings.\nFigure 184 region Argument Example\nexternal_corner1_edge()", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nFigure 185  shows the effect of the convex_to_concave_boundary  argument\nsettings.\nFigure 185 convex_to_concave_boundary Argument Example", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.\nFigure 186  shows the effect of the convex_to_convex_boundary  argument\nsettings.\nexternal_corner1_edge()\nFigure 186 convex_to_convex_boundary Argument Example", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when the input layer is an edge layer.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 187  shows the effect of the edge_endpoints  argument settings.\nFigure 187 edge_endpoints Argument Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\nexternal_corner1_edge()\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 188  shows the effect of the connectivity  argument settings.\nFigure 188 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "membership": "Optional. Specifies how to check between corners that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is ALL.\n\u2022 ALL. Checks all corners regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only corners that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only corners that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity =\nSAME_NET, this function can incorrectly report violations on the same\npolygon depending on the given hierarchy and spacing distance.\nFigure 189  shows the effect of the membership  argument settings.\nexternal_corner1_edge()\nFigure 189 membership Argument Example", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the\nexternal1()  function for\nmore information.\nFigure 190  shows the effect of the look_thru  argument settings.\nFigure 190 look_thru Argument Example\nexternal_corner1_edge()", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. The orientation of POINT_TO_POINT\nedges from a layer1  check is arbitrary. POINT_TO_POINT  creates an orphan\nedge layer.\nFigure 191  shows the effect of the output_type  argument settings.\nFigure 191 output_type Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nexternal_corner1_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The external_corner1_edge()  function creates edges that consist of pairs of violation\ncorners.", "function_name": "external_corner1_edge()"}
{"description": "The external_corner1_error()  function measures outside-to-outside spacing on\nlayer1  based on the distance  specified. The arguments define various geometric\nconditions for measuring the point-to-point distance between the corners.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the external_corner1()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.", "syntax": "external_corner1_error(\nlayer1                      = data_layer,\nexternal_corner1_error()\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONCAVE, CONVEX_TO_CONVEX,\nCONVEX_TO_EDGE,\nPARALLEL_POINT_PROJECTION},   //optional\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database,              //optional\nmembership                 = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nlook_thru                  = NONE  | ALL,                    //optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\nvoltage_filter             = {delta_voltage  = doubleconstraint,\ndelta_method   = HIGH_LOW_MAX  |\nSAME_TYPE_MAX |\nSYNC_NET,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\",\noverride_by_net_pair_property =\ntrue |\nfalse,\nerror_limit = integer,        //optional\noverride_by_net_pair_property_criteria =\nALWAYS  | LESS_THAN_EQUAL},  //optional\nlayer1_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer1_high_voltage        = double,\nlayer1_low_voltage         = double,\n},                            //optional\nnet_double_property_filter  = {property_value = doubleconstraint,\nproperty_name  = \"string\",\nerror_limit    = integer}     //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nexternal_corner1_error()\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\nexternal_corner1_error()\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when the input layer is an edge layer.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "membership": "Optional. Specifies how to check between corners that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is ALL.\nexternal_corner1_error()\n\u2022 ALL. Checks all corners regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only corners that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only corners that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the\nexternal1()  function for\nmore information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "voltage_filter": "Optional. Specifies that each spacing error is prefiltered to meet the voltage\nconstraints. The default is no constraint and no prefiltering.\n\u2022 delta_voltage. Specifies with a nonnegative value that each spacing error\nmust have a delta voltage to satisfy the constraint. The default is <0, which\nmeans no constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage. The default is\nHIGH_LOW_MAX.\nexternal_corner1_error()\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1  - VL2, VH2  -\nVL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1  - VH2),\nabs(VL1  - VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MA. Otherwise, use HIGH_LOW_MAX.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nlow voltage.\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets is overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property.\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated the calculated delta voltage\nwhen there is a net-pair property and its value is smaller than or equal to\nthe calculated delta voltage.\n\u2022 layer1_voltage_from. Specifies how layer1  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When you use this option, layer1  must be in the connect\ndatabase.\nexternal_corner1_error()\n\u25e6 USER_DEFINED. Specifies that layer1  data obtains voltage from user-\ndefined values. When you use this option, layer1  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer1  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When you use this option, layer1  is not\nrequired in the connect database.\n\u2022 layer1_high_voltage. Specifies the high voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.\n\u2022 layer1_low_voltage. Specifies the low voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.", "net_double_property_filter": "Optional. Specifies that each spacing error is prefiltered to meet the property\nconstraints. The default is no constraint and no prefiltering.\n\u2022 property_value. Specifies with a nonnegative value that each spacing\nerror must have either net with a property value to satisfy the constraint. The\ndefault is <0, which means no constraint.\n\u2022 property_name. Specifies the name of the property.\n\u2022 error_limit. Specifies the maximum number of reported violations to stop\nproperty value checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early."}, "summary": "The external_corner1_error()  function measures outside-to-outside spacing on\nlayer1  based on the distance  specified.", "function_name": "external_corner1_error()"}
{"description": "The external_corner2()  function creates polygons that are formed by pairs of violation\ncorners. It measures outside-to-outside spacing between two layers based on the\ndistance  specified. Other arguments define various geometric conditions for measuring\nthe point-to-point distance between the corners.\nThe output consists of rectangles that are the extents of the point-to-point violations. In\nthe case where the violation is horizontal or vertical, the output rectangle is generated by\nexpanding the violation three times the input library resolution on both sides.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\ncorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to\nthe corner falls in the projection zone of the corner. A portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the external_corner2()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\nexternal_corner2()", "syntax": "external_corner2(\nlayer1                      = data_layer,\nlayer2                      = data_layer,\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONVEX, CONVEX_TO_CONCAVE,\nCONVEX_TO_EDGE, CONCAVE_TO_EDGE,\nPARALLEL_POINT_PROJECTION},   //optional\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database,              //optional\nlook_thru                   = NONE  | COINCIDENT | INSIDE | ALL,\n//optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\nexternal_corner2()\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconcave corner check zone is exclusive.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.\nFigure 192  shows the effect of the type  argument settings.\nexternal_corner2()\nFigure 192 type Argument Example", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.\nFigure 193  shows the effect of the angle  argument settings.\nexternal_corner2()\nFigure 193 angle Argument Example", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 194  shows the effect of the region  argument settings.\nFigure 194 region Argument Example\nexternal_corner2()", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nFigure 195  shows the effect of the convex_to_concave_boundary  argument\nsettings.\nFigure 195 convex_to_concave_boundary Argument Example", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.\nFigure 196  shows the effect of the convex_to_convex_boundary  argument\nsettings.\nexternal_corner2()\nFigure 196 convex_to_convex_boundary Argument Example", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 197  shows the effect of the edge_endpoints  argument settings.\nexternal_corner2()\nFigure 197 edge_endpoints Argument Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 198  shows the effect of the connectivity  argument settings.\nFigure 198 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.\nexternal_corner2()", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 ALL. Looks through all edges.\nFigure 199  shows the effect of the look_thru  argument settings.\nFigure 199 look_thru Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The external_corner2()  function creates polygons that are formed by pairs of violation\ncorners.", "function_name": "external_corner2()"}
{"description": "The external_corner2_edge()  function creates edges that consist of pairs of violation\ncorners. It measures outside-to-outside spacing between two layers based on the\ndistance  specified. Other arguments define various geometric conditions for measuring\nthe point-to-point distance between the corners.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180-degree s) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\ncorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the external_corner2_edge()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.", "syntax": "external_corner2_edge(\nlayer1                      = data_layer,\nlayer2                      = data_layer,\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONVEX, CONVEX_TO_CONCAVE,\nCONVEX_TO_EDGE, CONCAVE_TO_EDGE,\nexternal_corner2_edge()\nPARALLEL_POINT_PROJECTION},   //optional\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database               //optional\nlook_thru                  = NONE  | COINCIDENT | INSIDE | ALL,\n//optional\noutput_layer               = LAYER1  | LAYER2,               //optional\noutput_type                 = FAIL  | POINT_TO_POINT,         //optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconcave corner check zone is exclusive.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\nexternal_corner2_edge()\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.\nFigure 200  shows the effect of the type  argument with the default setting.\nFigure 200 type Argument Example\nFigure 201  shows the effect of the type  argument with the CONCAVE_TO_EDGE\nsetting.\nexternal_corner2_edge()\nFigure 201 type Argument Example With CONCAVE_TO_EDGE\nFigure 202  shows the effect of the type  argument with the CONVEX_TO_CONVEX\nsetting.\nFigure 202 type Argument Example With CONVEX_TO_CONVEX\nFigure 203  shows the effect of the type  argument with the CONVEX_TO_CONCAVE\nsetting.\nFigure 203 type Argument Example With CONVEX_TO_CONCAVE\nFigure 204  shows the effect of the type  argument with the CONVEX_TO_EDGE\nsetting.\nexternal_corner2_edge()\nFigure 204 type Argument Example With CONVEX_TO_EDGE\nFigure 205  shows the effect of the type  argument with the\nPARALLEL_POINT_PROJECTION  setting.\nFigure 205 type Argument Example With PARALLEL_POINT_PROJECTION", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.\nFigure 206  shows the effect of the angle  argument settings.\nexternal_corner2_edge()\nFigure 206 angle Argument Example", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 207  shows the effect of the region  argument settings.\nFigure 207 region Argument Example\nexternal_corner2_edge()", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nFigure 208  shows the effect of the convex_to_concave_boundary  argument\nsettings.\nFigure 208 convex_to_concave_boundary Argument Example", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.\nFigure 209  shows the effect of the convex_to_convex_boundary  argument\nsettings.\nexternal_corner2_edge()\nFigure 209 convex_to_convex_boundary Argument Example", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 210  shows the effect of the edge_endpoints  argument settings.\nexternal_corner2_edge()\nFigure 210 edge_endpoints Argument Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 211  shows the effect of the connectivity  argument settings.\nFigure 211 connectivity Argument Example\nexternal_corner2_edge()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 ALL. Looks through all edges.\nFigure 212  shows the effect of the look_thru  argument settings.\nFigure 212 look_thru Argument Example", "output_layer": "Optional. Specifies the layer whose edges are output for the violations. The\ndefault is LAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\nexternal_corner2_edge()\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. Edge endpoints are ordered from\nlayer1  to layer2. POINT_TO_POINT  creates an orphan edge layer.\nFigure 213  shows the effect of the output_type  argument settings.\nFigure 213 output_type Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nexternal_corner2_edge()"}, "summary": "The external_corner2_edge()  function creates edges that consist of pairs of violation\ncorners.", "function_name": "external_corner2_edge()"}
{"description": "The external_corner2_error()  measures outside-to-outside spacing between two\nlayers based on the distance  specified. Other arguments define various geometric\nconditions for measuring the point-to-point distance between the corners.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\ncorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to\nthe corner falls in the projection zone of the corner. A portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the external_corner2()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\nexternal_corner2_error()", "syntax": "external_corner2_error(\nlayer1                      = data_layer,\nlayer2                      = data_layer,\ndistance                    = doubleconstraint,\ntype                       = {CONVEX_TO_CONVEX, CONVEX_TO_CONCAVE,\nCONVEX_TO_EDGE, CONCAVE_TO_EDGE,\nPARALLEL_POINT_PROJECTION},   //optional\nangle                      = ALL  | RIGHT,                   //optional\nregion                     = RADIAL  | SQUARE,               //optional\nconvex_to_concave_boundary = INCLUSIVE | EXCLUSIVE,         //optional\nconvex_to_convex_boundary  = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints             = CORNER  | ALL,                  //optional\nconnectivity               = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence           = connect_database,              //optional\nlook_thru                   = NONE  | COINCIDENT | INSIDE | ALL,\n//optional\nprocessing_mode            = CELL_LEVEL | HIERARCHICAL,     //optional\nname                       = \"layer_label\"                  //optional\nvoltage_filter            = {delta_voltage  = doubleconstraint,\ndelta_method =  HIGH_LOW_MAX  |\nSAME_TYPE_MAX | SYNC_NET\nHIGH_LOW,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\"},\nlayer2_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer2_high_voltage        = double,\nlayer2_low_voltage         = double,\noverride_by_net_pair_property =\ntrue |\nfalse,\nerror_limit = integer,\noverride_by_net_pair_property_criteria =\nALWAYS  | LESS_THAN_EQUAL},  //optional\nlayer1_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer1_high_voltage        = double,\nlayer1_low_voltage         = double,\n//optional\nnet_double_property_filter  = {property_value = doubleconstraint,\nproperty_name  = \"string\"},\nlayer2_property_from =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer2_property = double,\nexternal_corner2_error()\nerror_limit = integer}        //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconcave corner check zone is exclusive.\n\u2022 CONVEX_TO_CONVEX. Specifies that the check-zone boundary is controlled by\nthe convex_to_convex_boundary  argument.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe convex_to_concave_boundary  and\nconvex_to_convex_boundary  arguments are ignored.\nexternal_corner2_error()\nThe edge endpoints and all angle corners are always measured;\nedge_endpoints  and angle  arguments are ignored.\nThe region  argument is not used for this corner type.", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.", "convex_to_convex_boundary": "Optional. For convex-to-convex measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\nexternal_corner2_error()\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 ALL. Looks through all edges.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nexternal_corner2_error()", "voltage_filter": "Optional. Specifies that each spacing error is prefiltered to meet the voltage\nconstraints. The default is no constraint and no prefiltering.\n\u2022 delta_voltage. Specifies with a nonnegative value that each spacing error\nmust have a delta voltage to satisfy the constraint. The default is <0, which\nmeans no constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage.\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1  - VL2, VH2  -\nVL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1  - VH2),\nabs(VL1  - VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW_MAX.\n\u25e6 HIGH_LOW. Specifies the voltage of VH1  - VL2,  where 1 means layer1\nand 2 means layer2.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nlow voltage.\n\u2022 layer2_voltage_from. Specifies how layer2  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer2  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When this option is used, layer2  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer2  data obtains voltage from user-\ndefined values. When this option is used, layer2  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer2  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When this option is used, layer2  does not\nneed to be in the connect database.\n\u2022 layer2_high_voltage. Specifies the high voltage for layer2  data, and is\nused only when layer2_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.\nexternal_corner2_error()\n\u2022 layer2_low_voltage. Specifies the low voltage for layer2  data, and is\nused only when layer2_voltage_from = USER_DEFINED  or LAYER. The\ndefault is 0.0.\nNote:\nIf layer2_voltage_from = USER_DEFINED, always use the value\nof this option for every layer2  data.\nIf layer2_voltage_from = LAYER, use the value of this option\nonly when layer2  data does not carry property on itself.\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets is overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property.\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated the calculated delta voltage\nwhen there is a net-pair property and its value is smaller than or equal to\nthe calculated delta voltage.\n\u2022 layer1_voltage_from. Specifies how layer1  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When you use this option, layer1  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer1  data obtains voltage from user-\ndefined values. When you use this option, layer1  does not need to be in\nthe connect database.\nexternal_corner2_error()\n\u25e6 LAYER. Specifies that layer1  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When you use this option, layer1  does not\nneed to be in the connect database.\n\u2022 layer1_high_voltage. Specifies the high voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 layer1_low_voltage. Specifies the low voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.", "net_double_property_filter": "Optional. Specifies that each spacing error is prefiltered to meet the property\nconstraints. The default is no constraint and no prefiltering.\n\u2022 property_value. Specifies with a nonnegative value that each spacing\nerror must have either net with a property value to satisfy the constraint. The\ndefault is <0, which means no constraint.\n\u2022 property_name. Specifies the name of the property.\n\u2022 layer2_property_from. Specifies how layer2  data obtains property\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer2  data obtains properties from\nits net. Each net has associated property information in the connect\ndatabase. When this option is used, layer2  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer2  data obtains properties from user-\ndefined values. When this option is used, layer2  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer2  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When this option is used, layer2  does not\nneed to be in the connect database.\n\u2022 layer2_property. Specifies the properties for layer2  data, and is used\nonly when layer2_property_from = USER_DEFINED  or LAYER. The default\nis 0.0.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\nexternal_corner2_error()\nNote:\nIf layer2_voltage_from = USER_DEFINED, always use the value of\nthis option for every layer2  data.\nIf layer2_voltage_from = LAYER, use the value of this option only\nwhen layer2  data does not carry property on itself."}, "summary": "The external_corner2_error()  measures outside-to-outside spacing between two\nlayers based on the distance  specified.", "function_name": "external_corner2_error()"}
{"description": "The external1()  function creates polygons that are formed by pairs of violation edges. It\nmeasures outside-to-outside spacing on one layer based on the specified distance. The\narguments define geometric conditions for measuring the distance between the edges.", "syntax": "external1(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance       = double,                         //optional\nmembership                = ALL  | SAME_POLYGON |\nDIFFERENT_POLYGON,               //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH},                   //optional\npoint_touch_shape         = EXTENTS  | SQUARE,                //optional\nshape_size                = double,                          //optional\noutput_type               = REGION  | CENTERLINE | EXTENTS,   //optional\nwidth                     = double,                          //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nexternal1()\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle         = doubleconstraint                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\nexternal1()\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function.\nIn the conceptual diagram shown in Figure 214, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 214 Check Region Extension\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = RADIAL);\nexternal1()\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = SQUARE);", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership is\ndetermined by layer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nexternal1()\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance <= 1.0,\nextension = RADIAL, membership = SAME_POLYGON);\nexternal1()\nIn the following example,\ngreen = external1(red, distance <= 1.0,\nextension = RADIAL, membership = ALL);\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = RADIAL,\nmembership = DIFFERENT_POLYGON);", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\nexternal1()\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance < 1.0, extension = NONE,\norientation = {ACUTE, PARALLEL});\nexternal1()\nIn the following example,\ngreen = external1(red, distance < 1.0, extension = NONE,\norientation = {PERPENDICULAR});", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\nexternal1()\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance < 1.0, extension = NONE,\norientation = {}, intersecting = {ACUTE});\nIn the following example,\ngreen = external1(red, distance < 1.0, extension = NONE,\norientation = {}, intersecting =\n{PERPENDICULAR});\nexternal1()\nFigure 215  shows the effect of the obtuse  argument setting.\nFigure 215 obtuse Argument Example", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nexternal1()\nIn Figure 216, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 216 Projection Region for Edges\nFor the following examples,\nIn the following example,\ngreen = external1(red, <= 1.0, RADIAL, projection = {OUT});\nexternal1()\nIn the following example,\ngreen = external1(red, <= 1.0, RADIAL, projection = {ON});", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\nexternal1()\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nexternal1()\nIn the following example,\ngreen = external1(red, < 1.0, RADIAL, orthogonal = NEITHER);\nIn the following example,\ngreen = external1(red, < 1.0, RADIAL, orthogonal = ONE);\nexternal1()\nIn the following example,\ngreen = external1(red, < 1.0, RADIAL, orthogonal = ALL);\nIn the following example,\ngreen = external1(red, < 1.0, RADIAL, orthogonal = BOTH);", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\nexternal1()\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = NONE,\ndirection = HORIZONTAL);\nexternal1()\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = NONE,\ndirection = ORTHOGONAL);\nIn the following example,\ngreen = external1(red, distance <= 1.0, extension = NONE,\ndirection = NEGATIVE_45);\nexternal1()", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nexternal1()\nSee Figure 217  for an example of the corner_configuration  argument.\nFigure 217 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured.\nFigure 218  shows an example where the tool reports two violations.\nexternal1()\nFigure 218 look_thru = NOT_ADJACENT Example With Violations\nFigure 219  shows an example where the tool does not report violations.\nFigure 219 look_thru = NOT_ADJACENT Example With No Violations\n\u2022 ALL. Looks through all edges.\nFigure 220  shows an example of the edges that a spacing check looks through\nfor various look_thru  argument settings.\nProjections look_thru  argument setting\n1 NONE\n1, 2 ALL\nexternal1()\nFigure 220 Example of look_thru Projections\nFigure 221  shows four violations, 1-4.\n\u2022 NONE  reports none of these violations.\n\u2022 NOT_ADJACENT  reports violation 4.\n\u2022 ALL  reports all four violations.\nFigure 221 Example of NOT_ADJACENT", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.\nexternal1()", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 222  for an example of the extension_obstructions  argument.\nFigure 222 Example of extension_obstructions\nexternal1()", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity and membership are considered when\ngenerating these violations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The format of the violation is determined by the point_touch_shape\nand shape_size  arguments. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 223  shows the effect of the relational  argument settings.\nFigure 223 relational Argument Example", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance  constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of\nexternal1()\nthe spacing distance. This value must be positive. It is rounded to the\nnearest even multiple of the internal resolution, with a minimum value of\ntwice the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Reports violations as an expanded line at the center of the\nprojection region. The midpoints of the sides of the violation region form a\nline that is expanded in both directions by width/2. When the output_type\nargument is CENTERLINE, only parallel spacing and intersection angles are\nsupported.\nIn the following examples,\ngreen = external1(blue, distance < X, intersection_angle <\n180)\norange = external1(blue, distance < X, intersection_angle <\n180, output_type = CENTERLINE)\ngreen = external1(blue, [X, Y], intersection_angle < 180)\norange = external1(blue, [X, Y],, intersection_angle < 180,\noutput_type = CENTERLINE)\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when the extension  argument is\nRADIAL  or SQUARE.\nexternal1()\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  value on both\nsides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  value. Violations are oriented along the line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nFor the following examples,\nIn the following example,\ngreen = external1(red, distance <= 1.0,\nextension = RADIAL, output_type = REGION);\nexternal1()\nIn the following example,\ngreen = external1(red, <= 1.0, RADIAL,\norientation = {PARALLEL}, intersecting = {},\noutput_type = CENTERLINE);\nIn the following example,\ngreen = external1(red, <= 1.0, RADIAL,\noutput_type = EXTENTS);\nexternal1()", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nargument is the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default\nis .001.\nFor the following example,\nexternal1()\nIn the following example,\ngreen = external1(red, <= 1.0, RADIAL, orientation = {},\nintersecting = {PERPENDICULAR}, width = 0.5);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.\nexternal1()\nIn the following example,\nyellow = external1(pink, distance < minval, blocking_layer =\nblue);", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the enclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, extension  argument is NONE  or\nNONE_INCLUSIVE, and compatibility_options(drc = {spacing =\n{combine_edge_pair_violations = false}}). The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\nexternal1()\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\n\u25e6 When the extension  argument is EDGE  and\ncompatibility_options(drc = {spacing =\n{combine_edge_pair_violations = true}}),\nSYMMETRIC_NON_INTERSECTING  can be specified. The behavior is the\nsame as SYMMETRIC  to measure both projections from orthogonal and\nnonorthogonal edges. There is no output violation with a single point error\nedge.", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nexternal1()\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nSee the intersection_angle  argument of the\nexternal2()  function for an\nexample.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external1()  function creates polygons that are formed by pairs of violation edges.", "function_name": "external1()"}
{"description": "The external1_edge()  function selects the portion of layer1  edges that violates\nthe spacing constraints. It measures outside-to-outside spacing on one layer based\non the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the edges. The complement of this function is the\nnot_external1_edge()  function.", "syntax": "external1_edge(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH},                   //optional\nspacing_edge              = ALL  | PROJECTING,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer           = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type              = FAIL  | CENTERLINE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nexternal1_edge() and not_external1_edge()\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\n);\nnot_external1_edge(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,    //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH},                   //optional\nspacing_edge              = ALL  | PROJECTING,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer           = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle        = doubleconstraint                 //optional\n);\nexternal1_edge() and not_external1_edge()", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\nexternal1_edge() and not_external1_edge()\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function.\nIn the conceptual diagram shown in Figure 224, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 224 Check Region Extension\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nextension = RADIAL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nextension = SQUARE);", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership is\ndetermined by layer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nexternal1_edge() and not_external1_edge()\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nmembership = SAME_POLYGON);\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, membership = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nmembership = DIFFERENT_POLYGON);", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nexternal1_edge() and not_external1_edge()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFor the following examples,In the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {ACUTE, PARALLEL});\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {PERPENDICULAR});", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\nexternal1_edge() and not_external1_edge()\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {}, intersecting = {ACUTE});\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {},\nintersecting = {PERPENDICULAR});\nexternal1_edge() and not_external1_edge()", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of edges that are outside of the\nprojection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn\nFigure 225, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nexternal1_edge() and not_external1_edge()\nFigure 225 Projection Region for Edges\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, projection = {OUT});\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, projection = {ON});projection_length\nOptional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\nexternal1_edge() and not_external1_edge()\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal =\nNEITHER);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = ONE);\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = BOTH);", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\nexternal1_edge() and not_external1_edge()\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = HORIZONTAL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = ORTHOGONAL);\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = NEGATIVE_45);\nexternal1_edge() and not_external1_edge()", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nexternal1_edge() and not_external1_edge()\nSee Figure 226  for an example of the corner_configuration  argument.\nFigure 226 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee the examples for the look_thru  argument of the external1()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nexternal1_edge() and not_external1_edge()\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 227  for an example of the extension_obstructions  argument.\nexternal1_edge() and not_external1_edge()\nFigure 227 Example of extension_obstructions", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity and membership are considered when\ngenerating these violations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 228  shows the effect of the relational  argument settings.\nFigure 228 relational Argument Example", "spacing_edge": "Optional. Specifies the violation edges that are selected from distance violations.\nEach distance violation consists of one edge that creates a projection region,\nand another edge that falls inside that region. The default is ALL.\nexternal1_edge() and not_external1_edge()\n\u2022 ALL. Outputs all violation edges.\n\u2022 PROJECTING. Specifies that only the violation edge that created the projection\nregion is output. For nonparallel violations, the violation edge is the edge that\nis perpendicular to the violation.\nNote:\nThe projection region in parallel violations is commutative,\ntherefore PROJECTING  has no effect on parallel violations.\nEndpoint violations have no projecting edge, so they are not reported with\nthis setting.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, spacing_edge = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nspacing_edge = PROJECTING);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nexternal1_edge() and not_external1_edge()", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_external1_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nexternal1_edge() and not_external1_edge()\nWhen the output_type  argument is CENTERLINE, only parallel spacing\nand intersection angles are supported. See the output_type  argument in\nexternal1()  function for examples.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\nexternal1_edge() and not_external1_edge()", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nSee the intersection_angle  argument of the\nexternal2_edge() and\nnot_external2_edge()  functions for an example.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\nexternal1_edge() and not_external1_edge()\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external1_edge()  function selects the portion of layer1  edges that violates\nthe spacing constraints.", "function_name": "external1_edge()"}
{"description": "The external1_edge()  function selects the portion of layer1  edges that violates\nthe spacing constraints. It measures outside-to-outside spacing on one layer based\non the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the edges. The complement of this function is the\nnot_external1_edge()  function.", "syntax": "external1_edge(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH},                   //optional\nspacing_edge              = ALL  | PROJECTING,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer           = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type              = FAIL  | CENTERLINE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nexternal1_edge() and not_external1_edge()\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\n);\nnot_external1_edge(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,    //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH},                   //optional\nspacing_edge              = ALL  | PROJECTING,                //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer           = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle        = doubleconstraint                 //optional\n);\nexternal1_edge() and not_external1_edge()", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\nexternal1_edge() and not_external1_edge()\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function.\nIn the conceptual diagram shown in Figure 224, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 224 Check Region Extension\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nextension = RADIAL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nextension = SQUARE);", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership is\ndetermined by layer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nexternal1_edge() and not_external1_edge()\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nmembership = SAME_POLYGON);\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, membership = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nmembership = DIFFERENT_POLYGON);", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nexternal1_edge() and not_external1_edge()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFor the following examples,In the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {ACUTE, PARALLEL});\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {PERPENDICULAR});", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\nexternal1_edge() and not_external1_edge()\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {}, intersecting = {ACUTE});\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, extension = NONE,\norientation = {},\nintersecting = {PERPENDICULAR});\nexternal1_edge() and not_external1_edge()", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of edges that are outside of the\nprojection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn\nFigure 225, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nexternal1_edge() and not_external1_edge()\nFigure 225 Projection Region for Edges\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, projection = {OUT});\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, projection = {ON});projection_length\nOptional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\nexternal1_edge() and not_external1_edge()\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal =\nNEITHER);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = ONE);\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance < 1.0, orthogonal = BOTH);", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\nexternal1_edge() and not_external1_edge()\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = HORIZONTAL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = ORTHOGONAL);\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, extension = NONE,\ndirection = NEGATIVE_45);\nexternal1_edge() and not_external1_edge()", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nexternal1_edge() and not_external1_edge()\nSee Figure 226  for an example of the corner_configuration  argument.\nFigure 226 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee the examples for the look_thru  argument of the external1()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nexternal1_edge() and not_external1_edge()\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 227  for an example of the extension_obstructions  argument.\nexternal1_edge() and not_external1_edge()\nFigure 227 Example of extension_obstructions", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity and membership are considered when\ngenerating these violations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 228  shows the effect of the relational  argument settings.\nFigure 228 relational Argument Example", "spacing_edge": "Optional. Specifies the violation edges that are selected from distance violations.\nEach distance violation consists of one edge that creates a projection region,\nand another edge that falls inside that region. The default is ALL.\nexternal1_edge() and not_external1_edge()\n\u2022 ALL. Outputs all violation edges.\n\u2022 PROJECTING. Specifies that only the violation edge that created the projection\nregion is output. For nonparallel violations, the violation edge is the edge that\nis perpendicular to the violation.\nNote:\nThe projection region in parallel violations is commutative,\ntherefore PROJECTING  has no effect on parallel violations.\nEndpoint violations have no projecting edge, so they are not reported with\nthis setting.\nFor the following examples,\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0, spacing_edge = ALL);\nexternal1_edge() and not_external1_edge()\nIn the following example,\ngreen = external1_edge(red, distance <= 1.0,\nspacing_edge = PROJECTING);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nexternal1_edge() and not_external1_edge()", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_external1_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nexternal1_edge() and not_external1_edge()\nWhen the output_type  argument is CENTERLINE, only parallel spacing\nand intersection angles are supported. See the output_type  argument in\nexternal1()  function for examples.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\nexternal1_edge() and not_external1_edge()", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nSee the intersection_angle  argument of the\nexternal2_edge() and\nnot_external2_edge()  functions for an example.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\nexternal1_edge() and not_external1_edge()\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external1_edge()  function selects the portion of layer1  edges that violates\nthe spacing constraints.", "function_name": "not_external1_edge()"}
{"description": "The external1_error()  function measures outside-to-outside spacing between the\nedges of one layer based on the specified distance. The arguments define various\ngeometric conditions for measuring the distance between the layer edges. The output is\nunmerged errors.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nErrors output to the error database consist of pairs of violation edges.", "syntax": "external1_error(\nlayer1                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance       = double,                          //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {ACUTE, PERPENDICULAR},          //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | NOT_ADJACENT | ALL,       //optional\nlook_thru_count          = integerconstraint,               //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nexternal1_error()\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nvoltage_filter           = {delta_voltage = doubleconstraint,\ndelta_method  = HIGH_LOW_MAX  |\nSAME_TYPE_MAX | SYNC_NET,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\",\noverride_by_net_pair_property =\ntrue |\nfalse,\nerror_limit   = integer,\noverride_by_net_pair_property_criteria =\nALWAYS  | LESS_THAN_EQUAL},\nlayer1_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer1_high_voltage        = double,\nlayer1_low_voltage         = double,\nblocking_by_delta_voltage  =\nNONE  |\nLAYER1,\nblocking_source_layer      = data_layer\n//optional\nrelational                 = {POINT_TOUCH},                 //optional\nnet_double_property_filter  = {property_value = doubleconstraint,\nproperty_name  = \"string\",\nerror_limit    = integer},    //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle        = doubleconstraint                 //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\nexternal1_error()", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nexternal1_error()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership is\ndetermined by layer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nSee the examples for the membership  argument of the\nexternal1()  function for\nmore information.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\nexternal1_error()\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nSee the examples for the orientation  argument of the external1()  function\nfor more information.", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nSee the examples for the intersecting  argument of the\nexternal1()  function\nfor more information.", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nSee the examples for the projection  argument of the\nexternal1()  function for\nmore information.", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nexternal1_error()\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nSee the examples for the orthogonal  argument of the\nexternal1()  function for\nmore information.", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\nexternal1_error()\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nSee the examples for the direction  argument of the external1()  function for\nmore information.", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee the examples for the corner_configuration  argument of the\nexternal1()  function for more information.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\nexternal1_error()\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee the examples for the look_thru  argument of the external1()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\nexternal1_error()\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee the examples for the extension_obstructions  argument of the\nexternal1()  function for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.\nSee the examples for the blocking_layer_look_thru  argument of the\nexternal1()  function for more information.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\nexternal1_error()\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nexternal1_error()\nSee the intersection_angle  argument of the external2()  and\nexternal2_edge() and not_external2_edge()  functions for examples.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "voltage_filter": "Optional. Specifies that each spacing error is prefiltered to meet the voltage\nconstraints. The default is no constraint and no prefiltering.\n\u2022 delta_voltage. Specifies with a nonnegative value that each spacing error\nmust have a delta voltage to satisfy the constraint. The default is <0, which\nmeans no constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage. The default is\nHIGH_LOW_MAX.\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1  - VL2, VH2  -\nVL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1  - VH2),\nabs(VL1  - VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW_MAX.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nlow voltage.\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets is overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nexternal1_error()\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property.\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated the calculated delta voltage\nwhen there is a net-pair property and its value is smaller than or equal to\nthe calculated delta voltage.\nNote:\nWhen you specify property_merge_method = ALL,\nIC Validator collects all property values between a pair\nof nets. In the external1_error(voltage_filter =\n{ override_by_net_pair_property_criteria =\nLESS_THAN_EQUAL}), operation, IC Validator chooses the\nlargest net-pair property whose value is not greater than the\noriginal delta voltage to overwrite the value.\nexternal1_error()\nvoltage_filter = {>=3.0, HIGH_LOW_MAX, \"high\", \"low\", true,\noverride_by_net_pair_property_criteria =\nLESS_THAN_EQUAL}\n\u2022 layer1_voltage_from. Specifies how layer1  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When you use this option, layer1  must be in the connect\ndatabase.\nexternal1_error()\n\u25e6 USER_DEFINED. Specifies that layer1  data obtains voltage from user-\ndefined values. When you use this option, layer1  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer1  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When you use this option, layer1  is not\nrequired in the connect database.\n\u2022 layer1_high_voltage. Specifies the high voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 layer1_low_voltage. Specifies the low voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 blocking_by_delta_voltage. Specifies the blocking violations by\nconsidering delta voltage choosing the blocking data layer. The default is\nNONE.\n\u25e6 NONE. Follows the behavior of look_thru = NONE.\n\u25e6 LAYER1. Specifies that layer1  data shadows the violations. For a pair of\northogonal checked data in a delta voltage orientation PARALLEL  spacing\ncheck, data can shadow the violation when:\n\u25aa It is orthogonal.\n\u25aa Delta voltage between shadowing data and two checked data does\nnot meet the voltage constraint specified by the delta_voltage", "argument": "\u25aa Shadowing data passes through the bounding box of the violation.\n\u2022 blocking_source_layer. Optional. Specifies the polygon layer for input\nedge layer to find the corresponding polygon to shadow the violations by\ndelta voltage and bounding box. If an edge is the candidate of blocking\nviolation, it uses the polygons in this layer with edge touching relation to\ncheck blocking instead. By default, this argument is not used.\nNote:\nWhen blocking_source_layer  is specified, the corresponding\ninput layer from blocking_by_delta_voltage  (LAYER1/\nLAYER2) must be edge layer. When blocking_source_layer\nis not specified, the corresponding input layer from\nblocking_by_delta_voltage  (LAYER1/LAYER2) must be\npolygon layer.\nexternal1_error()", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity and membership are considered when\ngenerating these violations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 229  shows the effect of the relational  argument settings.\nFigure 229 relational Argument Example", "net_double_property_filter": "Optional. Specifies that each spacing error is prefiltered to meet the property\nconstraints. The default is no constraint and no prefiltering.\n\u2022 property_value: Specifies with a nonnegative value that each spacing\nerror must have either net with a property value to satisfy the constraint. The\ndefault is <0, which means no constraint.\n\u2022 property_name: Specifies the name of the property.\n\u2022 error_limit. Specifies the maximum number of reported violations to stop\nproperty value checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.\nexternal1_error()", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external1_error()  function measures outside-to-outside spacing between the\nedges of one layer based on the specified distance.", "function_name": "external1_error()"}
{"description": "The external2()  function creates polygons that are formed by pairs of violation edges.\nIt measures outside-to-outside spacing between two layers based on the specified\ndistance. The arguments define various geometric conditions for measuring the distance\nbetween the layer edges.", "syntax": "external2(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\nrelational_type           = EXPANDED_EDGE  | POLYGON,         //optional\npoint_touch_shape         = EXTENTS  | SQUARE,                //optional\nshape_size                = double,                          //optional\noutput_type               = REGION  | CENTERLINE | EXTENTS,   //optional\nexternal2()\nwidth                     = double,                          //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nline_touch_shape         = OUTSIDE  | INSIDE | BOTH,         //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint,                //optional\nrelational_expand_direction  = INSIDE | OUTSIDE               //optional\norientation_angle   = doubleconstraint,                //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\nexternal2()\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nIn the conceptual diagram shown in Figure 230, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 230 Check Region Extension\nexternal2()\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL);\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = SQUARE);\nexternal2()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity.\nThis must be a valid connect database when the connectivity  argument is\nSAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nexternal2()\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = NONE, orientation = {ACUTE,\nPARALLEL});\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = NONE, orientation =\n{PERPENDICULAR});\nexternal2()", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Independent of the distance  argument, reports an outside touch as\na violation.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFor the following examples,\nexternal2()\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {ACUTE, TOUCH});\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {PERPENDICULAR});\nexternal2()", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection  argument specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn\nFigure 231, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 231 Projection Region for Edges\nexternal2()\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL, projection = {OUT});\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL, projection = {ON});\nexternal2()", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\nexternal2()\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = RADIAL, orthogonal = NEITHER);IC Validator Reference Manual\nexternal2()\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = RADIAL, orthogonal = ONE);\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = RADIAL, orthogonal = ALL);\nIn the following example,\ngreen = external2(blue, red, distance < 1.0,\nextension = RADIAL, orthogonal = BOTH);\nexternal2()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nexternal2()\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0, extension = NONE,\ndirection = HORIZONTAL);\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0, extension = NONE,\ndirection = ORTHOGONAL);\nexternal2()\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0, extension = NONE,\ndirection = NEGATIVE_45);", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\nexternal2()\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL, from_layer = LAYER1);IC Validator Reference Manual\nexternal2()\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL, from_layer = LAYER2);\nIn the following example,\ngreen = external2(blue, red, distance <= 1.0,\nextension = RADIAL, from_layer = ALL);", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nexternal2()\nNote:\nUse the vertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 232  is an example of the corner_configuration  argument.\nFigure 232 corner_configuration Measurements\nexternal2()", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, uses NONE.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured.\nFigure 233  and Figure 234  show examples of the look_thru  argument set to\nNOT_ADJACENT. The syntax for these examples is:\nexternal2(red, blue, distance < dash_length,\nextension=RADIAL,\nlook_thru=NOT_ADJACENT,\nedge_containment=OUTSIDE)\nFigure 233  represents where the tool reports two violations.\nFigure 233 look_thru = NOT_ADJACENT Example With Violations\nFigure 234  represents where the tool does not report violations.\nexternal2()\nFigure 234 look_thru = NOT_ADJACENT Example With No Violations\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. A projection is contained when any of the following\nare true:\n\u25e6 Edges of one layer are outside coincident with projecting edges of the\nother layer.\n\u25e6 Polygons of one layer overlap projecting edges of the other layer. For\nedge layers, this contain does not apply.\nFigure 235  shows an example of using the NOT_CONTAINED  option.\nexternal2(gray, purple, look_thru = NOT_CONTAINED);\nexternal2()\nFigure 235 look_thru = NOT_CONTAINED Example\n\u2022 ALL. Looks through all edges.\nFigure 236  shows an example of the edges that a spacing check looks through\nfor various look_thru  argument settings.\nProjections look_thru argument setting\n1 NONE\n1, 2 COINCIDENT\n1, 2, 3, 4 INSIDE\n1, 2, 3, 4, 5 ALL\nexternal2()\nFigure 236 Example of look_thru Projections", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\nexternal2()\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nIn the following example,\ngreen = external2(red, black, distance > x,\nextension = RADIAL,\nextension_look_past = POINT_TO_POINT);\nexternal2()", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 237  for an example of the extension_obstructions  argument.\nexternal2()\nFigure 237 Example of extension_obstructions", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. INSIDE, CUTTING, and CROSS  are available only when both inputs are\npolygon layers. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The format of the violation is determined by the point_touch_shape\nand shape_size  arguments.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Creates a violation for polygons that are inside.\n\u2022 CUTTING. Creates a violation for polygons that are cutting.\n\u2022 OVERLAP. Creates a violation for material that is not outside the other layer.\nexternal2()\n\u25e6 When both inputs are polygon layers, any shared area between the two\nlayers is reported.\n\u25e6 When one of the inputs is a polygon layer and the other is an edge layer,\nedge portions that fall inside the polygon layer are reported.\n\u25e6 When both inputs are edge layers, inside coincident portions are\nreported.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross. The\nviolation reports the point where layer1  edges cross from inside to not\ninside of layer2  edges, and layer2  edges cross from inside to not inside of\nlayer1  edges, where not inside includes outside coincident.\nThe violations are created outside the polygons, as though the polygon\nedges are being measured outside to outside regardless of the angle. The\nlength of the violation is equal to the spacing distance unless the edges\noutside of the cross are coincident, then the entire coincident length is\nreported, like a touch violation.\nFigure 238  and Figure 239  show the effect of the relational  argument\nsettings.\nexternal2()\nFigure 238 relational Argument Example\nFigure 239 relational Argument Example", "relational_type": "Optional. Specifies how INSIDE, CUTTING, and OVERLAP  relational violations are\nreported. The default is EXPANDED_EDGE.\nexternal2()\n\u2022 EXPANDED_EDGE. Reports violations as individual edges expanded to the\noutside by width.\n\u2022 POLYGON. Reports violations as closed polygons (applies only when both\ninputs are polygons).\nFor the following examples,\nIn the following example,\ngreen = external2(blue, red, < 0, RADIAL,\nrelational = {INSIDE},\nrelational_type = EXPANDED_EDGE, width = 0.4);\nIn the following example,\ngreen = external2(blue, red, < 0, RADIAL,\nrelational = {CUTTING}, relational_type =\nPOLYGON);\nexternal2()", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance  constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of\nthe spacing distance. This value must be positive. It is rounded to the\nnearest even multiple of the internal resolution, with a minimum value of\ntwice the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Reports violations as an expanded line at the center of the\nprojection region. The midpoints of the sides of the violation region form a\nline that is expanded in both directions by width/2. When the output_type\nargument is CENTERLINE, only parallel spacing and intersection angles are\nexternal2()\nsupported. See the output_type  argument in external1()  function for\nexamples.\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when the extension  argument is\nRADIAL  or SQUARE.\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  value on both\nsides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  value. Violations are oriented along the line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nFor the following examples,\nIn the following example,\ngreen = external2(red, blue, distance <= 1.0,\nextension = RADIAL, output_type = REGION);\nexternal2()\nIn the following example,\ngreen = external2(red, blue, <= 1.0, RADIAL,\norientation = {PARALLEL}, intersecting = {},\noutput_type = CENTERLINE);\nIn the following example,\ngreen = external2(red, blue, <= 1.0, RADIAL,\noutput_type = EXTENTS);\nexternal2()", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nargument is the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default\nis .001.\nFor the following example,\nexternal2()\nIn the following example,\ngreen = external2(blue, red, < 0, RADIAL,\nintersecting = {TOUCH}, width = 0.5);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "line_touch_shape": "Optional. Specifies how to expand a line-touch edge violation into a polygon.\nThe default is OUTSIDE.\n\u2022 OUTSIDE. Outputs a line-touch polygon outside of the dimensional function\nlayer1  polygon. The output polygon size equals the value of the width\noption.\n\u2022 INSIDE. Outputs a line-touch polygon inside of layer1. The output polygon\nsize equals the value of the width  option.\n\u2022 BOTH. Outputs a line touch polygon inside and outside of the layer1. The\ntotal output size is 2*width  option.\nexternal2()", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.\nIn the following example,\nyellow = external2(green, pink, distance < minval, blocking_layer\n=\nblue);", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the enclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\nexternal2()\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE\nor NONE_INCLUSIVE, and compatibility_options(drc = {spacing =\n{combine_edge_pair_violations = false}}). The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\n\u25e6 When the extension  argument is EDGE  and\ncompatibility_options(drc = {spacing =\n{combine_edge_pair_violations = true}}),\nSYMMETRIC_NON_INTERSECTING  can be specified. The behavior is the\nsame as SYMMETRIC  to measure both projections from orthogonal and\nnonorthogonal edges. There is no output violation with a single point error\nedge.", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\nexternal2()\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. Polygon membership is determined by\nlayer ancestry. The default is ALL. The SAME_POLYGON  and DIFFERENT_POLYGON\noptions are valid only if the two input layers have the same layer ancestry.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nSee the examples for the membership  argument of the\nexternal1()  function for\nmore information.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 240  shows an example of using the intersection_angle  argument.\nexternal2()\ngreen = external2(blue, red, distance < 1.0, extension = RADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nFigure 240 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 OUTSIDE.\nIf the other layer is a polygon layer, only those edges that are outside and\ninside coincident with the other layer are included in the measurements.\nIf the other layer is an edge layer, those edges that are not outside coincident\nwith the other layer are included in the measurements.\nexternal2()\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nIn\nFigure 241, the dash lines are filtered out before the measurement. The\nsyntax is\nexternal2(layer1 = orange, layer2 = blue, ...)\nFigure 241 Example of Edge Containment for the external2 Functions\n\u2022 ALL. Does not filter edges.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.\nFigure 242  shows an example of intersecting = {}.\nexternal2()\nFigure 242 Example of Edge Breaking Behavior With intersecting Argument\nFigure 243  shows an example of projection_length > 8.\nFigure 243 Example of Edge Breaking Behavior With the projection_length\nArgument\nexternal2()\nFigure 244  shows an example of projection = {ON}.\nFigure 244 Example of Edge Breaking Behavior With projection Argument\nFigure 245  shows an example of the corner_to_edge  argument.\nFigure 245 Example of Edge Breaking Behavior With corner_to_edge Argument", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.\nexternal2()", "relational_expand_direction": "Optional. Controls the expanded direction of the selected edges. The default is\nOUTSIDE.\n\u2022 INSIDE. Controls the inside of the expanded direction of the selected edges.\n\u2022 OUTSIDE. Controls the outside of the expanded direction of the selected\nedges.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external2()  function creates polygons that are formed by pairs of violation edges.", "function_name": "external2()"}
{"description": "The external2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints. It measures outside-to-outside spacing between two\nlayers based on the specified distance. The arguments define various geometric\nconditions for measuring the distance between the layer edges. The complement of this\nfunction is the not_external2_edge()  function.", "syntax": "external2_edge(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,                //optional\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\noutput_layer             = LAYER1  | LAYER2,                 //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nexternal2_edge() and not_external2_edge()\nblocking_layer_look_thru = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type              = FAIL  | CENTERLINE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\n);\nnot_external2_edge(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,                //optional\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,    //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\nexternal2_edge() and not_external2_edge()\noutput_layer             = LAYER1  | LAYER2,                 //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle        = doubleconstraint                 //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Optional. Specifies the check distance. See\nConstraints  for more information.\nThe default is 0.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nIn the conceptual diagram shown in Figure 246, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 246 Check Region Extension\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = RADIAL);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = SQUARE);\nexternal2_edge() and not_external2_edge()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE,\norientation = {ACUTE, PARALLEL});\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE,\norientation = {PERPENDICULAR});\nexternal2_edge() and not_external2_edge()", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Independent of the distance  argument, reports an outside touch as\na violation.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {ACUTE, TOUCH});\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {PERPENDICULAR});\nexternal2_edge() and not_external2_edge()", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is (IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nexternal2_edge() and not_external2_edge()\nIn Figure 247, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 247 Projection Region for Edges\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red distance <= 1.0, projection =\n{OUT});\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0, projection =\n{ON});", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\nexternal2_edge() and not_external2_edge()\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\northogonal = NEITHER);\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nONE);\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nALL);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nBOTH);", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\nexternal2_edge() and not_external2_edge()\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction = HORIZONTAL);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction = ORTHOGONAL);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction =\nNEGATIVE_45);\nexternal2_edge() and not_external2_edge()", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = LAYER1);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = LAYER2);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = ALL);", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\nexternal2_edge() and not_external2_edge()\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee\nFigure 248  for an example of the corner_configuration  argument.\nFigure 248 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the external2()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nSee the examples for the look_thru  argument of the external2()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nexternal2_edge() and not_external2_edge()\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 249  for an example of the extension_obstructions  argument.\nexternal2_edge() and not_external2_edge()\nFigure 249 Example of extension_obstructions", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. INSIDE, CUTTING, and CROSS  are available only when both inputs are\npolygon layers. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Creates a violation for polygons that are inside.\n\u2022 CUTTING. Creates a violation for polygons that are cutting.\n\u2022 OVERLAP. Creates a violation for material that is not outside the other layer.\nexternal2_edge() and not_external2_edge()\n\u25e6 When both inputs are polygon layers, any shared area between the two\nlayers is reported.\n\u25e6 When one of the inputs is an edge layer, edge portions that fall inside the\npolygon layer are reported.\n\u25e6 When both inputs are edge layers, inside coincident portions are\nreported.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross. The\nviolation reports the point where layer1  edges cross from inside to not\ninside of layer2  edges, and layer2  edges cross from inside to not inside of\nlayer1  edges, where not inside includes outside coincident.\nThe violations are created outside the polygons, as though the polygon\nedges are being measured outside to outside regardless of the angle. The\nlength of the violation is equal to the spacing distance unless the edges\noutside of the cross are coincident, then the entire coincident length is\nreported, like a touch violation.\nFigure 250  and Figure 251  show the effect of the relational  argument\nsettings.\nFigure 250 relational Argument Example\nexternal2_edge() and not_external2_edge()\nFigure 251 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\noutput_layer = LAYER1);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\noutput_layer = LAYER2);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_external2_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing\nand intersection angles are supported. See the output_type  argument in\nexternal1()  function for examples.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\nexternal2_edge() and not_external2_edge()\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership\nis determined by layer ancestry. The default is ALL. The SAME_POLYGON  and\nDIFFERENT_POLYGON  options are valid only if the two input layers have the same\nlayer ancestry.\nexternal2_edge() and not_external2_edge()\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nSee the examples for the membership  argument of the\nexternal1()  function for\nmore information.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 252  shows an example of using the intersection_angle  argument.\ngreen = external2_edge(blue, red, distance < 1.0, extension =\nRADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nexternal2_edge() and not_external2_edge()\nFigure 252 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 OUTSIDE.\nIf the other layer is a polygon layer, only those edges that are outside and\ninside coincident with the other layer are included in the measurements.\nIf the other layer is an edge layer, those edges that are not outside coincident\nwith the other layer are included in the measurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nexternal2_edge() and not_external2_edge()\nSee Figure 241  for an example.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\nexternal2_edge() and not_external2_edge()\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints.", "function_name": "not_external2_edge()"}
{"description": "The external2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints. It measures outside-to-outside spacing between two\nlayers based on the specified distance. The arguments define various geometric\nconditions for measuring the distance between the layer edges. The complement of this\nfunction is the not_external2_edge()  function.", "syntax": "external2_edge(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,                //optional\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\noutput_layer             = LAYER1  | LAYER2,                 //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nexternal2_edge() and not_external2_edge()\nblocking_layer_look_thru = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type              = FAIL  | CENTERLINE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\n);\nnot_external2_edge(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,                //optional\nextension                 = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,       //optional\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,    //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\nexternal2_edge() and not_external2_edge()\noutput_layer             = LAYER1  | LAYER2,                 //optional\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru = COINCIDENT | NONE,               //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\noutput_side               = ALL  | HIGH | LOW,                //optional\nbreak_edges               = true | false,                    //optional\ncorner_to_corner_angle   = doubleconstraint                 //optional\norientation_angle        = doubleconstraint                 //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Optional. Specifies the check distance. See\nConstraints  for more information.\nThe default is 0.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nIn the conceptual diagram shown in Figure 246, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 246 Check Region Extension\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = RADIAL);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = SQUARE);\nexternal2_edge() and not_external2_edge()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE,\norientation = {ACUTE, PARALLEL});\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE,\norientation = {PERPENDICULAR});\nexternal2_edge() and not_external2_edge()", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Independent of the distance  argument, reports an outside touch as\na violation.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {ACUTE, TOUCH});\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\nextension = NONE, orientation = {},\nintersecting = {PERPENDICULAR});\nexternal2_edge() and not_external2_edge()", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is (IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nexternal2_edge() and not_external2_edge()\nIn Figure 247, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 247 Projection Region for Edges\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red distance <= 1.0, projection =\n{OUT});\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0, projection =\n{ON});", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\nexternal2_edge() and not_external2_edge()\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFor the following examples,\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0,\northogonal = NEITHER);\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nONE);\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nALL);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance < 1.0, orthogonal =\nBOTH);", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\nexternal2_edge() and not_external2_edge()\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction = HORIZONTAL);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction = ORTHOGONAL);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nextension = NONE, direction =\nNEGATIVE_45);\nexternal2_edge() and not_external2_edge()", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nexternal2_edge() and not_external2_edge()\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = LAYER1);\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = LAYER2);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\nfrom_layer = ALL);", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\nexternal2_edge() and not_external2_edge()\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee\nFigure 248  for an example of the corner_configuration  argument.\nFigure 248 corner_configuration Measurements", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the external2()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nSee the examples for the look_thru  argument of the external2()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  for more\ninformation. The default is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nexternal2_edge() and not_external2_edge()\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee\nFigure 249  for an example of the extension_obstructions  argument.\nexternal2_edge() and not_external2_edge()\nFigure 249 Example of extension_obstructions", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. INSIDE, CUTTING, and CROSS  are available only when both inputs are\npolygon layers. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Creates a violation for polygons that are inside.\n\u2022 CUTTING. Creates a violation for polygons that are cutting.\n\u2022 OVERLAP. Creates a violation for material that is not outside the other layer.\nexternal2_edge() and not_external2_edge()\n\u25e6 When both inputs are polygon layers, any shared area between the two\nlayers is reported.\n\u25e6 When one of the inputs is an edge layer, edge portions that fall inside the\npolygon layer are reported.\n\u25e6 When both inputs are edge layers, inside coincident portions are\nreported.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross. The\nviolation reports the point where layer1  edges cross from inside to not\ninside of layer2  edges, and layer2  edges cross from inside to not inside of\nlayer1  edges, where not inside includes outside coincident.\nThe violations are created outside the polygons, as though the polygon\nedges are being measured outside to outside regardless of the angle. The\nlength of the violation is equal to the spacing distance unless the edges\noutside of the cross are coincident, then the entire coincident length is\nreported, like a touch violation.\nFigure 250  and Figure 251  show the effect of the relational  argument\nsettings.\nFigure 250 relational Argument Example\nexternal2_edge() and not_external2_edge()\nFigure 251 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nFor the following examples,\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\noutput_layer = LAYER1);\nexternal2_edge() and not_external2_edge()\nIn the following example,\ngreen = external2_edge(blue, red, distance <= 1.0,\noutput_layer = LAYER2);", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\nexternal2_edge() and not_external2_edge()\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_external2_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing\nand intersection angles are supported. See the output_type  argument in\nexternal1()  function for examples.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\nexternal2_edge() and not_external2_edge()\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership\nis determined by layer ancestry. The default is ALL. The SAME_POLYGON  and\nDIFFERENT_POLYGON  options are valid only if the two input layers have the same\nlayer ancestry.\nexternal2_edge() and not_external2_edge()\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nSee the examples for the membership  argument of the\nexternal1()  function for\nmore information.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 252  shows an example of using the intersection_angle  argument.\ngreen = external2_edge(blue, red, distance < 1.0, extension =\nRADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\nexternal2_edge() and not_external2_edge()\nFigure 252 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 OUTSIDE.\nIf the other layer is a polygon layer, only those edges that are outside and\ninside coincident with the other layer are included in the measurements.\nIf the other layer is an edge layer, those edges that are not outside coincident\nwith the other layer are included in the measurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nexternal2_edge() and not_external2_edge()\nSee Figure 241  for an example.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\nexternal2_edge() and not_external2_edge()\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints.", "function_name": "external2_edge()"}
{"description": "The external2_error()  function measures outside-to-outside spacing between\ntwo layers based on the specified distance. The arguments define various geometric\nconditions for measuring the distance between the layer edges. The output is unmerged\nerrors.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nErrors output to the error database consist of pairs of violation edges.", "syntax": "external2_error(\nlayer1                    = data_layer,\nlayer2                    = data_layer,\ndistance                  = doubleconstraint,\nextension                 = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance       = double,                          //optional\nconnectivity              = SAME_NET | DIFFERENT_NET | ALL,  //optional\nconnect_sequence         = connect_database,                //optional\norientation               = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},         //optional\nintersecting              = {TOUCH, ACUTE, PERPENDICULAR},   //optional\nprojection                = {IN, OUT, ON},                   //optional\nprojection_length        = doubleconstraint,                //optional\northogonal                = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                 //optional\ndirection                 = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL, //optional\nfrom_layer                = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration     = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru                 = NONE  | COINCIDENT | RELATED_COINCIDENT |\nINSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,             //optional\nlook_thru_count          = integerconstraint,               //optional\nlook_thru_from_layer      = LAYER1 | LAYER2 | ALL,           //optional\nextension_look_past      = NONE  | POINT_TO_POINT,           //optional\nextension_obstructions    = POINT_TO_POINT  | ALL,            //optional\nexternal2_error()\nprocessing_mode          = CELL_LEVEL | HIERARCHICAL,       //optional\nblocking_layer            = data_layer,                      //optional\nblocking_layer_look_thru  = COINCIDENT | NONE,               //optional\nprojection_mode           = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                      //optional\nprojection_filter         = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,           //optional\nmembership                = ALL  | SAME_POLYGON | DIFFERENT_POLYGON,\n//optional\nintersection_angle        = doubleconstraint,                //optional\nname                     = \"layer_label\",                   //optional\nedge_containment          = OUTSIDE | ALL,                   //optional\nrelational                = {POINT_TOUCH, INSIDE, CUTTING,\nOVERLAP, CROSS},                //optional\nbreak_edges               = true | false,                    //optional\nvoltage_filter           = {delta_voltage  = doubleconstraint,\ndelta_method   = HIGH_LOW_MAX  |\nSAME_TYPE_MAX | SYNC_NET\nHIGH_LOW |\nSYNC_NET_MODE2,\nhigh_voltage_property_name = \"string\",\nlow_voltage_property_name  = \"string\",\nlayer2_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED,\nlayer2_high_voltage        = double,\nlayer2_low_voltage         = double,\noverride_by_net_pair_property =\ntrue |\nfalse,\nerror_limit    = integer,\noverride_by_net_pair_property_criteria =\nALWAYS  | LESS_THAN_EQUAL},  //optional\nlayer1_voltage_from        =\nCONNECT_DATABASE  |\nUSER_DEFINED |\nLAYER,\nlayer1_high_voltage        = double,\nlayer1_low_voltage         = double,\nblocking_by_delta_voltage  =\nNONE  |\nLAYER1 | LAYER2,\nblocking_source_layer      = data_layer\n//optional\nnet_double_property_filter  = {property_value  = doubleconstraint,\nproperty_name   = \"string\",\nlayer2_property_from =\nCONNECT_DATABASE  |\nUSER_DEFINED,\nlayer2_property = double,\nerror_limit     = integer},\n//optional\ncorner_to_corner_angle     =\ndoubleconstraint               //optional\nexternal2_error()\norientation_angle          =\ndoubleconstraint               //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Required. Specifies the check distance. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nexternal2_error()\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\nexternal2_error()\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nSee the examples for the orientation  argument of the external2()  function\nfor more information.", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Independent of the distance  argument, reports an outside touch as\na violation.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nSee the examples for the intersecting  argument of the\nexternal2()  function\nfor more information.", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  for more information about the\ncheck side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection  argument specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nSee the examples for the projection  argument of the\nexternal2()  function for\nmore information.\nexternal2_error()", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nSee the examples for the orthogonal  argument of the\nexternal2()  function for\nmore information.", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\nexternal2_error()\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nSee the examples for the direction  argument of the external2()  function for\nmore information.", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nSee the examples for the from_layer  argument of the\nexternal2()  function for\nmore information.", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\nexternal2_error()\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on convex, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a convex, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee the examples for the corner_configuration  argument of the\nexternal2()  function for more information.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 INSIDE. Looks inside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the external2()  function for exceptions and an example.\n\u2022 ALL. Looks through all edges.\nexternal2_error()\nSee the examples for the look_thru  argument of the external2()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is >=0, which means the count is\nignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nSee the examples for the extension_look_past  argument of the\nexternal2()\nfunction for more information.\nexternal2_error()", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee the examples for the extension_obstructions  argument of the\nexternal2()  function for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "blocking_layer": "Optional. Specifies the edge or polygon layer that provides an obstruction for\nthe spacing measurement in accordance with the blocking_layer_look_thru\nargument. The blocking_layer  has no effect on and does not interfere with the\nblocking provided by the input layers. By default, this argument is not used.", "blocking_layer_look_thru": "Optional. Specifies the edges of the blocking_layer  that the spacing check\nlooks through when measuring. The default is NONE.\n\u2022 NONE. Does not look through any edges of the blocking_layer, including\nedge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges of the blocking layer.\nSee the examples for the blocking_layer_look_thru  argument of the\nexternal2()  function for more information.\nexternal2_error()", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon or different polygons. For edge layers, polygon membership\nis determined by layer ancestry. The default is ALL. The SAME_POLYGON  and\nexternal2_error()\nDIFFERENT_POLYGON  options are valid only if the two input layers have the same\nlayer ancestry.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.\nNote:\nWhen membership = DIFFERENT_POLYGON  and connectivity\n= SAME_NET, this function might incorrectly report violations on\nthe same polygon depending on the given hierarchy and spacing\ndistance.\nSee the examples for the membership  argument of the\nexternal1()  function for\nmore information.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nSee the intersection_angle  argument of the\nexternal2()  and\nexternal2_edge() and not_external2_edge()  functions for examples.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nexternal2_error()\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 OUTSIDE.\nIf the other layer is a polygon layer, only those edges that are outside and\ninside coincident with the other layer are included in the measurements.\nIf the other layer is an edge layer, those edges that are not outside coincident\nwith the other layer are included in the measurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nSee\nFigure 241  for an example.\n\u2022 ALL. Does not filter edges.", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. INSIDE, CUTTING, and CROSS  are available only when both inputs are\npolygon layers. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\n\u2022 INSIDE. Creates a violation for polygons that are inside.\n\u2022 CUTTING. Creates a violation for polygons that are cutting.\n\u2022 OVERLAP. Creates a violation for material that is not outside the other layer.\nexternal2_error()\n\u25e6 When both inputs are polygon layers, the edges of any shared area\nbetween the two layers are reported.\n\u25e6 When one of the inputs is an edge layer, edge portions that fall inside the\npolygon layer are reported.\n\u25e6 When both inputs are edge layers, inside coincident portions are\nreported.\n\u2022 CROSS. Creates a violation where layer1  and layer2  edges cross. The\nviolation reports the point where layer1  edges cross from inside to not\ninside of layer2  edges, and layer2  edges cross from inside to not inside of\nlayer1  edges, where not inside includes outside coincident.\nThe violations are created outside the polygons, as though the polygon\nedges are being measured outside to outside regardless of the angle. The\nlength of the violation is equal to the spacing distance unless the edges\noutside of the cross are coincident; then the entire coincident length is\nreported, like a touch violation.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "voltage_filter": "Optional. Specifies that each spacing error is prefiltered to meet the voltage\nconstraints. The default is no constraint and no prefiltering.\n\u2022 delta_voltage. Specifies with a nonnegative value that each spacing error\nmust have a delta voltage to satisfy the constraint. The default is <0, which\nmeans no constraint.\n\u2022 delta_method. Specifies how to calculate the delta voltage.\nexternal2_error()\n\u25e6 HIGH_LOW_MAX. Specifies the maximum voltage of (VH1  - VL2, VH2  -\nVL1).\n\u25e6 SAME_TYPE_MAX. Specifies the maximum voltage of (abs(VH1  - VH2),\nabs(VL1  - VL2)).\n\u25e6 SYNC_NET. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW_MAX.\n\u25e6 HIGH_LOW. Specifies the voltage of VH1  - VL2,  where 1 means layer1\nand 2 means layer2.\n\u25e6 SYNC_NET_MODE2. Specifies that if the two nets are synchronous, use\nSAME_TYPE_MAX. Otherwise, use HIGH_LOW.\n\u2022 high_voltage_property_name. Specifies the property name that represents\nhigh voltage.\n\u2022 low_voltage_property_name. Specifies the property name that represents\nlow voltage.\n\u2022 layer2_voltage_from. Specifies how layer2  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer2  data obtains voltage from\nits net. Each net has associated voltage information in the connect\ndatabase. When this option is used, layer2  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer2  data obtains voltage from user-\ndefined values. When this option is used, layer2  does not need to be in\nthe connect database.\n\u2022 layer2_high_voltage. Specifies the high voltage for layer2  data, and is\nused only when layer2_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 layer2_low_voltage. Specifies the low voltage for layer2  data, and is\nused only when layer2_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 override_by_net_pair_property. Specifies that the delta voltage\nbetween two nets are overridden by the net_pair_property, if it exists. If\nnet_pair_property  does not exist for the two nets, use the value calculated\nby the delta_method  option. See the net_pair_property  argument of the\nproperty_to_net()  function for more information.\n\u2022 error_limit. Specifies the maximum number of reported violations to\nstop delta voltage checks early when there is a large number of violations.\nexternal2_error()\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.\n\u2022 override_by_net_pair_property_criteria. Specifies the condition used\nto override the calculated delta voltage when there is a net-pair property\nwith additional marker and text layers. This argument is valid only when\noverride_by_net_pair_property  is true.\n\u25e6 ALWAYS. Always overrides the calculated delta voltage when there is a\nnet-pair property.\n\u25e6 LESS_THAN_EQUAL. Overrides the calculated the calculated delta voltage\nwhen there is a net-pair property and its value is smaller than or equal to\nthe calculated delta voltage.\n\u2022 layer1_voltage_from. Specifies how layer1  data obtains voltage\ninformation. The default is CONNECT_DATABASE.\n\u25e6 CONNECT_DATABASE. Specifies that layer1  data obtains voltage from\nits net. Each net has an associated voltage information in the connect\ndatabase. When you use this option, layer1  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer1  data obtains voltage from user-\ndefined values. When you use this option, layer1  does not need to be in\nthe connect database.\n\u25e6 LAYER. Specifies that layer1  data obtains voltage from properties stored\non itself. The drc_features()  and annotate_by_property()  functions\ncan store properties on data. When you use this option, layer1  does not\nneed to be in the connect database.\n\u2022 layer1_high_voltage. Specifies the high voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 layer1_low_voltage. Specifies the low voltage for layer1  data, and is\nused only when layer1_voltage_from = USER_DEFINED. The default is\n0.0.\n\u2022 blocking_by_delta_voltage. Specifies the blocking violations by\nconsidering delta voltage choosing the blocking data layer. The default is\nNONE.\nexternal2_error()\n\u25e6 NONE. Follows the behavior of look_thru = NONE.\n\u25e6 LAYER1. Specifies that layer1  data shadows the violations. For a pair of\northogonal checked data in a delta voltage orientation PARALLEL  spacing\ncheck, data can shadow the violation when:\n\u25aa It is orthogonal.\n\u25aa Delta voltage between shadowing data and two checked data does\nnot meet the voltage constraint specified by the delta_voltage", "argument": "\u25aa Shadowing data passes through the bounding box of the violation.\n\u25e6 LAYER2. Specifies that layer2  data shadows the violations. This\noption must not be used with layer1  delta voltage functions, such as\nexternal1_error().\n\u2022 blocking_source_layer. Optional. Specifies the polygon layer for input\nedge layer to find the corresponding polygon to shadow the violations by\ndelta voltage and bounding box. If an edge is the candidate of blocking\nviolation, it uses the polygons in this layer with edge touching relation to\ncheck blocking instead. By default, this argument is not used.\nNote:\nWhen blocking_source_layer  is specified, the corresponding\ninput layer from blocking_by_delta_voltage  (LAYER1/\nLAYER2) must be edge layer. When blocking_source_layer\nis not specified, the corresponding input layer from\nblocking_by_delta_voltage  (LAYER1/LAYER2) must be\npolygon layer.", "net_double_property_filter": "Optional. Specifies that each spacing error is prefiltered to meet the property\nconstraints. The default is no constraint and no prefiltering.\n\u2022 property_value: Specifies with a nonnegative value that each spacing\nerror must have either net with a property value to satisfy the constraint. The\ndefault is <0, which means no constraint.\n\u2022 property_name: Specifies the name of the property.\n\u2022 layer2_property_from. Specifies how layer2  data obtains property\ninformation. The default is CONNECT_DATABASE.\nexternal2_error()\n\u25e6 CONNECT_DATABASE. Specifies that layer2  data obtains properties from\nits net. Each net has associated property information in the connect\ndatabase. When this option is used, layer2  must be in the connect\ndatabase.\n\u25e6 USER_DEFINED. Specifies that layer2  data obtains properties from user-\ndefined values. When this option is used, layer2  does not need to be in\nthe connect database.\n\u2022 layer2_property. Specifies the properties for layer2  data, and is used\nonly when layer2_property_from = USER_DEFINED. The default is 0.0.\n\u2022 error_limit. Specifies the maximum number of reported violations to stop\nproperty value checks early when there is a large number of violations.\nReports a message to the LAYOUT_ERRORS and summary files when the\ncheck stops early.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The external2_error()  function measures outside-to-outside spacing between\ntwo layers based on the specified distance.", "function_name": "external2_error()"}
{"description": "The extract_devices()  function extracts the device information defined in the device\nmatrix into a device database. The extract_devices()  function modifies the connect\ndatabase by creating ports and instance nets.\nCall this function after all device configuration functions are called and before the netlisting\nfunctions are called.", "syntax": "extract_devices(\nmatrix                = device_matrix,\nremove_dangling_ports  = ALL | UNTEXTED         //optional\n);", "returns": "device database", "arguments": {"matrix": "Required. Specifies the device matrix where device extraction data is stored by\nthe device configuration functions.", "remove_dangling_ports": "Optional. Specifies if the device information is preprocessed to find all cases\nwhere a port is considered to be dangling; that is, when no devices or instances\nin the cell connect to the port. The default is UNTEXTED.\n\u2022 UNTEXTED. Removes only untexted dangling ports.\n\u2022 ALL. Removes all dangling ports."}, "summary": "The extract_devices()  function extracts the device information defined in the device\nmatrix into a device database.", "function_name": "extract_devices()"}
{"description": "The fill_extend()  function helps in extending the polygon boundaries. It helps resolve\nthe empty violations from unified_fill().", "syntax": "fill_extend(\nempty_region  = polygon_layer,\noriginal_fills = list of polygon_layer,\nextend_direction = VERTICAL | HORIZONTAL,\npattern_spec = {\nspace_x   = double,\nspace_y   = double,\nstagger_x = double,\nstagger_y = double,\npattern_spacing = {\nallowed_spacing_x  = {doubleconstraint, ...},\nallowed_spacing_y  = {doubleconstraint, ...},\nmin_space_corner   = double,\nextension          =\nELLIPTICAL  | RADIAL |\nINTERSECTION |\nRADIAL_INTERSECTION,\ncorner_check       =\nPOSITIVE_SPACE  | ALL\n},\nother_pattern_spacing ={integer\n=> doubleconstraint,...},\n},\ngrid  = double,\ndpt_spacing   = {\ndpt_space_x = double,\ndpt_space_y = double,\ndpt_space_corner = double,\ndpt_space_extension = ELLIPTICAL | RADIAL |\nINTERSECTION  |\nRADIAL_INTERSECTION},                                  //optional\nfill_to_signal_spacing_list  = {\nsignal_layer          = polygon_layer,\nwidth_based_spacing   = {\n{width           = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}}, ...},\nmin_space             = double,\ncontext               =\nEXTERIOR  | INTERIOR |\nEXTERIOR_INTERIOR | BOUNDARY,\nmin_space_x           = double,\nmin_space_y           = double,\nwidth_based_spacing_x = {\n{width           = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}},\nfill_extend()\n...},\nwidth_based_spacing_y = {\n{width            = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}},\n...},\ncolor_aware_to_fill   =\nALL  | ONLY_COLOR_1 | ONLY_COLOR_2\nONLY_COLOR_3 | ONLY_COLOR_4,\nmin_space_inside      = double,\nmin_space_inside_x    = double,\nmin_space_inside_y    = double,\nspace_extension       = double,\nspace_extension_x     = double,\nspace_extension_y     = double,\ndebug_layer_name      = \"string\",\ndelta_projection_spec = min_space  = double,\nmin_length = double,\nprojection            =\nALL  | CORNER,\nmin_space_xy          = x = double,\ny = double\n},       //optional\nmax_length   = double, //optional\nmin_length   = double, //optional\nmax_height  = double   //optional\n);", "returns": "list of polygon_layer\n// two color case\nresult = fill_extend(...);\nfill_color_1 = result[0];\nfill_color_2 = result[1];\n// single color case\nresult = fill_extend(...);\nfill = result[0];", "arguments": {"empty_region": "Required. Specifies the polygon layer that needs to extend the\noriginal_fills. It is also the boundary of extend area.", "original_fills": "Required. Specifies the polygon layer that needs to be extended.", "extend_direction": "Required. Specifies the extend direction. The value can be VERTICAL  or\nHORIZONTAL.\nfill_extend()", "pattern_spec": "Required. Specifies the related setting of fill spacing. For more information, see", "the": "pattern_spec  section in the Reference Manual.", "grid": "Required. Specifies the grid value for extended polygon shapes.", "dpt_spacing": "Optional. Specifies the minimum distance between two fill rectangles of the\nsame color. These distances determine how to change the color of fill rectangles\nwhen the color_scheme  option is UF_DPT_SPACING.\n\u2022 dpt_space_x. Specifies the space in the x-direction. The default is 0.0.\n\u2022 dpt_space_y. Specifies the space in the y-direction. The default is 0.0.\n\u2022 dpt_space_corner. Specifies the space between corners. The default is\n0.0.\n\u2022 dpt_space_extension. Specifies how the tool checks the corners of the fill\nrectangles. The default is INTERSECTION.\n\u25e6 ELLIPTICAL\n\u25e6 RADIAL\n\u25e6 INTERSECTION\n\u25e6 RADIAL_INTERSECTION", "fill_to_signal_spacing_list": "Optional. Defines spacing rules for the fill shapes with respect to different signal\nlayers. For more information, see the\nfill_to_signal_spacing  section in the\nReference Manual.", "max_length": "Optional. The double value indicates the maximum length of fill.", "min_length": "Optional. The double value indicates the minimum length of fill.", "min_height": "Optional. The double value indicates the minimum height of fill."}, "summary": "The fill_extend()  function helps in extending the polygon boundaries.", "function_name": "netlist()"}
{"description": "The fill_pattern()  function creates a set of fill rectangles within a layer. The rectangles\nare placed within layer1  polygons either on a uniform grid or staggered in the x- or y-\ndirection.\nA remote function calls various utility functions that operate on the current polygon to\ncreate new polygons and to write these polygons to the output layer.", "syntax": "fill_pattern(\nlayer1           = polygon_layer,\nfill_function    = function,\ngrid_mode        = LOCAL  | GLOBAL                           //optional\noutput_aref      = {output_aref = true | false,\ncell_prefix = \"string\"},                //optional\ngrid             = double,                                  //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,               //optional\nmin_space        = double,                                  //optional\nname             = \"layer_label\",                           //optional\ncontext_layer     = polygon_layer,                           //optional\ncolor             = NO_COLOR  | COLOR_1 | COLOR_2 |\nCOLOR_3 | COLOR_4,                       //optional\ncolor_space       = double,                                  //optional\nmin_space_x       = double,                                  //optional\nmin_space_y       = double,                                  //optional\nmin_space_corner  = double,                                  //optional\nextension        = ELLIPTICAL  | RADIAL |\nINTERSECTION | RADIAL_INTERSECTION       //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "fill_function": "Required. Specifies the remote function containing the programmable density\nequations. See\nFill Pattern Utility Functions  for more information about the utility\nfunctions you can use to define a function.", "grid_mode": "Optional. Specifies the origin used for the placement of fill. The default is LOCAL.\nfill_pattern()\n\u2022 GLOBAL. Sets the origin for the placement of fill to the bottom left corner of\nthe top cell.\n\u2022 LOCAL. Sets the origin for the placement of fill to the bottom left of the extents\nof a given layer1  polygon.", "output_aref": "Optional. Specifies whether to output fill as AREFs (array references).\nNote:\nDo not manipulate the output generated by the fill_pattern()\nfunction. If you do, you are likely modifying specific instances\nof the AREFs, and as a result the AREF data can get exploded\ninto individual polygons. The exploded data can create hierarchy\nproblems and cause performance issues.\n\u2022 output_aref. The default is false.\n\u25e6 true: Outputs polygons in AREFs. To limit the size of the output files, use\nthis setting.\n\u25e6 false: Outputs individual polygons.\n\u2022 cell_prefix. Specifies the prefix for all cell names created when fill is\nadded. The default is \"$FA\".", "grid": "Optional. Specifies a user-defined grid. This grid applies to spacings, such as\nwidth; height; x-direction space, shift and stagger; and y-direction space, shift\nand stagger, specified in the\nfp_generate_fill()  utility function. The default\nis 0.0", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Process data within the cell that can cover the entire shape.\nThis includes data that is hierarchically overlapped or abutted.", "min_space": "Optional. Specifies the minimum spacing between fill patterns. The default is\n0.0.\nfill_pattern()\nNote:\nThe result of the fill_pattern()  function when using the\nmin_space  argument depends on the input order of the polygons.\nThe minimum spacing must be less than or equal to the internal distance\nderived according to the following\nMinimum Spacing Calculation  section. When\nthe min_space  argument is used, the patterns are placed under the top cell,\neven if the grid_mode  argument is LOCAL.\nNote:\nUse of the min_space  argument overrides any specified\nmin_space_x, min_space_y, min_space_corner, and extension\nargument values.\nFigure 253  shows a spacing violation.\nFigure 253 Spacing Violation\nMinimum Spacing Calculation\nUse the formulas described in this section to calculate the minimum spacing\nbetween polygons. Check that the minimum spacing satisfies your requirements.\n1. Determine the initial values to use in the fp_generate_fill()  utility function\nwithin your fill_function  remote function.\nfp_generate_fill(\n...\nfill_pattern()\nwidth         = double,\nheight        = double,\nspace_x       = double,\nspace_y       = double,\nstagger_x     = double,\nstagger_y     = double,\n...\n);\n2. Verify that the stagger_x  and stagger_y  values to are reasonable.\n3. Derive the minimum spacing. See\nFigure 254  for an example.\ninternal distance = min{d_BU, d_BR, d_RU}where\n\u25e6 d_BU = the minimum allowable distance between base and up polygons\n\u25e6 d_BR = the minimum allowable distance between base and right", "polygons": "\u25e6 d_RU = the minimum allowable distance between right and up polygons", "and": "\u25e6 If stagger_x  <= width: d_BU = space_y\n\u25e6 If stagger_x  > width: d_BU = sqrt(space_y2  + (stagger_x  \u2013 width)2)\n\u25e6 If stagger_y  <= height: d_BR = space_x\n\u25e6 If stagger_y  > height: d_BR = sqrt(space_x2  + (stagger_y  \u2013 height)2)\nfill_pattern()\n\u25e6 If stagger_x  < space_x  and stagger_y  < space_y:\nd_RU = sqrt((space_x \u2013 stagger_x)2  + (space_y-stagger_y)2)\n\u25e6 If stagger_x  >= space_x  or stagger_y  >= space_y: Patterns collide and\na warning message is output and the output layer is empty.\nFigure 254 Deriving the Minimum Spacing", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "context_layer": "Optional. Specifies an optional polygon layer that is used to align fill based on a\npitch rule.\nThis layer changes three insertion parameters, based on its individual polygons:\n\u2022 The context of the grid is changed from the origin to the lower-left of the\nextents of a given context_layer  polygon.\n\u2022 The fillable regions are obtained by performing an AND  operation between\nlayer1  and the context_layer  polygon.\n\u2022 The origin for fill insertion is forced to the lower-left of the extents of a given\ncontext_layer  polygon; therefore, the grid mode is ignored.\nfill_pattern()", "color": "Optional. Assigns alternating colors to fill shapes in a regular fill pattern. There is\na choice of four colors: COLOR_1, COLOR_2, COLOR_3, and COLOR_4. The default\nis NO_COLOR.\nTo assign colors to the fill, you must call the fill_pattern()  function twice in\nthe runset. For example,\nlayer_1 = fill_pattern(..., color = COLOR_1);\nlayer_2 = fill_pattern(..., color = COLOR_2);\nlayer_3 = fill_pattern(..., color = COLOR_3);\nlayer_4 = fill_pattern(..., color = COLOR_4);\nThe IC Validator tool tries to evenly split the fill shapes between the two colors\nand gives higher priority to alternating colors along the line ends, as shown in\nFigure 255.\nFigure 255 Coloring Example", "color_space": "Optional. Specifies the minimum spacing allowed between fills for two regions.\nThis is the interregion coloring constraint. The default is 0.0; that is, there is no\ninterregion coloring constraint. This spacing is specific to the fill_pattern()\nfunction call, not between two fill_pattern()  function calls.", "min_space_x": "Optional. Specifies the minimum spacing in the x-direction between fills. The\ndefault is 0.0.", "min_space_y": "Optional. Specifies the minimum spacing in the y-direction between fills. The\ndefault is 0.0.\nfill_pattern()", "min_space_corner": "Optional. Specifies the minimum corner spacing. This value is used when the\nextension  argument is RADIAL  or RADIAL_INTERSECTION. A value of 0 means\nthere is no minimum spacing. The default is the maximum of the min_space_x\nand min_space_y  argument values.", "extension": "Optional. Specifies the corner spacing requirement between fill regions, as\nshown in\nFigure 256. The default is ELLIPTICAL.\nFigure 256 Extensions Between Fill Regions"}, "summary": "The fill_pattern()  function creates a set of fill rectangles within a layer.", "function_name": "fill_pattern()"}
{"description": "The fill_to_text()  function uses a polygon layer with fill pattern extents, which are\ngenerated by the unified_fill()  function, to get an output text layer with texts placed on\nthe pattern extents locations.\nNote:\nInput must only be a polygon layer generated by the unified_fill()  function.\nAll other IC Validator function-generated polygon layers used as an input cause\na runset error.", "syntax": "fill_to_text(\nlayer1         = polygon_layer,\ntext           = string,\ntext_position  = LEFT_BOTTOM  | LEFT_TOP | RIGHT_BOTTOM |\nRIGHT_TOP | CENTER                       //optional\n);", "returns": "text layer", "arguments": {"layer1": "Required. Specifies the polygon layer with fill extents results.", "text": "Required. Defines the text to place on the fill locations.", "text_position": "Optional. Defines the position of the text relative to the fill pattern extents. The\ndefault is LEFT_BOTTOM.\n\u2022 LEFT_BOTTOM. Defines the text in the bottom-left position relative to the fill\npattern extents.\n\u2022 LEFT_TOP. Defines the text in the top-left position relative to the fill pattern\nextents.\n\u2022 RIGHT_BOTTOM. Defines the text in the bottom-right position relative to the fill\npattern extents.\nfill_to_text()\n\u2022 RIGHT_TOP. Defines the text in the top-right position relative to the fill pattern\nextents.\n\u2022 CENTER. Defines the text in the center position relative to the fill pattern\nextents."}, "summary": "The fill_to_text()  function uses a polygon layer with fill pattern extents, which are\ngenerated by the unified_fill()  function, to get an output text layer with texts placed on\nthe pattern extents locations.", "function_name": "fill_to_text()"}
{"description": "The filter()  function filters devices based on:\n\u2022 Predefined filter options\n\u2022 Filter functions\nCandidate devices for filtering can be specified based on:\n\u2022 Device names\n\u2022 Device types\n\u2022 Equivalence cell pairs\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "filter(\nstate                    = compare_state,\ndevice_type              = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names             = {\"string\", ...},                 //optional\nfilter_options           = {option, ...},                   //optional\nfilter_function          = \"string\",                        //optional\nequiv_cells              = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...},                           //optional\nschematic_filter_options  = {option, ...},                   //optional\nlayout_filter_options    = {option, ...},                   //optional\nshort_pins               = {\"string\" ...},                  //optional\nshort_default_pins        = {\"string\" ...},                  //optional\nshort_pins_groups         = {{\"string\", ...}, ...}           //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The filter()\nfunction information is added.\nfilter()", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that have filter options applied. Each\ndevice must match a device specified in a device_name  argument of a device\nconfiguration function.\nBy default, all devices of the type specified in the device_type  argument are\nfiltered.\nNote:\nWhen device names are specified but not declared by a device or\nmap_*  function, IC Validator automatically creates equates for these\ndevices when possible. Exceptions where device names do not\nautomatically create equates are when merge_series()  is used with\ngendev_series_pins  and filter()  is used with short_pins.", "filter_options": "Optional. Specifies the list of filtering options for device types, which are shown", "in": "Table 37. The option type must match the device_type  argument, and it\napplies to the devices specified by the device_names  argument. The default is\nno filter option ({}), which unsets all filtering options.\nThese options apply to the layout and schematic netlists. The net names\nare specified in the layout_power  and layout_ground  arguments of the\ntext_options()  function and the schematic_power  and schematic_ground\narguments of the net_options()  function. In addition, you can use the\nschematic_filter_options  argument to filter schematic devices and the\nlayout_filter_options  argument to filter layout devices.\nNote:\nYou must use the filter_function  argument or at least\none of the filter options arguments: filter_options,\nschematic_filter_options, or layout_filter_options. The\nIC Validator tool filters devices by first checking the filter options\narguments and then using the remote filter function.\nTable 37 Filtering Options\nOption Description\nCAP_0 Filters all capacitors.\nCAP_1 Filters devices when both pins are shorted.\nfilter()\nTable 37 Filtering Options  (Continued)\nOption Description\nCAP_2 Filters devices when both pins are floating.\nCAP_3 Filters devices when either pin is floating.\nGEN_0 Filters all generic devices.\nGEN_1 Filters devices when all pins are shorted.\nIND_0 Filters all inductors.\nIND_1 Filters devices when both pins are shorted.\nIND_2 Filters devices when both pins are floating.\nIND_3 Filters devices when either pin is floating.\nNMOS_0 Filters all NMOS devices.\nNMOS_1 Filters devices when gate, source, and drain pins are shorted.\nNMOS_2 Filters devices when gate, source, and drain pins are floating.\nNMOS_3 Filters devices when the gate pin is tied to ground.\nNMOS_4 Filters devices when source and drain pins are tied to ground.\nNMOS_5 Filters devices when source and drain pins are shorted.\nNMOS_6 Filters devices when source or drain pins are floating.\nNMOS_7 Filters devices when the gate pin and either the source or drain pin are floating.\nNMOS_8 Filters devices when gate, source, or drain pin is floating.\nNMOS_9 Filters devices when the gate pin is tied to power and source and drain pins are tied\nto ground.\nNMOS_10 Filters devices when source or drain is floating, and the gate net is tied only to the\ngate pin.\nNMOS_11 Filters devices when the gate pin is tied to ground, and source and drain pins are\ntied together.\nNMOS_12 Filters devices when the gate pin is tied to ground, and either the source or drain\npin is floating.\nNMOS_13 Filters devices when gate, source, drain, and first bulk pins are shorted.\nNMOS_14 Filters devices when the gate pin is floating.\nfilter()\nTable 37 Filtering Options  (Continued)\nOption Description\nNMOS_15 Filters devices when the gate pin and either the source or drain pin are floating, and\nthe other source or drain pin is tied to a power or ground net.\nNMOS_16 Filters devices when gate and first bulk pins are tied to the same net.\nNMOS_17 Filters devices when the gate pin is floating, and either the source or drain pin has\na path to ground.\nNMOS_19 Filters devices when the gate pin is floating, and source and drain pins are shorted.\nNMOS_20 Filters devices when source and drain pins are floating.\nNMOS_21 Filters devices when gate and first bulk pins are tied to the same ground.\nNMOS_22 Filters devices when the gate pin is floating and source and drain pins are tied to a\nsingle power net.\nNMOS_23 Filters devices when the gate pin is floating and source and drain pins are tied to a\nsingle ground net.\nNMOS_24 Filters devices when all pins are shorted including, bulk and optional pins.\nNMOS_25 Filters devices when gate is tied to either power or ground and source and drain\nare shorted.\nNMOS_26 Filters devices when neither source nor drain have any path to a pad net.\nNMOS_27 Filters devices when source, drain, and bulk pins are tied together and the gate pin\nis floating.\nNP_0 Filters all NP devices.\nNP_1 Filters devices when both pins are shorted.\nNP_2 Filters devices when both pins are floating.\nNP_3 Filters devices when either pin is floating.\nNPN_0 Filters all NPN devices.\nNPN_1 Filters devices when emitter, base, and collector pins are shorted.\nNPN_2 Filters devices when emitter, base, and collector pins are floating.\nNPN_4 Filters devices when the base pin is tied to ground.\nfilter()\nTable 37 Filtering Options  (Continued)\nOption Description\nNPN_5 Filters devices when the base pin is floating, and collector is tied to power (filters\nmultiple-emitter devices).\nThis filter applies only to multiple-emitter NPN devices extracted as individual\n3-terminal devices with parallel connections to the base and collector terminals.\nNPN_6 Filters devices when emitter and base pins are floating.\nNPN_7 Filters devices when all emitters are floating (filters multiple-emitter devices).\nThis filter applies only to multiple-emitter NPN devices extracted as individual\n3-terminal devices with parallel connections to the base and collector terminals.\nNPN_8 Filters devices when base and emitter are shorted.\nNPN_9 Filters devices when emitter and collector are shorted and not connect to other\ndevices or any pad nets.\nNPN_10 Filters devices when at least two of emitter, base, and collector pins are floating\nPMOS_0 Filters all PMOS devices.\nPMOS_1 Filters devices when gate, source, and drain pins are shorted.\nPMOS_2 Filters devices when gate, source, and drain pins are floating.\nPMOS_3 Filters devices when the gate pin is tied to power.\nPMOS_4 Filters devices when source and drain pins are tied to power.\nPMOS_5 Filters devices when source and drain pins are shorted.\nPMOS_6 Filters devices when source or drain pins are floating.\nPMOS_7 Filters devices when the gate pin and either the source or drain pin are floating.\nPMOS_8 Filters devices when the gate, source, or drain pin is floating.\nPMOS_9 Filters devices when the gate pin is tied to the ground and the source and drain\npins are tied to power.\nPMOS_10 Filters devices when source or drain is floating, and the gate net is tied only to the\ngate pin.\nPMOS_11 Filters devices when the gate is tied to power, and source and drain are tied\ntogether.\nPMOS_12 Filters devices when the gate is tied to power, and either source or drain is floating.\nPMOS_13 Filters devices when gate, source, drain, and first bulk pins are shorted.\nfilter()\nTable 37 Filtering Options  (Continued)\nOption Description\nPMOS_14 Filters devices when the gate pin is floating.\nPMOS_15 Filters devices when the gate pin and either source or drain pin are floating, and the\nother source or drain pin is tied to a power or ground net.\nPMOS_16 Filters devices when gate and first bulk pins are tied to the same net.\nPMOS_17 Filters devices when the gate pin is floating, and either the source or drain pin has\na path to power.\nPMOS_19 Filters devices when the gate pin is floating, and source and drain pins are shorted.\nPMOS_20 Filters devices when source and drain pins are floating.\nPMOS_21 Filters devices when gate and the first bulk pins are tied to the same power.\nPMOS_22 Filters devices when the gate pin is floating and source and drain pins are tied to a\nsingle power net.\nPMOS_23 Filters devices when the gate pin is floating and source and drain pins are tied to a\nsingle ground net.\nPMOS_24 Filters devices when all pins are shorted, including bulk and optional pins.\nPMOS_25 Filters devices when gate is tied to either power or ground and source and drain\nare shorted.\nPMOS_26 Filters devices when neither source nor drain have any path to a pad net.\nPMOS_27 Filters devices when source, drain, and bulk pins tied together and the gate pin is\nfloating.\nPN_0 Filters all PN devices.\nPN_1 Filters devices when both pins are shorted.\nPN_2 Filters devices when both pins are floating.\nPN_3 Filters devices when either pin is floating.\nPNP_0 Filters all PNP devices.\nPNP_1 Filters devices when emitter, base, and collector pins are shorted.\nPNP_2 Filters devices when emitter, base, and collector pins are floating.\nPNP_3 Filters devices when the base pin is tied to power.\nfilter()\nTable 37 Filtering Options  (Continued)\nOption Description\nPNP_4 Filters devices when all pins are floating (filters multiple-collector devices).\nThis filter applies only to multiple-collector PNP devices extracted as individual\n3-terminal devices with parallel connections to the base and emitter terminals.\nPNP_5 Filters devices when all collectors are floating (filters multiple-collector devices).\nThis filter applies only to multiple-collector PNP devices extracted as individual\n3-terminal devices with parallel connections to the base and emitter terminals.\nPNP_8 Filters devices when base and emitter are shorted.\nPNP_9 Filters devices when emitter and collector are shorted and not connect to other\ndevices or any pad nets.\nPNP_10 Filters devices when at least two of emitter, base, and collector pins are floating.\nRES_0 Filters all resistors.\nRES_1 Filters devices when both pins are shorted.\nRES_2 Filters devices when both pins are floating.\nRES_3 Filters devices when either pin is floating.", "filter_function": "Optional. Specifies the remote function that defines filtering conditions. If the\nfunction is satisfied, the devices listed in the device_names  argument are\nremoved. See\nCompare Utility Functions  for more information about the utility\nfunctions you can use to define a remote function.\nNote:\nYou must use the filter_function  argument or at least\none of the filter options arguments:\nfilter_options,\nschematic_filter_options, or layout_filter_options. The\nIC Validator tool filters devices by first checking the filter options\narguments and then using the remote filter function.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which the\nfilter()  function applies. You must specify the equiv_cells  pairs in the\nequiv_options()  function before calling the filter()  function. If only one cell\nname in the pair is specified, the names are assumed to be the same.\nfilter()\nNote:\nThe filter()  instruction is observed only when comparing each\nlisted equivalence cell pair. If an equivalence cell pair is exploded\ninto the parent equivalence cell pair while comparing the parent, the\nfilter()  instruction is discarded for the content of the exploded cell.", "schematic_filter_options": "Optional. Specifies the filtering options for each device type, as shown in\nTable 37. The option type must match the type specified by the device_type\nargument, and it applies to the devices specified by the device_names\nargument.\nThese options apply only to the schematic netlists. The net names are\nspecified in the schematic_power  and schematic_ground  arguments of", "the": "net_options()  function. In addition, you can use the filter_options\nargument to filter all devices and the layout_filter_options  argument to filter\nlayout devices.\nNote:\nYou must use the\nfilter_function  argument or at least\none of the filter options arguments: filter_options,\nschematic_filter_options, or layout_filter_options. The\nIC Validator tool filters devices by first checking the filter options\narguments and then using the remote filter function.", "layout_filter_options": "Optional. Specifies the filtering options for each device type, as shown in\nTable 37. The option type must match the type specified by the device_type\nargument, and it applies to the devices specified by the device_names\nargument.\nThese options apply to the layout netlists. The net names are specified in the\nlayout_power  and layout_ground  arguments of the\ntext_options()  function.\nIn addition, you can use the filter_options  argument to filter all devices and\nthe schematic_filter_options  argument to filter schematic devices.\nNote:\nYou must use the filter_function  argument or at least\none of the filter options arguments: filter_options,\nschematic_filter_options, or layout_filter_options. The\nIC Validator tool filters devices by first checking the filter options\narguments and then using the remote filter function.\nfilter()", "short_pins": "Optional. Specifies the pins that are shorted after filtering rather than being left\nas floating. Pins that are not listed are kept as floating after filtering. When listed\nin the short_pins  argument,\n\u2022 The pins of devices that are filtered by the options listed\nin the filter_options, schematic_filter_options, or\nlayout_filter_options  arguments are shorted.\n\u2022 The pins of devices that are filtered by the\nlvs_remove_device()  function\nare shorted.\nAt least two pin names must be listed, and all pin names must belong to a\ndevice specified in the device_names  argument.\nNote:\nA short between two or more port and static nets is not allowed. If the\nfiltering of a group of one or more devices results in a short between\ntwo or more port nets, all devices in the group are not filtered and an\nerror is reported.", "short_default_pins": "Optional. Specifies the pins that are shorted after filtering rather than being left\nas floating. Pins that are not listed are kept as floating after filtering. When listed\nin the short_pins_groups  argument,\n\u2022 The pins of devices that are filtered by the options listed\nin the filter_options, schematic_filter_options, or\nlayout_filter_options  arguments are shorted.\n\u2022 The pins of devices that are filtered by the\nlvs_remove_device()  function\nare shorted.\nAt least two pin names must be listed, and all pin names must be default pin\nnames, which belong to a device specified in the device_names  argument. See\nTable 38  for the default pin names of different types of devices:\nTable 38 Default Pin Names for Device Types\nDevice type Default pin name\nNMOS, PMOS GATE, SRC, DRN\nRESISTOR, CAPACITOR, INDUCTOR A, B\nNPN, PNP EMIT, BASE, COLL\nNP, PN ANODE, CATHODE\nfilter()\nThe specified short_default_pins  argument also works with the gendev()\nfunction using the mapped_device_type  and map_device_pin  arguments. For\nexample, the POS and NEG pins of the res device are shorted with the specified\nshort_default_pins  argument.\ngendev(..., device_layers = { { POS, \"POS\", mapped_device_pin =\n\"A\" },\n{ NEG, \"NEG\", mapped_device_pin = \"B\" }},\ndevice_name = \"res\", mapped_device_type = RESISTOR, ... );\nfilter(..., device_type = RESISTOR, short_default_pins = {\"A\",\n\"B\"});\nNote:\nA short between two or more port and static nets is not allowed. If the\nfiltering of a group of one or more devices results in a short between\ntwo or more port nets, all devices in the group are not filtered and an\nerror is reported.", "short_pins_groups": "Optional. Specifies groups of pins that are shorted after filtering rather than\nbeing left as floating. Pins that are not listed in the group are kept as floating\nafter filtering. When listed in the short_pins_groups  argument,\n\u2022 The pins of devices that are filtered by the options listed\nin the filter_options, schematic_filter_options, or\nlayout_filter_options  arguments are shorted.\n\u2022 The pins of devices that are filtered by the\nlvs_remove_device()  function\nare shorted.\nAt least two pin names must be listed in the group, and all pin names must\nbelong to a device specified in the device_names  argument.\nNote:\nA short between two or more port and static nets is not allowed. If the\nfiltering of a group of one or more devices results in a short between\ntwo or more port nets, all devices in the group are not filtered and an\nerror is reported."}, "summary": "The filter()  function filters devices based on:\n\u2022 Predefined filter options\n\u2022 Filter functions\nCandidate devices for filtering can be specified based on:\n\u2022 Device names\n\u2022 Device types\n\u2022 Equivalence cell pairs\nThis function must be called before the\ncompare()  function.", "function_name": "filter()"}
{"description": "The filter_off()  function disables filtering of the specified devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "filter_off(\nstate        = compare_state,\ndevice_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names = {\"string\", ...},                             //optional\nequiv_cells  = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                       //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. Information\nfrom the filter_off()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that do not have filter options applied.\nEach device must match a device specified in a device_name  argument of a\ndevice configuration function.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which the\nfilter_off()  function applies. You must specify the equiv_cells  pairs in the\nequiv_options()  function before calling the filter_off()  function. If only one\ncell name in the pair is specified, the names are assumed to be the same.\nfilter_off()\nNote:\nThe filter_off()  instruction is observed only when comparing\neach listed equivalence cell pair. If an equivalence cell pair is\nexploded into the parent equivalence cell pair while comparing the\nparent, the filter_off()  instruction is discarded for the content of\nthe exploded cell."}, "summary": "The filter_off()  function disables filtering of the specified devices.", "function_name": "filter_off()"}
{"description": "The flatten_by_cells()  function flattens data in the hierarchy under the specified cells\ninto the specified cells. The output layer is a copy of the input layer with data moved by the\nflatten operation for the specified cells.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells)\nand 2 (Hierarchy) in\nMethodology Check Functions  on page 52.", "syntax": "flatten_by_cells(\nlayer1  = polygon_layer,\ncells  = {\"string\", ...},     //optional\nname   = \"layer_label\",       //optional\nkeep_cells = true  | false     //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the layer that is flattened.", "cells": "Optional. Specifies the cells that are flattened. If the list is empty, the\nflatten_by_cells()  function returns a copy. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. By default, the IC Validator tool flattens all cells.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the exploding of cells in the select_cells list. The default is\ntrue.\nflatten_by_cells()\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization. If a selected cell does get exploded, the selected data (the cell\u2019s\nextents in this case) are placed in the parent cell."}, "summary": "The flatten_by_cells()  function flattens data in the hierarchy under the specified cells\ninto the specified cells.", "function_name": "flatten_by_cells()"}
{"description": "The flatten_by_cells_edge()  function creates a copy of an edge layer by flattening the\nspecified cells.\nNote:\nThis is a methodology check function. See disclaimers 1 (Preserving Cells)\nand 2 (Hierarchy) in\nMethodology Check Functions  on page 52.", "syntax": "flatten_by_cells_edge(\nlayer1  = edge_layer,\ncells  = {\"string\", ...},     //optional\nname   = \"layer_label\",       //optional\nkeep_cells = true  | false,    //optional\nancestry   = true | false     //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the layer that is flattened.", "cells": "Optional. Specifies the cells that are flattened. If the list is empty, the\nflatten_by_cells()  function returns a copy. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. By default, this function flattens all cells.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_cells": "Optional. Specifies the processing of cells in the cells in hierarchy optimization.\nThe default is true.\nflatten_by_cells_edge()\n\u2022 true. Does not explode cells during hierarchy optimization.\n\u2022 false. The selected cells are allowed to explode during hierarchy\noptimization.", "ancestry": "Optional. Specifies if ancestry information is propagated to the output. The\ndefault is false.\n\u2022 true. Propagates the ancestry information to the output. Therefore, the\noutput has polygon membership information.\n\u2022 false. Does not propagate the ancestry information to the output. Therefore,\nthe output does not have polygon membership information."}, "summary": "The flatten_by_cells_edge()  function creates a copy of an edge layer by flattening the\nspecified cells.", "function_name": "flatten_by_cells_edge()"}
{"description": "The fopen()  function generates a handle for the file to be written by the\ndf_fnote()  and\npf_fnote()  utility functions.", "syntax": "fopen(\nfile = \"string\",\nmode = OVERWRITE  | APPEND  //optional\n);", "returns": "ascii_file_handle", "arguments": {"file": "Required. Specifies the file name.", "mode": "Optional. If the file existed before the IC Validator run, specifies if the content\nof the file is either overwritten or appended. (The content of the file is not\noverwritten or appended for every call to the df_fnote()  and pf_fnote()\nfunctions.) The default is OVERWRITE."}, "summary": "The fopen()  function generates a handle for the file to be written by the\ndf_fnote()  and\npf_fnote()  utility functions.", "function_name": "fopen()"}
{"description": "The four_color()  function is used in multi-patterning flows to decompose the input layer\ninto four colors. Optional, precoloring assignments are used during graph coloring.", "syntax": "Note: The definitions for the arguments are after the Returns section.\nfour_color(\nnodes                   = polygon_layer,\nlinks                   = geometry_layer,\npre_color1              = polygon_layer,                     //optional\npre_color2              = polygon_layer,                     //optional\npre_color3              = polygon_layer,                     //optional\npre_color4              = polygon_layer,                     //optional\nstitch_nodes            = polygon_layer,                     //optional\nstitch_links            = {geometry_layer, ...},             //optional\noptional_links         = {geometry_layer, ...},             //optional\neffort_level           = integer,                           //optional\nshift_min_length       = double,                            //optional\nshift_ratio            = double,                            //optional\nshift_mode             = {SHORTEST, CENTER, CENTER_ALL_ANGLE,\nOPPOSITE, ERROR_CENTER, ...},     //optional\ncolor_preference       = NONE  | BALANCED,                   //optional\nsame_color_links       = geometry_layer                     //optional\noutput_complete_graphs = true | false,                      //optional\nlow_degree_reduction   = {WHOLE_GRAPH,\nNEIGHBOR_ONLY, ...},\n//optional\nadditional_reduction   = {CUT_NODE_PAIR_REDUCTION, ...},    //optional\noutput_irregular_links = ALL  | SELF_CONNECT,   //optional\nsearch_mode             = UNSET  | NORMAL | QUICK,   //optional\nquick_mode_spec         = {graph_nodes            = 100000,\nkn_ratio               = 0.3,\nself_loop_ratio        = 0.3,\nflatten_conflict_ratio          = 0.3,\n//optional\nconflict_elimination_time_ratio = 0.3,\npre_color_include_touch  = NONE  | EDGE,\n//optional\nstitch_nodes_list        = {{\nlayer = polygon_layer,\ntype = NONE  | MAX | MIN | REQUIRED},...}\n//optional\n);\nfour_color()", "returns": "The output is a structure of polygons:\nfour_color_result_s : newtype struct of {\ncolor1                               : polygon_layer;\ncolor2                               : polygon_layer;\ncolor3                               : polygon_layer;\ncolor4                               : polygon_layer;\ncolor_conflicts                      : polygon_layer;\nintersecting_links                    : polygon_layer;\ninvalid_stitch_links                  : polygon_layer;\npre_color_errors                     : polygon_layer;\ncolor_conflict_extended_fix_guidance : polygon_layer;\ncolor_conflict_fix_guidance           : polygon_layer;\ncomplete_graphs                       : polygon_layer;\n};\ncolor1\nInput polygons colored with color 1.\ncolor2\nInput polygons colored with color 2.\ncolor3\nInput polygons colored with color 3.\ncolor4\nInput polygons colored with color 4.\ncolor_conflicts\nColor conflict output. This contains both color conflicts and irregular links, which\ninclude invalid links and self-connected links.\nintersecting_links\nMerged or intersecting links.\ninvalid_stitch_links\nStitch links that do no interact with any stitch node.\npre_color_errors\nInput polygons with precolor conflicts. There are three types of precolor conflicts:\nnodes that are precolored with more than one color, required different-color links\nthat are connected to two nodes with the same precolors, and same-color links\nthat are connected to two nodes with different precolors.\nfour_color()\ncolor_conflict_extended_fix_guidance\nPart of the error visualization outputs; this contains nodes and links interacting\nwith color_conflict_fix_guidance  output to provide more context for\nthe areas of the layout that contain errors. When additional_reduction  is\nCUT_NODE_PAIR_REDUCTION, the output is the same as color_conflicts.\ncolor_conflict_fix_guidance\nOne of the error visualization outputs that is used if the input is not 4-colorable.\nIt contains the alternative minimum conflict link configurations and nodes\ninteracting with them. That is, the color_conflicts  output contains one set\nof minimum conflict links, whereas color_conflict_fix_guidance  output\ncontains a superset of those and nodes interacting with them to give you more\nchoices to make the layout 4-colorable. When additional_reduction  is\nCUT_NODE_PAIR_REDUCTION, the output is the same as color_conflicts.\ncomplete_graphs\nComplete graph output in which each pair of graph vertices is connected by\nan edge. A complete graph with N  vertices is represented by KN. A K5 graph\ncannot be four-colorable.", "arguments": {"nodes": "Required. Specifies the polygon layer that contains the polygons targeted for\ncoloring.", "links": "Required. Specifies the input geometry layer that contains polygons that connect\nnodes  polygons to complete the graph description. Each polygon in the links\ngeometry layer must interact, either by edge touch or polygon overlap, with at\nmost four nodes  polygons to achieve correct coloring. If a links  polygon is\nconnected to four nodes  polygons, all three connected nodes  polygons must be\nassigned to different colors.\nThe links  geometry layer is commonly generated using dimensional\ncommands on the nodes  polygon layer. For example, it is generated using\nan external spacing check on the nodes  polygon layer that captures multi-\npatterning critical spacing relationships.\nNote:\nedge_layer  is no longer a valid input of links. It is recommended to\nuse error layer as an input.\nfour_color()", "pre_color1": "Optional. Specifies the marker layers representing color 1 precoloring of the\npolygons. All of the polygons must be included in the nodes  layer. The precolors\nare markers on the nodes. If a precolor marker does not intersect with any node,\nthe marker is ignored.", "pre_color2": "Optional. Specifies the marker layers representing color 2 precoloring of the\npolygons. See\npre_color1  for more information.", "pre_color3": "Optional. Specifies the marker layers representing color 3 precoloring of the\npolygons. See\npre_color1  for more information.", "pre_color4": "Optional. Specifies the marker layers representing color 4 precoloring of the\npolygons. See\npre_color1  for more information.", "stitch_nodes": "Optional. Specifies a marker layer representing stitches.", "stitch_links": "Optional. Specifies a list of geometry layers. By default, all of the layers have the\nsame level of priority.", "optional_links": "Optional. Specifies a list of geometry layers. Each layer is a link layer and has\nan implied weight associated with it. The first layer has weight 1 and has the\nhighest priority after the required link layer. The second layer has weight 2\nand has the next highest priority, and so on. The tool uses these weights in\noptimization, for example, density balancing. You can specify up to seven layers.\nThe default is empty.\nNote:\nAll of the link layers, including the required link layer and layers\ndefined in the optional_links  argument, must be the same type,\nthat is, they all must be either polygon layers or error layers.\nList of edge_layer  are no longer valid inputs of optional_links.\nColor conflicts that involve only optional links are not output.", "effort_level": "Optional. Specifies the coloring effort level. The minimum value is 1, and the\nmaximum value is 6. Using a higher effort level in more complicated designs can\nfour_color()\nincrease accuracy (fewer color conflicts) but might increase the runtime. The\ndefault is 4.", "shift_min_length": "Optional. Specifies the link shifting threshold. A link is shifted only when its\nlength is equal to or greater than this value. The default is 0 (zero).", "shift_ratio": "Optional. Defines the ratio of the shift segment to the overlap segment. For\nexample, if the overlap segment for an error pair is 100 microns and this value\nis set to 0.1, the shift segment is 10 microns. The shifted link is within this\nsegment. The default is 1.", "shift_mode": "Optional. Specifies the mode used to generate the link, which can be a subset of\nall modes. The default is SHORTEST.\n\u2022 SHORTEST. Uses the shortest distance between error pairs to generate a link.\n\u2022 CENTER. Uses center points of the error pair to generate a link. This mode is\napplicable only when the run length is less than or equal to 0 (zero) and the\nlink derived by the default shift mode is orthogonal.\n\u2022 CENTER_ALL_ANGLE. Uses center points of the error pair to generate a link.\nThis mode is applicable only when the error pair run length is less than or\nequal to 0 (zero).\n\u2022 OPPOSITE. Shifts two endpoints of the generated link in opposite directions\nwith respect to the shift ratio. This mode is applicable only when the shift\nrange is positive, which means the run length is greater than 0 (zero), the\nlink length is greater than or equal to the shift threshold, and the shift ratio is\ngreater than 0 (zero).\n\u2022 ERROR_CENTER. Uses center points of the error pair to generate a link.\nNote:\nWhen you select the ERROR_CENTER  option to generate a link, all\nof the other modes are disabled.", "color_preference": "Optional. Specifies if the IC Validator tool balances the coloration on low-degree\nnodes. Balancing is based on the area of the nodes. The default is NONE.\nfour_color()\n\u2022 NONE. Does not balance coloration. Color selection on low-degree nodes is\nrandom.\n\u2022 BALANCED. Balances coloration. When multiple color choices are available,\ncolor selection on low-degree nodes is based on the minimal node area.", "same_color_links": "Optional. Specifies a geometry layer that contains links that connect same-color\nnodes. Same-color links have a higher priority than different-color links because\ntwo nodes connected by a same-color link are treated as one node during the\ncoloring process.\nAdditional color conflicts can be introduced on a required different-color link,\neven when the links have no shared nodes, as shown in\nFigure 257.\nFigure 257 Extra Color Conflict From Same-Color Link\nWhen two nodes are connected with both a same-color link and a different-color\nlink at the same time, the following priorities apply:\n\u2022 If two nodes are connected by a same-color link and a required different-\ncolor link, the required link has priority and the same-color link is ignored.\n\u2022 If two nodes are connected by a same-color link and an optional different-\ncolor link, the optional link is ignored and the two polygons are assigned the\nsame color.\n\u2022 If two nodes connected by a same-color link are precolored with different\ncolors, the same-color link is ignored.", "output_complete_graphs": "Optional. Specifies whether to output the complete graphs. For example, the K5\ngraph cannot be four-colorable. The default is false.\nfour_color()", "low_degree_reduction": "Specifies the method for doing low-degree reduction before coloring. The default\nis WHOLE_GRAPH.\n\u2022 WHOLE_GRAPH. Removes low-degree nodes iteratively. When a low degree-\nnode is identified, this node is removed. Otherwise, this node is kept for the\nnext iteration. The iterations are finished only when no more low-degree\nnodes can be removed.\n\u2022 NEIGHBOR_ONLY. Removes low-degree nodes iteratively. When a low-degree\nnode is identified, this node is removed, and its neighbors are stored for the\nnext iteration. The iterations are finished only when no more low-degree\nnodes can be removed.", "additional_reduction": "Optional. Specifies the method for doing additional graph reduction before\ncoloring. The default is empty.\n\u2022 CUT_NODE_PAIR_REDUCTION. Reduces a biconnected graph to triconnected\ngraphs.", "output_irregular_links": "Optional. Specifies which irregular links are to be output with color conflicts. The\ndefault is ALL.\n\u2022 ALL. Outputs all irregular links with color conflicts.\n\u2022 SELF_CONNECT. Outputs only self-connected links, which are links connecting\nto the same node with color conflicts.", "search_mode": "Optional. Controls the turning on and off of the QUICK  mode for the current\nfunction, but also represents whether the current function specifies its own\nQUICK  mode status. The default is UNSET.\n\u2022 UNSET. Current four_color()  function does not specify its own QUICK\nmode, and QUICK  mode is disabled by default.\n\u2022 NORMAL. Disables QUICK  mode.\n\u2022 QUICK. Enables QUICK  mode.", "quick_mode_spec": "Optional. Controls the early exit for an individual multiple patterning function.\nfour_color()\n\u2022 graph_nodes. Specifies the graph size limit for QUICK  mode. Only the graph\nwhose number of nodes is larger than or equal to the setting value has a\nchance of triggering QUICK  mode. The default is 100000.\n\u2022 kn_ratio. Specifies one of the conditions that can trigger QUICK  mode---the\nproportion of kn in the graph. The default is 0.3.\n\u2022 self_loop_ratio. Specifies one of the conditions that can trigger QUICK\nmode\u2014the proportion of self-loop in the graph. The default is 0.3.\n\u2022 flatten_conflict_ratio. Specifies one of the conditions that can trigger\nQUICK  mode\u2014the proportion of conflicts after flattening in the graph. The\ndefault is 0.3.\n\u2022 conflict_elimination_time_ratio. Specifies the condition that can\ntrigger early exit \u2014 the proportion of time on resolving conflicts. The smaller\nthe ratio, the more aggressive the early exit. The default is 0.3.", "pre_color_include_touch": "Optional. When input polygons share active area with pre-color polygons, the\npre-color polygons are always valid. The input polygons sharing no active area\nwith pre-color polygons can be optionally valid based on outside touches, as\nspecified by this argument. The default is NONE\n\u2022 NONE. Specifies that neither point touch nor line touch causes a polygon to be\nselected.\n\u2022 EDGE. Specifies that an edge touch causes a polygon to be selected.", "stitch_nodes_list": "Optional. Specifies a list of structs of stitch nodes, each combining with one\npolygon layer for stitch node input and one enumeration type value to define the\nusage.\nNote:\nThis option is mutually exclusive with the existing stitch_nodes\noption, only one of them is allowed to be used in each call.\nOtherwise, it would error out.\nThe usage for the stitch node here includes the following four types, the default\nis NONE.\n\u2022 NONE. The same behavior with the currently used input stitch_nodes, that\nis, after solving conflicts, this kind of stitch is not controlled. The node can be\nkept or removed after conflict resolution.\n\u2022 MAX. Retains as many of these stitch nodes as possible.\nfour_color()\n\u2022 MIN. Removes as many of these stitch nodes as possible.\n\u2022 REQUIRED. Always keep these stitch nodes, even if new conflicts arise."}, "summary": "The four_color()  function is used in multi-patterning flows to decompose the input layer\ninto four colors.", "function_name": "four_color()"}
{"description": "The fracture()  function generates triangular partitions when non-orthogonal edges are\npresent.", "syntax": "fracture(\nlayer1      = polygon_layer,\nmin_width    = double,                       //optional\nspace_x      = double,                       //optional\nspace_y      = double,                       //optional\njog_length   = \"double,                      //optional\noutput_type  = {ORTHOGONAL, NON_ORTHOGONAL}, //optional\nname         = \"layer_label\"                 //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer that is partitioned.", "min_width": "Optional. Specifies the minimum width of a partition side. Each side of a\nrectangular partition must have a length of at least the minimum width value.\nThe value must be nonnegative. A value of 0.0 indicates that partitions of all\nsizes are allowed. The default is 0.0.", "space_x": "Optional. Specifies the minimum spacing between partitions in the x-direction.\nThe value must be nonnegative. If space_x = 0.0  and space_y > 0.0, this\nindicates that gaps are not created in the x-direction. If both space_x  and\nspace_y = 0.0, an error occurs.", "space_y": "Optional. Specifies the minimum spacing between partitions in the y-direction.\nThe value must be nonnegative. If space_y = 0.0  and space_x > 0.0, this\nindicates that gaps are not created in the y-direction. If both space_x  and\nspace_y = 0.0, an error occurs.\nfracture()", "jog_length": "Optional. Specifies the jog length for jog removal. A value of 0.0 indicates that\nno jogs are removed before partitioning.", "output_type": "Optional. Specifies that orthogonal or nonorthogonal partitions are created.\n\u2022 ORTHOGONAL. Specifies that only orthogonal partitions are created.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal partitions are created.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The fracture()  function generates triangular partitions when non-orthogonal edges are\npresent.", "function_name": "fracture()"}
{"description": "The gds_library()  function defines a GDSII file name and returns a handle to be used\nby the output_library  argument of the\nwrite_gds()  function.\nNote:\nThe gds_library()  function cannot be called more than one time with the\nsame file  argument. The result, however, can be used in more than one\nwrite_gds()  function, in which case the file is overwritten.", "syntax": "gds_library(\nfile = \"string\"\n);", "returns": "gds_library_handle\ngds_library_handle", "arguments": {"file": "Required. Specifies the GDSII file name. See the\nwrite_gds()  function for\nmore information."}, "summary": "The gds_library()  function defines a GDSII file name and returns a handle to be used\nby the output_library  argument of the\nwrite_gds()  function.", "function_name": "gds_library()"}
{"description": "The gds_options()  function specifies the behavior of the IC Validator tool when reading a\nGDSII file.", "syntax": "gds_options(\nbox                    = DROP  | CONVERT_TO_RECT,            //optional\ncell_name_map          = {{search_string  = \"string\",\nreplace_string = \"string\"}, ...},\n//optional\nforce_cell_name_case   = UPPER | LOWER | MIXED,             //optional\npath_type_1            = ABORT | ACCEPT,                    //optional\npath_type_4            = ABORT | ACCEPT,                    //optional\nmissing_end_construct  = ABORT | CONTINUE,                  //optional\ngenerate_property_text  = NONE  | TOP | ALL,                  //optional\ntext                   = {objects    = {PROPERTY_TEXT, TEXT},\nproperties = {integer, ...}},     //optional\nduplicate_cell         = REPLACE | DROP | MERGE,            //optional\nmerge_references       = true | false,                      //optional\nreplace_instance_name_characters = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                   //optional\nmissing_cell            = REPORT  | ABORT                     //optional\npath_width_multiple_check      = {multiple = 1,\naction   = KEEP| KEEP_AND_WARN |\nDROP | DROP_AND_WARN |\nABORT},         //optional\npath_extension_multiple_check  = {multiple = 1,\naction   = KEEP| KEEP_AND_WARN |\nDROP | DROP_AND_WARN |\nABORT},       //optional\npath_type_1_extension          =  FLUSH  | ROUND | SQUARE    //optional\n);", "returns": "void", "arguments": {"box": "Optional. Specifies the action taken when reading in a GDSII box structure. The\ndefault is DROP.\n\u2022 DROP. Drops the box structures.\n\u2022 CONVERT_TO_RECT. Converts the box structures to rectangles.\ngds_options()", "cell_name_map": "Optional. Specifies a list that tells how cell names are remapped as data is read\nin. By default, the IC Validator tool does not remap cell names.\n\u2022 search_string. Required. Specifies the existing cell name in the input\nstream.\n\u2022 replace_string. Required. Specifies the cell name as it exists within the\nIC Validator tool after the input stream is read.", "force_cell_name_case": "Optional. Forces the character case of cell names. The default is MIXED.\n\u2022 UPPER. Converts all cell names to uppercase characters when the GDSII file\nis read.\n\u2022 LOWER. Converts all cell names to lowercase characters when the GDSII file\nis read.\n\u2022 MIXED. Maintains the character case that cell names have in the GDSII file.", "path_type_1": "Optional. Specifies if the run stops when PathType=1  is encountered while\nreading the GDSII file. When set to ABORT, the run stops. The default is ACCEPT.", "path_type_4": "Optional. Specifies if the run stops when PathType=4  is encountered while\nreading the GDSII file. When set to ABORT, the run stops. The default is ACCEPT.", "missing_end_construct": "Optional. Specifies if the run stops when ENDSTRUCT or ENDLIB is missing.\nWhen set to ABORT, the run stops. The default is CONTINUE.", "generate_property_text": "Optional. Specifies if text points are generated from polygon properties in the\ninput library. The default is NONE.\n\u2022 NONE. Does not generate text from properties in the input library.\n\u2022 TOP. Generates property text only for the top cell of the design.\n\u2022 ALL. Generates property text for all cells in the hierarchy.", "text": "Optional. Controls the reading of text from a GDSII file for each assigned text\nlayer. If the generate_property_text  argument is TOP  or ALL, text points are\ngds_options()\ngenerated for polygons with associated properties. The text is located on the\npolygon and has the same layer and datatype.\nNote:\nThis global option is overwritten by selections made in the gds\nargument of the\nassign_text()  function.\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading a\nGDSII file. The default is TEXT.\n\u25e6 PROPERTY_TEXT. Assigns automatically generated text for polygons.\n\u25e6 TEXT. Assigns GDSII file points from the input database.\n\u2022 properties. Optional. Specifies the property numbers to use when the\nobjects  argument contains PROPERTY_TEXT. The property numbers must\nbe in the range of 0\u2013255, inclusive. If this list is empty, no property text is\nassigned.", "duplicate_cell": "Optional. Specifies how the duplicate cells are processed when reading multiple\nGDSII files. The default is MERGE.\n\u2022 REPLACE. For any duplicate cells, replaces any previously read cells of the\nsame name with the last cell read.\n\u2022 DROP. Does not replace the first cell read with any subsequently read cells of\nthe same name.\n\u2022 MERGE. Merges all geometric data into a single cell. References, however, are\nfurther controlled by the merge_references  argument.\nNote:\nIC Validator tool behavior is arbitrary when multiple definitions of a\ncell exist in a single GDSII file. The duplicate_cell  argument only\napplies to duplicate cells in different GDSII files.", "merge_references": "Optional. Specifies the merging of cell references when duplicate cells are found\nin multiple GDSII files.\nThe merge_references  argument applies only when the duplicate_cell\nargument is MERGE. If the duplicate_cell  argument is REPLACE, the references\nin the last cell read replace any previously read cells of the same name. If the\nduplicate_cell  argument is DROP, the references of the first cell read are\nused. The default is true.\ngds_options()\n\u2022 true. Merges cell references into existing cells when duplicate cells are\nfound.\n\u2022 false. Does not merge cell references into duplicate cells.", "replace_instance_name_characters": "Optional. Lists the strings to be replaced in instance names. Neither string\ncan use string matching. By default, the IC Validator tool does not replace any\ncharacters.\n\u2022 search_string. Required. Specifies the string to replace.\n\u2022 replace_string. Required. Specifies the replacement string. An empty\nstring (\"\") results in the removal of the specified search string.", "missing_cell": "Optional. Specifies the behavior if a referenced cell is missing. The default is\nREPORT.\n\u2022 REPORT. Issues a warning message about the missing cell and reports it in\nthe block.LAYOUT_ERRORS file.\n\u2022 ABORT. Reports an error message for the missing cell.", "path_width_multiple_check": "Optional. Checks that the width value of path records is an even multiple of a\nspecific constraint value.\n\u2022 multiple. Specifies the integer constraint to identify the problematic path\nwidth. The default is 1.\n\u2022 action. Specifies whether the problematic path record is kept, kept and a\nwarning issued, dropped, dropped and a warning issued, or if IC Validator\nshould terminate. The default is KEEP.\n\u25e6 KEEP. Keeps the problematic path record.\n\u25e6 KEEP_AND_WARN. Keeps the problematic path record and issues a\nwarning.\n\u25e6 DROP. Drops the problematic path record.\n\u25e6 DROP_AND_WARN. Drops the problematic path record and issues a\nwarning.\n\u25e6 ABORT. Specifies that IC Validator should terminate.\ngds_options()", "path_extension_multiple_check": "Optional. Checks that the extension value of path records are an even multiple\nof a specific constraint value.\n\u2022 multiple. Specifies the integer constraint to identify the problematic path\nextension. The default is 1.\n\u2022 action. Specifies whether the problematic path record is kept, kept and a\nwarning issued, dropped, dropped and a warning issued, or if IC Validator\nshould stop. The default is KEEP.\n\u25e6 KEEP. Keeps the problematic path record.\n\u25e6 KEEP_AND_WARN. Keeps the problematic path record and issues a\nwarning.\n\u25e6 DROP. Drops the problematic path record.\n\u25e6 DROP_AND_WARN. Drops the problematic path record and issues a\nwarning.\n\u25e6 ABORT. Specifies that IC Validator should terminate.", "path_type_1_extension": "Optional. Specifies how path type 1 (round ended) paths are extended. The\ndefault is FLUSH.\n\u2022 FLUSH. The path extension is the same as path type 0, which is flush ended.\n\u2022 ROUND. The path extension is the same as path type 1, which is round ended.\n\u2022 SQUARE. The path extension is the same as path type 2, which is square\nended."}, "summary": "The gds_options()  function specifies the behavior of the IC Validator tool when reading a\nGDSII file.", "function_name": "gds_options()"}
{"description": "The gendev()  function collects extraction configuration information about generic devices.\nThe configuration information, which contains device body and terminal layers, property\nextraction information, schematic device mappings, and pin handling instructions, is stored\nin the device matrix that is passed to the\nextract_devices()  function.\nUse the gendev()  function to represent generic devices that cannot be handled by one of\nthe standard device configuration functions: capacitor(), inductor(), nmos(), pmos(),\nnp(), pn(), npn(), pnp(), or resistor().\nNote:\nSee Device Names  for the device_name  argument restrictions.", "syntax": "gendev(\nmatrix                 = device_matrix,\ndevice_name             = \"string\",\ndevice_body             = polygon_layer,\ndevice_layers          = {{device_layer      = polygon_layer,\npin_name          = \"string\",\npin_type          = TERMINAL | BULK,\npin_compared      = true  | false},\nmapped_device_pin = \"string\"},\n...},\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL,\nscale_mode =\nMULTIPLY  | UNIT},\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\ngendev()\nmerge_parallel         = true | false,                      //optional\nbulk_relationship       = ENCLOSE  | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name = \"string\",\nterminals   = {\"string\", ...},\nignore_pins = {\"string\", ...}},\n...},                             //optional\nspice_netlist_function = \"string\",                          //optional\nconnectivity           = {{layers   = {polygon_layer, ...},\nby_layer = polygon_layer}, ...}, //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\nextract_shorted_device     = true | false,                  //optional\nmapped_device_type         = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR |\nGENERIC,                        //optional\ntop_simulation_properties = true | false                    //optional\ntext_model_layer        = text_layer                    //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.", "device_name": "Required. Specifies the generic device. A device name can be reused across\nmultiple calls of the gendev()  function if all calls have\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.", "device_body": "Required. Specifies the body layer of the device.\ngendev()", "device_layers": "Required. Specifies a list that defines new terminal layers, including pin names\nand pin types. The number of pins that can be specified is limited to 160.\nNote:\nDo not apply a layer to two device terminals when pin_type  =\nBULK  and pin_type  = TERMINAL, or the tool ignores the setting of\npin_type  = BULK  in the first terminal and reports a warning message.\nFor example:\ndevice_layers = { { aLAYER2, \"A\" }, { aLAYER2, \"B\",\nBULK } }\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Required. Specifies the pin.\n\u2022 pin_type. Optional. Specifies the pin type. The default is TERMINAL.\nNote:\nWhen the layer created from the cell_extent()  or buildsub()\nfunction is a substrate, specify the pin_type  as BULK  (default is\nTERMINAL) to improve performance.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.\n\u2022 mapped_device_pin. Optional. Specifies the default pin name that a specific\npin is mapped to. Each device type has its own predefined default pin\nnames, which are summarized below:\nTable 39 Default Pin Names\nDevice type Required default pin names\nNMOS, PMOS GATE, SRC, DRN\nRESISTOR, CAPACITOR, INDUCTOR A, B\nNPN, PNP EMIT, BASE, COLL\nNP, PN ANODE, CATHODE\ngendev()\nThe layout pin names that are defined or mapped in the gendev()  function\nmust contain all required default pin types of the mapped_device_type\nargument, unless the type is GENERIC. You can explicitly specify the pin\nmapping using this argument or define its pin name as the default pin name.\nWhen any required default pins are not specified, the tool searches for pins\nthat have a default pin name. An error occurs if no default pin name is found.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers (includes text model layer) must interact with this specified\nrecognition layer. This layer is also used to identify device instances that are\nmerged during layout extraction when multiple individual devices occur within a\nsingle recognition layer polygon. See the\nmerge_parallel  argument for more\ninformation.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\ngendev()\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  function for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device. By default, the IC\nValidator tool does not extract any properties.\n\u2022 name. Required. Specifies the property name. See \u201cPredefined Name\nMatches\u201d in Chapter 7, \u201cCompare Functions Basics\u201d of the IC Validator\nLVS User Guide  for the names and associated matches that are predefined\nduring LVS compare.\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Optional. Specifies the data type of the property. The default is\nDOUBLE.\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\ngendev()\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\ngendev()\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the\nnetlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\ngendev()\n- IC Validator determines automatically whether to write the property to a\nnetlist or an annotation file based on the compare section of the runset.\n- The property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the\nnmos() and pmos()  functions for an example.\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric properties\nfor each extracted device. There is no default calculation. The default\ngendev()\ncalc_gendev_properties()  function is defined in the device_public.rh header\nfile.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon. The default is ENCLOSE.\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, no pins can be swapped.\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped independently, and\n\u201cC\u201d and \u201cD\u201d can be swapped independently. However, \u201cA\u201d and \u201cC\u201d cannot be\nswapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}\nDependent-swappable rules can be defined using the following gendev-specific\nfunctions:\n\u2022\nfixed_pins(), swappable_pins, gendev()\nfixed_pins(). Defines a group of pins that are not swappable within the\ngroup, but that can be dependently swapped with other fixed_pins()\ngroups.\nIn this example, \u201cA\u201d and \u201cB\u201d cannot be swapped, but \u201cC\u201d and \u201cD\u201d cannot be\nswapped. However, \u2018A\u201d and \u201cB\u201d can be swapped with \u201cC\u201d and \u201cD\u201d if they are\nswapped as groups.\ngendev()\nswappable_pins = {\npermutable_pins({\nfixed_pins({{\"A\",\"B\"}}),\nfixed_pins({{\"C\",\"D\"}})\n})};\n\u2022\npermutable_pins(), swappable_pins, gendev()\npermutable_pins(). Defines pins or groups of pins that can be permuted.\nIn this example, \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and \u201cD\u201d can be independently swapped with\neach other.\nswappable_pins = {permutable_pins({{\"A\",\"B\",\"C\",\"D\"}})}\nIn this example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. And, \u201cA\u201d and \u201cB\u201d can be swapped with \u201cC\u201d and \u201cD\u201d if they are\nswapped as groups.\nswappable_pins = {\npermutable_pins({\npermutable_pins({{'A\",\"B\"}}),\npermutable_pins({{\"C\",\"D\"}})\n})};", "schematic_devices": "Optional. Specifies the corresponding schematic devices and terminals used\nfor comparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the pin names provided in\nthe device_layers  argument of the gendev()  function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminals. Optional. Specifies the terminals.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the terminals  list, that pin\nis ignored both in the layout and schematic. This behavior is similar to the\ngendev()\npin_compared  option of the device_layers  argument of the gendev()\nfunction.\nIf the schematic device has an optional pin that does not correspond to any\npin in the gendev()  function, that pin can be specified with the ignore_pins.\nOtherwise, this optional pin produces an error during the compare operation.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  for more information.", "connectivity": "Optional. Lists the connections for different layers that make up the body of\nan inductor. This information is used by the\ndev_coil_path_length()  utility\nfunction.\n\u2022 layers. Required. Specifies the layers that make up the inductor.\n\u2022 by_layer. Required. Specifies the polygon layer by which specified layers\nare connected.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Specifies the user-derived string used by the remote property function. The\nunique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe string is valid and unique because the IC Validator tool does not check the\nvalue. The default is an empty string (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\ngendev()\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.", "swappable_properties": "Optional. Specifies the pins and pin-specific device properties that can be\nswapped. The IC Validator tool considers the connectivity of the corresponding\nswapped pins for property-based merge exclusion, device merging composite\nproperty calculations, and property comparisons. Pins that have properties with\nidentical property_list  indexes are swapped. By default, the IC Validator tool\ndoes not map swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to\nthe runset report file. If the text_model_layer  argument is set, text from\ntext_model_layer  takes higher priority. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement data\nto external libraries. See the \u201cDynamic-Link Library Support\u201d chapter in the\nIC Validator User Guide  and\nDynamic Linking Utility Functions  for more\ninformation.", "extract_shorted_device": "Optional. Specifies whether shorted devices, that is, devices with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted devices.\n\u2022 false. Reports shorted devices as error devices.", "mapped_device_type": "Optional. Specifies the target device type that the specified devices are mapped\nto. The default is GENERIC. The target device types are:\n\u2022 NMOS, PMOS, RESISTOR, CAPACITOR, INDUCTOR, NP, PN, NPN, PNP, GENERIC\ngendev()", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nThis behavior is summarized in\nTable 40.\nTable 40 top_simulation_properties Combinations\n-dvp top_simulation_properties -dhe Result\nALL false true Dual-hierarchy flow:\nCompare pass (layout netlist file)\nextraction is hierarchical.\nSimulation pass (annotation file)\nproperties are extracted hierarchically\n(but given the nature of simulation\nproperties, the hierarchy is still mostly\nflat).\nALL false false Single pass flow:\nProperties for both simulation and\ncompare are extracted hierarchically in\nthe layout netlist file (given the nature of\nsimulation properties, the hierarchy is\nstill mostly flat).\nALL true true Dual-hierarchy flow:\nCompare pass (layout netlist file)\nextraction is hierarchical.\nSimulation pass (annotation file)\nproperties are extracted flat in the top\ncell.\nALL true false Single pass flow:\nProperties for both simulation and\ncompare are extracted flat in the layout\nnetlist file.\nLVS \u201cdon\u2019t care\u201d \u201cdon\u2019t care\u201d Single pass flow:\nThe device_properties = LVS\noption forces only the properties being\nused for LVS compare to be netlisted.\nBecause no simulation properties are\noutput, properties for compare are\nextracted hierarchically in the layout\nnetlist file.\ngendev()", "text_model_layer": "Optional. Specifies the layer used to give string property $.MODEL  to the device.\nThe $.MODEL  property of a device is the text whose origin interacts with the body\npolygon of the specific device."}, "summary": "The gendev()  function collects extraction configuration information about generic devices.", "function_name": "gendev()"}
{"description": "The gendev_select()  function selects device polygons from generic devices on the\nspecified layers that fit the specified criteria. A remote function specifies arithmetic\nconditions relative to generic device parameters.", "syntax": "gendev_select(\ndevice_body            = polygon_layer,\ndevice_layers          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},\nmapped_device_pin = \"string\",\ngendev_func            = function,\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nconnect_sequence       = connect_database,\nconnectivity           = {{layer    = {polygon_layer, ...}\nby_layer = polygon_layer}, ...},\n//optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nextract_shorted_device = true | false,                      //optional\nbulk_relationship      = ENCLOSE  | INTERACT                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_body": "Required. Specifies the body layer of the device.", "device_layers": "Required. Specifies a list that defines new terminal layers, including pin names\nand pin types. The number of pins that can be specified is limited to 160.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Required. Specifies the pin.\n\u2022 pin_type. Optional. Specifies the pin type. The default is TERMINAL.\ngendev_select()\nNote:\nWhen the layer created from the cell_extent()  or buildsub()\nfunction is a substrate, specify the pin_type  as BULK  (default is\nTERMINAL) to improve performance.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.\n\u2022 mapped_device_pin. Optional. Specifies the default pin name that a specific\npin is mapped to. Each device type has its own predefined default pin\nnames, which are summarized below:\nTable 41 Default Pin Names\nDevice type Required default pin names\nNMOS, PMOS GATE, SRC, DRN\nRESISTOR, CAPACITOR, INDUCTOR A, B\nNPN, PNP EMIT, BASE, COLL\nNP, PN ANODE, CATHODE\nThe layout pin names that are defined or mapped in the gendev()  function\nmust contain all required default pin types of the mapped_device_type\nargument, unless the type is GENERIC. You can explicitly specify the pin\nmapping using this argument or define its pin name as the default pin name.\nWhen any required default pins are not specified, the tool searches for pins\nthat have a default pin name. An error occurs if no default pin name is found.", "gendev_func": "Required. Specifies the remote function that selects devices based on geometric\ncriteria. See\nUtility Functions  for more information about the utility functions you\ncan use to define a remote function.\ngendev_select()", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  functions for diagrams that illustrate the application of the range\nvalue.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "connect_sequence": "Optional. Specifies the connect database. If specified, the connection is\nconsidered in the device checking process.", "connectivity": "Optional. Lists the connections for different layers that make up the body of\nan inductor. This information is used by the\ndev_coil_path_length()  utility\nfunction.\ngendev_select()\n\u2022 layers. Required. Specifies the layers that make up the inductor.\n\u2022 by_layer. Required. Specifies the polygon layer by which specified layers\nare connected.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "extract_shorted_device": "Optional. Specifies whether shorted devices, that is, devices with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted devices.\n\u2022 false. Reports shorted devices as error devices.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon. The default is ENCLOSE.\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by the enclosing, cutting, or outside edge touching method."}, "summary": "The gendev_select()  function selects device polygons from generic devices on the\nspecified layers that fit the specified criteria.", "function_name": "gendev_select()"}
{"description": "The generate_dpstitch()  function generates valid stitches meeting the input\nspecifications to resolve color conflicts in two_color().", "syntax": "get_filtered_devices(\nstate  = compare_state\n);", "returns": "device_type_name_s", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the init_compare_matrix()  function. The\ninformation from the get_filtered_devices()  function is added."}, "summary": "The generate_dpstitch()  function generates valid stitches meeting the input\nspecifications to resolve color conflicts in two_color().", "function_name": "res_select()"}
{"description": "The get_layout_drawn_violation()  function returns the violation that layout\ndrawn errors (such as self-intersection) are written to during preprocessing. This\nviolation can be used as an argument to the\nwrite_gds(), write_milkyway(), and\nwrite_oasis_global_options()  functions to output polygons for the violation.\nNote:\nBecause layout grid errors consist of a single point, the layer output from\nthis violation contains a generated polygon for each violation. The generated\npolygon is an X, and the polygon is identical to what is displayed in VUE. When\na self-intersection polygon disappears a vanishing polygon error is reported.\nThis polygon error is the bounding box of the original boundary.", "syntax": "get_layout_drawn_violation();", "returns": "violation", "arguments": {}, "summary": "The get_layout_drawn_violation()  function returns the violation that layout\ndrawn errors (such as self-intersection) are written to during preprocessing.", "function_name": "get_layout_drawn_violation()"}
{"description": "The get_layout_grid_violation()  function returns the violation that layout grid errors\nare written to during preprocessing. This violation can be used as an argument to the\nwrite_gds(), write_milkyway(), and write_oasis_global_options()  functions to\noutput polygons for the violation.\nNote:\nBecause layout grid errors consist of a single point, the layer output from\nthis violation contains a generated polygon for each violation. The generated\npolygon is an X, and the polygon is identical to what is displayed in VUE.", "syntax": "get_layout_grid_violation();", "returns": "violation", "arguments": {}, "summary": "The get_layout_grid_violation()  function returns the violation that layout grid errors\nare written to during preprocessing.", "function_name": "get_layout_grid_violation()"}
{"description": "The get_lvs_black_box_cells()  function returns a black-box cell list that is set in the\nlvs_black_box_options()  function.", "syntax": "get_lvs_black_box_cells(\n);", "returns": "list of string", "summary": "The get_lvs_black_box_cells()  function returns a black-box cell list that is set in the\nlvs_black_box_options()  function.", "function_name": "layout_grid_options()", "arguments": {}}
{"description": "The get_netlist_connect_database()  function allows you to access the connect\ndatabase from which the layout netlist is generated from the given device database.\nThe\nextract_devices()  function modifies the input connect database with hierarchy\npreprocessing, such as leveling and merging. In your write function, you can use the same\nconnect database from which the layout netlist is generated so that the net names in the\noutput layout match the netlist. Call this function after the extract_devices()  function.", "syntax": "get_netlist_connect_database(\ndevice_db = device_database\n);", "returns": "connect database", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database."}, "summary": "The get_netlist_connect_database()  function allows you to access the connect\ndatabase from which the layout netlist is generated from the given device database.", "function_name": "get_netlist_connect_database()"}
{"description": "The get_substrate()  function returns a hierarchical layer representing the substrate\nthat is typically used for device extraction and connection. The returned substrate layer\ncontains a single rectangle in each cell of the hierarchy. The rectangle in each cell is the\nsize of the extents for that cell.", "syntax": "get_substrate();", "returns": "polygon layer", "arguments": {}, "summary": "The get_substrate()  function returns a hierarchical layer representing the substrate\nthat is typically used for device extraction and connection.", "function_name": "get_substrate()"}
{"description": "The get_text_merged()  function returns a new violation that contains only the merged\ntext opens from the input violation.", "syntax": "get_text_merged(\nviolation1  = violation\n);", "returns": "violation", "arguments": {"violation1": "Required. Specifies the violation from which the output is derived. The violation\nis usually the left side of an @=  assignment. For more information about\nviolations, see the \u201cViolation Block\u201d section in the IC Validator User Guide."}, "summary": "The get_text_merged()  function returns a new violation that contains only the merged\ntext opens from the input violation.", "function_name": "get_text_merged()"}
{"description": "The get_text_reassign_shorted()  function returns a new violation that contains only\nthe reassigned text shorts from the input violation.", "syntax": "get_text_reassign_shorted(\nviolation1  = violation\n);", "returns": "violation", "arguments": {"violation1": "Required. Specifies the violation from which the output is derived. The violation\nis usually the left side of an @=  assignment. For more information about\nviolations, see the \u201cViolation Block\u201d section in the IC Validator User Guide."}, "summary": "The get_text_reassign_shorted()  function returns a new violation that contains only\nthe reassigned text shorts from the input violation.", "function_name": "get_text_reassign_shorted()"}
{"description": "The get_text_renamed()  function returns a new violation that contains only the renamed\ntext opens from the input violation.", "syntax": "get_text_renamed(\nviolation1  = violation\n);", "returns": "violation", "arguments": {"violation1": "Required. Specifies the violation from which the output is derived. The violation\nis usually the left side of an @=  assignment. For more information about\nviolations, see the \u201cViolation Block\u201d section in the IC Validator User Guide."}, "summary": "The get_text_renamed()  function returns a new violation that contains only the renamed\ntext opens from the input violation.", "function_name": "get_text_renamed()"}
{"description": "The get_text_shorted()  function returns a new violation that contains only the text\nshorts from the input violation.", "syntax": "get_text_shorted(\nviolation1  = violation\n);", "returns": "violation", "arguments": {"violation1": "Required. Specifies the violation from which the output is derived. The violation\nis usually the left side of an @=  assignment. For more information about\nviolations, see the \u201cViolation Block\u201d section in the IC Validator User Guide."}, "summary": "The get_text_shorted()  function returns a new violation that contains only the text\nshorts from the input violation.", "function_name": "get_text_shorted()"}
{"description": "The get_text_unused()  function returns a new violation that contains only the unused\ntext errors from the input violation.", "syntax": "get_text_unused(\nviolation1  = violation\n);", "returns": "violation", "arguments": {"violation1": "Required. Specifies the violation from which the output is derived. The violation\nis usually the left side of an @=  assignment. For more information about\nviolations, see the \u201cViolation Block\u201d section in the IC Validator User Guide."}, "summary": "The get_text_unused()  function returns a new violation that contains only the unused\ntext errors from the input violation.", "function_name": "get_text_unused()"}
{"description": "The get_top_cell()  function returns the top cell name\ntop cell name, getting\n. The top cell name is obtained\nfrom the cell  argument of the library()  function or from the -c  command-line option.\nThe -c  command-line option overrides the top cell name. See the Command-Line Options\nsection in the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more\ninformation.", "syntax": "get_top_cell();", "returns": "string", "arguments": {}, "summary": "The get_top_cell()  function returns the top cell name\ntop cell name, getting\n.", "function_name": "get_top_cell()"}
{"description": "The gradient_density()  function checks\nlayout density\nlayout density changes (gradients) between\nneighboring the delta_window  subwindow based on user-programmable density\nequations.\nThe gradient_density()  function calls a remote density function for each subwindow.\nThe remote function calls various utility functions that operate on the current subwindow or\nneighboring subwindow to produce error output and density statistics.", "syntax": "gradient_density(\nwindow_layer             = polygon_layer,\nlayer_hash               = {\"string\" => polygon_layer, ...},\nwindow_function          = function,\ndelta_window             = {width = double, height = double},\n//optional\nrows                     = integer,                         //optional\ncolumns                  = integer,                         //optional\nx_edge_process_amount    = double,                          //optional\ny_edge_process_amount    = double,                          //optional\narea_clip_delta_percent  = double                           //optional\nstatistics_files         = {density_statistics_file_handle,  ...},\n//optional\nstatistics_file_modes    = {OVERWRITE | APPEND, ...},       //optional\ncentered_square_size     = double,                          //optional\nboundary                  = CLIP  | ALIGN | IGNORE |\nREPLICATE_WINDOW | BACKUP        //optional\noutput_type               = DELTA_WINDOW  | CLIPPED_DELTA_WINDOW |\nCENTER | CLIPPED_CENTER,         //optional\noutput_center_dimensions = {width = double, height = double},\n//optional\nprocess_delta_windows    = OVERLAPPING  | ALL,               //optional\nname                     = \"layer_label\",                   //optional\ndelta_x                   = double,                          //optional\ndelta_y                   = double,                          //optional\ntraverse_boundary        = POLYGON_EXTENT  |\nVERTICAL_TRAPEZOID_EXTENTS |\nHORIZONTAL_TRAPEZOID_EXTENTS     //optional\n);", "returns": "polygon layer or error result\ngradient_density()", "arguments": {"window_layer": "Required. Specifies the polygon layer containing one or more polygons that\ndefine the boundaries where layers are processed for density calculations.\nThe\nchip_extent()  and layer_extent()  functions can be used to create a\nwindow layer. Call these functions before the gradient_density()  function.\n\u2022 The chip_extent()  function returns a layer containing a single rectangle\nequal to the extents of the chip. Use this function to create a single full-chip\ncheck window. See the\nchip_extent()  function for more information.\n\u2022 The layer_extent()  function returns a layer containing a single rectangle\nequal to the extents of the input layer. Use this function to create a single-\nlayer check window. See the\nlayer_extent()  function for more information.", "layer_hash": "Required. Specifies the hash of string to polygon layer that is processed for\ndensity calculations. Data in this hash is accessible via the hash key within the\nremote window function. When referencing data from within the window function,\nonly the portion of the layer within the current delta_window  subwindow or the\ncurrent window_layer  polygon is seen.", "window_function": "Required. Specifies the remote function that calculates the gradient density. See\nGradient Density Utility Functions  for more information about the utility functions\nyou can use to define a remote function.", "delta_window": "Optional. Specifies the subwindow stepped across each window_layer  polygon.\nThe density equations are evaluated within each subwindow. The default is\ncalculated based on the number of rows and columns, specified using the rows\nand columns  arguments, and the extents of each window_layer  polygon.", "rows": "Optional. Specifies the number of rows each window_layer  polygon is divided\ninto. The default is 1.", "columns": "Optional. Specifies the number of columns each window_layer  polygon is\ndivided into. The default is 1.\ngradient_density()", "x_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the right edge of\nthe boundary by the specified value or more, specifies to shift the current\nsubwindow left to make it flush with the right edge of the current boundary.", "y_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the top edge of the\nboundary by the specified value or more, specifies to shift the current\nsubwindow down to make it flush with the top edge of the current boundary.", "area_clip_delta_percent": "Optional. Ignores the current delta_window  subwindow if the density ratio\nof the window_layer  material inside the current subwindow is less than the\nspecified value. By default, the IC Validator tool ignores any subwindow with a\nwindow_layer  density of 0.", "statistics_files": "Optional. Specifies the handles of the files written to by\ngden_window_statistics()  utility functions included in the specified remote\nwindow function. Do not specify the same file more than one time. These files\nare defined using the\ndensity_statistics_file()  function.", "statistics_file_modes": "Optional. Specifies the action taken when the file already exists for each\nstatistics file of the gradient_density()  function. If only one mode is specified,\nit is used for all files. The default is OVERWRITE.\n\u2022 OVERWRITE. Overwrites the previous statistics file. That is, the statistics file\ncontains only statistics from this function.\n\u2022 APPEND. Appends the new data to the previous statistics file. That is, the\nstatistics file contains the statistics from previous density functions along with\nthe new statistics from this function.", "centered_square_size": "Optional. Specifies that squares centered on polygons inside the window layer\nare used as the windows for density calculations. The default is 0.0.\n\u2022 The value must be greater than or equal to 0.\n\u2022 If the value is 0, the gradient_density()  function does not output centered\nsquares.\ngradient_density()\nIf the value is greater than 0, then the IC Validator tool performs the following\nsteps:\n1. For each polygon of the window layer, find the rectangular extent.\n2. Find the center point of the rectangular extent, whose coordinates are (x,y).\n3. Set\n\u25e6 X1 = x - centered_square_size/2\n\u25e6 Y1 = y - centered_square_size/2\n\u25e6 X2 = x + centered_square_size/2\n\u25e6 Y2 = y + centered_square_size/2\nNote:\nIf the values are not on grid, they are rounded up to the next grid\nvalue.\n4. Perform all normal density operations with X1, Y1, X2, Y2 defining the\nwindow layer.\nFor example,\ngradient_density(\nwindow_layer = metal1_extent,\nlayer_hash = { \"layer1\" => metal1 },\nwindow_function = my_density_function,\ncentered_square_size = 15\n);\nThe window is defined by\nX1 = x - 15/2\nY1 = y - 15/2\nX2 = x + 15/2\nY2 = y + 15/2\nPerforming the normal density operations the generated window layer is defined\nas shown in\nFigure 263.\ngradient_density()\nFigure 263 Generation of Centered Square", "boundary": "Optional. Specifies how to process a delta_window  subwindow that overlaps\nthe boundary of the extents of a window layer polygon. The default is CLIP.\n\u2022 CLIP. Truncates the subwindow at the limits of the window layer.\nif the x_edge_process_amount  or y_edge_process_amount  argument is not\nequal to -1 when the boundary  argument is CLIP, then\n\u25e6 If the overhang is less than the x_edge_process_amount  or\ny_edge_process_amount  value, a clip is performed.\n\u25e6 If the overhang is equal to or greater than the x_edge_process_amount\nor y_edge_process_amount  value, an align is performed.\n\u25e6 If the overhang in the horizontal direction is less than the\nx_edge_process_amount  value, then clip the subwindow along the\nwindow layer.\n\u25e6 If the overhang in the horizontal direction is equal to or greater than\nthe x_edge_process_amount  value, then align the subwindow with the\nwindow layer\ngradient_density()\n\u25e6 If the overhang in the vertical direction is less than\ny_edge_process_amount  value, then clip the u along the window layer\n\u25e6 If the overhang in the vertical direction is equal or more than\ny_edge_process_amount  value, then align the subwindow with the\nwindow layer\nFigure 69  shows how a subwindow is clipped.\n\u2022 ALIGN. If a subwindow overlaps the right side or top edge of the window\nlayer, shifts the window left or down until it no longer overlaps the window\nlayer. The density calculation is performed after the window is shifted.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is ALIGN.\nFigure 70  shows how a subwindow is aligned.\n\u2022 IGNORE. If a subwindow overlaps the right or top edges of the window\nlayer boundary, ignores the subwindow and does not output data for that\nsubwindow location.\nNote:\nBoth x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is IGNORE.\nFigure 71  shows when the subwindow is ignored.\n\u2022 REPLICATE_WINDOW. To simulate density measurements on a die, replicates\nthe input layers to properly measure density at the boundary of the chip. if\na window overlaps the right or top edges of the window layer polygons, the\nwindow layer extent and its data is duplicated and added to the right or top\nside of the original bounding box. The density measurement on the boundary\nsubwindow is calculated considering the original data and the duplicated\ndata.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is\nREPLICATE_WINDOW.\nFigure 72  shows a replicated subwindow.\n\u2022 BACKUP. Shifts the overlapping subwindow the same way the ALIGN  option\nshifts it. See ALIGN  for more details.\ngradient_density()\nIn addition, BACKUP prevents gradient evaluation between the center\nsubwindow and any adjacent subwindows that overlap the row or column of\nthe center subwindow.\nFigure 264  shows examples comparing the gradient evaluation between\nthe center subwindow and adjacent subwindows by the ALIGN  and BACKUP\noptions.\nFigure 264 Gradient Evaluation Between the Center Subwindow and Adjacent\nSubwindows", "output_type": "Optional. Specifies the type of output generated. The default is DELTA_WINDOW.\n\u2022 DELTA_WINDOW. Outputs the delta_window  subwindow saved by the\ngden_save_window()  utility function.\n\u2022 CLIPPED_DELTA_WINDOW. Outputs the intersection between the subwindow\nand the window_layer  polygon. This intersection is performed after\nthe remote window function calculations are completed. This option\nensures all output subwindows are inside the boundaries of nonrectangular\nwindow_layer  polygons.\n\u2022 CENTER. Outputs the rectangle placed at the center of the subwindow\nsaved by the gden_save_window()  utility function. The dimensions of the\nrectangle are specified by the output_center_dimensions  argument.\nAn error is given when the output_type  argument is CENTER  and the\noutput_center_dimensions  argument is {0, 0}.\n\u2022 CLIPPED_CENTER. Output the intersection between the rectangle placed\nat the center of the subwindow and the window_layer  polygon. This\nintersection is performed after the remote window function calculations\nare completed. This option ensures all center subwindows are inside the\nboundaries of the window_layer  polygons.", "output_center_dimensions": "Optional. Specifies the dimensions of the rectangle output when the\noutput_type  argument is CENTER.\ngradient_density()", "process_delta_windows": "Optional. Controls the handling of delta_window  subwindow processing within\nthe extents of a window layer polygon. The default is OVERLAPPING.\n\u2022 OVERLAPPING. Specifies to process only subwindows that overlap the window\nlayer polygon.\n\u2022 ALL. Specifies to process all subwindows that fall within the extent of the\nwindow layer polygon.\nWhen using the ALL  option,\n\u25e6 Do not set the output_type  argument to CLIPPED_DELTA_WINDOW  or\nCLIPPED_CENTER.\n\u25e6 Do not use the area_clip_delta_percent  argument.\nSee\nFigure 73  in the density()  function for more information.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "delta_x": "Optional. Specifies the delta_window  subwindow step distance in the x-\ndirection. The delta_x  value must evenly divide into the width  option of the\ndelta_window  argument. The default is the width  option of the delta_window\nargument.", "delta_y": "Optional. Specifies the delta_window  subwindow step distance in the y-\ndirection. The delta_y  value must evenly divide into the height  option of the\ndelta_window  argument. The default is the height  option of the delta_window\nargument.", "traverse_boundary": "Optional. Specifies the type of delta_window  subwindow traversal to be\nperformed. The default is POLYGON_EXTENT.\n\u2022 POLYGON_EXTENT. Specifies that the extents of the current window_layer\npolygon define the boundary in which the delta windows are traversed. The\ntraversal starts at the left-bottom corner of the current window layer polygon\nextent and ends at the right-top corner of the polygon extent.\ngradient_density()\n\u2022 VERTICAL_TRAPEZOID_EXTENTS. Specifies that each vertically fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each vertical trapezoid extent and ends at the right-top corner of the\ntrapezoid extent.\n\u2022 HORIZONTAL_TRAPEZOID_EXTENTS. Specifies that each horizontally fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each horizontal trapezoid extent and ends at the right-top corner of the\ntrapezoid extent."}, "summary": "The gradient_density()  function checks\nlayout density\nlayout density changes (gradients) between\nneighboring the delta_window  subwindow based on user-programmable density\nequations.", "function_name": "gradient_density()"}
{"description": "The grid_pattern_edge()  function outputs the imaginary grid lines that are inside or\ncoincident with the layer extent of the union of the bounding layer and reference layer.", "syntax": "grid_pattern_edge(\nbounding_layer  = polygon_layer,\nreference_layer  = polygon_layer,\ngrid_pattern    = list of double,\noffset          = double,\norientation     = VERTICAL | HORIZONTAL,\nname            = \"layer_label\"                             //optional\n);", "returns": "edge layer", "arguments": {"bounding_layer": "Required. Specifies the input polygon layer to limit the edges that can be\nsnapped. Both the data to be snapped and the snapped result should be inside\nor coincident with the bounding layer.", "reference_layer": "Required. Specifies the input polygon layer to use (left, bottom) of its layer\nextents as the reference point to define the grid pattern.", "grid_pattern": "Required. Specifies different distance values to form the repeated pattern.", "offset": "Required. Specifies the distance before the repeated pattern, measured from\nthe reference point, which depends on the orientation  argument:\n\u2022 orientation=VERTICAL. Uses the left of the layer extents of the reference\nlayer.\n\u2022 orientation=HORIZONTAL. Uses the bottom of the layer extents of the\nreference layer.", "orientation": "Required. Specifies the orientation used to snap to the grids.\ngrid_pattern_edge()\n\u2022 VERTICAL. Snaps the x-coordinate of vertices from vertical edges.\n\u2022 HORIZONTAL. Snaps the y-coordinate of vertices from horizontal edges.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The grid_pattern_edge()  function outputs the imaginary grid lines that are inside or\ncoincident with the layer extent of the union of the bounding layer and reference layer.", "function_name": "grid_pattern_edge()"}
{"description": "The group_library()  function defines a group library path and returns a handle to\nbe used by the output_library  argument of the\nwrite_group()  function and the\ninput_library  argument of the read_group()  and read_group_edge()  functions.\nNote:\nThe group_library()  function cannot be called more than one time with the\nsame path value. Multiple read_group()  and read_group_edge()  functions\ncan use the same handle within a run; however, these functions cannot have\nthe same handle as a write_group()  function within that run.", "syntax": "group_library(\npath = \"string\"\n);", "returns": "group_library_handle\ngroup_library_handle", "arguments": {"path": "Required. Specifies the library path."}, "summary": "The group_library()  function defines a group library path and returns a handle to\nbe used by the output_library  argument of the\nwrite_group()  function and the\ninput_library  argument of the read_group()  and read_group_edge()  functions.", "function_name": "group_library()"}
{"description": "The grouped_by()  function selects polygons from layer1  layer that interact with the\nlayer2  layer and satisfy the specified filter. The filter is applied to groups of layer1\npolygons that are formed by gathering any layer1  and layer2  polygons that interact.\nOnly one polygon is selected from each group. Because the filter is not a unique\ncharacteristic, the polygon selection is arbitrary.\nNote:\nInteraction includes overlap and edge touch but not point touch.", "syntax": "grouped_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\nfilter           = MAX_AREA | MIN_AREA,\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer defining grouping of layer1.", "filter": "Required. Specifies the criteria for polygon selection.\n\u2022 MAX_AREA. Selects a layer1  polygon with maximum area from each group.\n\u2022 MIN_AREA. Selects a layer1  polygon with minimum area from each group.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ngrouped_by()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The grouped_by()  function selects polygons from layer1  layer that interact with the\nlayer2  layer and satisfy the specified filter.", "function_name": "grouped_by()"}
{"description": "The grow()  function creates polygons from the input layer that are oversized in\nthe specified directions by the specified distances. If the north, south, east,\nand west  arguments are all 0 (zero) then the output is the original layer. See the\nprototype_options()  function for more information about defining the criteria for the\ncreation of prototype cells during hierarchical preprocessing.", "syntax": "grow(\nlayer1          = polygon_layer,\nnorth           = double,                     //optional\nsouth           = double,                     //optional\neast            = double,                     //optional\nwest            = double,                     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",             //optional\norientation      = ALL  | ORTHOGONAL,          //optional\ncorner_extension  = NONE | INTERSECTION       //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "north": "Optional. Specifies the oversize distance in the northern direction, or the top of\nthe polygons. The default is 0.", "south": "Optional. Specifies the oversize distance in the southern direction, or the bottom\nof the polygons. The default is 0.", "east": "Optional. Specifies the oversize distance in the eastern direction, or right of the\npolygons. The default is 0.", "west": "Optional. Specifies the oversize distance in the western direction, or left of the\npolygons. The default is 0.\ngrow()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "orientation": "Optional. Specifies the edges to grow. The default is ALL.\n\u2022 ALL. Grows all the edges.\n\u2022 ORTHOGONAL. Grows only the orthogonal edges.", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The default is INTERSECTION.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 NONE. Does not extend corners."}, "summary": "The grow()  function creates polygons from the input layer that are oversized in\nthe specified directions by the specified distances.", "function_name": "grow()"}
{"description": "The hierarchy_auto_options()  function specifies the hierarchy optimizations that are\nautomatically performed on the input design hierarchy. These optimizations maximize\nperformance. This function can be called only one time in a runset.\nThe hierarchy_options()  function take precedence over the\nhierarchy_auto_options()  function. The order of precedence is listed in the\nhierarchy_options()  function.", "syntax": "hierarchy_auto_options(\napplication          = AUTO_DETECT  | DRC | LVS |\nFILL | PERC | LVL,                         //optional\nflow                 = NONE  | ERROR_CLASSIFICATION,         //optional\noptimizations        = {REDUCTION, INSERTION},              //optional\nno_explode_with_text = true | false,                        //optional\ndelete_exploded_text  = true | false,                        //optional\nreplace_cell_optimization  = OFF | UNSPECIFIED  | ON          //optional\n);", "returns": "void", "arguments": {"application": "Optional. Specifies the type of run being performed so that the IC Validator tool\ncan optimally set the hierarchy. The default is AUTO_DETECT.\n\u2022 AUTO_DETECT. Determines the type of run based on the functions within the\nrunset.\n\u2022 DRC. Optimizes the hierarchy for performance when generating DRC\nviolations.\n\u2022 LVS. Optimizes the hierarchy for netlist generation, device extraction, LVS\nperformance, and LVS debugging.\n\u2022 FILL. Optimizes the hierarchy for performance when generating fill.\n\u2022 PERC. Optimizes the hierarchy for device extraction and netlist generation\nnecessary for PERC flows.\nYou must add layer_intent = {LAYER_INTENT_INTERCONNECT}  in each\ncall to assign()  for any layers you want to identify as interconnect layers.\nhierarchy_auto_options()\nThis enables IC Validator to explode \u201cinterconnect only\u201d cells, that is, cells\nthat contain only layers identified as interconnect layers, when the PERC\noptimization is enabled. See the\nlayer_intent  of the assign()  function for\nmore information.\n\u2022 LVL. Optimizes the hierarchy for Layout vs Layout runs through IC Validator.\nSee the library_import()  function for importing a second library for a LVL-\nstyle run. The icv_lvl utility can also be used for LVL.", "flow": "Optional. Restricts automatic hierarchy optimizations to increase consistency of\nerror output between subsequent IC Validator runs. The default is NONE.\nNote:\nhierarchy optimization, disablingerror classification\nThis option is typically set to ERROR_CLASSIFICATION  when you run\nerror classification in CELL_LEVEL  mode, including for the initial IC\nValidator run. However, HIERARCHICAL  mode is the recommended\nmode for error classification, and the flow  argument must be\nNONE. See the partially_exploded_cells  argument of the\nerror_options()  function for more information on HIERARCHICAL\nmode.\n\u2022 NONE. Makes normal automatic hierarchy optimizations.\n\u2022 ERROR_CLASSIFICATION. Restricts automatic hierarchy optimizations to\nmake the hierarchy more consistent between IC Validator runs.", "optimizations": "Optional. Specifies optimizations to occur during hierarchy preprocessing. The\ndefault is {REDUCTION, INSERTION}.\n\u2022 REDUCTION. Explodes cells to reduce ineffective hierarchy. Virtual cells,\nvcells, are not created.\nvirtual cellscreatedvcells\n\u2022 INSERTION. Inserts virtual cells to provide more effective hierarchy.", "no_explode_with_text": "Optional. Specifies the exploding of cells with text. The default is false.\n\u2022 true. Does not explode cells with text.\n\u2022 false. Explodes cells with text and text might be lost.", "delete_exploded_text": "Deletes exploded text from automatically exploded cells.\nBy default IC Validator deletes all exploded text. Setting\nhierarchy_auto_options(delete_exploded_text=true)  by itself has no\nhierarchy_auto_options()\neffect. When text_options(use_exploded_text=true), user-exploded text is\nretained while automatically exploded text is deleted. The default is false.\n\u2022 true. Specifies that exploded text from automatically exploded cells is\ndeleted.\n\u2022 false. Specifies that text is deleted according to the text_options()  and\nassign_text()  functions.", "replace_cell_optimization": "Optional. Replaces duplicate cells. The default is UNSPECIFIED.\n\u2022 OFF. Turns off duplicate cell placement.\n\u2022 UNSPECIFIED. Turns on duplicate cell placement.\n\u2022 ON. Turns on duplicate cell placement.\nWhen hierarchy_auto_options(optimizations = {}, ...), duplicate cell\nreplacement is turned off for UNSPECIFIED, but not for ON.\nDuplicate cell replacement creates at most two log files in\nrun_details/hierarchy/duplicate_cells.log1\nrun_details/hierarchy/duplicate_cells.log2\nThe duplicate_cells.log1 file indicates which duplicate cells were found, kept,\nand replaced. The first section lists the root duplicate cells. These are duplicate\ncells which are the root of a duplicate cell tree, that is, they have at least one\nparent cell that is not a duplicate cell. Notice that root duplicate cells are not\nnecessarily the root cell for all of their placements. A non-root duplicate cell is\nalways a child of another duplicate cell.\nEach group of duplicate cells is listed as shown here:", "kept_cellname": "", "replaced_cellname_1": "", "replaced_cellname_2": "...\nreplaced_cellname_N\nIn this case, the duplicate cell group consists of N+1 cells. The\nkept_cellname cell is kept in the hierarchy, while replaced_cellname_1,\nreplaced_cellname_2, ..., replaced_cellname_N are replaced with\nkept_cellname.\nDuplicate cell replacement is turned off for a number of flows that are not\ncurrently supported, regardless of the replace_cell_optimization  argument\nhierarchy_auto_options()\nsetting. You can determine if replace duplicate cells was disabled by referring to\nthe duplicate_cells.log1 file."}, "summary": "The hierarchy_auto_options()  function specifies the hierarchy optimizations that are\nautomatically performed on the input design hierarchy.", "function_name": "hierarchy_auto_options()"}
{"description": "The hierarchy_options()  function modifies the hierarchy in the input layout. See the\nhierarchy_auto_options()  function for arguments related to the automatic optimization\nof the hierarchy.\nEquivalence and black-box cells are preserved from being exploded by automatic\nexplodes, but not from a manual flatten or explode such as hierarchy_options(flatten\n= {\"*\"}  or hierarchy_options(explode = {\"foo\"})). The only hierarchy\noption that overrides a manual flatten or explode is a manual no explode, that is,\nhierarchy_options(no_explode = {\"bar\"}).\nThe hierarchy_options()  function take precedence over the\nhierarchy_auto_options()  function. The order of precedence is a follows:\n\u2022 Equivalence and black-box cells are automatically no-exploded. These automatic\nno-explodes take precedence over automatically-generated hierarchy optimization\nexplodes.\n\u2022 hierarchy_options(explode, flatten)  takes precedence over automatically-\ngenerated no-explodes for equivalence and black-box cells.\n\u2022 hierarchy_options(no_explode)  takes precedence over everything.", "syntax": "hierarchy_options(\ndelete             = {\"string\", ...},                       //optional\nexplode            = {\"string\", ...},                       //optional\nexplode_all        = {\"string\", ...},                       //optional\nflatten            = {\"string\", ...},                       //optional\nno_explode         = {\"string\", ...},                       //optional\narefs_to_srefs     = {\"string\", ...},                       //optional\npairs  = {}, //deprecated\nsets  = {}, //deprecated\nflatten_by_layer     = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},\n...},                                //optional\nflatten_by_layer_purpose     = {{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},                       //optional\nno_replace           = {\"string\", ...},                      //optional\nno_explode_by_layer  = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},\n...}                               //optional\n);\nhierarchy_options()", "returns": "void", "arguments": {"delete": "Optional. Specifies the cells that are deleted from the hierarchy. Therefore,\nthese cells are not checked. String matching using metacharacters is allowed.\nSee\nString Matching  on page 3353 for more information. By default, the\nIC Validator tool does not delete cells.", "explode": "Optional. Specifies the cells that are exploded into their parent cells. All data\nplacements within an exploded cell are translated and stored in the parent\ncell. String matching using metacharacters is allowed. See\nString Matching\non page 3353 for more information. By default, the IC Validator tool does not\nexplode cells other than those cells that meet the automatic explode criteria, for\nexample, placed only one time.", "explode_all": "Optional. Specifies the cells that are hierarchically exploded, along with all\ncells beneath the specified cells, into the parent of the specified cells. (This\nargument is, therefore, a combination of the flatten  and explode  arguments\nfor the specified cells.) The result is flat data in the parent cell. String matching\nusing metacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. By default, the IC Validator tool does not explode cells and their\nchildren other than those cells, and all of their descendants, that meet the\nautomatic explode criteria.", "flatten": "Optional. Specifies the cells that are beneath where the specified cells are\nexploded up so that the specified cells contain only flat data.\nflat dataflatten\nString matching\nusing metacharacters is allowed. See String Matching  on page 3353 for more\ninformation. By default, the IC Validator tool does not flatten cells other than\nthose cells that get flattened as a by product of the automatic explode criteria.", "no_explode": "Optional. Specifies cells that are not exploded. This list takes precedence over\nany explode argument for a specified cell or any automatic optimization. String\nmatching using metacharacters is allowed. See\nString Matching  on page 3353\nfor more information. By default, the IC Validator tool does not protect cells from\nexploding during preprocessing.\nhierarchy_options()\nNote:\nArguments to other functions in the OPTIONS section can\nalso prevent the explosion of specifically named cells during\npreprocessing. For example, the cells specified in the select_cells\nargument of the assign()  function are not exploded even if they are\nlisted in the explode  or explode_all  arguments.\nThe no_explode  argument takes precedence over the explode  and\nexplode_all  arguments, but it does not prevent a cell from being\nflattened. If a cell is in the no_explode  and flatten  lists, then it is\npreserved (not exploded into its parent cells), but it is still flattened.\nThat is, all of its children are exploded up into it, so that it has no\nchildren; it is a flat cell.\nDisabling or limiting automatic hierarchy optimization can have a\nsignificant negative affect on performance and is discouraged.", "arefs_to_srefs": "Optional. Specifies the cells for which the AREFs (array references) are broken\ninto their component SREFs (structured references). String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. The default is only those AREFs that meet the default conversion\ncriteria are converted to SREFs.", "pairs": "This argument is deprecated, it does not do anything.", "sets": "This argument is deprecated, it does not do anything.", "flatten_by_layer": "Optional. Lists layer range and datatype range pairs that are flattened. Cells that\ncontain at least one polygon on the specified layers and datatypes are flattened.\nBy default, there is no flattening of cells by layer. The data_type_range  value\nfor each pair is optional, with a default of all datatypes. See\nLayout Layer and\nDatatype Ranges  for information about the limits of the values.", "flatten_by_layer_purpose": "Optional. Lists layer range and purpose name pairs that are flattened. Cells in\nan OpenAccess layout that contain at least one polygon on the specified layers\nand purposes are flattened. The purpose name for each pair is optional, with a\ndefault of all purpose names. By default, there is no flattening of cells by layer.\nhierarchy_options()", "no_replace": "Optional. Specifies a list of cells that should not participate in duplicate cell\nreplacement.", "no_explode_by_layer": "Optional. Lists layer range and data type range pairs that are marked\nno_explode. Cells that contain at least one polygon on the specified layers and\ndata types are marked no_explode. By default, there is no no_explode  of cells\nby layer. The data_type_range  value for each pair is optional, with a default of\nall data types. See\nLayout Layer and Datatype Ranges  for information about the\nlimits of the values."}, "summary": "The hierarchy_options()  function modifies the hierarchy in the input layout.", "function_name": "hierarchy_options()"}
{"description": "The import_gds_cell()  function reads the hierarchy tree of a cell from the specified\nGDSII library.\nUsing the result of the import_gds_cell()  function as input to the cell  option of the\nplace_cells  argument of a write function, you can place the cell based on shapes in a\nmarker layer.\nNote:\nA GDSII file can be gzipped\nGDSII filezipped\n. The IC Validator tool automatically detects if a\nGDSII file is gzipped.", "syntax": "import_gds_cell(\ninput_library = gds_library_handle,\ncell          = \"string\"\n);", "returns": "cell_handle", "arguments": {"input_library": "Required. Specifies the library that has the cell to be placed. See the\ngds_library()  function for information about defining the gds_library_handle.", "cell": "Required. Specifies the top cell name of the cell to be placed."}, "summary": "The import_gds_cell()  function reads the hierarchy tree of a cell from the specified\nGDSII library.", "function_name": "import_gds_cell()"}
{"description": "The import_oasis_cell()  function reads the hierarchy tree of a cell from the specified\nOASIS library.\nUsing the result of the import_oasis_cell()  function as input to the cell  option of the\nplace_cells  argument of a write function, you can place the cell based on shapes in a\nmarker layer.\nNote:\nAn OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool automatically detects if an\nOASIS file is gzipped.", "syntax": "import_oasis_cell(\ninput_library = oasis_library_handle,\ncell          = \"string\"\n);", "returns": "cell_handle", "arguments": {"input_library": "Required. Specifies the library that has the cell to be placed. See", "the": "oasis_library()  function for information about defining the\noasis_library_handle.", "cell": "Required. Specifies the top cell name of the cell to be placed."}, "summary": "The import_oasis_cell()  function reads the hierarchy tree of a cell from the specified\nOASIS library.", "function_name": "import_oasis_cell()"}
{"description": "The incremental_connect()  function creates a new connect database by adding\nelectrical connectivity for the specified layers to a previously created connect database.\nFor each entry within the connect_items  argument, connectivity is independently\nestablished from each layer in the layers  list to the layer specified with the by_layer\noption. The resulting connect database is untexted.", "syntax": "incremental_connect(\nconnect_sequence = connect_database,\nconnect_items    = {{layers              = {polygon_layer, ...},\nby_layer            = polygon_layer,\ninclude_touch       = NONE | EDGE,\nby_layer_connection = ALL  | SHIELDED_OVERLAP},\n...}\n);", "returns": "connect database", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "connect_items": "Required. Lists the connection specifications.\n\u2022 layers. Required. Specifies a list of the polygon layers to connect.\n\u2022 by_layer. Optional. Specifies the polygon layer by which the layers specified\nin the layers  argument are connected. By default, these layers connect\ndirectly with each other; they are not connected through a by layer.\nIn the following example, the layers are all connected to each other without a\nby layer.\nFigure 268  illustrates this example.\nincremental_connect(connect_database, connect_items =\n{{{layer1,\nlayer2, layer3, layer4}}} );\nincremental_connect()\nFigure 268 Layers Connected Without a By Layer\n\u2022 include_touch. Optional. Specifies whether polygons with only an outside\ntouch interaction form an electrical connection. The default is EDGE.\n\u25e6 NONE. Specifies that outside touch does not form an electrical connection.\n\u25e6 EDGE. Specifies that outside edge touch forms an electrical connection.\n\u2022 by_layer_connection. Optional. Specifies whether polygons must share\nan overlap touch interaction in a common area with the by layer to form an\nelectrical connection. The default is ALL.\n\u25e6 ALL. Specifies that a common overlap touch between all three layers\nis not required to form an electrical connection and that shielding is\nnot taken into account. All the layers specified in the layers  argument\nconnect to the by layer.\n\u25e6 SHIELDED_OVERLAP. Specifies that a common overlap touch between\nall three layers is required to form an electrical connection and that\nshielding is taken into account. Both the first layer specified in the layers\nargument and the by layer must be present to form the three-layer\nconnection.\nIn the following example, a by layer connects layer1 to layer2, and layer1\nis not connected to layer3 or layer4 because they are shielded by layer2.\nFigure 269  illustrates this example.\nincremental_connect(connect_database, connect_items =\n{{{layer1,\nlayer2, layer3,layer4},by_layer = by_layer, include_touch =\nNONE,\nby_layer_connection = SHIELDED_OVERLAP }} );\nincremental_connect()\nAlternatively, if by_layer_connection = ALL, then layer1, layer2, layer3,\nand layer4 are connected to the by layer.\nFigure 269 Layers Shielded by Overlaps"}, "summary": "The incremental_connect()  function creates a new connect database by adding\nelectrical connectivity for the specified layers to a previously created connect database.", "function_name": "incremental_connect()"}
{"description": "The incremental_options()  function specifies a subset of the input layout to be\nprocessed. Window selection is performed first followed by the punching of holes with the\nexclude windows. This function can be called only one time in a runset.", "syntax": "incremental_options(\nexclude_window                = {{left = double,  bottom = double,\nright = double, top = double}, ...},\n//optional\nexclude_window_by_cells       = {\"string\", ...},            //optional\nexclude_window_by_cells_delta = double,                     //optional\nselect_window                 = {{left = double,  bottom = double,\nright = double, top = double}, ...},\n//optional\nclip_window                   = false  | true,               //optional\nwindow_error_filter            = KEEP_ALL  | KEEP_INTERACTING |\nKEEP_ENCLOSED,              //optional\nwindow_ambit                  = double,             //optional\napply_window           = {INPUT_LAYOUT, OUTPUT_ERRORS},     //optional\nselect_window_by_cells = {\"string\", ...}            //optional\n);", "returns": "void", "arguments": {"exclude_window": "Optional.\nexclude window\nLists the windows in the coordinate system of the top cell that defines\nareas excluded from processing. See the clip_window  argument to define the\naction for data that crosses the window boundaries. The default is an empty list\n({}).", "exclude_window_by_cells": "Optional. Specifies the cells excluded from processing. This is achieved by\nclipping and removing any shapes within the bounding boxes of placements\nof the specified cells, and is performed in the top cell. Any shape originating\nfrom any cell is removed if it is within a specified cell's bounding box from a flat\nview in the top cell. There is no support for excluding a rectilinear shape within\nspecified cells; the rectangular extents are used instead. The default is an empty\nlist ({}).\nincremental_options()\nNote:\nWhen using the exclude_window_by_cells  argument, the\nclip_window  argument must be true.", "exclude_window_by_cells_delta": "Optional. Specifies the minimum spacing between cells. A positive delta shrinks\nthe cells and a negative delta expands the cells. The default is 0.", "select_window": "Optional.\nselect window\nLists the windows in the coordinate system of the top cell that defines\nareas selected for processing. All areas outside of these windows are excluded\nfrom processing. See the clip_window  argument to define the action for data\nthat crosses the window boundaries. The default is an empty list ({}).", "clip_window": "Optional.\nclip window\nSpecifies whether polygons whose extents overlap window boundaries\nare clipped. The default is false.\n\u2022 true. Clips overlapping polygons at the window boundary.\n\u2022 false. Retains polygons in their entirety if the extent of the polygon overlaps\nthe window boundary.", "window_error_filter": "Optional. Specifies how top cell errors are filtered when writing to the error\ndatabase. The default is KEEP_ALL.\nNote:\nOnly errors reported in the top cell are filtered. Errors reported in\nother cells are not filtered.\n\u2022 KEEP_ALL. Specifies that no error filtering occurs. All errors are written to the\nerror database.\n\u2022 KEEP_INTERACTING. Specifies that only errors that touch or overlap the\nselected area are written to the error database.\n\u2022 KEEP_ENCLOSED. Specifies that only errors that are completely enclosed by\nthe selected areas are written to the error database.", "window_ambit": "Optional. Oversizes the selected windows when filtering layout data to be read.\nThe filtering of errors based on select window values is not be affected.\nOversizes the windows specified with the select_window  argument by the\nspecified amount when reading layout data, but not when filtering errors. Any\nincremental_options()\nwindows specified with the exclude_window  argument are undersized by the\nspecified amount. The default is 0.0.", "apply_window": "Optional. Chooses the type of data to be filtered: input layout data, error output\ndata, both types of data, or neither type, when you use the select_window,\nexclude_window, and exclude_window_by_cells  arguments of the\nincremental_options()  function. The default is filtering, that is selection or\nexclusion from the specified windows, of input layout and error output data,\n{INPUT_LAYOUT, OUTPUT_ERRORS}.\nNote:\nThe window_error_filter  argument affects filtering only when it\nis KEEP_INTERACTING  or KEEP_ENCLOSED  and the apply_window\nargument specifies the OUTPUT_ERRORS  option.\nThe clip_window  argument affects filtering only when the\napply_window  argument specifies the INPUT_LAYOUT  option.\n\u2022 INPUT_LAYOUT. Filters input layout data.\n\u2022 OUTPUT_ERRORS. Filters error output data.", "select_window_by_cells": "Optional.\nselect window\nSpecifies a list of cells to be included for processing. All areas outside\nof these cells are excluded from processing. See the clip_window  argument\nfor more information about how to define the action for data that crosses the\nwindow boundaries. The default is an empty list ({})."}, "summary": "The incremental_options()  function specifies a subset of the input layout to be\nprocessed.", "function_name": "incremental_options()"}
{"description": "The inductor()  function collects extraction configuration information about designed\ninductors that have a device layer and two terminal layers. One or more optional pin\nlayers can also be specified. The configuration information, which contains device\nbody and terminal layers, property extraction information, schematic device mappings,\nand pin handling instructions, is stored in the device matrix that is passed to the\nextract_devices()  function.\nTo recognize inductor devices, the device body layer polygons must interact with one\npolygon from each terminal layer and from each specified optional pins layer. Multiple\npolygons from one terminal layer can be treated as a single pin if those terminal layer\npolygons belong to the same net. If an optional pin layer with the pin_type  option set to\nBULK  is specified, the required relationship between the pin layer polygon and the device\nbody layer polygon is defined by the bulk_relationship  argument. If an optional pin\nlayer with the pin_type  option set to TERMINAL  is specified, the optional pin layer polygon\nmust interact with the device body layer polygon but is not required to enclose the device\nbody layer polygon.\nThe device layer is usually generated by an and()  function call between an inductor\nrecognition layer and the inductor material. The device layer is then used to cut the\ninductor material using a not()  function call to form the inductor terminals.\nNote:\nSee\nDevice Names  for the device_name  argument restrictions.", "syntax": "inductor(\nmatrix                 = device_matrix,\ndevice_name             = \"string\",\ndevice_body            = polygon_layer,\nterminal_a             = polygon_layer,\nterminal_b             = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name = \"string\",\npin_type = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\ninductor()\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL,\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nconnectivity           = {{layer    = {polygon_layer, ...}\nby_layer = polygon_layer}, ...}, //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\nextract_shorted_device = true | false,                      //optional\ntop_simulation_properties     = true | false                //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.\ninductor()", "device_name": "Required. Specifies the inductor. A device name can be reused across multiple\ncalls of the inductor()  function if all calls have\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.", "device_body": "Required. Specifies the body layer of the inductor.", "terminal_a": "Required. Specifies the device layer that contains the first terminal of the\ninductor. The pin name generated by the IC Validator tool is \u201cA\u201d.", "terminal_b": "Required. Specifies the device layer that contains the second terminal of the\ninductor. The pin name generated by the IC Validator tool is \u201cB\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is BULK.\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named BULK.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.\ninductor()", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  functions for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultinductor\nThe default is\nproperties = {{\"l\", DOUBLE, NONE}},\ninductor()\n\u2022 name. Required. Specifies the property name.\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Optional. Specifies the data type of the property. The default is\nDOUBLE.\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\ninductor()\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\ninductor()\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\ninductor()\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the nmos() and pmos()  functions for an example.\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric properties\nfor each extracted inductor. The default calculations are for the inductance, the\nlength from one end of the polygon path to another end, the width of the polygon\npath, turns of the spiral inductor, the space of the closest polygon path, the\narea of the bounding box, the height of the bounding box, and the width of the\nbounding box. The default calc_inductor_properties()  function is defined in\nthe device_public.rh header file.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Parallel devices enclosed by the same recognition layer polygon are\nnot merged.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon. The default is ENCLOSE. The bulk polygon is defined as the first\ninductor()\nmember of the optional_pins  argument list for which the pin_type  option is\nBULK.\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the standard \u201cA\u201d, \u201cB\u201d, and\n\u201cBULK\u201d pin names, in addition to optional pin names provided in the\noptional_pins  list of structures argument of the device configuration\nfunction.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin_name  option in the optional_pins  argument.\ninductor()\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\ninductor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the inductor()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "x_card": "Optional. Specifies if the instance name prefix is replaced. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with an X-card. This option facilitates the use of SPICE SUBCKT\nmodels to represent devices in simulation.\n\u2022 false. The default instance name prefix for the layout extracted device is not\nreplaced.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  for more information.", "connectivity": "Optional. Lists the connections for different layers that make up the body of\nan inductor. This information is used by the\ndev_coil_path_length()  utility\nfunction.\n\u2022 layers. Specifies the layers that make up the inductor.\n\u2022 by_layer. Specifies the polygon layer by which specified layers are\nconnected.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninductor()", "unique_identifier": "Optional. Specifies the user-derived string used by the remote property function.\nThe unique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe string is valid and unique because the IC Validator tool does not check the\nvalue. The default is an empty string (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped. By default, the IC Validator tool does not\nmap swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nrunset report file. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement data\nto external libraries. See the \u201cDynamic-Link Library Support\u201d chapter in the\ninductor()\nIC Validator User Guide  and Dynamic Linking Utility Functions  for more\ninformation.", "extract_shorted_device": "Optional. Specifies whether shorted devices, that is, devices with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted devices.\n\u2022 false. Reports shorted devices as error devices.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee\nTable 40  for more information about the behavior of the\ntop_simulation_properties  argument."}, "summary": "The inductor()  function collects extraction configuration information about designed\ninductors that have a device layer and two terminal layers.", "function_name": "inductor()"}
{"description": "The init_compare_matrix()  function creates a compare matrix. Invoke this function\nbefore the compare functions. You can call this function only one time in a runset.\nThe compare functions add data to the matrix by collecting information from settings.", "syntax": "init_compare_matrix(\nnetlist_vs_netlist  = FULL_RUNSET  | PARTIAL_RUNSET\n);", "returns": "compare state", "arguments": {"netlist_vs_netlist": "Optional. Specifies if automatic device mappings are performed for netlist-\nversus-netlist flows. Netlist-versus-netlist flows differ from layout-versus-\nschematic flows in that netlist-versus-netlist flows do not perform device\nextraction from layout. Instead, two standalone netlists are imported into the\nIC Validator tool and compared. IC Validator netlist-versus-netlist runsets\noptionally include calls to the following functions to map device names in the\nimported netlists to IC Validator device types:\nmap_capacitor()\nmap_gendev()\nmap_inductor()\nmap_nmos() and map_pmos()\nmap_np() and map_pn()\nmap_npn() and map_pnp()\nmap_resistor()\nThe netlist_vs_netlist  argument of the compare()  function regulates\nwhether netlist-versus-netlist mapping function calls are required for every\ndevice instance in each imported netlist, or whether the mapping of device\ninstance to device type is inferred from the netlist without an explicit mapping\nfunction call for each instance.\ninit_compare_matrix()\nThe default is FULL_RUNSET.\n\u2022 FULL_RUNSET. Does not perform automatic device mappings. A full netlist-\nversus-netlist runset containing netlist-versus-netlist mapping function calls\nfor every device instance in each imported netlist is required. Otherwise, an\nerror results for any imported device instance that is not mapped to an IC\nValidator device type by a mapping function.\n\u2022 PARTIAL_RUNSET. Performs automatic device mappings. The netlist-versus-\nnetlist runset is not required to contain netlist-versus-netlist mapping function\ncalls for every device instance in each imported netlist. If an explicit device\ntype mapping function call exists for a particular device name, then instances\ncorresponding to the device name are handled according to the mapping\nfunction call. However, if an explicit device type mapping function call does\nnot exist for a particular device name, then instances corresponding to the\ndevice name is implicitly mapped to a device type as follows:\n\u25e6 The device type is implicitly determined by the TYPE field in the\nIC Validator format netlist input. The TYPE field is derived from the\nleading character in instance names read from SPICE netlists.\n\u25e6 However, because the TYPE field does not differentiate n-type from\np-type devices, the device type of doped devices like MOS, bipolar\ntransistors, and diodes cannot be uniquely determined based on the\nTYPE field alone. For these devices, the type is implicitly determined by\nthe device_type  argument to any compare-related function call that also\nspecifies a non-empty list of the device_names  argument.\nThe compare-related functions are:\ncheck_property(),\ncheck_property_off(), filter(), fopen(), merge_parallel(),\nmerge_parallel_off(), merge_series(), merge_series_off(), and\nrecalculate_property().\nWhen the netlist_vs_netlist  argument is PARTIAL_RUNSET, a compare-\nrelated function call that specifies a device_type  argument value equal to\nNMOS, PMOS, NP, PN, NPN, or PNP  must also specify a non-empty list value for\nthe device_names  argument. This list of device names enables the netlist-\nversus-netlist flow to differentiate n-type and p-type devices. An error results\nif an empty list value is specified for the device_names  argument in this\nsituation.\nImplicit type mappings must not conflict. That is, the mapping of device\nname to device type must be consistent across all calls to compare-related\nfunctions. A conflict causes an error.\ninit_compare_matrix()\nNote:\nThis restriction for calling compare-related functions only exists for\nthe partial netlist-versus-netlist runset mode (PARTIAL_RUNSET).\nIt does not exist for the full netlist-versus-netlist runset mode\n(FULL_RUNSET) or for generic LVS runs."}, "summary": "The init_compare_matrix()  function creates a compare matrix.", "function_name": "init_compare_matrix()"}
{"description": "The init_device_matrix()  function creates the device matrix that is used to store\nconfiguration information for device extraction for use by the\nextract_devices()\nfunction. The device matrix data is populated by configuration information for device\nextraction by calls to device configuration functions, including\ncapacitor(), gendev(),\ninductor(), nmos() and pmos(), np() and pn(), npn() and pnp(), and resistor().\nIn addition, this function is used to activate the\ndual-hierarchy extraction\ndual-hierarchy extraction flow\nthat extracts environment-sensitive properties from postflattened hierarchy for\nsimulation while maintaining preflattened hierarchy for use in compare. See the\nwrite_annotation_file()  function for more information.", "syntax": "init_device_matrix(\nconnect_sequence          = connect_database,\ndual_hierarchy_extraction = true | false,      //optional\ndfm_files                 = {\"string\", ...},   //optional\ndevice_properties         = ALL  | LVS          //optional\nparallel_device_count      = {\n{device_type        = NMOS | PMOS | NPN | PNP |\nPN | NP | RESISTOR |\nCAPACITOR | INDUCTOR |\nGENERIC,\nproperty           = \"string\",\ndevice_names       = {\"string\", ...}},\nsame_properties    = {\"string\", ...}},\nexclude_tolerances = {{property = \"string\",\ntolerance          = doubleconstraint,\ntolerance_type     =\nRELATIVE  |\nABSOLUTE}, ...},    //optional\nmode               = SAME_DEVICE_NAME |\nSAME_SIMULATION_MODEL_NAME},\nsum_property       = \"string\",\nparallel_pins      = {PARALLEL_PINS_ALL},\n//optional\ndefault_value      = {\"string\",\ndouble}, //optional\ngroup_id           = {\nproperty = \"string\",\nthreshold = integer}, //optional\n},\npdc_short_equivalent_nodes  = {\n{device_type         = NMOS | PMOS,\ndevice_names        = {\"string\", ...},\nname_mode           = SAME_DEVICE_NAME |\nSAME_SIMULATION_MODEL_NAME,\nexclude_tolerances  = {\ninit_device_matrix()\n{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type =\nRELATIVE| ABSOLUTE,\ntolerance_calculation_method = CASCADE |\nRATIO}, ...},\nshort_nodes         = SAME_DEVICE_NAME_ONLY  |\nANY_DEVICE_NAME |\nANY_DEVICE_TYPE\n}, ...} // Optional\n);", "returns": "device_matrix", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "dual_hierarchy_extraction": "Optional. Selects either dual-hierarchy extraction or standard device extraction.\nThe default is false.\n\u2022 true. Specifies to run two device extractions internally within the IC Validator\ntool to generate the environment-sensitive property annotation file:\n1. Annotation file hierarchy extraction\nAll of the device extraction functions are considered during the\nextract_devices()  function run. Hierarchical preflattening is performed\nso that all processing_layer_hash  layers can be passed to the internal\ndevice property configuration function.\nAlso, certain device terminal layers with hierarchically interacting\npolygons are leveled to ensure accurate property extraction.\n2. Ideal compare hierarchy extraction\nAll device configuration function calls are considered during\nthe extract_devices()  function run. To minimize hierarchical\npreflattening and to retain as much hierarchy as possible, certain\nprocessing_layer_hash  layers are discarded.\ninit_device_matrix()\nBoth of these hierarchies are stored within the device database returned\nby the extract_devices()  function for use in downstream IC Validator\nfunctions.\n\u2022 false. Specifies to run a single-hierarchy extraction of all device\nconfiguration function calls. Calls to the write_annotation_file()  function\nare not allowed when the dual_hierarchy_extraction  argument is false.", "dfm_files": "Optional. Specifies the files to use for table-based functionality. The tool uses\nthe lookup tables in these files to import poly and diffusion rounding effects into\nthe hierarchy extraction flow, providing a more accurate estimate of the effective\nwidth and length of a MOS device.\nFor more information, see the\nmos_get_dfm_double()  utility function and\nChapter 7, \u201cTable-Based Lookup Functionality in the IC Validator LVS User\nGuide.", "device_properties": "Optional. Defines which properties are extracted during device extraction. The\ndefault is ALL.\n\u2022 ALL. Extracts all of the properties defined in the device commands in the\nrunset.\n\u2022 LVS. Extracts only the properties that the compare()  functions reference,\nor the properties whose write_property_to  settings are explicitly\nspecified as NETLIST_XTR_SPICE, NETLIST_PEX_SPICE, NETLIST, or\nNETLIST_ANNOTATION_FILE_SPICE.\nNote:\nThe dual_hierarchy_extraction  argument is ignored if\ndevice_properties=LVS.\nFor more information, See the -dhe  command-line option in the \u201cIC Validator\nBasics\u201d chapter of the IC Validator User Guide", "parallel_device_count": "Calculates the parallel device count in the same cell based on either the same\ndevice name or the same simulation model name. The simulation model name\nof the devices is defined in the simulation_model_name  argument in the device\nfunctions.\ninit_device_matrix()\n\u2022 device_type. Specifies the target device type. The target device types are:\n\u25e6 NMOS, PMOS, RESISTOR, CAPACITOR, INDUCTOR, NP, PN, NPN, PNP, GENERIC\n\u2022 property. Specifies the property name of the parallel device count.\n\u2022 device_names. Specifies the device name. Each device must match a\ndevice specified in a device_name  argument of a device configuration\nfunction.\n\u2022 same_properties. Specifies the properties that the IC Validator tool\ncompares to determine the return value. The default is an empty list, which\ndisables the property comparison.\nThe properties must be created by the drc_features(), gendev_select(),\nmos_select(), or res_select()  function and attached to the device body\nlayer by the dev_save_polygon_double_property()  function.\n\u2022 exclude_tolerances. Lists the tolerance settings that exclude candidate\ndevices from being merged based on the property values of the devices.\n\u25e6 property. Required. Specifies the property name. When none of the\nmerged candidates contain a property, the exclude condition does not\napply.\n\u25e6 tolerance. Optional. Specifies the tolerance. The property  option\nis checked for violations based on this tolerance. The tolerance must\nbe specified as a range. The tolerance_type  option specifies if the\ntolerance is a percentage (default) or absolute value. The default is [-10,\n+10].\nThe minimum resolution allowed for tolerance checking is as follows:\n\u25aa When schematic_property !=0, the minimum resolution value is\nabsolute_value(schematic_property*1e-6)\n\u25aa When schematic_property ==0, the minimum resolution value is\nabsolute_value(layout_property*1e-6)\nIf the specified tolerance range is less than this minimum value, for\nexample, [-0,0], the property  option is checked for violations\naccording to the minimum resolution.\n\u25e6 tolerance_type. Optional. Checks property tolerances based on a\nrelative or absolute property difference. The default is RELATIVE.\ninit_device_matrix()\n\u25aa RELATIVE. Specifies that tolerances are checked based on a\npercentage difference.\n\u25aa ABSOLUTE. Specifies that tolerances are checked based on an\nabsolute value difference. The units are based on the lvs_user_unit\nargument of the run_options()  function.\n\u2022 mode. Specifies the parallel device count based on either the same\ndevice name or the same simulation model name. The default is\nSAME_SIMULATION_MODEL_NAME.\n\u25e6 SAME_DEVICE_NAME. Specifies a list of device names used to calculate the\nparallel device count.\n\u25e6 SAME_SIMULATION_MODEL_NAME. Specifies a list of simulation model\nnames used to calculate the parallel device count.\n\u2022 sum_property. Calculates the parallel device. When this option is not empty,\nit calculates the sum of the specified property between parallel devices.\n\u2022 parallel_pins. Specifies the pins used for parallel connection checking.\nThe default is PARALLEL_PINS_ALL.\nThe parallel_pins  option cannot contain a partial swappable_pins\ngroups, or an error occurs. For example, this behavior is correct:\nnmos(..., swappable_pins={{\"SRC\", \"DRN\"}});\nparallel_device_count_s(NMOS, ..., parallel_pins={\"SRC\",\n\"DRN\", \"GATE\"});\nHowever, this behavior is not correct because only SRC (partial\nswappable_pins  group) appears in parallel_pins. SRC and DRN must\neither both appear, or not appear in parallel_pins:\nnmos(..., swappable_pins={{\"SRC\", \"DRN\"}});\nparallel_device_count_s(NMOS, ...,\nparallel_pins={\"SRC\",\"GATE\"});\n\u2022 default_value. Optional. It specifies the parallel result when the\ndevices have only one missing specified property. Originally, devices\nskip the calculation because of any missing property specified either\nin same_properties  or exclude_tolerances. default_value  and\nsum_property  cannot be active at the same time. By default, they are\ninactive because of empty strings.\n\u25e6 property. It is a string value. Specifies the missing property in the\ncontext above. By default, it is empty and the default_value  is inactive.\nOtherwise, it is active. The property  must be in either same_properties\ninit_device_matrix()\nor exclude_tolerances. Also, the restrictions must be declared in the\nproperties of device commands.\n\u25e6 value. It is a double value. Specifies the parallel result.\n\u2022 group_id. Optional. Does the post-processing on the netlist by calculating\nand assigning of parallel device counts and group indexes.\n\u25e6 property. Specifies the name for the group index property (must not\nconflict with other property names). By default, it is an empty string.\n\u25e6 threshold. Specifies the minimum group size for indexing (must be \u2265 1).\nThe parallel devices are in the same group. The group size is the number\nof devices in the group. By default, it is 1.", "pdc_short_equivalent_nodes": "Optional. Specifies the parallel device count is calculated based on the netlist\nafter shorting equivalent nodes.\n\u2022 device_type. Specifies the target device type. The target device types are\nNMOS, PMOS.\n\u2022 device_names. Specifies the device name. Each device must match a\ndevice specified in a device_name  or simulation_model_name  argument of\na device configuration function according to name_mode.\n\u2022 name_mode. Specifies the shorting equivalent nodes based on either the\nsame device name or the same simulation model name. The default is\nSAME_SIMULATION_MODEL_NAME.\n\u2022 exclude_tolerances. Lists the tolerance settings that exclude the\ncandidate devices from being shorted based on the property values of the\ndevices. It currently only supports the range [0, 0].\n\u2022 short_nodes. Specifies when shorts can be created. It relaxes the criteria of\nhow devices in a valid series could be.\n\u25e6 SAME_DEVICE_NAME_ONLY. Default. All devices in the series chain must be\nof same name and type.\n\u25e6 ANY_DEVICE_NAME. All devices in the series chain must be of same type.\n\u25e6 ANY_DEVICE_TYPE. All devices in the series chain can be any type or\nname."}, "summary": "The init_device_matrix()  function creates the device matrix that is used to store\nconfiguration information for device extraction for use by the\nextract_devices()\nfunction.", "function_name": "init_device_matrix()"}
{"description": "The init_pex_layer_matrix()  function creates a PEX layer matrix database where\nconfiguration values are stored.\nIn the runset you can have multiple PEX layer matrix databases. The databases are\ngenerated by multiple calls to the init_pex_layer_matrix()  function. You can populate\nthese PEX layer matrix databases using the following functions:\npex_cell_extents_file()\npex_conducting_layer_map()\npex_ignore_cap_layer_map()\npex_marker_layer_map()\npex_remove_layer_map()\npex_via_layer_map()\npex_viewonly_layer_map()\nThe parasitic extraction map functions\nparasitic extractionmap functions\npopulate the PEX layer matrix database with\nmapping information that is used to generate the two StarRC parasitic extraction\nmapping files, MAPPING_FILE and OA_LAYER_MAPPING_FILE, which are used in the\nIC Validator to StarRC tool flow.\nStarRC tool, mapping files\nYou can use the populated PEX layer matrix databases to\ngenerate these two files plus a connected layout database using the following functions:\npex_generate_database()\npex_generate_lpp_map()\npex_generate_process_map()\npex_generate_results()\nYou create output file handles for the parasitic extraction data generation functions using\nthe following file-handle functions:\nmilkyway_library()\npex_lpp_map_file()\npex_process_map_file()\npex_runset_report_file()\ninit_pex_layer_matrix()", "syntax": "init_pex_layer_matrix(\ndevice_db = device_database\n);", "returns": "PEX layer matrix (pex_layer_matrix)", "arguments": {"device_db": "Required. Specifies the device database. The\nextract_devices()  function\ngenerates this database."}, "summary": "The init_pex_layer_matrix()  function creates a PEX layer matrix database where\nconfiguration values are stored.", "function_name": "init_pex_layer_matrix()"}
{"description": "The init_substitute_terminal_matrix()  creates a function terminal substitution\nmatrix for storing terminal substitution related information.", "syntax": "init_substitute_terminal_matrix(\ndevice_db = device_database\n);", "returns": "pex_perc_substitute_terminal_matrix", "arguments": {"device_db": "Required. Specifies the device database. The\nextract_devices()  function\ngenerates this database."}, "summary": "The init_substitute_terminal_matrix()  creates a function terminal substitution\nmatrix for storing terminal substitution related information.", "function_name": "init_substitute_terminal_matrix()"}
{"description": "The initialize_net_property()  function initializes the net-based property that is used\nas input to the in_property  argument of the\nnet_property_select()  function.", "syntax": "initialize_net_property(\nname_list_merge_method = {{property_name = \"string\",\nproperty_merge_method = MAX  | MIN | SUM},\n...}\n);", "returns": "net_property", "arguments": {"name_list_merge_method": "Required. Lists the property settings that defines the property names and merge\nmethods.\n\u2022 property_name. Specifies the property name.\n\u2022 property_merge_method. Specifies the merge method type when new nets\nare formed from an incremental connect. The default is MAX.\n\u25e6 MAX. Selects the property with the maximum value as the new property\nvalue.\n\u25e6 MIN. Selects the property with the minimum value as the new property\nvalue.\n\u25e6 SUM. Selects the cumulative total of all properties as the new net property\nvalue."}, "summary": "The initialize_net_property()  function initializes the net-based property that is used\nas input to the in_property  argument of the\nnet_property_select()  function.", "function_name": "initialize_net_property()"}
{"description": "The initialize_property()  function creates a property layer\nproperty layer\nfrom a polygon layer.", "syntax": "initialize_property(\nlayer1    = polygon_layer,\nname_list = {\"string\", ...}\n);", "returns": "property layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "name_list": "Required. Specifies the strings used to access properties on the returned\nproperty layer."}, "summary": "The initialize_property()  function creates a property layer\nproperty layer\nfrom a polygon layer.", "function_name": "initialize_property()"}
{"description": "The inside()  function selects layer1  polygons that are inside the layer2  polygons. The\ncomplement of this function is the not_inside()  function.", "syntax": "inside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ninclude_touch   = POINT | ALL,                //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_inside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ninclude_touch   = POINT | ALL,                //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer that defines the selection region.", "include_touch": "Optional. Specifies the inside touches that are included in the definition of fully\nenclosed for layer2  polygons. The default is ALL.\n\u2022 POINT. Considers point touch as enclosed.\n\u2022 ALL. Considers all touches (edge and point) as enclosed.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ninside() and not_inside()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The inside()  function selects layer1  polygons that are inside the layer2  polygons.", "function_name": "inside()"}
{"description": "The inside()  function selects layer1  polygons that are inside the layer2  polygons. The\ncomplement of this function is the not_inside()  function.", "syntax": "inside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ninclude_touch   = POINT | ALL,                //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_inside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ninclude_touch   = POINT | ALL,                //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer that defines the selection region.", "include_touch": "Optional. Specifies the inside touches that are included in the definition of fully\nenclosed for layer2  polygons. The default is ALL.\n\u2022 POINT. Considers point touch as enclosed.\n\u2022 ALL. Considers all touches (edge and point) as enclosed.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ninside() and not_inside()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The inside()  function selects layer1  polygons that are inside the layer2  polygons.", "function_name": "not_inside()"}
{"description": "The inside_hole()  function selects layer1  polygons that fill the holes in layer2\npolygons. The selected polygons must be exactly coincident with the holes of layer2. The\ncomplement of this function is the not_inside_hole()  function.", "syntax": "inside_hole(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_inside_hole(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninside_hole() and not_inside_hole()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The inside_hole()  function selects layer1  polygons that fill the holes in layer2\npolygons.", "function_name": "inside_hole()"}
{"description": "The inside_hole()  function selects layer1  polygons that fill the holes in layer2\npolygons. The selected polygons must be exactly coincident with the holes of layer2. The\ncomplement of this function is the not_inside_hole()  function.", "syntax": "inside_hole(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_inside_hole(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninside_hole() and not_inside_hole()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The inside_hole()  function selects layer1  polygons that fill the holes in layer2\npolygons.", "function_name": "not_inside_hole()"}
{"description": "The inside_point_touching_edge()  function selects entire layer1  edges that have\nany inside point touching with layer2  edges. The complement of this function is the\nnot_inside_point_touching_edge()  function.\nThe behavior of the point edge touching functions [inside_point_touching_edge()\nand not_inside_point_touching_edge(),\noutside_point_touching_edge()\nand not_outside_point_touching_edge(), and point_touching_edge() and\nnot_point_touching_edge()] is as follows:\n\u2022 The output of the inside_point_touching_edge()  function when layer1  is a\npolygon layer is the same as when layer1  is the result of the length_edge()  function\nwith the distance  argument set to >0, that is, length_edge(layer1, distance >0).\n\u2022 If layer2  is a polygon layer, a point touch happens when an endpoint of layer1\ntouches a layer2  polygon boundary. To determine whether a point touch is inside or\noutside:\n\u25e6 The type of point touch is the same as the type of line touch if there is also a line\ntouch with the layer2  polygon that includes the endpoint of a point touch.\n\u25e6 Otherwise, the type of point touch is defined by whether the layer1  edge is inside\nor outside the layer1  polygon near the point touch.\n\u2022 If layer2  is an edge layer, a point touch happens when an endpoint of a layer1  edge\npoint touches a layer2  edge. To determine whether a point touch is inside or outside:\n\u25e6 When a layer1  edge point touches the endpoint of a layer2  edge:\n\u25aa The touch is inside if the edges are in the same direction. That is, if the layer1\nedge head point touches the layer2  edge tail or the layer1  edge tail point\ntouches the layer2  edge head.\n\u25aa The touch is outside if the edges are in different directions. That is, if the layer1\nedge head point touches the layer2  edge head or the layer1  edge tail point\ntouches the layer2  edge tail.\n\u25e6 When a layer1  edge point touches the interior point of a layer2  edge:\n\u25aa The touch is inside if layer1  edge is on the right side of the layer2  edge.\n\u25aa The touch is outside if layer1  edge is on the left side of the layer2  edge.\ninside_point_touching_edge() and not_inside_point_touching_edge()", "syntax": "inside_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_inside_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The inside_point_touching_edge()  function selects entire layer1  edges that have\nany inside point touching with layer2  edges.", "function_name": "not_inside_point_touching_edge()"}
{"description": "The inside_touching_edge()  function selects entire layer1  edges that have the\nspecified inside coincidence with layer2  edges. The complement of this function is the\nnot_inside_touching_edge()  function.", "syntax": "inside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_inside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional. Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, then polygons are counted. If layer2\nis an edge layer, then individual edges are counted. See\nConstraints  on\npage 3344 for more information. The default is >0.\nFigure 277  shows the effect of the count  argument settings with the\ninside_touching_edge()  function.\ninside_touching_edge() and not_inside_touching_edge()\nFigure 277 count Argument Example With the inside_touching_edge() Function\nFigure 278  shows the effect of the count  argument settings with the\nnot_inside_touching_edge()  function.\ninside_touching_edge() and not_inside_touching_edge()\nFigure 278 count Argument Example With the not_inside_touching_edge() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninside_touching_edge() and not_inside_touching_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The inside_touching_edge()  function selects entire layer1  edges that have the\nspecified inside coincidence with layer2  edges.", "function_name": "not_inside_touching_edge()"}
{"description": "The inside_touching_edge()  function selects entire layer1  edges that have the\nspecified inside coincidence with layer2  edges. The complement of this function is the\nnot_inside_touching_edge()  function.", "syntax": "inside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_inside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional. Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, then polygons are counted. If layer2\nis an edge layer, then individual edges are counted. See\nConstraints  on\npage 3344 for more information. The default is >0.\nFigure 277  shows the effect of the count  argument settings with the\ninside_touching_edge()  function.\ninside_touching_edge() and not_inside_touching_edge()\nFigure 277 count Argument Example With the inside_touching_edge() Function\nFigure 278  shows the effect of the count  argument settings with the\nnot_inside_touching_edge()  function.\ninside_touching_edge() and not_inside_touching_edge()\nFigure 278 count Argument Example With the not_inside_touching_edge() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninside_touching_edge() and not_inside_touching_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The inside_touching_edge()  function selects entire layer1  edges that have the\nspecified inside coincidence with layer2  edges.", "function_name": "inside_touching_edge()"}
{"description": "The instance_property_number()  function redefines the property number used for cell\ninstance names.", "syntax": "instance_property_number(\nproperty_number = integer\n);", "returns": "void", "arguments": {"property_number": "Required. Redefines the property number. The default is 4."}, "summary": "The instance_property_number()  function redefines the property number used for cell\ninstance names.", "function_name": "instance_property_number()"}
{"description": "The interface_antenna()  function filters polygons for antenna checks based on the\noptions set in the interface_antenna_options()  function.", "syntax": "interface_antenna_options(\ncells  = {\"string\", ...},     //optional\ninclude_nets_with_text  = {\"string\", ...},   //optional\nexclude_nets_with_text  = {\"string\", ...},   //optional\ninclude_other_nets  = NONE  | ALL     //optional\n);", "returns": "void", "arguments": {"cells": "Optional. Specifies the names of the sub-blocks (cells) where only their interface\nnets should be considered during antenna checks. String matching using\nmetacharacters, except !, is allowed. See\nString Matching  for more information.\nBy default, all nets in every sub-block are checked.\nNote:\nSpecified cell names are added to the no explode list defined in the\nno_explode  argument of the hierarchy_options()  function. An\nexception to this behavior is that the *  metacharacter does not add to\nthe no explode list.", "include_nets_with_text": "Optional. Only applies to the cells that match the cells argument. Specifies the\ntext strings that determine the interface nets to be selected for antenna checks.\nThis list cannot be empty. String matching using metacharacters is allowed. See\nString Matching  for more information. By default, the IC Validator tool checks all\ninterface nets.", "exclude_nets_with_text": "Optional. Only applies to the cells that match the cells argument. Specifies\nthe text strings. For each cell, to make an interface net to not be selected and\nskipped for antenna checks, its text must match at least one of these strings.\nString matching using metacharacters, except !, is allowed. See\nString Matching\ninterface_antenna_options()\nfor more information. Specifying {}  implies all nets are checked. By default, the\nIC Validator tool checks all interface nets.\nNote:\nThe exclude_nets_with_text  argument takes precedence over the\ninclude_nets_with_text  argument.", "include_other_nets": "Optional. Determines if only the interface nets of cells should be selected in\nantenna checks. Set to ALL  if all nets of the other cells (that is, the cells that do\nnot match the cells argument) should be selected too. The default is NONE, which\nmeans the IC Validator tool does not check the nets of the other cells."}, "summary": "The interface_antenna()  function filters polygons for antenna checks based on the\noptions set in the interface_antenna_options()  function.", "function_name": "write_oasis_global_options()"}
{"description": "The interacting()  function selects layer1  polygons that touch or overlap layer2  data.\nAn optional argument specifies the number of layer2  polygons or edges that must be\ninteracted with. The complement of this function is the not_interacting()  function.", "syntax": "interacting(\nlayer1            = polygon_layer,\nlayer2            = data_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = NONE | EDGE  | ALL,          //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL, ODD, EVEN,             //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);\nnot_interacting(\nlayer1            = polygon_layer,\nlayer2            = data_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = NONE | EDGE  | ALL,          //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL, ODD, EVEN,             //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.\ninteracting() and not_interacting()", "count": "Optional. Specifies the number of layer2  polygons or edges that must be\ninteracted with. Edges are counted individually; there is no recognition of edge\nchains. The default is >0.\nFigure 282  shows the effect of the count  argument settings with the\ninteracting()  function.\nFigure 282 count Argument Example With the interacting() Function\nFigure 283  shows the effect of the count  argument settings with the\nnot_interacting()  function.\ninteracting() and not_interacting()\nFigure 283 count Argument Example With the not_interacting() Function", "include_touch": "Optional. When layer2  is a polygon layer, layer1  polygons that share active\narea with layer2  are always selected. The layer1  polygons that share no\nactive area with layer2  can optionally be selected based on outside touches, as\nspecified by this argument.\nWhen layer2  is an edge layer, layer1  polygons that share active area with a\nlayer2  edges are always selected. The layer1  polygons that share no active\narea with layer2  edges, can optionally be selected based on edges that interact\ntheir boundary, as specified by this argument.\nThe default is EDGE.\n\u2022 NONE. Specifies that neither either point touch nor line touch causes a\npolygon to be selected.\n\u2022 EDGE. Edge touch causes a polygon to be selected.\n\u2022 ALL. All touches (edge and point) cause a polygon to be selected.\ninteracting() and not_interacting()\nFigure 284  shows the effect of the include_touch  argument settings with the\ninteracting()  function.\nFigure 284 include_touch Argument Example With the interacting() Function\nFigure 285  shows the effect of the include_touch  argument settings with the\nnot_interacting()  function.\ninteracting() and not_interacting()\nFigure 285 include_touch Argument Example With the not_interacting() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and count_parity  is EVEN, the layer1\npolygons that interact with four, six, or eight layer2  polygons are selected.\nFigure 286  shows an example of two interacting layers.\ninteracting() and not_interacting()\nFigure 286 count_parity Argument Example\nFor the following command, the result is shown in Figure 287.\ninteracting(L1, L2, count = [2, 5], count_parity = ODD)\nFigure 287 Result of count_parity Argument Example", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\n\u2022 NET. Selects a layer1  polygon if it interacts with distinct nets on the layer2\nlayer the number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it interacts the layer2  layer the number\nof times specified by the count  argument.\nRefer to Figure 288  for the following examples.\ninteracting() and not_interacting()\nFigure 288 count_by Argument Example\nThe following commands select polygon A of layer L1.\n\u2022 interacting(L1, L2, count >=3),\nNet1, Net2, and Net4 are each counted as two interactions because\ncount_by = SHAPE  (default). Therefore, polygon A meets the count>=3\ncriteria (two L2 polygons on Net1 plus two L2 polygons on Net2). Polygon B\ndoes not meet the criteria, because the L2 polygon on Net3 is a point-touch\ninteraction. If the argument include_touch = ALL  is specified, then Polygon\nB meets the count>= 3  criteria and is selected.\n\u2022 interacting(L1, L2, count == 2, count_by = NET,\nconnect_sequence = cdb);\nNet1, Net2, and Net4 are each counted as one interaction because the\ncount_by = NET. Therefore, polygon A meets the count == 2  criteria\n(one Net1 interaction plus one Net2 interaction). Polygon B does not meet\nthe criteria because Net3 is a point-touch interaction. If the argument\ninclude_touch = ALL  is specified, then Polygon B meets the count == 2\ncriteria and is selected.", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninteracting() and not_interacting()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting()  function selects layer1  polygons that touch or overlap layer2  data.", "function_name": "not_interacting()"}
{"description": "The interacting()  function selects layer1  polygons that touch or overlap layer2  data.\nAn optional argument specifies the number of layer2  polygons or edges that must be\ninteracted with. The complement of this function is the not_interacting()  function.", "syntax": "interacting(\nlayer1            = polygon_layer,\nlayer2            = data_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = NONE | EDGE  | ALL,          //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL, ODD, EVEN,             //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);\nnot_interacting(\nlayer1            = polygon_layer,\nlayer2            = data_layer,\ncount             = integerconstraint,          //optional\ninclude_touch     = NONE | EDGE  | ALL,          //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity       = ALL, ODD, EVEN,             //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence   = connect_database,           //optional\nname              = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.\ninteracting() and not_interacting()", "count": "Optional. Specifies the number of layer2  polygons or edges that must be\ninteracted with. Edges are counted individually; there is no recognition of edge\nchains. The default is >0.\nFigure 282  shows the effect of the count  argument settings with the\ninteracting()  function.\nFigure 282 count Argument Example With the interacting() Function\nFigure 283  shows the effect of the count  argument settings with the\nnot_interacting()  function.\ninteracting() and not_interacting()\nFigure 283 count Argument Example With the not_interacting() Function", "include_touch": "Optional. When layer2  is a polygon layer, layer1  polygons that share active\narea with layer2  are always selected. The layer1  polygons that share no\nactive area with layer2  can optionally be selected based on outside touches, as\nspecified by this argument.\nWhen layer2  is an edge layer, layer1  polygons that share active area with a\nlayer2  edges are always selected. The layer1  polygons that share no active\narea with layer2  edges, can optionally be selected based on edges that interact\ntheir boundary, as specified by this argument.\nThe default is EDGE.\n\u2022 NONE. Specifies that neither either point touch nor line touch causes a\npolygon to be selected.\n\u2022 EDGE. Edge touch causes a polygon to be selected.\n\u2022 ALL. All touches (edge and point) cause a polygon to be selected.\ninteracting() and not_interacting()\nFigure 284  shows the effect of the include_touch  argument settings with the\ninteracting()  function.\nFigure 284 include_touch Argument Example With the interacting() Function\nFigure 285  shows the effect of the include_touch  argument settings with the\nnot_interacting()  function.\ninteracting() and not_interacting()\nFigure 285 include_touch Argument Example With the not_interacting() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and count_parity  is EVEN, the layer1\npolygons that interact with four, six, or eight layer2  polygons are selected.\nFigure 286  shows an example of two interacting layers.\ninteracting() and not_interacting()\nFigure 286 count_parity Argument Example\nFor the following command, the result is shown in Figure 287.\ninteracting(L1, L2, count = [2, 5], count_parity = ODD)\nFigure 287 Result of count_parity Argument Example", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\n\u2022 NET. Selects a layer1  polygon if it interacts with distinct nets on the layer2\nlayer the number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it interacts the layer2  layer the number\nof times specified by the count  argument.\nRefer to Figure 288  for the following examples.\ninteracting() and not_interacting()\nFigure 288 count_by Argument Example\nThe following commands select polygon A of layer L1.\n\u2022 interacting(L1, L2, count >=3),\nNet1, Net2, and Net4 are each counted as two interactions because\ncount_by = SHAPE  (default). Therefore, polygon A meets the count>=3\ncriteria (two L2 polygons on Net1 plus two L2 polygons on Net2). Polygon B\ndoes not meet the criteria, because the L2 polygon on Net3 is a point-touch\ninteraction. If the argument include_touch = ALL  is specified, then Polygon\nB meets the count>= 3  criteria and is selected.\n\u2022 interacting(L1, L2, count == 2, count_by = NET,\nconnect_sequence = cdb);\nNet1, Net2, and Net4 are each counted as one interaction because the\ncount_by = NET. Therefore, polygon A meets the count == 2  criteria\n(one Net1 interaction plus one Net2 interaction). Polygon B does not meet\nthe criteria because Net3 is a point-touch interaction. If the argument\ninclude_touch = ALL  is specified, then Polygon B meets the count == 2\ncriteria and is selected.", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninteracting() and not_interacting()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting()  function selects layer1  polygons that touch or overlap layer2  data.", "function_name": "interacting()"}
{"description": "The interacting_edge()  function selects entire layer1  edges that touch\nor overlap layer2  polygons or edges. The complement of this function is the\nnot_interacting_edge()  function.", "syntax": "interacting_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ninclude_touch   = EDGE | ALL,                 //optional\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_interacting_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ninclude_touch   = EDGE | ALL,                 //optional\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "include_touch": "Optional. Specifies the touches that cause a layer1  edge to be selected. The\ndefault is ALL.\ninteracting_edge() and not_interacting_edge()\nWhen layer2  is a polygon layer, layer1  edges that have any portion inside\nlayer2, including inside coincident, are always selected. For interacting edges\nthat do not have any portion inside layer2:\n\u2022 EDGE. Outside edge touch causes a layer1  edge to be selected.\n\u2022 ALL. All outside touches (edge and point) cause a layer1  edge to be\nselected.\nWhen layer2  is an edge layer, layer1  edges that cross a layer2  edge are\nalways selected. For interacting edges that do not cross a layer2  edge.\n\u2022 EDGE. Edge touch causes a layer1  edge to be selected.\n\u2022 ALL. All outside touches (edge and point) cause a layer1  edge to be\nselected.", "count": "Optional. Specifies the number of interactions that must occur for an edge\nto be selected. If layer2  is a polygon layer, then polygons are counted. If\nlayer2  is an edge layer, then individual edges are counted. See\nConstraints  on\npage 3344 for more information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting_edge()  function selects entire layer1  edges that touch\nor overlap layer2  polygons or edges.", "function_name": "interacting_edge()"}
{"description": "The interacting_edge()  function selects entire layer1  edges that touch\nor overlap layer2  polygons or edges. The complement of this function is the\nnot_interacting_edge()  function.", "syntax": "interacting_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ninclude_touch   = EDGE | ALL,                 //optional\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_interacting_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ninclude_touch   = EDGE | ALL,                 //optional\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "include_touch": "Optional. Specifies the touches that cause a layer1  edge to be selected. The\ndefault is ALL.\ninteracting_edge() and not_interacting_edge()\nWhen layer2  is a polygon layer, layer1  edges that have any portion inside\nlayer2, including inside coincident, are always selected. For interacting edges\nthat do not have any portion inside layer2:\n\u2022 EDGE. Outside edge touch causes a layer1  edge to be selected.\n\u2022 ALL. All outside touches (edge and point) cause a layer1  edge to be\nselected.\nWhen layer2  is an edge layer, layer1  edges that cross a layer2  edge are\nalways selected. For interacting edges that do not cross a layer2  edge.\n\u2022 EDGE. Edge touch causes a layer1  edge to be selected.\n\u2022 ALL. All outside touches (edge and point) cause a layer1  edge to be\nselected.", "count": "Optional. Specifies the number of interactions that must occur for an edge\nto be selected. If layer2  is a polygon layer, then polygons are counted. If\nlayer2  is an edge layer, then individual edges are counted. See\nConstraints  on\npage 3344 for more information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting_edge()  function selects entire layer1  edges that touch\nor overlap layer2  polygons or edges.", "function_name": "not_interacting_edge()"}
{"description": "The interacting_error()  function selects entire layer1  errors that touch or overlap\nlayer2  polygons. The complement of this function is the not_interacting_error()\nfunction.", "syntax": "interacting_error(\nlayer1          = error_layer,\nlayer2          = polygon_layer,\ncount           = integerconstraint,          //optional\ninclude_touch   = NONE | EDGE  | ALL,          //optional\nerror_shape     = EDGES  | REGION,             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_interacting_error(\nlayer1          = error_layer,\nlayer2          = polygon_layer,\ncount           = integerconstraint,          //optional\ninclude_touch   = NONE | EDGE  | ALL,          //optional\nerror_shape     = EDGES  | REGION,             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the error layer.", "layer2": "Required. Specifies the polygon layer.", "count": "Optional. Specifies the number of layer2  polygons that must be interacted with.\nSee\nConstraints  on page 3344 for more information. The default is >0.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\ninteracting_error() and not_interacting_error()\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected. A center-to-center error is treated as a\npair of endpoints. If either endpoint meets the interaction specification, the\nerror is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons. A center-\nto-center error is treated as an edge. If the edge meets the interaction\nspecification, the error is selected.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting_error()  function selects entire layer1  errors that touch or overlap\nlayer2  polygons.", "function_name": "not_interacting_error()"}
{"description": "The interacting_error()  function selects entire layer1  errors that touch or overlap\nlayer2  polygons. The complement of this function is the not_interacting_error()\nfunction.", "syntax": "interacting_error(\nlayer1          = error_layer,\nlayer2          = polygon_layer,\ncount           = integerconstraint,          //optional\ninclude_touch   = NONE | EDGE  | ALL,          //optional\nerror_shape     = EDGES  | REGION,             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_interacting_error(\nlayer1          = error_layer,\nlayer2          = polygon_layer,\ncount           = integerconstraint,          //optional\ninclude_touch   = NONE | EDGE  | ALL,          //optional\nerror_shape     = EDGES  | REGION,             //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the error layer.", "layer2": "Required. Specifies the polygon layer.", "count": "Optional. Specifies the number of layer2  polygons that must be interacted with.\nSee\nConstraints  on page 3344 for more information. The default is >0.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction check\nbetween the primary layer and the secondary layers. The default is EDGE.\ninteracting_error() and not_interacting_error()\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "error_shape": "Optional. Specifies how errors are treated in the interaction check between the\nprimary layer and the secondary layer. The default is EDGES.\n\u2022 EDGES. Recognizes interaction only with the violating edges. The errors\nare treated as pairs of edges, and if either edge meets the interaction\nspecification, the error is selected. A center-to-center error is treated as a\npair of endpoints. If either endpoint meets the interaction specification, the\nerror is selected.\n\u2022 REGION. Recognizes interaction with any part of the violating region. The\nerrors are treated as polygons, as created when the output_type  argument\nis REGION  in the spacing check functions that produce polygons. A center-\nto-center error is treated as an edge. If the edge meets the interaction\nspecification, the error is selected.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The interacting_error()  function selects entire layer1  errors that touch or overlap\nlayer2  polygons.", "function_name": "interacting_error()"}
{"description": "The internal_corner1()  function creates polygons that are formed by pairs of violation\ncorners. It measures inside-to-inside spacing on layer1  based on distance  specified.\nOther arguments define various geometric conditions for measuring the point-to-point\ndistance between the corners. The measurements are limited to corners that are on the\nsame polygon, and are never made through obstructions.\nThe output consists of rectangles that are the extents of the point-to-point violations. In\nthe case where the violation is horizontal or vertical, the output rectangle is generated by\nexpanding the violation three times the input library resolution on both sides.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  on page 3360 for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the internal_corner1()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\ninternal_corner1()", "syntax": "internal_corner1(\nlayer1                       = data_layer,\ndistance                     = doubleconstraint,\ntype                        = {CONCAVE_TO_CONCAVE,\nCONCAVE_TO_EDGE, CONVEX_TO_CONCAVE,\nPARALLEL_POINT_PROJECTION},  //optional\nangle                       = ALL  | RIGHT,                  //optional\nregion                      = RADIAL, SQUARE,               //optional\nconcave_to_concave_boundary = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nconvex_to_concave_boundary  = INCLUSIVE, EXCLUSIVE,         //optional\nedge_endpoints              = CORNER  | ALL,                 //optional\nprocessing_mode             = CELL_LEVEL | HIERARCHICAL,    //optional\nname                        = \"layer_label\"                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the concave_to_concave_boundary  argument.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\ninternal_corner1()\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe region  argument is not used for this corner type.\nThe edge_endpoints  and angle  arguments are ALL.\nFigure 289  shows the effect of the type  argument settings.\nFigure 289 type Argument Examples", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\ninternal_corner1()\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 290  shows the effect of the region  argument settings.\nFigure 290 region Argument Examples", "concave_to_concave_boundary": "Optional. For concave-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE_PARALLEL  applies\nonly when two edges from the corners are parallel and not collinear. The default\nis EXCLUSIVE.\nFigure 291  shows the effect of the concave_to_concave_boundary  argument\nsettings.\ninternal_corner1()\nFigure 291 concave_to_concave_boundary Argument Examples", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nNote:\nThis function never measures through obstructions, therefore convex\ncorner-check-zone boundaries are always exclusive.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when the input layer is an edge layer.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 292  shows the effect of the edge_endpoints  argument settings.\ninternal_corner1()\nFigure 292 edge_endpoints Argument Examples", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The internal_corner1()  function creates polygons that are formed by pairs of violation\ncorners.", "function_name": "internal_corner1()"}
{"description": "The internal_corner1_edge()  function creates edges that consist of pairs of violation\ncorners. It measures inside-to-inside spacing on layer1  based on distance  specified.\nOther arguments define various geometric conditions for measuring the point-to-point\ndistance between the corners.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  on page 3360 for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to the\ncorner falls in the projection zone of the corner.\nFor edge input, the internal_corner1_edge()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.", "syntax": "internal_corner1_edge(\nlayer1                       = data_layer,\ndistance                     = doubleconstraint,\ntype                        = {CONCAVE_TO_CONCAVE,\nCONCAVE_TO_EDGE, CONVEX_TO_CONCAVE,\nPARALLEL_POINT_PROJECTION},  //optional\ninternal_corner1_edge()\nangle                       = ALL  | RIGHT,                  //optional\nregion                      = RADIAL, SQUARE,               //optional\nconcave_to_concave_boundary = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nconvex_to_concave_boundary  = INCLUSIVE, EXCLUSIVE,         //optional\nedge_endpoints              = CORNER  | ALL,                 //optional\noutput_type                  = FAIL  | POINT_TO_POINT,        //optional\nprocessing_mode             = CELL_LEVEL | HIERARCHICAL,    //optional\nname                        = \"layer_label\"                 //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the concave_to_concave_boundary  argument.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe region  argument is not used for this corner type.\nThe edge_endpoints  and angle  arguments are ALL.\ninternal_corner1_edge()\nFigure 293  shows the effect of the type  argument settings.\nFigure 293 type Argument Examples", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\ninternal_corner1_edge()\nFigure 294  shows the effect of the region  argument settings.\nFigure 294 region Argument Examples", "concave_to_concave_boundary": "Optional. For concave-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE  applies only\nwhen two edges from the corners are parallel and not collinear. The default is\nEXCLUSIVE.\nFigure 295  shows the effect of the concave_to_concave_boundary  argument\nsettings. The red outlines highlight the selected boundaries.\nFigure 295 concave_to_concave_boundary Argument Examples", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nNote:\nThis function never measures through obstructions, therefore convex\ncorner-check-zone boundaries are always exclusive.\ninternal_corner1_edge()", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when the input layer is an edge layer.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 296  shows the effect of the edge_endpoints  argument settings.\nFigure 296 edge_endpoints Argument Examples", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. The orientation of POINT_TO_POINT\nedges from a layer1  check is arbitrary. POINT_TO_POINT  creates an orphan\nedge layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ninternal_corner1_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The internal_corner1_edge()  function creates edges that consist of pairs of violation\ncorners.", "function_name": "internal_corner1_edge()"}
{"description": "The internal_corner2()  function creates polygons that are formed by pairs of violation\ncorners. It measures inside-to-inside spacing between two layers based on the distance\nspecified. The arguments define various geometric conditions for measuring the point-to-\npoint distance between the corners.\nThe output consists of rectangles that are the extents of the point-to-point violations. In\nthe case where the violation is horizontal or vertical, the output rectangle is generated by\nexpanding the violation three times the input library resolution on both sides.\nThe corner-to-corner distance is checked only when each corner falls within the check\nzone of the other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  on page 3360 for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nThe corner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to\nthe corner falls in the projection zone of the corner. A portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the internal_corner2()  function optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.\ninternal_corner2()", "syntax": "internal_corner2(\nlayer1                       = data_layer,\nlayer2                       = data_layer,\ndistance                     = doubleconstraint,\ntype                        = {CONCAVE_TO_CONCAVE,\nCONCAVE_TO_EDGE, CONVEX_TO_CONCAVE,\nCONVEX_TO_EDGE,\nPARALLEL_POINT_PROJECTION},  //optional\nangle                       = ALL  | RIGHT,                  //optional\nregion                      = RADIAL  | SQUARE,              //optional\nconvex_to_concave_boundary  = INCLUSIVE |EXCLUSIVE,        //optional\nconcave_to_concave_boundary = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints              = CORNER  | ALL,                 //optional\nconnectivity                = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence            = connect_database,             //optional\nlook_thru                    = NONE  | COINCIDENT | OUTSIDE |\nALL,                          //optional\nprocessing_mode             = CELL_LEVEL | HIERARCHICAL,    //optional\nname                        = \"layer_label\"                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\ninternal_corner2()\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the concave_to_concave_boundary  argument.\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconcave corner check zone is exclusive.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is inclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for concave corners\nis inclusive, whereas the boundary for convex corners is exclusive.\nNote:\nThe region  argument is not used for this corner type.\nThe edge_endpoints  and angle  arguments are ALL.\nFigure 297  shows the effect of the type  argument settings.\nFigure 297 type Argument Examples\ninternal_corner2()", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 298  shows the effect of the region  argument settings.\nFigure 298 region Argument Examples", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. The default is EXCLUSIVE.\nNote:\nThis function never measures through obstructions, therefore convex\ncorner check-zone boundaries are always exclusive.\ninternal_corner2()", "concave_to_concave_boundary": "Optional. For concave-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE  applies only\nwhen two edges from the corners are parallel and not collinear. The default is\nEXCLUSIVE.\nFigure 299  shows the effect of the concave_to_concave_boundary  argument\nsettings.\nFigure 299 concave_to_concave_boundary Argument Examples", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 300  shows the effect of the edge_endpoints  argument settings.\ninternal_corner2()\nFigure 300 edge_endpoints Argument Examples", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 301  shows the effect of the edge_endpoints  argument settings.\ninternal_corner2()\nFigure 301 connectivity Argument Examples", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 ALL. Looks through all edges.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninternal_corner2()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The internal_corner2()  function creates polygons that are formed by pairs of violation\ncorners.", "function_name": "internal_corner2()"}
{"description": "The internal_corner2_edge()  function creates edges that consist of pairs of violation\ncorners. It measures inside-to-inside spacing between two layers based on the distance\nspecified. Other arguments define various geometric conditions for measuring the point-to-\npoint distance between the corners.\nCorner-to-corner distance is checked only when each corner falls within the check zone of\nthe other corner.\nThe check zone for convex corners (interior angle of less than 180 degrees) is determined\nby the following steps:\n1. For each adjacent edge of the corner, draw a perpendicular line toward the check side.\nSee\nSpacing Checks  on page 3360 for more information about the check side.\n2. The check zone is bounded by the two lines.\nThe check zone for concave corners (exterior angle of less than 180 degrees) is\ndetermined by the following steps:\n1. Extend each adjacent edge of the corner.\n2. The check zone is bounded by the two lines.\nCorner-to-edge distance is checked only when the corner falls in the perpendicular\nprojection region of the edge, and the perpendicular projection point from the edge to\nthe corner falls in the projection zone of the corner. A portion of the edge must fall in the\ncorner projection zone, and neither of the edges forming the corner can be parallel to the\nedge.\nFor edge input, the internal_corner2_edge()  optionally includes terminal edge\nendpoints as corners; there is no adjacent edge. In this case, the angle  argument is not\nused. The check zone of an edge endpoint with no adjacent edge is determined by the\nfollowing steps:\n1. Draw a line extending the edge beyond the endpoint.\n2. From the endpoint, draw a perpendicular line toward the check side of the edge.\n3. The check zone is bounded by the two lines. The boundary defined by the line\nextending the edge is always inclusive.", "syntax": "internal_corner2_edge(\nlayer1                       = data_layer,\nlayer2                       = data_layer,\ninternal_corner2_edge()\ndistance                     = doubleconstraint,\ntype                        = {CONCAVE_TO_CONCAVE, CONVEX_TO_CONCAVE,\nCONCAVE_TO_EDGE, CONVEX_TO_EDGE,\nPARALLEL_POINT_PROJECTION},  //optional\nangle                       = ALL  | RIGHT,                  //optional\nregion                      = RADIAL  | SQUARE,              //optional\nconvex_to_concave_boundary  = INCLUSIVE |EXCLUSIVE,        //optional\nconcave_to_concave_boundary = INCLUSIVE_PARALLEL | EXCLUSIVE,\n//optional\nedge_endpoints              = CORNER  | ALL,                 //optional\nconnectivity                = SAME_NET | DIFFERENT_NET | ALL,\n//optional\nconnect_sequence            = connect_database,             //optional\nlook_thru                    = NONE  | COINCIDENT | OUTSIDE |\nALL,                          //optional\noutput_layer                = LAYER1  | LAYER2,              //optional\noutput_type                  = FAIL  | POINT_TO_POINT,        //optional\nprocessing_mode             = CELL_LEVEL | HIERARCHICAL,    //optional\nname                        = \"layer_label\"                 //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "type": "Optional. Specifies the corner types included in the spacing check. By default,\nthe IC Validator tool selects all types.\n\u2022 CONCAVE_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the concave_to_concave_boundary  argument.\n\u2022 CONVEX_TO_CONCAVE. Specifies that the check-zone boundary is controlled\nby the convex_to_concave_boundary  argument.\ninternal_corner2_edge()\n\u2022 CONCAVE_TO_EDGE. Specifies that the edge projection region is inclusive;\nconcave corner check-zone is exclusive.\n\u2022 CONVEX_TO_EDGE. Specifies that the edge projection region is inclusive;\nconvex corner check zone is exclusive.\n\u2022 PARALLEL_POINT_PROJECTION. Specifies convex to concave or convex\nto convex, where two edges from the corners are parallel and have a\nperpendicular projection length equal to 0. The boundary for convex corners\nis inclusive, whereas the boundary for concave corners is exclusive.\nNote:\nThe region  argument is not used for this corner type.\nThe edge_endpoints  and angle  arguments are ALL.\nFigure 302  shows the effect of the type  argument settings. The red outlines\nhighlight the selected boundaries.\nFigure 302 type Argument Examples", "angle": "Optional. Specifies the angles of the corners that are included in the spacing\ncheck. The default is ALL.\ninternal_corner2_edge()\n\u2022 ALL. Specifies that all angles are checked.\n\u2022 RIGHT. Specifies that only right angles are checked.", "region": "Optional. Specifies the shape of the corner-check region. Intrusion into the\ncorner-check region results in a spacing violation. The default is RADIAL.\n\u2022 RADIAL. Connects check-zone boundaries with a radial arc at the specified\ndistance  from the corner. The boundary of the arc is inclusive or exclusive\ndepending on the distance  argument.\n\u2022 SQUARE. Defines the check region with two squares. For each corner check-\nzone boundary, a square equal in size to the specified distance  is placed\npoint-touching the corner. One edge is coincident to the boundary. For right\ncorners, the two boxes are coincident. The far boundaries of the boxes are\ninclusive or exclusive depending on the distance  argument.\nFigure 307  shows the effect of the region  argument settings.\nFigure 303 region Argument Examples", "convex_to_concave_boundary": "Optional. For convex-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE  applies only\nwhen two edges from the corners are parallel and not collinear. The default is\nEXCLUSIVE.\nFigure 304  shows the effect of the concave_to_concave_boundary  argument\nsettings.\ninternal_corner2_edge()\nFigure 304 concave_to_concave_boundary Argument Examples", "concave_to_concave_boundary": "Optional. For concave-to-concave measurements, specifies whether the corner\ncheck-zone boundaries are exclusive or inclusive. INCLUSIVE  applies only\nwhen two edges from the corners are parallel and not collinear. The default is\nEXCLUSIVE.", "edge_endpoints": "Optional. Specifies the edge endpoints measured. The default is CORNER.\nNote:\nThis argument is used only when an input layer is an edge layer.\n- If layer1  is an edge layer, then the argument applies to layer1.\n- If layer2  is an edge layer, then the argument applies to layer2.\n- If layer1  and layer2  are edge layers, then the argument applies to\nboth layers.\n\u2022 CORNER. Checks only the endpoints that form a corner.\n\u2022 ALL. Checks all endpoints, including those that have no adjacent edge.\nFigure 305  shows the effect of the edge_endpoints  argument settings.\ninternal_corner2_edge()\nFigure 305 edge_endpoints Argument Examples", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Measures corners from polygons that are on the same net.\n\u2022 DIFFERENT_NET. Measures corners from polygons that are on different nets.\n\u2022 ALL. Measures all edges regardless of connectivity.\nFigure 306  shows the effect of the edge_endpoints  argument settings.\ninternal_corner2_edge()\nFigure 306 connectivity Argument Examples", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges, including edge endpoints.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 ALL. Looks through all edges.", "output_layer": "Optional. Specifies the layer whose edges are output for the violations. The\ndefault is LAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.", "output_type": "Optional. Specifies the edge types that are output. The default is FAIL.\ninternal_corner2_edge()\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 POINT_TO_POINT. Specifies that violations are output as an edge connecting\nthe two corners that are in violation. Edge endpoints are ordered from\nlayer1  to layer2. POINT_TO_POINT  creates an orphan edge layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The internal_corner2_edge()  function creates edges that consist of pairs of violation\ncorners.", "function_name": "internal_corner2_edge()"}
{"description": "The internal1()  function creates polygons that are formed by pairs of violation edges.\nIt measures inside-to-inside spacing on one layer based on the specified distance. The\narguments define various geometric conditions for measuring the distance between the\nedges. This check is limited to edges that are on the same polygon. For edge layers,\npolygon membership is determined by layer ancestry.", "syntax": "internal1(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\npoint_touch_shape       = EXTENTS  | SQUARE,                  //optional\nshape_size              = double,                            //optional\noutput_type             = REGION  | CENTERLINE | EXTENTS,     //optional\nwidth                   = double,                            //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\ninternal1()\ncorner_to_corner_angle = doubleconstraint,                  //optional\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\norientation_angle       = doubleconstraint,                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\ninternal1()\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nFigure 307  shows the effect of the extension  argument settings.\nFigure 307 extension Argument Examples", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 308  shows the effect of the extension_distance  argument settings.\ninternal1()\nFigure 308 extension_distance Argument Examples", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 309  shows the effect of the orientation  argument settings.\ninternal1()\nFigure 309 orientation Argument Examples\nFigure 310  shows the effect of the obtuse  argument setting.\nFigure 310 obtuse Argument Example", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\ninternal1()\nFigure 311  shows the effect of the intersecting  argument settings.\nFigure 311 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\ninternal1()\nFigure 312  shows the effect of the projection  argument settings.\nFigure 312 projection Argument Examples", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  of the enclose()  function\nargument for more information.\ninternal1()\nFigure 313  shows the effect of the projection_length  argument settings.\nFigure 313 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFigure 314  shows the effect of the orthogonal  argument settings.\ninternal1()\nFigure 314 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal1()\nFigure 315  shows the effect of the direction  argument settings.\nFigure 315 direction Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\ninternal1()\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 316  shows the effect of the corner_configuration  argument settings.\nFigure 316 corner_configuration Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 317  shows the effect of the extension_look_past  argument settings.\ninternal1()\nFigure 317 extension_look_past Argument Examples", "extension_obstructions": "Optional. Specifies how obstructions are processed in the check region\nextension. Some endpoint violations might be undesirable even though they are\nunobstructed. This argument specifies how aggressively the check finds and\nrefines endpoint violations in accordance with obstructed regions. The default is\nPOINT_TO_POINT.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 318  shows the effect of the extension_obstructions  argument\nsettings.\nFigure 318 extension_obstructions Argument Example", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. The default is no additional reporting.\ninternal1()\n\u2022 POINT_TOUCH. Creates a violation where there is an outside-to-outside point\ntouch. The format of the violation is determined by the point_touch_shape\nand shape_size  arguments. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 319  shows the effect of the relational  argument settings.\nFigure 319 relational Argument Example", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance  constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.\nFigure 320  shows the effect of the point_touch_shape  argument settings.\ninternal1()\nFigure 320 point_touch_shape Argument Examples", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of\nthe spacing distance. This value must be positive. It is rounded to the\nnearest even multiple of the internal resolution, with a minimum value of\ntwice the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\nFigure 321  shows the effect of the shape_size  argument settings.\nFigure 321 shape_size Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Reports violations as an expanded line at the center of the\nprojection region. The midpoints of the sides of the violation region form a\nline that is expanded in both directions by width/2. When the output_type\ninternal1()\nargument is CENTERLINE, only parallel spacing and intersection angles are\nsupported.\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when extension is RADIAL  or\nSQUARE.\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  value on both\nsides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  value. Violations are oriented along the line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nFigure 322  shows the effect of the output_type  argument settings.\nFigure 322 output_type Argument Examples\ninternal1()", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nargument is the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default\nis .001.\nFigure 323  shows the effect of the width  argument settings.\nFigure 323 width Argument Examples", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the\nprojection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the enclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\ninternal1()\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\nFigure 324  shows the effect of the cumulative_projection_length  argument\nsettings.\nFigure 324 cumulative_projection_length Argument Examples", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE\nor NONE_INCLUSIVE, and compatibility_options(drc = {spacing =\n{combine_edge_pair_violations = false}}). The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\n\u25e6 When the extension  argument is EDGE  and\ncompatibility_options(drc = {spacing =\n{combine_edge_pair_violations = true}}),\nSYMMETRIC_NON_INTERSECTING  can be specified. The behavior is the\ninternal1()\nsame as SYMMETRIC  to measure both projections from orthogonal and\nnonorthogonal edges. There is no output violation with a single point error\nedge.", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The orthogonal\nargument is not ignored.\nSee the intersection_angle  argument of the\ninternal2()  function for an\nexample.\ninternal1()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "membership": "Optional. Specifies how to check between edges that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is SAME_POLYGON.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 NOT_PROJECTING. Uses NONE  for projecting edges. This setting does not look\nthrough edges except for this special case: for edges that do not project, if\nthere exists a line of sight from either edge endpoint to the other edge, within\nthe check region, the extension violation is reported.\nFigure 325  shows an example of look_thru  with NOT_PROJECTING.\ninternal1()\nFigure 325 look_thru = NOT_PROJECTING\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: for\nedges that do not project onto each other, if an edge adjacent to either edge\nfully cuts the violation shape, the extension violation is not reported. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\nFigure 326  shows an example of look_thru  with NOT_ADJACENT.\nFigure 326 look_thru = NOT_ADJACENT\n\u2022 ALL. Looks through all edges.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal1()  function creates polygons that are formed by pairs of violation edges.", "function_name": "internal1()"}
{"description": "The internal1_edge()  function selects the portion of layer1  edges that violates the\nspacing constraints. It measures inside-to-inside spacing on one layer based on the\nspecified distance. The arguments define various geometric conditions for measuring the\ndistance between the edges. This check is limited to edges that are on the same polygon.\nFor edge layers, polygon membership is determined by layer ancestry. The complement of\nthis function is the not_internal1_edge()  function.", "syntax": "internal1_edge(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\nspacing_edge            = ALL  | PROJECTING,                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type            = FAIL  | CENTERLINE,                 //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\ninternal1_edge() and not_internal1_edge()\ncorner_to_corner_angle = doubleconstraint,                  //optional\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\n);\nnot_internal1_edge(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},\n//optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\nspacing_edge            = ALL  | PROJECTING,                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\ncorner_to_corner_angle = doubleconstraint,                  //optional\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\norientation_angle      = doubleconstraint,                  //optional\n);", "returns": "edge layer or error result\ninternal1_edge() and not_internal1_edge()", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\ninternal1_edge() and not_internal1_edge()\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nFigure 327  shows the effect of the extension  argument settings.\nFigure 327 extension Argument Examples", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 328  shows the effect of the extension_distance  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 328 extension_distance Argument Examples", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 329  shows the effect of the orientation  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 329 orientation Argument Examples", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFigure 330  shows the effect of the intersecting  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 330 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nFigure 331  shows the effect of the projection  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 331 projection Argument Examples", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function argument for more information.\ninternal1_edge() and not_internal1_edge()\nFigure 332  shows the effect of the projection_length  argument settings.\nFigure 332 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\ninternal1_edge() and not_internal1_edge()\nFigure 333  shows the effect of the orthogonal  argument settings.\nFigure 333 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal1_edge() and not_internal1_edge()\nFigure 334  shows the effect of the direction  argument settings.\nFigure 334 direction Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\ninternal1_edge() and not_internal1_edge()\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 335  shows the effect of the corner_configuration  argument settings.\nFigure 335 corner_configuration Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 336  shows the effect of the extension_look_past  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 336 extension_look_past Argument Examples", "extension_obstructions": "Optional. Specifies how obstructions are processed in the check region\nextension. Some endpoint violations might be undesirable even though they are\nunobstructed. This argument specifies how aggressively the check finds and\nrefines endpoint violations in accordance with obstructed regions. The default is\nPOINT_TO_POINT.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 337  shows the effect of the extension_obstructions  argument\nsettings.\nFigure 337 extension_obstructions Argument Example", "relational": "Optional. Specifies if a check outputs violations based on the relationship of\nthe polygons. Connectivity is considered when generating these violations. The\ndefault is no additional reporting.\ninternal1_edge() and not_internal1_edge()\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 338  shows the effect of the relational  argument settings.\nFigure 338 relational Argument Example", "spacing_edge": "Optional. Specifies the violation edges that are selected from spacing violations.\nEach spacing violation consists of one edge that creates a projection region, and\nanother edge that falls inside that region. The default is ALL.\n\u2022 ALL. Outputs all violation edges.\n\u2022 PROJECTING. Specifies that only the violation edge that created the projection\nregion is output. For nonparallel violations, the violation edge is the edge that\nis perpendicular to the violation.\nNote:\nThe projection region in parallel violations is commutative,\ntherefore PROJECTING  has no effect on parallel violations.\nEndpoint violations have no projecting edge, so they are not\nreported with this setting.\nFigure 339  shows the effect of the spacing_edge  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 339 spacing_edge Argument Examples", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\ninternal1_edge() and not_internal1_edge()\nFigure 340  shows the effect of the cumulative_projection_length  argument\nsettings.\nFigure 340 cumulative_projection_length Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_internal1_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\ninternal1_edge() and not_internal1_edge()", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The orthogonal\nargument is not ignored.\nSee the intersection_angle  argument of\ninternal2_edge() and\nnot_internal2_edge()  functions for an example.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninternal1_edge() and not_internal1_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "membership": "Optional. Specifies how to check between edges that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is SAME_POLYGON.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\ninternal1_edge() and not_internal1_edge()\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 NOT_PROJECTING. Uses NONE  for projecting edges. This setting does not look\nthrough edges except for this special case: for edges that do not project, if\nthere exists a line of sight from either edge endpoint to the other edge, within\nthe check region, the extension violation is reported.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: for\nedges that do not project onto each other, if an edge adjacent to either edge\nfully cuts the violation shape, the extension violation is not reported. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee Figure 325  and Figure 326for examples of look_thru  with\nNOT_PROJECTING  and look_thru  with NOT_ADJACENT.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal1_edge()  function selects the portion of layer1  edges that violates the\nspacing constraints.", "function_name": "not_internal1_edge()"}
{"description": "The internal1_edge()  function selects the portion of layer1  edges that violates the\nspacing constraints. It measures inside-to-inside spacing on one layer based on the\nspecified distance. The arguments define various geometric conditions for measuring the\ndistance between the edges. This check is limited to edges that are on the same polygon.\nFor edge layers, polygon membership is determined by layer ancestry. The complement of\nthis function is the not_internal1_edge()  function.", "syntax": "internal1_edge(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\nspacing_edge            = ALL  | PROJECTING,                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\noutput_type            = FAIL  | CENTERLINE,                 //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\ninternal1_edge() and not_internal1_edge()\ncorner_to_corner_angle = doubleconstraint,                  //optional\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\n);\nnot_internal1_edge(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},\n//optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\nspacing_edge            = ALL  | PROJECTING,                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\ncorner_to_corner_angle = doubleconstraint,                  //optional\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\norientation_angle      = doubleconstraint,                  //optional\n);", "returns": "edge layer or error result\ninternal1_edge() and not_internal1_edge()", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\ninternal1_edge() and not_internal1_edge()\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nFigure 327  shows the effect of the extension  argument settings.\nFigure 327 extension Argument Examples", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 328  shows the effect of the extension_distance  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 328 extension_distance Argument Examples", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nFigure 329  shows the effect of the orientation  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 329 orientation Argument Examples", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nFigure 330  shows the effect of the intersecting  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 330 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nFigure 331  shows the effect of the projection  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 331 projection Argument Examples", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument of the\nenclose()  function argument for more information.\ninternal1_edge() and not_internal1_edge()\nFigure 332  shows the effect of the projection_length  argument settings.\nFigure 332 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\ninternal1_edge() and not_internal1_edge()\nFigure 333  shows the effect of the orthogonal  argument settings.\nFigure 333 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal1_edge() and not_internal1_edge()\nFigure 334  shows the effect of the direction  argument settings.\nFigure 334 direction Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\ninternal1_edge() and not_internal1_edge()\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nFigure 335  shows the effect of the corner_configuration  argument settings.\nFigure 335 corner_configuration Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 336  shows the effect of the extension_look_past  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 336 extension_look_past Argument Examples", "extension_obstructions": "Optional. Specifies how obstructions are processed in the check region\nextension. Some endpoint violations might be undesirable even though they are\nunobstructed. This argument specifies how aggressively the check finds and\nrefines endpoint violations in accordance with obstructed regions. The default is\nPOINT_TO_POINT.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 337  shows the effect of the extension_obstructions  argument\nsettings.\nFigure 337 extension_obstructions Argument Example", "relational": "Optional. Specifies if a check outputs violations based on the relationship of\nthe polygons. Connectivity is considered when generating these violations. The\ndefault is no additional reporting.\ninternal1_edge() and not_internal1_edge()\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.\nFigure 338  shows the effect of the relational  argument settings.\nFigure 338 relational Argument Example", "spacing_edge": "Optional. Specifies the violation edges that are selected from spacing violations.\nEach spacing violation consists of one edge that creates a projection region, and\nanother edge that falls inside that region. The default is ALL.\n\u2022 ALL. Outputs all violation edges.\n\u2022 PROJECTING. Specifies that only the violation edge that created the projection\nregion is output. For nonparallel violations, the violation edge is the edge that\nis perpendicular to the violation.\nNote:\nThe projection region in parallel violations is commutative,\ntherefore PROJECTING  has no effect on parallel violations.\nEndpoint violations have no projecting edge, so they are not\nreported with this setting.\nFigure 339  shows the effect of the spacing_edge  argument settings.\ninternal1_edge() and not_internal1_edge()\nFigure 339 spacing_edge Argument Examples", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\ninternal1_edge() and not_internal1_edge()\nFigure 340  shows the effect of the cumulative_projection_length  argument\nsettings.\nFigure 340 cumulative_projection_length Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_internal1_edge()  function.\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\ninternal1_edge() and not_internal1_edge()", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The orthogonal\nargument is not ignored.\nSee the intersection_angle  argument of\ninternal2_edge() and\nnot_internal2_edge()  functions for an example.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\ninternal1_edge() and not_internal1_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "membership": "Optional. Specifies how to check between edges that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is SAME_POLYGON.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\ninternal1_edge() and not_internal1_edge()\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 NOT_PROJECTING. Uses NONE  for projecting edges. This setting does not look\nthrough edges except for this special case: for edges that do not project, if\nthere exists a line of sight from either edge endpoint to the other edge, within\nthe check region, the extension violation is reported.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: for\nedges that do not project onto each other, if an edge adjacent to either edge\nfully cuts the violation shape, the extension violation is not reported. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee Figure 325  and Figure 326for examples of look_thru  with\nNOT_PROJECTING  and look_thru  with NOT_ADJACENT.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal1_edge()  function selects the portion of layer1  edges that violates the\nspacing constraints.", "function_name": "internal1_edge()"}
{"description": "The internal1_error()  function measures inside-to-inside spacing between the edges\nof one layer based on the specified distance. The arguments define various geometric\nconditions for measuring the distance between the layer edges. The output is unmerged\nerrors.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nErrors output to the error database consist of pairs of violation edges.", "syntax": "internal1_error(\nlayer1                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {ACUTE, PERPENDICULAR},            //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE |\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nmembership              = ALL | SAME_POLYGON  | DIFFERENT_POLYGON,\n//optional\nrelational              = {POINT_TOUCH},                     //optional\ncorner_to_corner_angle = doubleconstraint,                  //optional\ninternal1_error()\nlook_thru               = NONE  | NOT_PROJECTING | NOT_ADJACENT\nALL                                //optional\norientation_angle       = doubleconstraint,                  //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\ninternal1_error()\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nSee the examples for the extension_distance  argument of the internal1()\nfunction for more information.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nSee the examples for the orientation  argument of the\ninternal1()  function\nfor more information.", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\ninternal1_error()\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nSee the examples for the intersecting  argument of the internal1()  function\nfor more information.", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nSee the examples for the projection  argument of the\ninternal1()  function for\nmore information.", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\ninternal1_error()\nSee the examples for the projection_length  argument of the internal1()\nfunction for more information.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nSee the examples for the orthogonal  argument of the\ninternal1()  function for\nmore information.", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nSee the examples for the direction  argument of the\ninternal1()  function for\nmore information.\ninternal1_error()", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee the examples for the corner_configuration  argument of the\ninternal1()  function for more information.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\nNote:\nThis argument is applicable only when look_thru = NONE.\ninternal1_error()\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nSee the examples for the extension_look_past  argument of the\ninternal1()  function for more information.", "extension_obstructions": "Optional. Specifies how obstructions are processed in the check region\nextension. Some endpoint violations might be undesirable even though they are\nunobstructed. This argument specifies how aggressively the check finds and\nrefines endpoint violations in accordance with obstructed regions. The default is\nPOINT_TO_POINT.\nNote:\nThis argument is applicable only when look_thru = NONE.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee the examples for the extension_obstructions  argument of the\ninternal1()  function for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\ninternal1_error()\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The orthogonal\nargument is not ignored.\ninternal1_error()\nSee the intersection_angle  argument of the internal2()  and\ninternal2_edge() and not_internal2_edge()  functions for examples.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "membership": "Optional. Specifies how to check between edges that are on the same polygon\nor different polygons. For edge layers, polygon membership is determined by\nlayer ancestry. The default is SAME_POLYGON.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\n\u2022 DIFFERENT_POLYGON. Checks only edges that are on different polygons.", "relational": "Optional. Specifies if a check outputs violations based on the relationship of\nthe polygons. Connectivity is considered when generating these violations. The\ndefault is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution. The POINT_TOUCH  argument is not available for\nedge input.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 NOT_PROJECTING. Uses NONE  for projecting edges. This setting does not look\nthrough edges except for this special case: for edges that do not project, if\ninternal1_error()\nthere exists a line of sight from either edge endpoint to the other edge, within\nthe check region, the extension violation is reported.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: for\nedges that do not project onto each other, if an edge adjacent to either edge\nfully cuts the violation shape, the extension violation is not reported. See\nFigure 218  and Figure 219  in the external1()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 ALL. Looks through all edges.\nSee Figure 325  and Figure 326  for examples of look_thru  with\nNOT_PROJECTING  and look_thru  with NOT_ADJACENT.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal1_error()  function measures inside-to-inside spacing between the edges\nof one layer based on the specified distance.", "function_name": "internal1_error()"}
{"description": "The internal2()  function creates polygons that are formed by pairs of violation edges. It\nmeasures inside-to-inside spacing between two layers based on the specified distance.\nThe arguments define various geometric conditions for measuring the distance between\nthe layer edges.", "syntax": "internal2(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nOUTSIDE | NOT_ADJACENT |           //optional\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\npoint_touch_shape       = EXTENTS  | SQUARE,                  //optional\nshape_size              = double,                            //optional\noutput_type             = REGION  | CENTERLINE | EXTENTS,     //optional\nwidth                   = double,                            //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ninternal2()\nline_touch_shape       = OUTSIDE  | INSIDE | BOTH,           //optional\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle       = doubleconstraint                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\nFigure 341  shows the effect of the distance  argument settings. For example,\nResult = internal2(layer1, layer2, <=1.0, extension = NONE);\ninternal2()\nFigure 341 distance Argument Examples", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\ninternal2()\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nFigure 342  and Figure 343  show the effect of the extension  argument settings.\nFigure 342 extension Argument Examples\nFigure 343 extension Argument Examples\ninternal2()", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 344  shows the effect of the extension_distance  argument settings.\nFigure 344 extension_distance Argument Examples", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\nFigure 345  shows the effect of the connectivity  argument settings.\ninternal2()\nFigure 345 connectivity Argument Examples", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\ninternal2()\nFigure 346  shows the effect of the orientation  argument settings.\nFigure 346 orientation Argument Examples", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where two layers outside touch. There is no\nmeasurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\ninternal2()\nFigure 347  shows the effect of the intersecting  argument settings.\nFigure 347 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\ninternal2()\nFigure 348  shows the effect of the projection  argument settings.\nFigure 348 projection Argument Examples", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.\ninternal2()\nFigure 349  shows the effect of the projection_length  argument settings.\nFigure 349 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\ninternal2()\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFigure 350  shows the effect of the orthogonal  argument settings.\nFigure 350 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal2()\nFigure 351  shows the effect of the direction  argument settings.\nFigure 351 direction Argument Examples\nFigure 352  shows the effect of additional direction  argument settings.\nFigure 352 direction Argument Examples", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\ninternal2()\nFigure 353  shows the effect of the from_layer  argument settings.\nFigure 353 from_layer Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\ninternal2()\nFigure 354  shows the effect of the corner_configuration  argument settings.\nFigure 354 corner_configuration Argument Examples", "look_thru": "Optional. Specifies how the dimensional check looks through obstructions when\nmeasuring the separation between check edges. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\ninternal2()\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. A projection is contained when any of the following\nare true:\n\u25e6 Edges of one layer are inside or outside coincident with projecting edges\nof the other layer.\n\u25e6 The projection is inside a polygon of any layer. For edge layers, this\ncontain does not apply.\nFigure 355  shows an example of using the NOT_CONTAINED  option.\ninternal2(purple, green, look_thru = NOT_CONTAINED);\nFigure 355 look_thru = NOT_CONTAINED Example\n\u2022 ALL. Looks through all edges.\nFigure 356  shows the effect of the look_thru  argument settings.\nFigure 356 look_thru Argument Examples\ninternal2()", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is >=0, which means the count is\nignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.\nFigure 357  shows the effect of the look_thru_count  argument settings.\nFigure 357 look_thru_count Argument Examples", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\ninternal2()\nFigure 358  shows the effect of the look_thru_from_layer  argument settings.\nFigure 358 look_thru_from_layer Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 359  shows the effect of the extension_look_past  argument settings.\nFigure 359 extension_look_past Argument Examples\ninternal2()", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nFigure 360  shows the effect of the extension_obstructions  argument\nsettings.\nFigure 360 extension_obstructions Argument Examples", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The format of the violation is determined by the point_touch_shape\nand shape_size  arguments.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\ninternal2()\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\nFigure 361  shows the effect of the relational  argument settings.\nFigure 361 relational Argument Example", "point_touch_shape": "Optional. Specifies the shapes that are generated for point touches. The default\nis EXTENTS.\n\u2022 EXTENTS. Specifies that the length of the violation is equal to the\nmaximum of the distance  constraint, with a minimum value of two times\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The violation\nregion is approximated with edges that are either perpendicular, parallel,\nor at a 45-degree angle, to the edges that form the point touch, to avoid\ncreating odd-angle data.\n\u2022 SQUARE. Specifies that a square is centered on the point touch. The sides of\nthe square are horizontal and vertical. The size of the square is determined\nby the shape_size  argument.\nFigure 362  shows the effect of the point_touch_shape  argument settings.\nFigure 362 point_touch_shape Argument Examples\ninternal2()", "shape_size": "Optional. Specifies the length of the sides of the squares generated when\npoint_touch_shape = SQUARE. The default is twice the maximum of\nthe spacing distance. This value must be positive. It is rounded to the\nnearest even multiple of the internal resolution, with a minimum value of\ntwice the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\nFigure 363  shows the effect of the point_touch_shape  argument settings.\nFigure 363 shape_size Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is REGION.\n\u2022 REGION. Reports violations as polygons, which are generated by connecting\nthe violation edges.\n\u2022 CENTERLINE. Reports violations as an expanded line at the center of the\nprojection region. The midpoints of the sides of the violation region form a\nline that is expanded in both directions by width/2. When the output_type\nargument is CENTERLINE, only parallel spacing and intersection angles are\nsupported.\n\u2022 EXTENTS. Reports violations as boxes, oriented along the violation edges,\nthat contain the extents of the violation. This setting is used to avoid the\ncreation of odd-angle data normally seen when the extension  argument is\nRADIAL  or SQUARE.\ninternal2()\nThe following violations require special consideration when generating output\nshapes:\n\u2022 When set to REGION, point-to-point violations are reported as rectangles by\nexpanding the line connecting the two points by the width  value on both\nsides.\n\u2022 When set to CENTERLINE, point-to-point violations are reported as squares,\ncentered on the midpoint of the line connecting the two points, with a\ndimension equal to the width  value. Violations are oriented along the line.\n\u2022 When set to EXTENTS, point-to-point violations are reported the same as\nwhen set to REGION.\nFigure 364  shows the effect of the output_type  argument settings.\nFigure 364 output_type Argument Examples", "width": "Optional. Specifies the value used to expand a single edge violation into a\npolygon, including perpendicular spacing violations that are a single edge.\nIf fixed_violation_width = true  in the compatibility_options()\nfunction, the global default violation width is set to four times the database\nunits for non-centerline violations. Otherwise, the minimum value for the\nargument is the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default\nis .001.\ninternal2()\nFigure 365  shows the effect of the width  argument settings.\nFigure 365 width Argument Examples", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "line_touch_shape": "Optional. Specifies how to expand a line-touch edge violation into a polygon.\nThe default is OUTSIDE.\n\u2022 OUTSIDE. Outputs a line-touch polygon outside of the dimensional function\nlayer1  polygon. The output polygon size equals the value of the width\noption.\n\u2022 INSIDE. Outputs a line-touch polygon inside of layer1. The output polygon\nsize equals the value of the width  option.\n\u2022 BOTH. Outputs a line touch polygon inside and outside of the layer1. The\ntotal output size is 2*width  option.\ninternal2()\nFigure 366  shows the effect of the line_touch_shape  argument settings.\nFigure 366 line_touch_shape Argument Examples", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\ninternal2()\nFigure 367  shows the effect of the cumulative_projection_length  argument\nsettings.\nFigure 367 cumulative_projection_length Argument Examples", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE\nor NONE_INCLUSIVE, and compatibility_options(drc = {spacing =\n{combine_edge_pair_violations = false}}). The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\n\u25e6 When the extension  argument is EDGE  and\ncompatibility_options(drc = {spacing =\n{combine_edge_pair_violations = true}}),\nSYMMETRIC_NON_INTERSECTING  can be specified. The behavior is the\nsame as SYMMETRIC  to measure both projections from orthogonal and\nnonorthogonal edges. There is no output violation with a single point error\nedge.\ninternal2()\nFigure 368  shows the effect of the projection_mode  argument settings.\nFigure 368 projection_mode Argument Examples", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\ninternal2()\nFigure 369  shows the effect of the projection_filter  argument settings.\nFigure 369 projection_filter Argument Examples", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\nFigure 370  shows an example of using the intersection_angle  argument.\ngreen = internal2(blue, red, distance < 1.0, extension = RADIAL,\norientation = {}, intersecting = {},\nintersection_angle < 180);\ninternal2()\nFigure 370 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\ninternal2()\n\u2022 INSIDE. Includes the following measurements:\nIf layer1  is a polygon, edges on the layer1  polygon measure those layer2\nedges that are inside of the same layer1  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer1  polygon measure those layer2  edges that are inside of\nany layer1  polygon.\nIf layer2  is a polygon, edges on the layer2  polygon measure those layer1\nedges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside of\nany layer2  polygon.\nIf the other layer is an edge layer, those edges that are neither inside\ncoincident nor outside coincident inside of the other layer are included in the\nmeasurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nIn\nFigure 371, the dash lines are filtered out before the measurement.\ninternal2(layer1 = orange, layer2 = blue, ...)\nFigure 371 Example of Edge Containment for the internal2() Functions\ninternal2()\n\u2022 COINCIDENT. Includes layer1  and layer2  edges that are inside coincident\nwith the other layer.\n\u2022 ALL. Does not filter edges.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon. Polygon membership is determined by layer ancestry. The\nSAME_POLYGON  option is valid only if the two input layers have the same polygon\nlayer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\nNote:\nThe connectivity  argument is not supported when\nmembership = SAME_POLYGON.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\ninternal2()\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal2()  function creates polygons that are formed by pairs of violation edges.", "function_name": "internal2()"}
{"description": "The internal2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints. It measures inside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The complement of this function is the\nnot_internal2_edge()  function.", "syntax": "internal2_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR,\nOBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nOUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length= NONE  | SAME_EDGE | JOGGING_EDGE,\ninternal2_edge() and not_internal2_edge()\n//optional\noutput_type            = FAIL  | CENTERLINE,                 //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\n);\nnot_internal2_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR,\nOBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nOUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ninternal2_edge() and not_internal2_edge()\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle       = doubleconstraint                   //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Optional. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation. The default is 0.\nSee the distance  example.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\nFigure 372  shows the effect of the distance  argument settings. For example,\nresult = internal2_edge(layer1, layer2, <=1.0, extension = NONE);\ninternal2_edge() and not_internal2_edge()\nFigure 372 distance Argument Examples", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\ninternal2_edge() and not_internal2_edge()\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nIn the conceptual diagram shown in Figure 373, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 373 Check Region Extension\nFigure 374  and Figure 375  show the effect of the extension  argument settings.\nFigure 374 extension Argument Examples\ninternal2_edge() and not_internal2_edge()\nFigure 375 extension Argument Examples", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 344  shows the effect of the extension_distance  argument settings.\nFigure 376 extension_distance Argument Examples", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\ninternal2_edge() and not_internal2_edge()\nFigure 377  shows the effect of the connectivity  argument settings.\nFigure 377 connectivity Argument Examples", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\ninternal2_edge() and not_internal2_edge()\nFigure 378  shows the effect of the orientation  argument settings.\nFigure 378 orientation Argument Examples", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where two layers outside touch. There is no\nmeasurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\ninternal2_edge() and not_internal2_edge()\nFigure 379  shows the effect of the intersecting  argument settings.\nFigure 379 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\ninternal2_edge() and not_internal2_edge()\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn Figure 380, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 380 Projection Regions for Edges\nFigure 381  shows the effect of the projection  argument settings.\nFigure 381 projection Argument Examples\ninternal2_edge() and not_internal2_edge()", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.\ninternal2_edge() and not_internal2_edge()\nFigure 382  shows the effect of the projection_length  argument settings.\nFigure 382 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\ninternal2_edge() and not_internal2_edge()\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFigure 383  shows the effect of the orthogonal  argument settings.\nFigure 383 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal2_edge() and not_internal2_edge()\nFigure 384  and Figure 385  show the effects of the direction  argument\nsettings.\nFigure 384 direction Argument Examples\nFigure 385 direction Argument Examples", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\ninternal2_edge() and not_internal2_edge()\nFigure 386  shows the effect of the from_layer  argument settings.\nFigure 386 from_layer Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\ninternal2_edge() and not_internal2_edge()\nFigure 387  shows the effect of the corner_configuration  argument settings.\nFigure 387 corner_configuration Argument Examples", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured.See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the internal2()  function for exceptions and examples.\n\u2022 ALL. Looks through all edges.\ninternal2_edge() and not_internal2_edge()\nFigure 388  shows the effect of the look_thru  argument settings.\nFigure 388 look_thru Argument Examples", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is >=0, which means the count is\nignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.\nFigure 389  shows the effect of the look_thru_count  argument settings.\nFigure 389 look_thru_count Argument Examples\ninternal2_edge() and not_internal2_edge()", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\nFigure 390  shows the effect of the look_thru_from_layer  argument settings.\nFigure 390 look_thru_from_layer Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\ninternal2_edge() and not_internal2_edge()\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 391  shows the effect of the extension_look_past  argument settings.\nFigure 391 extension_look_past Argument Examples", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\ninternal2_edge() and not_internal2_edge()\nSee Figure 392  for an example of the extension_obstructions  argument.\nFigure 392 extension_obstructions Argument Examples", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\ninternal2_edge() and not_internal2_edge()\nSee Figure 393  for an example of the relational  argument.\nFigure 393 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nSee\nFigure 394  for an example of the output_layer  argument.\nFigure 394 output_layer Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninternal2_edge() and not_internal2_edge()", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\nSee\nFigure 394  for an example of the cumulative_projection_length\nargument.\nFigure 395 cumulative_projection_length Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_internal2_edge()  function.\ninternal2_edge() and not_internal2_edge()\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.\nSee\nFigure 396  for an example of the output_type  argument.\nFigure 396 output_type Argument Examples", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\ninternal2_edge() and not_internal2_edge()\nSee Figure 397  for an example of the projection_mode  argument.\nFigure 397 projection_mode Argument Examples", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\ninternal2_edge() and not_internal2_edge()\nFigure 398  shows the effect of the projection_filter  argument settings.\nFigure 398 projection_filter Argument Examples", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\ninternal2_edge() and not_internal2_edge()\nFigure 399  shows an example of using the intersection_angle  argument.\nFigure 399 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\ninternal2_edge() and not_internal2_edge()\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 INSIDE. Includes the following measurements:\nIf layer1  is a polygon, edges on the layer1  polygon measure those layer2\nedges that are inside of the same layer1  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer1  polygon measure those layer2  edges that are inside of\nany layer1  polygon.\nIf layer2  is a polygon, edges on the layer2  polygon measure those layer1\nedges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside of\nany layer2  polygon.\nIf the other layer is an edge layer, those edges that are neither inside\ncoincident nor outside coincident inside of the other layer are included in the\nmeasurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nSee\nFigure 371  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are inside coincident.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\ninternal2_edge() and not_internal2_edge()\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon. Polygon membership is determined by layer ancestry. The\nSAME_POLYGON  option is valid only if the two input layers have the same polygon\nlayer ancestry. The default is ALL.\ninternal2_edge() and not_internal2_edge()\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\nNote:\nThe connectivity  argument is not supported when\nmembership = SAME_POLYGON.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints.", "function_name": "internal2_edge()"}
{"description": "The internal2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints. It measures inside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The complement of this function is the\nnot_internal2_edge()  function.", "syntax": "internal2_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR,\nOBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nOUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ncumulative_projection_length= NONE  | SAME_EDGE | JOGGING_EDGE,\ninternal2_edge() and not_internal2_edge()\n//optional\noutput_type            = FAIL  | CENTERLINE,                 //optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\n);\nnot_internal2_edge(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,                  //optional\nextension               = NONE | NONE_INCLUSIVE | RADIAL  |\nSQUARE | RECTANGLE | EDGE,         //optional\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR,\nOBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH,      //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT |\nOUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nrelational              = {POINT_TOUCH},                     //optional\noutput_layer           = LAYER1  | LAYER2,                   //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\ninternal2_edge() and not_internal2_edge()\ncumulative_projection_length  = NONE  | SAME_EDGE | JOGGING_EDGE,\n//optional\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\noutput_side             = ALL  | HIGH | LOW,                  //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle       = doubleconstraint                   //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Optional. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation. The default is 0.\nSee the distance  example.\nNote:\nThe only constraint operators allowed are <, <=, and ==.\nFigure 372  shows the effect of the distance  argument settings. For example,\nresult = internal2_edge(layer1, layer2, <=1.0, extension = NONE);\ninternal2_edge() and not_internal2_edge()\nFigure 372 distance Argument Examples", "extension": "Optional. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked. The default is RADIAL.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-point\nviolations whose edges have no length. The edges reported have a length\nequal to the internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\ninternal2_edge() and not_internal2_edge()\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.\nIn the conceptual diagram shown in Figure 373, the current edge being checked\nis shown in solid black. The check region is dashed.\nFigure 373 Check Region Extension\nFigure 374  and Figure 375  show the effect of the extension  argument settings.\nFigure 374 extension Argument Examples\ninternal2_edge() and not_internal2_edge()\nFigure 375 extension Argument Examples", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.\nFigure 344  shows the effect of the extension_distance  argument settings.\nFigure 376 extension_distance Argument Examples", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\ninternal2_edge() and not_internal2_edge()\nFigure 377  shows the effect of the connectivity  argument settings.\nFigure 377 connectivity Argument Examples", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\ninternal2_edge() and not_internal2_edge()\nFigure 378  shows the effect of the orientation  argument settings.\nFigure 378 orientation Argument Examples", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where two layers outside touch. There is no\nmeasurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\ninternal2_edge() and not_internal2_edge()\nFigure 379  shows the effect of the intersecting  argument settings.\nFigure 379 intersecting Argument Examples", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\ninternal2_edge() and not_internal2_edge()\n\u2022 IN. Measures edges that have any portion inside the projection region.\n\u2022 OUT. Measures edges that are outside of the projection region.\n\u2022 ON. Measures edges that fall exactly on the boundary of the projection region.\nIn Figure 380, the projection region for edge A is shown in gray. The green\nedges are IN, the red edges are OUT, and the magenta edges are ON.\nFigure 380 Projection Regions for Edges\nFigure 381  shows the effect of the projection  argument settings.\nFigure 381 projection Argument Examples\ninternal2_edge() and not_internal2_edge()", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.\nNote:\nSee the cumulative_projection_length  argument for more\ninformation.\ninternal2_edge() and not_internal2_edge()\nFigure 382  shows the effect of the projection_length  argument settings.\nFigure 382 projection_length Argument Examples", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\ninternal2_edge() and not_internal2_edge()\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nFigure 383  shows the effect of the orthogonal  argument settings.\nFigure 383 orthogonal Argument Examples", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\ninternal2_edge() and not_internal2_edge()\nFigure 384  and Figure 385  show the effects of the direction  argument\nsettings.\nFigure 384 direction Argument Examples\nFigure 385 direction Argument Examples", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\ninternal2_edge() and not_internal2_edge()\nFigure 386  shows the effect of the from_layer  argument settings.\nFigure 386 from_layer Argument Examples", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the\nvertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\ninternal2_edge() and not_internal2_edge()\nFigure 387  shows the effect of the corner_configuration  argument settings.\nFigure 387 corner_configuration Argument Examples", "look_thru": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured.See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the internal2()  function for exceptions and examples.\n\u2022 ALL. Looks through all edges.\ninternal2_edge() and not_internal2_edge()\nFigure 388  shows the effect of the look_thru  argument settings.\nFigure 388 look_thru Argument Examples", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is >=0, which means the count is\nignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.\nFigure 389  shows the effect of the look_thru_count  argument settings.\nFigure 389 look_thru_count Argument Examples\ninternal2_edge() and not_internal2_edge()", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.\nFigure 390  shows the effect of the look_thru_from_layer  argument settings.\nFigure 390 look_thru_from_layer Argument Examples", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\ninternal2_edge() and not_internal2_edge()\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.\nFigure 391  shows the effect of the extension_look_past  argument settings.\nFigure 391 extension_look_past Argument Examples", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\ninternal2_edge() and not_internal2_edge()\nSee Figure 392  for an example of the extension_obstructions  argument.\nFigure 392 extension_obstructions Argument Examples", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function\nsets the internal resolution.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\ninternal2_edge() and not_internal2_edge()\nSee Figure 393  for an example of the relational  argument.\nFigure 393 relational Argument Example", "output_layer": "Optional. Specifies the layer that is output for the violations. The default is\nLAYER1.\n\u2022 LAYER1. Specifies that only layer1  edges are output.\n\u2022 LAYER2. Specifies that only layer2  edges are output.\nSee\nFigure 394  for an example of the output_layer  argument.\nFigure 394 output_layer Argument Example", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\ninternal2_edge() and not_internal2_edge()", "cumulative_projection_length": "Optional. Specifies how the projection length is measured when there are\nmultiple violations. See the projection_length  argument for more information.\nThe default is NONE.\nSee the cumulative_projection_length  argument of the\nenclose()  function\nfor more information about the SAME_EDGE  and JOGGING_EDGE  options.\n\u2022 NONE. Measures each violation separately.\n\u2022 SAME_EDGE. Measures violations by accumulating a projection length for\ninteracting violations that project from the same edge. A given violation can\ncontribute to more than one unique accumulated projection lengths.\n\u2022 JOGGING_EDGE. Measures violations by accumulating a projection length\nfor interacting violations that project from the same edge or a jogging edge.\nA given violation can contribute to more than one unique accumulated\nprojection lengths.\nSee\nFigure 394  for an example of the cumulative_projection_length\nargument.\nFigure 395 cumulative_projection_length Argument Examples", "output_type": "Optional. Specifies the type of output generated. The default is FAIL.\nNote:\nThe output_type  argument is not available for the\nnot_internal2_edge()  function.\ninternal2_edge() and not_internal2_edge()\n\u2022 FAIL. Specifies that the portions of the edges that fall within the check region\nare output.\n\u2022 CENTERLINE. Outputs spacing violations as lines at the center of the\nprojection region. A line is two points connected with no specific order. The\nmidpoints of the sides of the violation region are used to create the lines.\nWhen the output_type  argument is CENTERLINE, only parallel spacing and\nintersection angles are supported.\nSee\nFigure 396  for an example of the output_type  argument.\nFigure 396 output_type Argument Examples", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).\ninternal2_edge() and not_internal2_edge()\nSee Figure 397  for an example of the projection_mode  argument.\nFigure 397 projection_mode Argument Examples", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.\ninternal2_edge() and not_internal2_edge()\nFigure 398  shows the effect of the projection_filter  argument settings.\nFigure 398 projection_filter Argument Examples", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\ninternal2_edge() and not_internal2_edge()\nFigure 399  shows an example of using the intersection_angle  argument.\nFigure 399 intersection_angle Argument Example", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\ninternal2_edge() and not_internal2_edge()\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 INSIDE. Includes the following measurements:\nIf layer1  is a polygon, edges on the layer1  polygon measure those layer2\nedges that are inside of the same layer1  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer1  polygon measure those layer2  edges that are inside of\nany layer1  polygon.\nIf layer2  is a polygon, edges on the layer2  polygon measure those layer1\nedges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside of\nany layer2  polygon.\nIf the other layer is an edge layer, those edges that are neither inside\ncoincident nor outside coincident inside of the other layer are included in the\nmeasurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\nSee\nFigure 371  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are inside coincident.\n\u2022 ALL. Does not filter edges.", "output_side": "Optional. Specifies to output only the check edges on the specified side of any\nviolation projected from an orthogonal edge. The default is ALL.\nNote:\nTo use the HIGH  or LOW  options,\n- The direction  argument needs to be HORIZONTAL  or VERTICAL.\n- The extension  argument needs to be NONE.\ninternal2_edge() and not_internal2_edge()\n\u2022 ALL. Outputs all check edges\n\u2022 HIGH. Outputs all check edges except:\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\ntop side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the right\nside is output.\n\u2022 LOW. Outputs all check edges.\n\u25e6 For any violation projected from a horizontal edge, only the edge on the\nbottom side is output.\n\u25e6 For any violation projected from a vertical edge, only the edge on the left\nside is output.\nFor examples, see the output_side  argument of the\nenclose_edge() and\nnot_enclose_edge()  functions.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon. Polygon membership is determined by layer ancestry. The\nSAME_POLYGON  option is valid only if the two input layers have the same polygon\nlayer ancestry. The default is ALL.\ninternal2_edge() and not_internal2_edge()\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\nNote:\nThe connectivity  argument is not supported when\nmembership = SAME_POLYGON.", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal2_edge()  function selects the portion of layer1  or layer2  edges that\nviolates the spacing constraints.", "function_name": "not_internal2_edge()"}
{"description": "The internal2_error()  function measures inside-to-inside spacing between two layers\nbased on the specified distance. The arguments define various geometric conditions for\nmeasuring the distance between the layer edges. The output is unmerged errors.\nDerived error layers are unformatted. These layers can be used by the\ndrc_features()\nfunction. The layers can be formatted and merged into normal layers using the\nerror_merge()  and error_merge_edge()  functions.\nErrors output to the error database consist of pairs of violation edges.", "syntax": "internal2_error(\nlayer1                  = data_layer,\nlayer2                  = data_layer,\ndistance                = doubleconstraint,\nextension               = NONE | NONE_INCLUSIVE | RADIAL |\nSQUARE | RECTANGLE | EDGE,\nextension_distance     = double,                            //optional\nconnectivity            = SAME_NET | DIFFERENT_NET | ALL,    //optional\nconnect_sequence       = connect_database,                  //optional\norientation             = {ACUTE, PARALLEL,\nPERPENDICULAR, OBTUSE},           //optional\nintersecting            = {TOUCH, ACUTE, PERPENDICULAR},     //optional\nprojection              = {IN, OUT, ON},                     //optional\nprojection_length      = doubleconstraint,                  //optional\northogonal              = ALL  | BOTH | NEITHER | ONE\nONE_OR_NEITHER | ONE_OR_BOTH |\nNEITHER_OR_BOTH,                   //optional\ndirection               = HORIZONTAL | VERTICAL |\nNON_ORTHOGONAL | ORTHOGONAL |\nPOSITIVE_45 | NEGATIVE_45 |\nALL,   //optional\nfrom_layer              = LAYER1 | LAYER2 | ALL  |\nEXTENDED1 | EXTENDED2,\n//optional\ncorner_configuration   = ALL  | CORNER_TO_CORNER_OR_EDGE |\nCORNER_TO_CORNER | CORNER_TO_EDGE |\nNOT_CORNER | CORNER_TO_CORNER_INCLUSIVE,\n//optional\nlook_thru               = NONE  | COINCIDENT | RELATED_COINCIDENT\nOUTSIDE | NOT_ADJACENT |\nNOT_CONTAINED | ALL,               //optional\nlook_thru_count        = integerconstraint,                 //optional\nlook_thru_from_layer    = LAYER1 | LAYER2 | ALL,             //optional\nextension_look_past    = NONE  | POINT_TO_POINT,             //optional\nextension_obstructions  = POINT_TO_POINT  | ALL,              //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL          //optional\ninternal2_error()\nprojection_mode         = SYMMETRIC  | SYMMETRIC_NON_INTERSECTING |\nASYMMETRIC,                        //optional\nprojection_filter       = INDIVIDUAL  | MUTUAL |\nMUTUAL_NON_ORTHOGONAL,             //optional\nintersection_angle      = doubleconstraint,                  //optional\nname                   = \"layer_label\",                     //optional\nedge_containment        = INSIDE | COINCIDENT | ALL,         //optional\nbreak_edges             = true | false,                      //optional\nmembership              = ALL  | SAME_POLYGON,                //optional\nrelational              = {POINT_TOUCH},                     //optional\ncorner_to_corner_angle = doubleconstraint                   //optional\norientation_angle       = doubleconstraint                   //optional\n);", "returns": "error layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer against which the layer1  layer is\nchecked.", "distance": "Required. Specifies the check distance. See\nConstraints  on page 3344 for more\ninformation.\nNote:\nThe only constraint operators allowed are <, <=, and ==.", "extension": "Required. Specifies the extension of the check region, beyond the endpoints of\nthe edge being checked.\n\u2022 NONE. Does not extend the check region; it is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the distance  value.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value. When the\nprojection  argument includes the ON  setting and the projection_length\ninternal2_error()\nargument contains 0, the NONE_INCLUSIVE  setting generates point-to-\npoint violations whose edges have no length. See the description of the\noutput_type  argument for more information.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u2022 SQUARE. Extends the check region past the endpoints of the edges using the\ndistance  value with a square. The boundary of the check region is inclusive\nor exclusive depending on the constraint of the distance  value.\n\u2022 RECTANGLE. Extends the check region past the endpoints of the edges using\nthe extension_distance  value with a rectangle. The boundary of the check\nregion is inclusive or exclusive depending on the constraint of the distance\nvalue.\n\u2022 EDGE. Forms the check region by extending the edges using the\nextension_distance, and creating right-angle boundaries at the extended\nendpoints based on the distance  constraint. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero, and the extension_distance  is nonzero.\nSee\nFigure 103  for an example of RECTANGLE  and Figure 104  for an example of\nEDGE  in the enclose()  function for more information.", "extension_distance": "Optional. Specifies the check region extension distance when the extension\nargument is RECTANGLE  or EDGE. The value must be nonnegative. The default is\n0.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the edges that are on the same net.\n\u2022 DIFFERENT_NET. Checks the edges that are on different nets.\n\u2022 ALL. Checks all edges regardless of connectivity.\ninternal2_error()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET.", "orientation": "Optional. Specifies the orientations of nonintersecting edges that are checked.\nThe default is {ACUTE, PARALLEL}.\n\u2022 ACUTE. Measures all nonintersecting edges that are oriented at an acute\nangle.\n\u2022 PARALLEL. Measures all nonintersecting parallel edges.\n\u2022 PERPENDICULAR. Measures all nonintersecting perpendicular edges.\n\u2022 OBTUSE. Measures all nonintersecting edges that are oriented at an obtuse\nangle.\nSee the examples for the orientation  argument of the\ninternal2()  function\nfor more information.", "intersecting": "Optional. Specifies the intersecting edge types that are checked. Use an empty\nlist ({}) to not measure intersecting edges. The default is ACUTE.\n\u2022 TOUCH. Creates a violation where two layers outside touch. There is no\nmeasurement in this case.\n\u2022 ACUTE. Measures separation of intersecting edges that form an acute angle.\n\u2022 PERPENDICULAR. Measures separation of intersecting edges that form a\nperpendicular angle.\nSee the examples for the intersecting  argument of the\ninternal2()  function\nfor more information.", "projection": "Optional. Specifies the projections that must be satisfied for an edge\nmeasurement to occur. Each edge creates a projection region bounded by\nperpendicular lines at each endpoint, extended to the check side of the edge\nindefinitely. The other edges fall either in, out, or exactly on this region. The\ndefault is {IN, OUT, ON}. See\nSpacing Checks  on page 3360 for more\ninformation about the check side.\ninternal2_error()\nNote:\nProjection is mutual for parallel spacing. For nonparallel spacing,\nthere are two separate measurements and each is individually\ncompared with the projection specification.\nSee the examples for the projection  argument of the\ninternal2()  function for\nmore information.", "projection_length": "Optional. Reports spacing violations if the projection length meets the\nspecification. The default is >=0, which means to ignore the projection length.\nThe projection length is the length of the projecting edge, where the projecting\nedge is the violation edge that created the projection region. For nonparallel\nviolations, the projecting edge is the edge that is perpendicular to the violation.\nThe restrictions are\n\u2022 The orientation  argument cannot contain PERPENDICULAR.\n\u2022 The intersecting  argument cannot contain PERPENDICULAR.\n\u2022 The corner_configuration  argument cannot be CORNER_TO_CORNER.\n\u2022 The projection  argument must contain IN  for extension=NONE, or contain\nON  for extension=NONE_INCLUSIVE.", "orthogonal": "Optional. Measures two edges only when the number of orthogonal edges in the\npair meets the specification. The default is ALL.\n\u2022 ALL. Checks all pairs of edges regardless of orthogonality.\n\u2022 ONE_OR_NEITHER. Checks the pairs of edges where one or neither are\northogonal.\n\u2022 ONE_OR_BOTH. Checks the pairs of edges where at least one is orthogonal.\n\u2022 ONE. Checks the pairs of edges where one is orthogonal.\n\u2022 NEITHER. Checks the pairs of edges where neither are orthogonal.\n\u2022 BOTH. Checks the pairs of edges where both are orthogonal.\n\u2022 NEITHER_OR_BOTH. Checks the pairs of edges where neither or both are\northogonal.\nSee the examples for the orthogonal  argument of the\ninternal2()  function for\nmore information.\ninternal2_error()", "direction": "Optional. Specifies the direction of the spacing check. The specification refers to\nthe perpendicular projection being measured. The default is ALL.\n\u2022 HORIZONTAL. Specifies that only horizontal projections are measured.\n\u2022 VERTICAL. Specifies that only vertical projections are measured.\n\u2022 NON_ORTHOGONAL. Specifies that only nonorthogonal projections are\nmeasured.\n\u2022 ORTHOGONAL. Specifies that only orthogonal projections are measured.\n\u2022 POSITIVE_45. Specifies that only positive 45-degree projections are\nmeasured.\n\u2022 NEGATIVE_45. Specifies that only negative 45-degree projections are\nmeasured.\n\u2022 ALL. Specifies that projections are measured regardless of direction.\nSee the examples for the direction  argument of the\ninternal2()  function for\nmore information.", "from_layer": "Optional. Specifies the layer that is used to create check regions. The default is\nALL.\n\u2022 LAYER1. Specifies that only layer1  edges create check regions.\n\u2022 LAYER2. Specifies that only layer2  edges create check regions.\n\u2022 ALL. Specifies that all edges check regions.\n\u2022 EXTENDED1. Generates non-extension and extension violations from\nLAYER1  to LAYER2  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\n\u2022 EXTENDED2. Generates non-extension and extension violations from\nLAYER2  to LAYER1  and non-extension violations from LAYER2  to LAYER1  if\nextension=RECTANGLE.\nSee the examples for the from_layer  argument of the\ninternal2()  function for\nmore information.", "corner_configuration": "Optional. Specifies how to check edges in a corner orientation. This argument\napplies only to nonintersecting edges. If this argument is not ALL, it overrides\ninternal2_error()\nthe orthogonal, projection, and orientation  arguments for nonintersecting\nedges. The default is ALL.\nNote:\nUse the vertex()  function to find corners of a specific angle.\n\u2022 ALL. Measures edge pairs regardless of corner orientation.\n\u2022 CORNER_TO_CORNER_OR_EDGE. Measures the spacing between two edges\nonly if the edges satisfy the CORNER_TO_CORNER  or CORNER_TO_EDGE\nrequirements.\n\u2022 CORNER_TO_CORNER. Measures the spacing between two edges only if both\nfall on concave, right-angle corners, are parallel, and do not project.\n\u2022 CORNER_TO_EDGE. Measures the spacing between two edges only if one falls\non a concave, right-angle corner, they are nonparallel, and project. Also, the\nline bisecting the corner must intersect the edge.\n\u2022 NOT_CORNER. Measures the spacing between two edges that do not satisfy\nthe CORNER_TO_CORNER_OR_EDGE  requirements.\n\u2022 CORNER_TO_CORNER_INCLUSIVE. Measures the spacing between two edges\nonly if they both fall on convex, right-angle corners, are parallel and do not\nproject, but the right-angle boundaries of the check region are inclusive.\nSee the examples for the corner_configuration  argument of the\ninternal2()  function for more information.", "look_thru": "Optional. Specifies how the dimensional check looks through obstructions when\nmeasuring the separation between check edges. The default is NONE.\n\u2022 NONE. Does not look through any edges.\n\u2022 COINCIDENT. Looks through inside coincident edges.\n\u2022 RELATED_COINCIDENT. Uses COINCIDENT  if the two input layers have the\nsame layer ancestry; otherwise, NONE  is used.\n\u2022 OUTSIDE. Looks outside both layer1  and layer2.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured. See\nFigure 233  and Figure 234  in the external2()  function for examples of the\nlook_thru  argument set to NOT_ADJACENT.\ninternal2_error()\n\u2022 NOT_CONTAINED. Looks through all edges, except polygons or edges that\ncontain the projection. See the NOT_CONTAINED  option of the look_thru\nargument of the internal2()  function for exceptions and examples.\n\u2022 ALL. Looks through all edges.\nSee the example for the look_thru  argument of the internal2()  function for\nmore information.", "look_thru_count": "Optional. Specifies the number of edges that must be looked through for a\nmeasurement to occur. Edges coincident to the edge being measured are not\nincluded in the count. The value must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is >=0, which means the count is\nignored.\nNote:\nUse this argument only when the extension  argument is NONE  and\nthe look_thru  argument is ALL.", "look_thru_from_layer": "Optional. Controls which edges are counted for the look_thru_count\nargument. The default is ALL.\n\u2022 LAYER1. Counts only layer1  edges.\n\u2022 LAYER2. Counts only layer2  edges.\n\u2022 ALL. Counts both layer1  and layer2  edges.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL. The look_thru_from_layer\nargument has no effect unless the look_thru_count  argument is\nalso specified.", "extension_look_past": "Optional. Specifies which extension obstructions are looked past during the\nviolation discovery process. When processing a measurement from edge a to\nedge b, the check begins at the shortest distance between the two edges in the\nextension region of edge a. The term past refers to portions of edge b that are\nfarther away from edge a than the portion that is obstructed. The default is NONE.\ninternal2_error()\n\u2022 NONE. Specifies that this check does not look past any extension\nobstructions. The violation discovery process stops when an obstruction is\nencountered.\n\u2022 POINT_TO_POINT. Specifies that this check looks past point-to-point\nobstructions to measure edges beyond the obstruction. The discovery\nprocess stops when anything other than a point-to-point obstruction is found.", "extension_obstructions": "Optional. Specifies how look_thru  is processed for the check region extension.\nSome endpoint violations might be undesirable even though they fit the\nlook_thru  setting. This argument specifies how aggressively the check finds\nand refines endpoint violations in accordance with obstructed regions. The\ndefault is POINT_TO_POINT.\n\u2022 POINT_TO_POINT. Reports violations. If the shortest distance from edge to\nedge is obstructed, there is no violation; otherwise a violation is reported.\nOther obstructions are ignored.\n\u2022 ALL. Reports the same violations as POINT_TO_POINT; however, the\nviolations are corrected for other obstructions.\nSee the examples for the extension_obstructions  argument of the\ninternal2()  function for more information.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "projection_mode": "Optional. Specifies which projection is measured for nonparallel spacing,\nwhere exactly one edge is orthogonal, and extension  argument is NONE  or\nNONE_INCLUSIVE. The default is SYMMETRIC.\n\u2022 SYMMETRIC. Measures both projections.\n\u2022 ASYMMETRIC. Measures only the projection from the orthogonal edge.\n\u2022 SYMMETRIC_NON_INTERSECTING\ninternal2_error()\n\u25e6 For nonintersecting edges, measures both projections (the SYMMETRIC\nsetting).\n\u25e6 For intersecting edges, measures only the projection from the orthogonal\nedge (the ASYMMETRIC  setting).", "projection_filter": "Optional. Controls the measurement of nonparallel edges based on their\nrespective projection status. The default is INDIVIDUAL.\n\u2022 INDIVIDUAL. Measures edges if either edge matches the projection criteria\nas specified in the projection  argument.\n\u2022 MUTUAL. Measures edges only if both edges match the following projection\ncriteria:\n\u25e6 If the extension  argument is NONE, both edges must match the IN  option;\nthat is, edges that have any portion inside the projection region are\nmeasured. The projection  argument is ignored.\n\u25e6 If the extension  argument is NONE_INCLUSIVE, both edges must match\nthe IN  or ON  options; that is, edges that edges that have any portion\ninside the projection region or that fall exactly on the boundary of the\nprojection region are measured. The projection  argument is ignored.\n\u25e6 Otherwise, both edges must match the projection criteria as specified in\nthe projection  argument.\n\u2022 MUTUAL_NON_ORTHOGONAL.\n\u25e6 If both edges are nonorthogonal, apply the MUTUAL  option setting.\n\u25e6 If either edge is orthogonal, apply the INDIVIDUAL  option setting.", "intersection_angle": "Optional. Specifies the required angle of separation between two intersecting\nedges for additional violations. The angle must be greater than or equal to\n0 and less than 180. When an intersection angle is not specified, the angle\nof separation is not checked. When an intersection angle is specified, the\nintersecting  argument must be an empty list ({}).\nNote:\nThe direction, orientation, intersecting, projection,\nprojection_length, and corner_configuration  arguments are\nignored for the intersection_angle  argument. The look_thru\nargument is ignored. The connectivity  and orthogonal  arguments\nare not ignored.\ninternal2_error()\nSee the intersection_angle  argument of the internal2()  and\ninternal2_edge() and not_internal2_edge()  functions for examples.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "edge_containment": "Optional. Filters edges, based on the topological relation of the two layers,\nbefore the tool makes any measurements. Edges are broken into segments that\nare inside, outside, inside coincident, and outside coincident with the other layer.\nThe default is ALL.\nNote:\nWhen the edge_containment  argument is not ALL  and the two\ninput layers do not have the same layer ancestry, the break_edges\nargument is forced to true.\n\u2022 INSIDE. Includes the following measurements:\nIf layer1  is a polygon, edges on the layer1  polygon measure those layer2\nedges that are inside of the same layer1  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer1  polygon measure those layer2  edges that are inside of\nany layer1  polygon.\nIf layer2  is a polygon, edges on the layer2  polygon measure those layer1\nedges that are inside of the same layer2  polygon.\nNote:\nWhen you specify the connectivity  argument, edges on the\nlayer2  polygon measure those layer1  edges that are inside of\nany layer2  polygon.\nIf the other layer is an edge layer, those edges that are neither inside\ncoincident nor outside coincident inside of the other layer are included in the\nmeasurements.\nNote:\nEdges that are outside coincident with the other layer are included\nin the measurement for touch violations.\ninternal2_error()\nSee Figure 371  for an example.\n\u2022 COINCIDENT. Includes layer1  edges that are inside coincident.\n\u2022 ALL. Does not filter edges.", "break_edges": "Optional. Controls edge breaking behavior for two-layer spacing checks when\nthe two input layers do not have the same layer ancestry. The segments\nresulting from the edge breaking are processed individually by the edge filters\nand spacing constraints. The default is false.\n\u2022 true. Enables edge breaking behavior when the two input layers do not\nhave the same layer ancestry. Edges are broken into individual segments as\nfollows:\n\u25e6 Specifies that edges are broken at every point of intersection with the\nother layer.\n\u25e6 Specifies that coincident edges are broken at the point where they\nbecome not-coincident.\n\u2022 false. Specifies that edges are not broken.", "membership": "Optional. Specifies whether to check all distances between edges that are on\nthe same polygon. Polygon membership is determined by layer ancestry. The\nSAME_POLYGON  option is valid only if the two input layers have the same polygon\nlayer ancestry. The default is ALL.\n\u2022 ALL. Checks all edges regardless of polygon membership.\n\u2022 SAME_POLYGON. Checks only edges that are on the same polygon.\nNote:\nThe connectivity  argument is not supported when\nmembership = SAME_POLYGON.", "relational": "Optional. Specifies if a check outputs additional violations based on the\nrelationship of the polygons. Connectivity is considered when generating these\nviolations. The default is no additional reporting.\n\u2022 POINT_TOUCH. Creates a violation where there is an inside-to-inside point\ntouch. The length of the violation is equal to the maximum of the distance\nconstraint, with a minimum value of two times the internal resolution. The\ninternal2_error()\ninternal_resolution  argument of the resolution_options()  function\nsets the internal resolution.\nWhen the edge_containment  argument is specified, the POINT_TOUCH\nargument creates a violation by using an intersection angle for all edges\nthat touch any point-touch point. The angle of the intersection angle must be\ngreater than or equal to 0 and less than 180. When the edge_containment\nargument is specified, the point_touch_shape  and shape_size  arguments\nare ignored.\nThe POINT_TOUCH  argument is not available for edge input.\nSee\nFigure 400  for an example of the relational  argument.\nFigure 400 relational Argument Example", "corner_to_corner_angle": "Optional. Specifies the measurement of any two edges\nwhen corner_configuration = CORNER_TO_CORNER  or\nCORNER_TO_CORNER_INCLUSIVE, by considering the angles between the line\nsegment of two corners and the x-axis.", "orientation_angle": "Optional. Specifies the orientation_angle  with the option. It measures\nthe separation of non-intersecting edges that form a specified angle. The\nangle must be greater than or equal to 0 and less than 180. When an\norientation_angle  is not specified, the angle of separation is not checked.\nWhen an orientation_angle  is specified, the orientation argument must be an\nempty list ({})."}, "summary": "The internal2_error()  function measures inside-to-inside spacing between two layers\nbased on the specified distance.", "function_name": "internal2_error()"}
{"description": "The intersections()  function creates polygons that represent the specified intersections\nwith the specified output format. Each intersection between the layer1  edges and the\nlayer2  edges is compared to the angle list. Intersections includes endpoints. Collinear\nedges do not match any angle specifications.\nThe intersections()  function considers only the smallest of the two angles for a given\nintersection. For example, as shown in\nFigure 401, with a specification of outside-to-\noutside angle measurement, the intersection A has two angles. Only the smallest of the\ntwo, the 90-degree angle, is measured.\nFigure 401 Outside-to-Outside Example\nThe following figures, Figure 402, Figure 403, and Figure 404, show intersections with\ndefined angle measurements.\nFigure 402 Defined Angle Measurement: Crossing Point of Two Edges\nintersections()\nFigure 403 Defined Angle Measurement: Point Where the End of One Edge is Coincident\nWith the Start of Another; Edges Are Not CollinearFigure 404 Defined Angle Measurement: T Intersection That Is on the Check Side of the\nEdge; for Checking the Outside of Blue\nThe following figures, Figure 405  and Figure 406, show intersections that do not have\nangle measurements.\nFigure 405 No Angle Measurement: Collinear edges\nFigure 406 No Angle Measurement: T Intersection That Is Not on the Check Side of the Edge;\nNot for Checking the Outside of Blue\nYou specify which side of the edges of each layer is used for angle measurement, inside\nor outside. This side is the check side of the edges. The inside is always to the right of the\nedge. For example, as shown in\nFigure 407, for two arbitrary edges, the inside is always\nintersections()\non the right. See Spacing Checks  on page 3360 for more information about the check\nside.\nFigure 407 Check Side", "syntax": "intersections (\nlayer1           = data_layer,\nlayer2           = data_layer,\nlayer1_side     = OUTSIDE | INSIDE,\nlayer2_side      = OUTSIDE | INSIDE,\nangles          = {doubleconstraint, ...},\nshape           = TRIANGLE | EXTENTS | DIAMOND | SQUARE,    //optional\nshape_size      = double,                                   //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "layer1_side": "Required. Specifies the check side of the layer1  edges.", "layer2_side": "Required. Specifies the check side of the layer2  edges.\nintersections()", "angles": "Required. Specifies the angles that determine the intersections to find. The\nangles must be greater than 0 and less than 360. A value of 180 does not match\nany intersections.", "shape": "Optional. Specifies the shape of the polygon generated at each selected\nintersection. The default is SQUARE.\n\u2022 TRIANGLE. Marks the intersection with a triangle that fills the interior of\nconvex angles and the exterior of concave angles.\n\u2022 EXTENTS. Creates extents boxes from the TRIANGLE  shapes.\n\u2022 DIAMOND. Marks the intersection with a diamond that is centered.\n\u2022 SQUARE. Marks the intersection with a square that is centered.", "shape_size": "Optional. Specifies the size of the output squares. The value must be positive.\nThe default is DRC_ERROR_BOX, which has a default of 0.1.\n\u2022 When the shape is SQUARE  or DIAMOND, the value is rounded to the\nnearest even multiple of the internal resolution, with a minimum of twice\nthe internal resolution. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution.\n\u2022 Otherwise, the value is rounded to the nearest internal resolution unit, with a\nminimum of one internal resolution unit.\n\u2022 When the shape is TRIANGLE, the sides of the shape coincident with the\ninput edges are not longer than the edges forming the intersection.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nintersections()"}, "summary": "The intersections()  function creates polygons that represent the specified intersections\nwith the specified output format.", "function_name": "intersections()"}
{"description": "The intersections_edge()  function creates edges that represent the specified\nintersections. Each intersection between the layer1  edges and the layer2  edges is\ncompared to the angle list. Intersections includes endpoints. Collinear edges do not match\nany angle specifications. See the examples for the\nintersections()  function for more\ninformation.", "syntax": "intersections_edge (\nlayer1           = data_layer,\nlayer2           = data_layer,\nlayer1_side     = OUTSIDE | INSIDE,\nlayer2_side      = OUTSIDE | INSIDE,\nangles          = {doubleconstraint, ...},\noutput_layer    = LAYER1 | LAYER2,                          //optional\nshape_size      = double,                                   //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "layer1_side": "Required. Specifies the check side of the layer1  edges.", "layer2_side": "Required. Specifies the check side of the layer2  edges.", "angles": "Required. Specifies the angles that determine the intersections to find. The\nangles must be greater than 0 and less than 360. A value of 180 does not match\nany intersections.\nintersections_edge()", "output_layer": "Optional. Specifies the layer whose edges are output for the violations. The\ndefault is LAYER1.\n\u2022 LAYER1. Outputs only layer1 edges.\n\u2022 LAYER2. Outputs only layer2 edges are output.", "shape_size": "Optional. Specifies the maximum length of the output edges. The value must be\npositive. The default is DRC_ERROR_BOX, which has a default of 0.1. The value\nis rounded to the nearest internal resolution unit, with a minimum of one internal\nresolution unit.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The intersections_edge()  function creates edges that represent the specified\nintersections.", "function_name": "intersections_edge()"}
{"description": "The label_text()  function creates a text layer that contains text strings for any probe\nlayer polygon that edge touches or overlaps a connect layer polygon. A point touch is not\nconsidered an interaction. The text is placed at an arbitrary location on the probe polygon.\nEach text string consists of the path to the connect layer net from the top cell of the design\nand the net name. The created text layer can be attached to a probe layer with net names\nby connecting and texting the probe layer.\nThe probe layer must be in the top cell. Any probe layer that is not in the top cell is\nignored. If the probe layer interacts with more than one connect polygon that has text at\nthe same level, the results are arbitrary.\nAn error occurs if a connect layer is already texted but text opens are ignored by the\nsetting the opens  argument of the text_net()function to IGNORE.\nA text file can be written to any output layout database, such as GDSII and Milkyway.\nUntexted nets use the net prefix specified in the\ntext_options()  function.", "syntax": "label_text(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\nconnect_sequence  = connect_database,\ninclude_path      = true  | false,      //optional\nuse_text          = UPPER | LOWER,     //optional\nname             = \"layer_label\"      //optional\n);", "returns": "text layer", "arguments": {"layer1": "Required. Specifies the probe layer.", "layer2": "Required. Specifies the connect layer.", "connect_sequence": "Required. Specifies the connect database that contains layer2, the connect\nlayer.\nlabel_text()", "include_path": "Optional. Specifies if the created text string includes the full path to the net. The\ndefault is true.\n\u2022 true. Specifies that the text string has the full path to the net.\n\u2022 false. Specifies that the text string has only the net name.", "use_text": "Optional. Specifies from where the text is selected. This argument is used only\nwhen a probe layer interacts more than one physical polygon on the same net.\nThe default is LOWER.\n\u2022 UPPER. Acquires the text from the highest polygon in the net that has direct\ninteraction with the probe layer.\n\u2022 LOWER. Acquires the net name from the lowest interacting probe polygon,\neven if the polygon is not texted.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The label_text()  function creates a text layer that contains text strings for any probe\nlayer polygon that edge touches or overlaps a connect layer polygon.", "function_name": "label_text()"}
{"description": "The layer_extent()  function creates a polygon layer consisting of a single rectangle\nin the top cell that is equal to the extents of the input layer in the top cell and all its\nplacements. The top cell is defined by the\nlibrary()  function.", "syntax": "layer_extent(\nlayer1 = data_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The layer_extent()  function creates a polygon layer consisting of a single rectangle\nin the top cell that is equal to the extents of the input layer in the top cell and all its\nplacements.", "function_name": "layer_extent()"}
{"description": "The layer_extent_list()  function creates a polygon layer consisting of a single\nrectangle in the top cell that is equal to the extents of the input layers in the top cell and all\nits placements. The top cell is defined by the\nlibrary()  function.", "syntax": "layer_extent_list(\nlayers = {data_layer, ...},\nname   = \"layer_label\"        //optional\n);", "returns": "polygon layer", "arguments": {"layers": "Required. Specifies the edge and polygon layers.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The layer_extent_list()  function creates a polygon layer consisting of a single\nrectangle in the top cell that is equal to the extents of the input layers in the top cell and all\nits placements.", "function_name": "layer_extent_list()"}
{"description": "The layer_statistics()  function reports statistics of the input layer. Use this function for\ndebugging purposes.", "syntax": "layer_statistics(\nlayer1     = data_layer,\nfile       = layer_statistics_file_handle,  //optional\nmode       = OVERWRITE  | APPEND,            //optional\nuser_input  = \"string\"                       //optional\n);", "returns": "void", "arguments": {"layer1": "Required. Reports statistics for this data layer.", "file": "Optional. Writes statistics to this file. The file is defined using the\nlayer_statistics_file()  function. By default, the IC Validator tool writes the\nstatistics to the summary file (cell.sum) and to the screen when the -verbose\noption is used. Table 42  lists the reported statistics.\nTable 42 Statistics Reported for the Specified Layer\nStatistic Definition\nHierarchical levels Number of levels\nUnique cells Number of unique cells\nHierarchical", "placements": "Total number of references in each array reference at each hierarchical", "level": "Hierarchical\nRECTANGLE\nNumber of rectangles in each cell\nHierarchical\nPOLYGONS\nNumber of nonrectangular polygons in each cell\nTotal data coverage Fraction of the top-cell area covered by this layer reported as a", "percentage": "Group file size Size of the group file\nHighest TRAP count in\na polygon\nHighest trapezoid count found in a polygon\nHighest cell level\nTRAP count\nHighest trapezoid count found in a cell\nHighest cell level\nDATA count\nHighest count of data primitives found in a cell\nHighest cell level\nPLACEMENT count\nHighest placement count found in a cell. Cell placements are counted\nif the cell contains the specified layer anywhere in its hierarchy. If a\nplacement is an AREF, the number of references in the array at the first\nhierarchical level is counted.\nThe total sum of\npolygon perimeter\nSum of the perimeters of all polygons in microns\nlayer_statistics()\nTable 42 Statistics Reported for the Specified Layer  (Continued)\nStatistic Definition\nThe total sum of\npolygon area\nSum of the areas of all polygons in square microns", "mode": "Optional. Specifies the action for when the statistics file already exists. The\ndefault is OVERWRITE.\n\u2022 OVERWRITE. Overwrites the previous statistics file.\n\u2022 APPEND. Appends the new data to the previous statistics file.", "user_input": "Optional. Specifies a user comment. This comment is written to the file specified\nby the file  argument or to the summary file (cell.sum)."}, "summary": "The layer_statistics()  function reports statistics of the input layer.", "function_name": "layer_statistics()"}
{"description": "The layer_statistics_file()  function defines a layer statistics file. This file is specified\nin the file  argument of the\nlayer_statistics()  function\nNote:\nThe layer_statistics_file()  function cannot be called more than one\ntime with the same file  argument. The result can be used in more than one\nlayer_statistics()  function.", "syntax": "layer_statistics_file(\nfile = \"string\"\n);", "returns": "layer_statistics_file_handle\nlayer_statistics_file_handle", "arguments": {"file": "Required. Specifies the layer statistics file name. See the\nlayer_statistics()\nfunction for more information."}, "summary": "The layer_statistics_file()  function defines a layer statistics file.", "function_name": "layer_statistics_file()"}
{"description": "The layout_drawn_options()  function specifies criteria for checking and, where\nappropriate, correction of various invalid layout data. (Problems with drawn data is\ncorrected automatically whenever possible.) If this function is not in the runset, it is\nautomatically invoked with the default values. This function can be called only one time in\na runset.\nThis checking occurs only on layers specified in assign functions, such as assign()\nor assign_edge(). When a runset is optimized, unused assign layers are pruned and,\ntherefore, are not checked for invalid data.\nErrors are reported to the LAYOUT_ERRORS file with the tag layout_drawn_errors. The\nerrors appear as an X in VUE.", "syntax": "layout_drawn_options(\nbacktracking_points   = true | false,                       //optional\ncollinear_points      = true | false,                       //optional\nduplicate_placements  = true | false,                       //optional\nduplicate_points      = true | false,                       //optional\npath_check            = CENTERLINE | BOUNDARY,              //optional\npath_length           = true | false,                       //optional\npath_length_end       = true | false,                       //optional\npath_invalid_styles   = {SQUARE, ROUND, SQUARE_EXTENDED,\nCUSTOM},                           //optional\nscaled_instances      = true | false,                       //optional\nself_intersect        = true | false,                       //optional\nself_intersect_action = EMPTY  | FILL,                       //optional\nzero_area             = true | false,                       //optional\nzero_path             = true | false,                       //optional\nzero_segment          = true | false                        //optional\n);", "returns": "void", "arguments": {"backtracking_points": "Optional. Specifies if backtracking points are reported. When set to true, these\npoints are reported. (A backtrack point is the second point in a sequence of\nthree points in a polygon boundary where the first and third points are identical.)\nThe default is false.\nlayout_drawn_options()", "collinear_points": "Optional. Specifies if collinear polygon points are reported. When set to true,\nthese points are reported. (A collinear polygon point is a point that is collinear\nwith the preceding and following points on a straight edge of a boundary.) The\ndefault is false.", "duplicate_placements": "Optional. Specifies if duplicate instance placements of a child cell within a cell\nare reported. When set to true, these placements are reported. The default is\nfalse.", "duplicate_points": "Optional. Specifies if duplicate polygon points are reported. When set to true,\nthese points are reported. (Duplicate polygon points are a series of identical\npoints along a boundary.) The default is false.", "path_check": "Optional. Specifies which feature of a path is checked. The default is BOUNDARY.\n\u2022 BOUNDARY. Specifies that the resulting boundary, after path expansion, is\nchecked for violations in accordance with the other argument settings.\n\u2022 CENTERLINE. Specifies that only the centerline of the path, before path\nexpansion, is checked for violations in accordance with the other argument\nsettings.\nFor example, a path is drawn in the shape of a P. When the path is converted\ninto a polygon, it intersects where the end of the path curls in upon itself.\nThe IC Validator tool does not report this intersection as a self-intersection;\nit reports errors in the LAYOUT_ERRORS file only for path centerlines that\nactually cross each other. Path centerlines are also checked for duplicate,\ncollinear, and backtracking points when the backtracking_points,\ncollinear_points, and duplicate_placements  arguments are set to\ntrue.", "path_length": "Optional. Specifies if a segment of a path that has a length less than one-half\nof the path width is a violation. When set to true, any segment of a path that\nhas a length less than one-half of the path width is a violation. All path types are\nchecked. The default is false.", "path_length_end": "Optional. Specifies if the first or last segment of a path that has a length less\nthan one-half of the path width and that would remove material is a violation.\nWhen set to true, the first or last segment of a path that has a length less than\nlayout_drawn_options()\none-half of the path width and that would remove material is a violation. The\ndefault is false.\nNote:\nThe GDSII path types 0 and 1 that do not have an extension larger\nthan one-half of the path width can remove material.\nUse the path_length  argument to check all segments of a path. Single-\nsegment paths are not checked by the path_length_end  argument.", "path_invalid_styles": "Optional. Reports paths that have any of the following specified styles. By\ndefault, the IC Validator tool does not report paths.\nThe styles are:\n\u2022 SQUARE\n\u2022 ROUND\n\u2022 SQUARE_EXTENDED\n\u2022 CUSTOM", "scaled_instances": "Optional. Specifies if scaled instances are reported. When set to true, these\ninstances are reported. The default is false.", "self_intersect": "Optional. Controls the reporting of self-intersecting polygons. The default is\nfalse.\n\u2022 true. Reports all self-intersecting polygons.\n\u2022 false. Does not report self-intersecting polygons unless the IC Validator tool\ncannot form a closed boundary with the points given.\nA self-intersecting polygon is a polygon with edges that cross each other. Edges\nthat simply touch are not self-intersecting. A self-intersecting polygon can also\nbe a polygon with edges that cross in such a way that it appears as a polygon is\nwithin a polygon.\nFigure 415  shows examples of self-intersecting polygons.\nlayout_drawn_options()\nFigure 415 Examples of Self-Intersecting Polygons\nThe IC Validator tool always attempts to create a closed boundary\nfrom every self-intersecting polygon, according to the setting of the\nself_intersect_action  argument.", "self_intersect_action": "Optional. Specifies whether an area of self-intersection is filled. The default is\nEMPTY.\n\u2022 EMPTY. Specifies that the area of self-intersection is left as an empty area\nwithin the polygon.\n\u2022 FILL. Specifies that the area of self-intersection is filled within the polygon.\nThis argument affects only polygons. Areas of self-intersection in paths are\nalways filled, as shown in\nFigure 416.\nFigure 416 Areas of Self-Intersecting Polygons", "zero_area": "Optional. Specifies if zero-area polygons are reported. When set to true, these\npolygons are reported. The default is false.", "zero_path": "Optional. Specifies if paths with assigned widths of 0 are reported. When set to\ntrue, these paths are reported. The default is false.\nFigure 417  shows a zero width path.\nlayout_drawn_options()\nFigure 417 Example of Zero Width Path", "zero_segment": "Optional. Specifies if any part of a polygon that is a line segment or a zero width\nsegment is a violation. When set to true, if any part of a polygon is effectively a\nline segment or a zero width segment, a violation occurs. The default is false.\nFigure 418  shows a zero width segment within a polygon.\nFigure 418 Examples of Zero Width Path Within a Polygon"}, "summary": "The layout_drawn_options()  function specifies criteria for checking and, where\nappropriate, correction of various invalid layout data.", "function_name": "layout_drawn_options()"}
{"description": "The layout_integrity_by_cell()  function checks the specified cells against the layout\nintegrity databases (LIDBs) specified in the layout_integrity_options()  function.\nMultiple checksums can be present in the LIDBs listed for any given design cell. A design\ncell is considered a match if its calculated checksums match any set of checksums for a\ncell of the same name in any input LIDB specified in the layout_integrity_options()\nfunction.\nNote:\nAlthough the layout_integrity_by_cell()  function executes a check on the\ndesign, because the check occurs while reading the layout, this function must\nappear in the OPTIONS section and before assign functions.", "syntax": "layout_integrity_by_cell(\ncells               = {\"string\", ...},\nintegrity_mismatch  = REPORT  | ABORT,                        //optional\nprocessing_mode     = CELL_LEVEL  | HIERARCHICAL              //optional\n);", "returns": "void", "arguments": {"cells": "Required. Specifies the cells to check. If a design cell specified in this list exists\nin any LIDB specified in the layout_integrity_options()  function, the\nchecksum values are calculated and compared against cells of the same name\nin the LIDB list. String matching using metacharacters is allowed. See\nString\nMatching  on page 3353 for more information.", "integrity_mismatch": "Optional. Specifies whether to terminate the IC Validator tool if a cell is checked\nand fails to match any set of checksums in the LIDB list. The default is REPORT:\nThe IC Validator tool reports the mismatch in the LAYOUT_ERRORS file and\ncontinues to run.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is CELL_LEVEL.\nlayout_integrity_by_cell()\n\u2022 CELL_LEVEL. Checks cells that match the cell name list; children in the\nhierarchy of the cell are not checked, but placements within the cell are\nchecked. The cell names of the child cells in the layout must match the\nchild cell names in the LIDB, or a cell name map must be used in the LIDB\nspecification of the layout_integrity_options()  function. CELL_LEVEL\nmode does not look down the hierarchy. Therefore, while the placements\nwithin the parent cell are checked, the contents of the child cells do not\ncontribute to the outcome of a CELL_LEVEL  check on the parent cell.\n\u2022 HIERARCHICAL. Checks cells that match the cell name list; all children in the\nhierarchy of the cell are also checked. Any layout integrity mismatch in a\nchild cell is reported in all parent modules that match the cell name list. It\nis not necessary for child cell names under the layout cell with the marker\nlayer polygon to match the child cell names in the LIDB, as the child cells are\nmatched based on their contents."}, "summary": "The layout_integrity_by_cell()  function checks the specified cells against the layout\nintegrity databases (LIDBs) specified in the layout_integrity_options()  function.", "function_name": "layout_integrity_by_cell()"}
{"description": "The layout_integrity_by_marker_layer()  function checks any design cell containing\ndata on the specified marker layer against the layout integrity databases (LIDBs) specified\nin the layout_integrity_options()  function. A design cell is considered a match if\nits calculated checksums match any set of checksums for a cell with data present on the\nmarker layer in any input LIDB specified in the layout_integrity_options()  function.\nNote:\nAlthough the layout_integrity_by_marker_layer()  function executes a\ncheck on the design, because the check occurs while reading the layout, this\nfunction must appear in the OPTIONS section and before assign functions.", "syntax": "layout_integrity_by_marker_layer(\nmarker_layer         = {layer_num = integer, data_type = integer},\n//optional\nmarker_layer_purpose = {layer_name    = \"string\",\npurpose_name  = \"string\"},          //optional\nintegrity_mismatch    = REPORT  | ABORT,                      //optional\ncheck_layers         = {{layer_num_range = integerconstraint,\ndata_type_range = integerconstraint},\n...},                               //optional\ncheck_layer_purposes  = {{layer_names   = {\"string\", ...},\npurpose_names = {\"string\", ...}},\n...},                               //optional\nprocessing_mode       = CELL_LEVEL  | HIERARCHICAL            //optional\n);", "returns": "void", "arguments": {"marker_layer": "Optional. Specifies the layer and datatype of the marker layer. Either the\nmarker_layer  or marker_layer_purpose  argument is required. The default\nof the data_type  option is 0. See\nLayout Layer and Datatype Ranges  on\npage 3347 for information about the limits of the values.", "marker_layer_purpose": "Optional. Specifies the layer and purpose name of the marker layer, for\nOpenAccess input layouts. Either the marker_layer  or marker_layer_purpose\nargument is required.\nlayout_integrity_by_marker_layer()", "integrity_mismatch": "Optional. Specifies whether to terminate the IC Validator tool if a cell is checked\nand fails to match any set of checksums in the LIDB list. The default is REPORT:\nThe IC Validator tool reports the mismatch in the LAYOUT_ERRORS file and\ncontinues to run.", "check_layers": "Optional. Lists the layer range and datatype range pairs that determine which\nlayers to compare against checksum entries in the LIDB. If this list is specified,\nonly mismatches on those layers count as a cell mismatch. By default, the IC\nValidator tool checks all layers in each cell. See\nLayout Layer and Datatype\nRanges  for information about the limits of the values.", "check_layer_purposes": "Optional. Lists the layer name and purpose name pairs that determine which\nlayers to compare against checksum entries in the LIDB for OpenAccess\nlayouts. If this list is specified, only mismatches on those layers count as a cell\nmismatch. By default, the IC Validator tool checks all layers in each cell.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is CELL_LEVEL.\n\u2022 CELL_LEVEL. Checks cells with a marker layer polygon without regard to\nchildren in the hierarchy, but placements within the cell are checked. The\ncell names of the child cells in the layout must match the child cell names in\nthe LIDB, or a cell name map must be used in the LIDB specification of the\nlayout_integrity_options()  function. CELL_LEVEL  mode does not look\ndown the hierarchy. Therefore, while the placements within the parent cell\nare checked, the contents of the child cells do not contribute to the outcome\nof a CELL_LEVEL  check on the parent cell.\n\u2022 HIERARCHICAL. Checks cells with a marker layer polygon; all children in the\nhierarchy are also checked. Any layout integrity mismatch in a child cell is\nreported in all parent modules that contain a marker layer. It is not necessary\nfor child cell names under the layout cell with the marker layer polygon to\nmatch the child cell names in the LIDB, as the child cells are matched based\non their contents."}, "summary": "The layout_integrity_by_marker_layer()  function checks any design cell containing\ndata on the specified marker layer against the layout integrity databases (LIDBs) specified\nin the layout_integrity_options()  function.", "function_name": "layout_integrity_by_marker_layer()"}
{"description": "The layout_integrity_options()  function specifies which layout integrity databases\n(LIDBs) should be used for checking cells in the design. The databases are searched in\norder for a matching cell. Use the icv_lidb utility to generate and manage layout integrity\ndatabases.\nNote:\nFor the mixed Milkyway and GDSII flow, each replacement library has its own\nlist of layout integrity databases. In this flow, only Milkyway cells are matched\nagainst the database list specified in the layout_integrity_options()\nfunction.", "syntax": "layout_integrity_options(\ndatabases  = {{db_name       = \"string\",\nmissing_db    = = ABORT  | IGNORE,              //optional\ncell_name_map = {{search_string  = \"string\",\nreplace_string = \"string\"},...},\n...}                          //optional\n);", "returns": "void", "arguments": {"databases": "Optional. Specifies the list of layout integrity databases that the IC Validator\ntool uses for layout integrity checking. By default, the IC Validator tool does not\ncheck layout integrity.\n\u2022 db_name. Required. Specifies the path to the layout integrity database.\n\u2022 missing_db. Optional. Specifies the behavior when the IC Validator tool\ndoes not find the specified layout integrity database. By default, the IC\nValidator tool terminates with an error.\n\u25e6 ABORT. Specifies that the run stops when the layout integrity database is\nnot found.\n\u25e6 IGNORE. Continues the IC Validator run if the tool cannot find the layout\nintegrity database.\nlayout_integrity_options()\n\u2022 cell_name_map. Optional. Specifies lists that tells how cell names are\nremapped as data is read from the LIDB. By default, the IC Validator tool\ndoes not remap cell names.\n\u25e6 search_string. Required. Specifies the existing cell name in the input\nLIDB.\n\u25e6 replace_string. Required. Specifies the cell name used for layout\nintegrity checking within IC Validator."}, "summary": "The layout_integrity_options()  function specifies which layout integrity databases\n(LIDBs) should be used for checking cells in the design.", "function_name": "layout_integrity_options()"}
{"description": "The layout_overlap()  function creates a polygon layer from the overlapping areas of the\ninput layer. The input layer, produced by the assign_layout()  function, is a special layer\ntype with limited use. It represents the original layout polygons before any merging. The\noperation includes cell-level and hierarchical overlap.", "syntax": "layout_overlap(\nlayer1          = layout_layer,\ncount           = integer_constraint,       //optional\nname            = \"layer_label\"             //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the layout layer.", "count": "Optional. Specifies the overlapping count required for an area to be selected.\nSee\nConstraints  for more information. The default is >1.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The layout_overlap()  function creates a polygon layer from the overlapping areas of the\ninput layer.", "function_name": "layout_overlap()"}
{"description": "The layout_text_to_net_property()  applies the layout text to the specified layers\nin the connect database to produce a text property that is not affected by hierarchy. The\nhierarchical levels of the layout text are determined by the original layout hierarchy, not\nthe optimized internal hierarchy. Internal hierarchy operations such as user and automatic\ncell exploding do not delete layout text from these layers. Text can be deleted by explicitly\nspecifying assign_text(delete_text={...})  or text_options(delete_text={...})\nThe behavior of this function is always processed as text_net(attach_text=ALL),\nas it must output a new connect database because connectivity might change. The\nnet_select()  and net_texted_with()  functions can take a text property from this\nfunction by using the text_property, text_property_with, and text_property_at\narguments to select nets.", "syntax": "layout_text_to_net_property(\nconnect_sequence   = connect_database,\ntext_layer_items   = {{layer = polygon_layer,\ntext_layer = text_layer}, ...},\nuse_text           = {HIGHEST, ALL, TOP_CELL},\ntext_priority_list  = {\"string\", ...}\n); returning text_to_net_property_result : unique connect_database;", "returns": "void", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "text_layer_items": "Required. Lists the polygon layer and text layer pairs. Text whose origin interacts\nwith polygons in the associated layer is applied to the net containing the\npolygon. The layers must be in the specified connect database. By default, no\nlayers are texted by text layer.\n\u2022 layer. Specifies the polygon layer.\n\u2022 text_layer. Specifies the text layer.\nlayout_text_to_net_property()", "use_text": "Required. Specifies the polygon and text layer pins. Text whose origin interacts\nwith polygons in the associated layer is applied to the net containing the\npolygon. The layers must be specified in the connect database.\n\u2022 HIGHEST. Uses the highest hierarchical-level text on the net to generate the\ntext_property.\n\u2022 ALL. Uses all hierarchical-level text on the net to generate the text property.\n\u2022 TOP_CELL. Uses text in the top cell to generate text property nets.", "text_priority_list": "Optional. Lists the strings that prioritize the selection of multiple text properties\non the same net. Here, the net position honors error hierarchy, and not original\nhierarchy.\n\u2022 text. Specifies priority strings. The default is to sort by alphabetical order.\nFor texts on the same net, this argument chooses only one to keep, according\nthe following priority:\n\u2022 power/ground text\n\u2022 text_priority_list  order\n\u2022 alphabetical order"}, "summary": "The layout_text_to_net_property()  applies the layout text to the specified layers\nin the connect database to produce a text property that is not affected by hierarchy.", "function_name": "layout_text_to_net_property()"}
{"description": "The length_edge()  function selects edges based on their length. The complement of this\nfunction is the not_length_edge()  function.", "syntax": "length_edge(\nlayer1          = data_layer,\ndistance        = doubleconstraint,\ncorners         = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_length_edge(\nlayer1          = data_layer,\ndistance        = doubleconstraint,\ncorners         = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "distance": "Required. Length specification.\nFigure 421  shows the effect of the distance  argument setting with the\nlength_edge()  function.\nlength_edge() and not_length_edge()\nFigure 421 distance Argument Example With the length_edge() Function", "corners": "Optional. The processing at corners. The default is IGNORE.\n\u2022 CONNECT. Connects the edges at corners, measuring the entire length.\n\u25e6 For polygon layers, this processing is a perimeter check.\n\u25e6 For edge layers, a corner is a point where the start of exactly one edge\nis coincident with the end of exactly one edge, and the edges are not\ncollinear.\n\u2022 IGNORE. Ignores the corners; edges are measured individually.\nFigure 422  shows the effect of the corners  argument setting with the\nlength_edge()  function. The distance  argument is >4.\nlength_edge() and not_length_edge()\nFigure 422 corners Argument Example With the length_edge() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The length_edge()  function selects edges based on their length.", "function_name": "not_length_edge()"}
{"description": "The length_edge()  function selects edges based on their length. The complement of this\nfunction is the not_length_edge()  function.", "syntax": "length_edge(\nlayer1          = data_layer,\ndistance        = doubleconstraint,\ncorners         = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_length_edge(\nlayer1          = data_layer,\ndistance        = doubleconstraint,\ncorners         = CONNECT | IGNORE,           //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which edges are selected.", "distance": "Required. Length specification.\nFigure 421  shows the effect of the distance  argument setting with the\nlength_edge()  function.\nlength_edge() and not_length_edge()\nFigure 421 distance Argument Example With the length_edge() Function", "corners": "Optional. The processing at corners. The default is IGNORE.\n\u2022 CONNECT. Connects the edges at corners, measuring the entire length.\n\u25e6 For polygon layers, this processing is a perimeter check.\n\u25e6 For edge layers, a corner is a point where the start of exactly one edge\nis coincident with the end of exactly one edge, and the edges are not\ncollinear.\n\u2022 IGNORE. Ignores the corners; edges are measured individually.\nFigure 422  shows the effect of the corners  argument setting with the\nlength_edge()  function. The distance  argument is >4.\nlength_edge() and not_length_edge()\nFigure 422 corners Argument Example With the length_edge() Function", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The length_edge()  function selects edges based on their length.", "function_name": "length_edge()"}
{"description": "The level()  function creates a copy of the input layer, where hierarchically interacting\ndata is moved up to a common point in the hierarchy. The interaction is limited to overlap\nand abutment.", "syntax": "level(\nlayer1                 = polygon_layer,\nallow_duplicate_output  = true | false,   //optional\nname                   = \"layer_label\"   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "allow_duplicate_output": "Optional. Specifies how the level()  function processes data with duplicate\nshapes. The default is false.\n\u2022 true. Keeps duplicate shapes that are in different cells, or placements of\nthe same cell, rather than leveling the shapes to the common parent and\nmerging one away. Setting the allow_duplicate_output  argument to true\ncan help IC Validator performance when there are multiple duplicate shapes\nthroughout the hierarchy. For example, performance is helped for vias where\neach placement of a cell has an exact overlapping column or row of vias with\nthe previous placement.\n\u2022 false. Does not keep duplicate shapes.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The level()  function creates a copy of the input layer, where hierarchically interacting\ndata is moved up to a common point in the hierarchy.", "function_name": "level()"}
{"description": "The level_edge()  function creates a copy of the input layer, where hierarchically\ninteracting data is moved up to a common point in the hierarchy. For edge layers, any\ninteraction (including point touch) is considered a hierarchical interaction.", "syntax": "level_edge(\nlayer1 = edge_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The level_edge()  function creates a copy of the input layer, where hierarchically\ninteracting data is moved up to a common point in the hierarchy.", "function_name": "level_edge()"}
{"description": "The level_to()  function creates a copy of the layer1  polygon layer where data\nthat is hierarchically interacting with data in the layer2  data layer is moved up to a\ncommon point in the hierarchy. It also moves hierarchically interacting data within the\nlayer1  polygon layer to a common point. If both layers are polygon data, the definition\nof interacting is limited to overlap and abutment. When layer2  is an edge layer, any\ninteraction, including point touch, is considered a hierarchical interaction.", "syntax": "level_to(\nlayer1 = polygon_layer,\nlayer2 = data_layer,\nname   = \"layer_label\"   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is leveled.", "layer2": "Required. Specifies the data layer to which the layer1  polygon layer is leveled.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The level_to()  function creates a copy of the layer1  polygon layer where data\nthat is hierarchically interacting with data in the layer2  data layer is moved up to a\ncommon point in the hierarchy.", "function_name": "level_to()"}
{"description": "The level_to_edge()  function creates a copy of layer1  where data that is hierarchically\ninteracting with layer2  data is moved up to a common point in the hierarchy. It also moves\nhierarchically interacting data within the layer1  layer to a common point. For edge layers,\nany interaction (including point touch) is considered a hierarchical interaction.", "syntax": "level_to_edge(\nlayer1 = edge_layer,\nlayer2 = data_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer that is leveled.", "layer2": "Required. Specifies the edge or polygon layer to which the layer1  edge layer is\nleveled.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The level_to_edge()  function creates a copy of layer1  where data that is hierarchically\ninteracting with layer2  data is moved up to a common point in the hierarchy.", "function_name": "level_to_edge()"}
{"description": "The library()  function registers a library for other functions, such as the assign()\nfunction. You must use the appropriate arguments of the library()  function for each\ninput layout format. Otherwise, the input layout file is not found and the run ends with an\nerror.\nThe library()  function defines the design library. Call it before calling assign functions.\nIf you are importing additional libraries, as opposed to merging additional libraries into\nthe main library using the merge_libraries  argument, also call the\nlibrary_import()\nfunction in the OPTIONS section of the runset.\nNote:\nA runset cannot call both the library()  and the library_create()  functions,\nand neither can be called more than one time.", "syntax": "library(\nlibrary_name            = \"string\",\nformat                  = GDSII | OASIS | MILKYWAY | OPENACCESS |\nNDM | AUTO,\ncell                    = \"string\",\nlibrary_path            = \"string\",                         //optional\nlibrary_definition_file = \"string\",                         //optional\nmagnification_factor    = double,                           //optional\nmerge_libraries        = {{library_name = \"string\",\nformat = GDSII | OASIS,\nlayer_map_file = \"string\"}, ...}, //optional\ngolden_libraries       = {{library_name = \"string\",\nformat = GDSII | OASIS}, ...},    //optional\nadd_shapes             = {\"string\", ...},                    //optional\nadd_shape_files        = {\"string\", ...}                     //optional\n);", "returns": "library or void\nThe library()  function does not return a value when the merge_libraries  argument is\nused.", "arguments": {"library_name": "Required. Specifies the path and file name for GDSII and OASIS formats; library\nname for Milkyway, NDM, and OpenAccess formats.\nlibrary()\nNote:\nThe -i  command-line option overrides this name. See the Command-\nLine Options section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.\nA GDSII or OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool automatically\ndetects if a GDSII or OASIS file is gzipped.", "format": "Required. Specifies the format of the input: GDSII, MILKYWAY, NDM, OASIS,\nOPENACCESS, and AUTO. See the ldt_list  argument of assign functions for\ninformation about the layer and datatype range limits.\nNote:\nThe -f  command-line option overrides this format. See the\nCommand-Line Options section in the \u201cIC Validator Basics\u201d chapter of\nthe IC Validator User Guide  for more information.\nMILKYWAY is no longer supported as an input format starting in\nX-2025.06.", "cell": "Required. Specifies the cell to be checked. This structure must be in the\nspecified library.\nNote:\nThe -c  command-line option overrides this name. See the Command-\nLine Options section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.\nBy specifying -cell \"*\"  you can run the IC Validator tool using the OASIS\nor GDSII format without specifying the top cell. The tool finds the top cell in\nthe database. If there is more than one potential top cell, the IC Validator tool\nchooses the first one it finds in the database and writes a warning message in\nthe summary file. Do not use -cell \"*\"  in these situations:\n\u2022 LVS runsets; that is, runsets with a call to the compare()  function.\n\u2022 Runsets that call the get_top_cell()  function before the end of the\nASSIGN section.\n\u2022 With the -ndg  or -C  command-line options.\n\u2022 Runsets that set the select_window  or exclude_window  argument of the\nincremental_options()  function.\n\u2022 Databases that are not in GDSII or OASIS format.\nlibrary()", "library_path": "Required when the format  argument is MILKYWAY or NDM. Specifies the path\nof the parent directory for the Milkyway or NDM library. This file is not used for\nGDSII, OASIS, or OpenAccess input.", "library_definition_file": "Required when the format  argument is OPENACCESS. Specifies the library\ndefinition file for the OpenAccess input database. This file is not used for GDSII,\nMilkyway, or OASIS input.", "magnification_factor": "Optional. Scales data as it is read in.\nmagnification factorinput data\nA magnification factor between 0.0 and\nless than 1.0 shrinks data. A magnification factor greater than 1.0 enlarges data.\nThe default is 1.0  (no magnification).", "merge_libraries": "Optional. Specifies a list of the libraries that are merged.\nmerge librarieslibraries, merging\nThe merge_libraries\nargument supports only the GDSII and OASIS formats, and all libraries must\nhave the same format as the main library. Cells with the same name are\nmerged. The library()  function does not return a value when using the\nmerge_libraries  argument.\nNote:\nThe -i  command-line option overrides this list. See the Command-\nLine Options section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.\n\u2022 library_name\nRequired. Specifies the path and file name for GDSII and OASIS formats.\n\u2022 format\nRequired. Specifies the format of the library: GDSII  or OASIS. This format\nmust be the same as the main library format.\n\u2022 layer_map_file\nOptional. Specifies the layer mapping file for this library. The file format is:\nDstLayer[:DstDatatype] SrcLayer[:SrcDatatype]\nComments are specified with a semicolon. All text following the semicolon on\nthe current line is part of the comment.\nFor example, to map layer 5 to layer 35, datatype 2\n35:2 5\nlibrary()", "golden_libraries": "golden libraries\ngeometry-match flow\ngeometric matches\nOptional. Specifies a list of \u201cgolden\u201d libraries that the IC Validator tool can use\nwhen performing geometric matches to determine which cells to select in the\nassign()  function. The golden_libraries  argument supports only the GDSII\nand OASIS formats.\n\u2022 library_name. Required. Specifies the path and file name for a GDSII and\nOASIS format library.\n\u2022 format. Required. Specifies the format of the library: GDSII  or OASIS. This\nformat must be the same as the main library format.\nNote:\nThe\nlibrary_import()  function is not supported when this\ngeometry-match flow is active.", "add_shapes": "Optional. Specifies a list of shapes to add to specified cells when reading the\ninput libraries, including the golden library. If a cell from an add shape string\ndoes not exist in any of the input libraries, the IC Validator tool issues a warning\nmessage in the dp.log file.\nThe add_shapes  argument has a few restrictions. This argument:\n\u2022 Supports only the GDSII and OASIS file formats. All other input library\nformats cause an error at the beginning of the IC Validator run.\n\u2022 Cannot be used with the\nlibrary_import()  or library()  function when it\nreturns a value. The library()  function returns a value in runsets when it is\nused with the library_import()  function.\n\u2022 VUE overlays errors over the input layout which does not contain these\nshapes.\nThe add_shapes  argument has the following behaviors:\n\u2022 A warning message is issued if there are no corresponding cells in the input\nlibraries for the shape being added.\n\u2022 Layer mapping is applied to the added shapes.\n\u2022 The //  is treated as a comment and everything after //  is ignored except for\nthe following cases.\nlibrary()\n\u25e6 If the //  is within square brackets [], which is for text content in shape\nfiles.\n\u25e6 If the //  is within double quotation, which is for cell name in shape files.\nFormat of add shapes strings\nThe first element in the string indicates the type of shape being added. The\ntype of shape being added dictates the remaining elements in the string. The\nelements are separated by a space.\nAdding polygons\nThe format for adding polygons is as follows:\nField Field Type Description\nType string Required. Type of shape being added. Use P for polygons.\nNumber of Vertices integer Required. Number of vertices that follow. 2 can be used to\nrepresent the lower-left and upper-right of a rectangle.\nVertices float Required. List of x and y values representing vertices.\nLayer integer Required. Layer number of shape being added.\nDatatype integer Optional. Datatype number of shape being added. Defaults to 0 if\nnot provided.\nCell string Optional. Cell name to add shapes. Defaults to top cell if not\nprovided."}, "summary": "The library()  function registers a library for other functions, such as the assign()\nfunction.", "function_name": "library()"}
{"description": "Type string Required. Type of shape being added. Use ET for edtext.\nText string Required. Text to add inside square brackets, it can contain\nspaces.\nVertex float Required. x and y value for text location.\nLayer integer Required. Layer number of shape being added.\nDatat\nype\ninteger Optional. Datatype number of text being added. Defaults to 0 if\nnot provided.\nCell string Optional. Cell name to add text. Defaults to top cell if not\nprovided.", "summary": "Type string Required.", "function_name": "text_options()", "syntax": "", "returns": "", "arguments": {}}
{"description": "The library_create()  function creates a one-cell library that has no data. This library is\ninternal to the IC Validator tool to be used during the run. This function allows you to create\na top-level holding cell. Each library_import()  function call places its top cell under the\nholding cell.\nNote:\nA runset cannot call both the library()  and the library_create()  functions,\nand neither can be called more than one time.", "syntax": "library_create(\ncell                  = \"string\"\n);", "returns": "void", "arguments": {"cell": "Required. Names the cell."}, "summary": "The library_create()  function creates a one-cell library that has no data.", "function_name": "library_create()"}
{"description": "The library_import()  function reads in the specified library and places its top cell under\nthe top cell of the design library defined by the\nlibrary()  or library_create()  function.\nYou can call the library_import()  function multiple times in a runset. Use this function\nto\n\u2022 Read in multiple libraries and place them under a holding cell.\n\u2022 Add a fill library to a design library. The top cell of the fill library is placed under the top\ncell of the design library.\nYou can use the return value of this function and of the library()  function in assign\nfunctions.\nNote:\nIf you use the library_import()  function, you must use the libraries\nargument of an assign function that is in the runset. (The assign(),\nassign_edge(), and assign_text()  functions have a libraries  argument.\nAssign functions that support OpenAccess do not have a libraries\nargument.)", "syntax": "library_import(\nlibrary_name          = \"string\",\nformat                = GDSII | OASIS | AUTO,\ncell                  = \"string\",\nmagnification_factor  = double,            //optional\ncell_prefix            = \"string\",          //optional\napply_prefix          = LOWER_CELLS | ALL_CELLS,  //optional\nlayer_map_file        = \"string\",         //optional\nedtext                 = {{cell = \"string\",\ntext = \"string\",\nlayer_number = integer,\ndata_type = integer,\nx = double,\ny = double}, ...}, //optional\nx                     = double,           //optional\ny                     = double,           //optional\nreflection             = true | false,             //optional\nrotation               = ROTATE_0  | ROTATE_90 |\nROTATE_180 | ROTATE_270,\n//optional\nmultidie_label         = \"string\",         // optional\nmultidie_seal_ring_width   = {left=double, bottom=double,\nright=double, top=double},   //\noptional\nlibrary_import()\nmultidie_scribe_line_remaining_width  = {left=double, bottom=double,\nright=double, top=double}, //\noptional,\nadditional_placements  = {{ cell = \"string\",\nx = double,\ny = double,\nreflection = true|false,\nrotation = ROTATE_0| ROTATE_90 |\nROTATE_180 | ROTATE_270},\n{ cell = \"string\",\nx = double,\ny = double,\nreflection = true|false,\nrotation = ROTATE_0| ROTATE_90 |\nROTATE_180 | ROTATE_270},\n...\n}\n);", "returns": "library", "arguments": {"library_name": "Required. Specifies the path and file name for GDSII and OASIS formats.\nNote:\nA GDSII or OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool\nautomatically detects if a GDSII or OASIS file is gzipped.", "format": "Required. Specifies the format of the input: GDSII, OASIS, or AUTO. AUTO  auto\ndetects GDSII  or OASIS. See the ldt_list  argument of assign functions for\ninformation about the layer and datatype range limits.", "cell": "Required. Specifies the cell to be imported. This structure must be in the\nspecified library.\nBy specifying cell = \"*\"  in library_import(),you can run the IC\nValidator tool using the OASIS or GDSII format without specifying the cell in\nlibrary_import(). The tool finds the top cell as the imported cell from the\nimported library. If there is more than one potential top cell, the IC Validator tool\nchooses the first cell it finds in the library and writes a warning message in the\nsummary file.\nlibrary_import()", "magnification_factor": "Optional. Scales data as it is read in.\nmagnification factorinput data\nA magnification factor between 0.0 and\nless than 1.0 shrinks data. A magnification factor greater than 1.0 enlarges data.\nThe default is 1.0  (no magnification).", "cell_prefix": "Optional. Specifies the prefix for the cells in this library.\nNote:\nIf the runset calls the library()  function, as opposed to the\nlibrary_create()  function, then you should not use an empty\ncell_prefix  string for any of the library_import()  functions calls\nunless you know that there are no naming conflicts between any of\nthe imported libraries and the main design library specified in the\nlibrary()  function.", "apply_prefix": "Optional. Specifies if the cell_prefix  is applied to only the cells below the top\ncell or to all cells. The default is ALL_CELLS.", "layer_map_file": "Optional. Specifies the data layer mapping file for this library. The file format is:\nDstLayer[:DstDatatype] SrcLayer[:SrcDatatype]\nComments are specified with a semicolon. All text following the semicolon on\nthe current line is part of the comment.\nFor example, to map layer 4, datatype 8 to layer 43, datatype 4\n43:4 4:8", "edtext": "Optional. Lists the text objects that are added to the specified cell on the\nspecified layer number and datatype. If text already exists on the layer number\nand datatype at the xy location, it is replaced with this new text.\nAll text object properties must be specified.\n\u2022 cell. Specifies the cell name of the new text object.\n\u2022 text. Specifies the text of the new text object. See\nText Strings  on\npage 3351 for the rules apply to text strings.\n\u2022 layer_number. Specifies the layer number of the new text object. See\nLayout Layer and Datatype Ranges  on page 3347 for information about the\nlimits of the values.\nlibrary_import()\n\u2022 data_type. Specifies the datatype of the new text object. See Layout Layer\nand Datatype Ranges  on page 3347 for information about the limits of the\nvalues.\n\u2022 x. Specifies the x-coordinate of the new text object. This coordinate is scaled\nby the magnification_factor  argument of the library()  function.\n\u2022 y. Specifies the y-coordinate of the new text object. This coordinate is scaled\nby the magnification_factor  argument of the library()  function.\nNote:\nTo include an external Edtext file, use a \uff0cinclude  statement.\nPreprocessor directives, such as \uff0cinclude, must be first on a line.\nFor example,\ntext_options(\nedtext = {\n\uff0cinclude \"edtext.rs\"\n}\n);\nWhere edtext.rs is formatted to match the Edtext requirements, for\nexample:\n{ \"cell_abc\", \"VDD\", 1, 0, 3.450, 5.120 },\n{ \"cell_abc\", \"vdd\", 1, 0, 10.025, 5.120 },\n{ \"cell_xyzl\", \"Vss\", 4, 1, 0.125, 1.125 }", "x": "Optional. Specifies the placement origin of the value.", "y": "Optional. Specifies the placement origin of the y value.", "reflection": "Optional. Specifies if the library placement is reflected across the x-axis.\nNote:\nReflection is performed before rotation. Rotation is performed before\nshifting.\nThe default is false.\n\u2022 true. Reflects the library placement.\n\u2022 false. Does not reflect the library placement.\nlibrary_import()", "rotation": "Optional. Specifies the rotation of the library placement in multiples of 90\ndegrees.", "multidie_label": "Optional. Label used to match an interchip layer map in multidie_options().", "multidie_seal_ring_width": "Optional. Specifies a set of four directional ambit values which specify\nhow much to expand the shapes from interchip layer map source layers\nfrom multidie_options()  that have the seal_ring  set to true in the\nmapping. The total expansion amount is obtained by adding this ambit\nto the multidie_scribe_line_remaining_width  ambit. The default is\nUNSPECIFIED_AMBIT.", "multidie_scribe_line_remaining_width": "Optional. Specifies a set of four directional ambit values which specify how\nmuch to expand the shapes from interchip layer map source layers from\nmultidie_options()  that have the scribe_line_remaining_width  set to true\nin the mapping. The total expansion amount is obtained by adding this ambit to\nthe multidie_seal_ring_width  ambit. The default is UNSPECIFIED_AMBIT.", "additional_placements": "Optional. Lists all the placements inserted under the top cell of main library.\nPrefixed are applied as the same as the library_prefix. The following\nplacement properties need to be specified:\n\u2022 Cell. Specifies the cell to be imported. This structure must be in the\nspecified library.\n\u2022 x. Optional. Specifies the x-coordinate of the placement.\n\u2022 y. Optional. Specifies the y-coordinate of the placement.\n\u2022 reflection. Optional. Specifies if the library placement is reflected across\nthe x-axis.\n\u2022 rotation. Optional. Specifies the rotation of the library placement in\nmultiples of 90 degrees.\nNote:\nThe tool does not support LOWER_CELLS  for prefix application with\nadditional_placements  at the same time. The tool does not\nsupport multidie flow with additional_placements  at the same time.\nlibrary_import()"}, "summary": "The library_import()  function reads in the specified library and places its top cell under\nthe top cell of the design library defined by the\nlibrary()  or library_create()  function.", "function_name": "library_import()"}
{"description": "The lvs_black_box_options()  function defines which equivalence cells are black-box\ncells. Any device and connection data contained within the black-box cell is ignored; only\nthe port connections of the black-box cells are checked. If a black-box cell exists in the\nschematic or layout, it is maintained during the compare process.\nThis function must be called before assign functions.\nNote:\nYou can use the -e  command-line option to add equivalence options that\nyou have defined in a separate file. See the Command-Line Options section\nin the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more\ninformation.\nEquivalence and Black-Box Conflict Behavior\nThe IC Validator tool handles equivalence and black-box conflict behavior by using the\nfollowing priority setting rules when input settings are in conflict.\n\u2022 Full name wins wildcard\nFor example:\nSchematic side has cells A1, D1\nLayout side has cells B1, C1\nTable 43 Priority Rule: Full Name Wins Wildcard\nRunset setting Result\nequiv_options({{\"A*\",\"C*\"}});\nequiv_options({{\"A*\",\"B*\"}});\nequiv_options({{\"D1\",\"B1\"}});\nequiv(D1,B1)\nequiv(A1,C1)\nlvs_black_box_options({{\"A*\",\"C*\"}});\nlvs_black_box_options({{\"A*\",\"B*\"}});\nlvs_black_box_options({{\"D1\",\"B1\"}});\nblack_box(D1,B1)\nblack_box(A1,C1)\nlvs_black_box_options({{\"A*\",\"B*\"}});\nequiv_options({{\"A1\",\"B1\"}});\nequiv(A1,B1)\nlvs_black_box_options({{\"D1\",\"C1\"}});\nequiv_options({{\"D*\",\"C*\"}});\nblack_box(D1,C1)\nlvs_black_box_options()\n\u2022 lvs_black_box_options()  wins equiv_options()\nFor example:\nSchematic side has cells A1, D1\nLayout side has cells B1, C1\nTable 44 Priority Rule: lvs_black_box_options() Wins the equiv_options()\nRunset setting Result\nlvs_black_box_options({{\"A1\",\"B1\"}});\nequiv_options({{\"A1\",\"C1\"}});\nblack_box(A1,B1)\nlvs_black_box_options({{\"D*\",\"C*\"}});\nequiv_options({{\"A*\",\"C*\"}});\nblack_box(D1,C1)\nIn summary, the priority rules are as follows:\n\u2022 lvs_black_box_options(full name)\n\u2022 equiv_options(full name)\n\u2022 lvs_black_box_options(wildcard)\n\u2022 equiv_options(wildcard)", "syntax": "lvs_black_box_options(\nequiv_cells               = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"}, ...},\nequate_ports               = {{schematic_port = \"string\",\nlayout_port    = \"string\"}, ...},\n//optional\nremove_schematic_ports    = {\"string\", ...},                //optional\nremove_layout_ports       = {\"string\", ...},                //optional\nschematic_swappable_ports = {{\"string\", ...}, ...}          //optional\nstatic_ports               = NONE  | ALL_PORTS,              //optional\nmetacharacter_match_mode   = FULL_NAME | ALL,              //optional\nignore_netlist_content  = true  | false                //optional\n);", "returns": "void\nlvs_black_box_options()", "arguments": {"equiv_cells": "Required. Lists the schematic and layout cell name pairs. If only one cell name\nof a cell pair is specified, both cell names are assumed to be the same. String\nmatching using metacharacters is allowed. See\nString Matching  on page 3353\nfor more information.", "equate_ports": "Optional. Lists the schematic and layout port pairs that determine the port\ncorrespondence between the schematic and layout cells. These pairs are\ntreated as if they compare. Ports not listed are matched by name. By default, the\nIC Validator tool matches all ports by name.", "remove_schematic_ports": "Optional. Specifies the schematic ports to be removed. Use this argument to list\nthe ports in the schematic netlist that do not have an equivalent port in the layout\nnetlist. The IC Validator tool matches all other ports with the same name. You\ncan use the \"*\" metacharacter in the list of ports.", "remove_layout_ports": "Optional. Specifies the layout ports to be removed. Use this argument to list the\nports in the layout netlist that do not have an equivalent port in the schematic\nnetlist. The IC Validator tool matches all other ports with the same name. You\ncan use the \"*\" metacharacter in the list of ports.\nThe following example uses multiple metacharacters. Ports with names like\nfloatingnet_1_fill_1, floatingnet_1_fill_2, and floatingnet_2_fill_1 are removed\nfrom black-box cells during the compare operation.\nremove_layout_ports = {\"floatingnet_*_fill_*\"}", "schematic_swappable_ports": "Optional. Lists the port names that are treated as being logically equivalent for\ncomparison purposes at higher levels of the design hierarchy.", "static_ports": "Optional. Specifies whether the ports are static for cells below the top cell. The\ndefault is NONE.\n\u2022 NONE. Uses the settings of the push_down_pins  and remove_dangling_net\narguments of the compare()  function to determine if the ports of the black\nboxes specified by the equiv_cells  argument are merged or removed.\n\u2022 ALL_PORTS. Does not use the settings of the push_down_pins  and\nremove_dangling_net  arguments of the compare()  function to determine\nlvs_derived_layer()\nif the ports of the black boxes specified by the equiv_cells  argument are\nmerged or removed. That is, all ports of the black boxes specified by the\nequiv_cells  argument are static and neither merged nor removed.", "metacharacter_match_mode": "Optional. Specifies the required matching mode. The default is ALL.\n\u2022 ALL. An equivalent pair is created if its schematic and layout cell names\nmatch the specified equiv name with metacharacter.\n\u2022 FULL_NAME. An equivalent pair is only created if its schematic and layout\ncell names are the same and match the specified equiv name with\nmetacharacter.", "ignore_netlist_content": "Optional. Preserves the contents of specific black-box cells when set to false\nas lvs_options(ignore_all_black_box_netlist_content = true)  causes\nIC Validator to ignore the contents of all black-box cells. The default is true."}, "summary": "The lvs_black_box_options()  function defines which equivalence cells are black-box\ncells.", "function_name": "lvs_black_box_options()"}
{"description": "The lvs_derived_layer()  function takes the following two actions:\n\u2022 Incremental connect inherits the connectivity from an original connect layer to the\nderived layers\n\u2022 Original layer and derived layer information added to the runset report files for the\nparasitic extraction tool\nThis function must be called before the\nextract_devices()  function.\nlvs_derived_layer()", "syntax": "lvs_derived_layer(\nmatrix          = device_matrix,\nconnected_layer  = polygon_layer,\nderived_layers   = {polygon_layer, ...}\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix that is used to store information. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.", "connected_layer": "Required. Specifies the original connect layer. The original connect layer must\nbe in the connect database.", "derived_layers": "Required. Specifies the derived layers that are created from the original connect\nlayer. The layers must be the derived layers from the original connect layer. The\nlayers must also be enclosed by the original connect layer, and it must not be in\nthe connect database. The layers must not be the body layer or terminal layer of\nany device. An empty list is not allowed."}, "summary": "The lvs_derived_layer()  function takes the following two actions:\n\u2022 Incremental connect inherits the connectivity from an original connect layer to the\nderived layers\n\u2022 Original layer and derived layer information added to the runset report files for the\nparasitic extraction tool\nThis function must be called before the\nextract_devices()  function.", "function_name": "lvs_derived_layer()"}
{"description": "The lvs_generate_database()  function saves LVS results for any runset usage.\nSaved data includes polygon layers (attachment data is not included), error hierarchy,\nconnectivity database, device database, cross-reference database, schematic netlist and\nlayout netlist. The IC Validator include file and annotated-OASIS files are generated and\nplaced in the db_path directory. To obtain stored data, include the restore_include.rh file in\nyour runset.\nNote:\nA restored device database, generated by the lvs_restore_device_db()\nfunction, can only be used by the following Programmable Electrical Rule\nChecking (PERC) family of functions:\n\u2022 perc_property_to_net()\n\u2022 perc_create_device_layer()\n\u2022 perc_create_device_list_layer()\n\u2022 perc_create_net_layer()", "syntax": "lvs_generate_database(\ndb_path            = \"string\",\ndevice_db          = device_database,\nlayer_maps         = {{layer  = layer,\ntagname = string}, ...},\ntext_layer_maps    = {{layer   = text_layer,\ntagname = string}, ...},              //optional\nxref               = xref_database_handle,                  //optional\nschematic_netlist  = schematic_netlist_file_handle,         //optional\nlayout_netlist     = layout_netlist_file_handle             //optional\n);", "returns": "void", "arguments": {"db_path": "Required. Specifies a stored path name for the LVS results database.\nlvs_generate_database()", "device_db": "Required. Specifies a device database to be written to the LVS results database.\nThe\nextract_devices()  function generates the device database.", "layer_maps": "Required. Specifies the stored polygon layers with a tag name.\n\u2022 layer. Required. Specifies a polygon layer to be stored.\n\u2022 tagname. Required. Associates a user-defined name with a layer  polygon\nlayer. This tag name represents the layer in the restored runset. Each\nspecified tag name must be unique and cannot be reused.", "text_layer_maps": "Optional. Specifies the stored text layers with a tag name.\n\u2022 text_layer. Required. Specifies a text layer to be stored.\n\u2022 tagname. Required. Associates a user-defined name with a layer  text layer.\nThis tag name represents the layer in the restored runset. Each specified tag\nname must be unique and cannot be reused.", "xref": "Optional. Specifies a cross-reference database to be written to the LVS results\ndatabase. The compare()  function generates a cross-reference database.", "schematic_netlist": "Optional. Specifies a schematic netlist database to be written to the LVS results\ndatabase. The schematic()  function generates a schematic netlist database.", "layout_netlist": "Optional. Specifies a layout netlist database to be written to the LVS results\ndatabase."}, "summary": "The lvs_generate_database()  function saves LVS results for any runset usage.", "function_name": "lvs_generate_database()"}
{"description": "The lvs_options()  function generates user-intended and system-generated\nequivalence cell pairs. This functionality generates equivalences without the use of the\nequiv_options()  function.\nThe lvs_options()  function provides two arguments to separately control the generation\nof user-intended and system-generated equivalences.\n\u2022 A user-intended equivalence cell pairing is a pairing that you intend to be logically\nequivalent in the design. You want to see errors for user-intended equivalence cell\npairings reported in all compare error outputs to enable your design debugging.\n\u2022 A system-generated equivalence cell pairing is heuristically generated by the\nIC Validator tool to improve the hierarchical performance of the compare engine.\nYou do not necessarily intend this pairing to be logically equivalent. As such,\nyou do not want to see errors for system-generated equivalence cell pairings in\nstandard compare error outputs. Furthermore, system-generated equivalence\ncell pairings that fail the compare operation are exploded when using the\ncompare(action_on_error=NO_EXPLODE)  setting, thereby enabling the compare run\nto continue as if the pairing never existed.\nThe lvs_options()  function observes the specification of equivalences to be ignored\nthat are specified in the equiv_options()  function. In the following example, the\nlvs_options()  function generates equivalence cell pairings for all schematic and layout\ncell names having matching strings, except for schematic cells named cellA.\nlvs_options(generate_user_equivs=FULL_NAME_CASE_SENSITIVE);\nequiv_options({{schematic_cell=\"cellA\", layout_cell=\"*\", ignore=true});", "syntax": "lvs_options(\ngenerate_user_equivs                = FULL_NAME_CASE_SENSITIVE |\nFULL_NAME_CASE_INSENSITIVE |\nSCHEMATIC_CELL_NAME |\nAUTO |\nNONE,\n//optional\ngenerate_system_equivs              = true | false,\n//optional\ndevice_extraction_preserved_cells   = {\"string\", ...},\n//optional\nspice_multiplier_names              = {\"string\", ...},\n//optional\nspice_device_multipliers = {\n{device_multiplier_names = {\"string\", ...},\ndevice_type             = spice_device_type,\nlvs_options()\ndevice_names            = {\"string\", ...}}, ...},\n//optional\nextract_devices_in_black_box_cells =  true  | false,\n//optional\nlvs_property_epsilon               =  E5_EPSILON | E6_EPSILON,\n//optional\ndevice_leveled_summary_file = {report_type = SHORT  |\nDETAIL},                //optional\nextract_single_terminal_mos_src_properties = EMPTY |\nDUPLICATE_DRN,\n//optional\ninherit_mapped_device_swappable_pins        = true | false,\n//optional\nallow_equiv_optimizations    = true | false,            //optional\ninter_die_flow               = true | false,             //optional\nstarrc_skip_cells            = {\"string\", ...},\n//optional\nwrite_ascii_layout_netlist   = true  | false,            //optional\nwrite_ascii_schematic_netlist  = true  | false,          //optional\nwrite_ascii_equiv_netlist    = true  | false,            //optional\nschematic_undefined_device   = ABORT | ALLOW,           //optional\nuser_equiv_substring         = \"\",       //optional\nignore_all_black_box_netlist_content  =\ntrue | false, //optional\nextract_single_terminal_resistor   =\ntrue | false //optional\n);", "returns": "void", "arguments": {"generate_user_equivs": "Optional. Specifies the user-intended equivalence cell pairings for cells with the\nsame name. Those cells are not exploded. The default is NONE.\n\u2022 FULL_NAME_CASE_SENSITIVE. Generates equivalence cell pairings for all cell\nname pairings having identical case-sensitive matching strings, in addition\nto those equivalence cell pairings generated by equiv_options()  and\nlvs_options(generate_system_equivs).\n\u2022 FULL_NAME_CASE_INSENSITIVE. Generates equivalence cell pairings for\nall cell name pairings having identical case-insensitive matching strings, in\naddition to those equivalence cell pairings generated by equiv_options()\nand lvs_options(generate_system_equivs).\n\u2022 SCHEMATIC_CELL_NAME. Specifies that all schematic cell names automatically\nbecome user equivalence cell names.\nlvs_options()\n\u2022 AUTO. Generates possible equivs based on matching cell name between\nschematic and layout, then based on hierarchy information determines which\ncells can be used as equivalence points.\n\u2022 NONE. Does not generate equivalence cell pairings\nexcept for those generated by equiv_options()  and\nlvs_options(generate_system_equivs).", "generate_system_equivs": "Optional. Enables the generation of system-generated equivalence cell pairings.\nSystem-generated equivalence cell pairings are generated heuristically\naccording to cell names and instance counts within the cells. Cells with the\nsame name might be explode to improve the overall runtime. The default is\nfalse.\n\u2022 true. Generates system-only equivalence cell pairings.\n\u2022 false. Does not generate system-only equivalence cell pairings that have no\nrunset-level control options; an equivalent option must be in the runset.", "device_extraction_preserved_cells": "Optional.\npreserving cells\nSpecifies parameterized cells (pcells) to preserve in the device\nextraction flow. If you select the\ndual-hierarchy extraction\ndual-hierarchy flow, the preserved cell setting\nis applied in only the compare pass. When extracting simulation properties,\ndevice extraction levels the device inside the preserved cell to ensure property\ncorrectness. preserved cells\nA preserved cell is a parameterized cell or pcell that is placed in the layout\nto represent a device. These device cells are pre-characterized and are not\nequiv points. The purpose of this argument is to maintain the device within\nthe cell even if there is cross hierarchy interaction between the device body,\nterminal, and the processing layers. (The processing layers are specified with\nthe processing_layer_hash  argument of the device configuration functions.)\nThe typical application for this argument is a flow in which parameterized\ncells (pcells) are specified as preserved cells in the StarRC tool with the\nSKIP_PCELLS command.\nNote:\nThis option is not intended to be a \u201cbrute force\u201d mechanism to\nprevent devices from leveling out of equivalence points, nor is this\noption intended to be used in lieu of using the dual-hierarchy flow for\npreserving LVS netlist hierarchy for compare. Do not declare a cell as\na preserved device cell unless all body, terminal, and recognition and\nprocessing layers for the devices are defined within the preserved cell\nbefore calling the extract_devices()  function. Otherwise, if some\nlvs_options()\nof the polygons for a device in the preserved cell reside in hierarchies\noutside of the preserved cell, including other preserved cells, the\ndevice might not be recognized correctly or the property values might\nbe incorrect.\nYou select the dual-hierarchy flow by setting the dual_hierarchy_extraction\nargument of the\ninit_device_matrix()  function to true.\nSee the Examples  section for more information.", "spice_multiplier_names": "Optional. Specifies multiplier factors that can be used in the LVS flow. The\nnames can consist of letters and digits. The initial character must be a letter, and\nthe letters are case-insensitive. The length of each multipliers must be less than\nor equal to 1024.\nThis argument can be used with or without the -sp-multiplier  command-\nline option of NetTran. See the -sp-multiplier  command-line option in the\nCommand-Line Syntax for NetTran section in the \u201cNetlist Formats\u201d section of the\nIC Validator LVS User Guide  for more information.", "spice_device_multipliers": "Optional. Specifies device-specific multipliers used to indicate parallel device\ninstances.\n\u2022 device_multiplier_names. Specifies multiplier factors that can be used\nwith device types specified with the device_type  option. The multiplier\nnames must be specified with the spice_multiplier_names  argument.\n\u2022 device_type. Specifies the SPICE device type where the device specific\nmultipliers are applied.\nTable 45  lists the SPICE device types.\nTable 45 SPICE Device Types\nSPICE_BJT SPICE_CAP SPICE_CELL SPICE_DIODE\nSPICE_IND SPICE_MOS SPICE_RES\n\u2022 device_names. Specifies device model names (or sub-circuit names if the\ndevice_type  argument is set to SPICE_CELL) where the device-specific\nmultipliers are applied. The default is an empty list, which denotes all device\nmodel names of the specified device type. These names must conform to\nthe naming rules discussed in the\nDevice Names\u201d section of the Strings and\nNames\u201d section of Appendix A, Runset Basics.\u201d\nlvs_options()", "extract_devices_in_black_box_cells": "Optional. Specifies if device extraction processes black-box cells. The default is\ntrue.\n\u2022 true. Extracts devices in black-box cells.\n\u2022 false. Does not extract devices in black-box cells. All child instances are\nremoved from within the black-box cells. All polygons necessary for creating\nports must be in the top cell to ensure proper top-level port creation.", "lvs_property_epsilon": "Optional. Specifies the setting of the LVS property epsilon value. The default is\nE6_EPSILON.\n\u2022 E5_EPSILON. Specifies that the setting of the LVS property epsilon value is\n10-5.\n\u2022 E6_EPSILON. Specifies that the setting of the LVS property epsilon value is\n10-6.", "device_leveled_summary_file": "Optional. Specifies the report type of device leveled summary file.\n\u2022 report_type. Optional. Specifies the report type of the device leveled\nsummary file. The default is SHORT.\n\u25e6 SHORT. Specifies that the device leveled summary file contains only the\nfollowing information: the leveled body layer, the interacted layer, and the\ncell from which the body layer is leveled.\n\u25e6 DETAIL. Specifies that the extra device leveling information is added\nto the device leveled summary file. The detailed leveling information of\nchosen devices is added, including the cell name and the coordinate\nbefore and after leveling, as well as the hierarchical path of leveling.", "extract_single_terminal_mos_src_properties": "Optional. Specifies if IC Validator should treat SRC as empty for a single\nterminal MOS with the same source/drain layers. This affects several SRC-\nrelated MOS property functions. The default isDUPLICATE_DRN.\n\u2022 EMPTY. Specifies that SRC is empty when calculating properties.\n\u2022 DUPLICATE_DRN. Specifies that SRC is equal to DRN when calculating\nproperties.\nlvs_options()", "inherit_mapped_device_swappable_pins": "Optional. Specifies if IC Validator should inherit the swappable_pins  setting\nbetween multiple equivalent devices. The default is false.\n\u2022 true. Specifies that a non-swappable device can be treated as swappable\nwhen it is equivalent to another swappable device.\n\u2022 false. Specifies that a non-swappable device cannot become swappable .IC\nValidator terminates if a non-swappable device is equivalent to a swappable\ndevice.", "allow_equiv_optimizations": "Optional. Allows equivalence cells to be exploded by hierarchy optimizations\nunless they are marked as no_explode. See the\nMethodology Check Functions\nfor more information. The default is false.\n\u2022 true. Specifies that all equivalences not explicitly marked no_explode\nin hierarchy_options(), or implicitly by use of a methodology check\nfunction, are treated as a \u201csoft equiv,\u201d and might be exploded if IC Validator\ndetermines that doing so improves runtime performance.\n\u2022 false. Specifies that all equivalences are marked no_explode. This is the\ndefault behavior.", "inter_die_flow": "optional. Specifies the die-to-die port connection check. The default is false.\nNotice that this argument implicitly sets up the required configuration for the\nflow, that is, only extract_devices(remove_dangling_ports=NONE)  can be\nset. This argument cannot be used with the -inter_die  command-line option.", "starcc_skip_cells": "Optional. Specifies the SKIP_CELLS  commands defined in the StarRC command\nfile. This option is used when you want to set compare(push_down_pins =\ntrue), but StarRC cannot accept cells defined as skip cells to have ports merge\nor remove. When an equiv or a black box cell match the given string patterns,\nthe IC Validator tool automatically sets its static_ports = ALL_PORTS, to\nprevent push_down_pins  affecting this cell.\nNote:\nSince StarRC can automatically set LVS black box cell as SKIP_CELL\nunder some conditions. If you rely on this RC behavior and not set\nthose black box cells as skip cell in RC command file, you need\nto manually set the lvs_black_box_options(static_ports =\nALL_PORTS)  for all black box cells.\nlvs_options()", "write_ascii_layout_netlist": "Optional. This argument is only valid when -lvsdb  is specified. While writing\na layout netlist, the layout netlist is written to LVSDB. This option determines\nwhether the layout netlist is additionally written to an ASCII file. The default is\ntrue.", "write_ascii_schematic_netlist": "Optional. This argument is only valid when -lvsdb  is specified. While writing\na schematic netlist, the schematic netlist is written to LVSDB. This option\ndetermines whether the schematic netlist is additionally written to an ASCII file.\nThe default is true.", "write_ascii_equiv_netlist": "Optional. This argument is only valid when -lvsdb  is specified. While writing\nan equiv netlist, when -lvsdb  is specified, the equiv netlist is written to LVSDB.\nThis option determines whether the equiv netlist is additionally written to an\nASCII file. The default is true.", "schematic_undefined_device": "Optional. Specifies if the tool should error out when a device is defined in the\nschematic but not in the runset. The default is ABORT.\n\u2022 ABORT. The IC Validator tool errors out when a device is defined in the\nschematic but not in the runset.\n\u2022 ALLOW. During compare, the IC Validator tool tries to automatically map the\nschematic device to a layout device with the same device name and the\nsame device type.", "user_equiv_substring": "Optional. Sets a substring for user equivs. The default is an empty string.\nuser_equiv_substring  is used to establish equivalence between two layout\ncells. It identifies equivalence when one layout cell's name is derived by\nappending a specific substring to the name of another layout cell, referred\nto as the original cell. By configuring user_equiv_substring, IC Validator\nautomatically marks these two layout cells as equivalent. Additionally, if the\noriginal cell is explicitly defined as a user equivalence, IC Validator also includes\nthe cell with the appended substring as part of the user equivalence.", "ignore_all_black_box_netlist_content": "lvs_options()\nOptional. Specifies if Nettran should ignore the contents of black-box cells.\nIf set to true, Nettran does not process any content within black box cells.\nIf set to false, Nettran continues to parse control statements and device\nsyntax inside these cells. To control this behavior for specific cells, use the\nlvs_black_box_options()  function. Ignoring cell contents might affect net\nshorts and could change the port count of black-box cells. The default is false.", "extract_single_terminal_resistor": "Optional. Enables extraction of single-terminal resistors. The default is false."}, "summary": "The lvs_options()  function generates user-intended and system-generated\nequivalence cell pairs.", "function_name": "lvs_options()"}
{"description": "The magnitude_density()  function checks\nlayout density\nlayout density changes (gradients)\nbetween a delta_window  subwindow and all other delta_window  subwindows within a\nwindow_layer  boundary based on user-programmable density equations.\nThe magnitude_density()  function calls a remote density function for each subwindow.\nThe remote function calls various utility functions that operate on the current subwindow\nor other subwindow to produce error output and density statistics. See\nMagnitude Density\nUtility Functions  for more information.", "syntax": "magnitude_density(\nwindow_layer             = polygon_layer,\nlayer_hash               = {\"string\" => polygon_layer, ...},\nwindow_function          = function,\ndelta_window             = {width = double,\nheight = double},             //optional\ndelta_x                   = double,                        //optional\ndelta_y                   = double,                        //optional\nrows                     = integer,                       //optional\ncolumns                  = integer,                       //optional\nx_edge_process_amount    = double,                        //optional\ny_edge_process_amount    = double,                        //optional\narea_clip_delta_percent  = double                         //optional\nstatistics_files         = {density_statistics_file_handle,\n...},                //optional\nstatistics_file_modes    = {OVERWRITE | APPEND, ...},     //optional\ncentered_square_size     = double,                        //optional\nboundary                  = CLIP  | ALIGN | IGNORE |\nREPLICATE_WINDOW | BACKUP      //optional\noutput_type               = DELTA_WINDOW  |\nCLIPPED_DELTA_WINDOW | CENTER |\nCLIPPED_CENTER,                //optional\noutput_center_dimensions = {width = double,\nheight = double},             //optional\nprocess_delta_windows    = OVERLAPPING  | ALL,             //optional\nname                     = \"layer_label\",                 //optional\ntraverse_boundary        = POLYGON_EXTENT  |\nVERTICAL_TRAPEZOID_EXTENTS |\nHORIZONTAL_TRAPEZOID_EXTENTS   //optional\n);", "returns": "polygon layer or error result\nmagnitude_density()", "arguments": {"window_layer": "Required. Specifies the polygon layer containing one or more polygons that\ndefine the boundaries where layers are processed for density calculations.\nThe\nchip_extent()  and layer_extent()  functions can be used to create a\nwindow layer. Call these functions before the magnitude_density()  function.\n\u2022 The chip_extent()  function returns a layer containing a single rectangle\nequal to the extents of the chip. Use this function to create a single full-chip\ncheck window. See the\nchip_extent()  function for more information.\n\u2022 The layer_extent()  function returns a layer containing a single rectangle\nequal to the extents of the input layer. Use this function to create a single-\nlayer check window. See the\nlayer_extent()  function for more information.", "layer_hash": "Required. Specifies the hash of string to polygon layer that is processed for\ndensity calculations. Data in this hash is accessible via the hash key within the\nremote window function. When referencing data from within the window function,\nonly the portion of the layer within the current delta_window  subwindow or the\ncurrent window_layer  polygon is seen.", "window_function": "Required. Specifies the remote function that calculates the gradient density.\nSee\nMagnitude Density Utility Functions  for more information about the utility\nfunctions you can use to define a remote function.", "delta_window": "Optional. Specifies the subwindow stepped across each window_layer  polygon.\nThe density equations are evaluated within each subwindow. The default is\ncalculated based on the number of rows and columns, specified using the rows\nand columns  arguments, and the extents of each window_layer  polygon.", "delta_x": "Optional. Specifies the delta_window  subwindow step distance in the x-\ndirection. The delta_x  value must evenly divide into the width  option of the\ndelta_window  argument. The default is the width  option of the delta_window\nargument.", "delta_y": "Optional. Specifies the delta_window  subwindow step distance in the y-\ndirection. The delta_y  value must evenly divide into the height  option of the\ndelta_window  argument. The default is the height  option of the delta_window\nargument.\nmagnitude_density()", "rows": "Optional. Specifies the number of rows each window_layer  polygon is divided\ninto. The default is 1.", "columns": "Optional. Specifies the number of columns each window_layer  polygon is\ndivided into. The default is 1.", "x_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the right edge of\nthe boundary by the specified value or more, specifies to shift the current\nsubwindow left to make it flush with the right edge of the current boundary.", "y_edge_process_amount": "Optional. If the delta_window  subwindow overhangs the top edge of the\nboundary by the specified value or more, specifies to shift the current\nsubwindow down to make it flush with the top edge of the current boundary.", "area_clip_delta_percent": "Optional. Ignores the current delta_window  subwindow if the density ratio\nof the window_layer  material inside the current subwindow is less than the\nspecified value. By default, the IC Validator tool ignores any subwindow with a\nwindow_layer  density of 0.", "statistics_files": "Optional. Specifies the handles of the files written to by\nmden_window_statistics()  utility functions included in the specified remote\nwindow function. Do not specify the same file more than one time. These files\nare defined using the\ndensity_statistics_file()  function.", "statistics_file_modes": "Optional. Specifies the action taken when the file already exists for each\nstatistics file of the gradient_density()  function. If only one mode is specified,\nit is used for all files. The default is OVERWRITE.\n\u2022 OVERWRITE. Overwrites the previous statistics file. That is, the statistics file\ncontains only statistics from this function.\n\u2022 APPEND. Appends the new data to the previous statistics file. That is, the\nstatistics file contains the statistics from previous density functions along with\nthe new statistics from this function.", "centered_square_size": "Optional. Specifies that squares centered on polygons inside the window layer\nare used as the windows for density calculations. The default is 0.0.\nmagnitude_density()\n\u2022 The value must be greater than or equal to 0.\n\u2022 If the value is 0, the gradient_density()  function does not output centered\nsquares.\nIf the value is greater than 0, then the IC Validator tool performs the following\nsteps:\n1. For each polygon of the window layer, find the rectangular extent.\n2. Find the center point of the rectangular extent, whose coordinates are (x,y).\n3. Set\n\u25e6 X1 = x - centered_square_size/2\n\u25e6 Y1 = y - centered_square_size/2\n\u25e6 X2 = x + centered_square_size/2\n\u25e6 Y2 = y + centered_square_size/2\nNote:\nIf the values are not on grid, they are rounded up to the next grid\nvalue.\n4. Perform all normal density operations with X1, Y1, X2, Y2 defining the\nwindow layer.\nFor example,\nmagnitude_density(\nwindow_layer = metal1_extent,\nlayer_hash = { \"layer1\" => metal1 },\nwindow_function = my_density_function,\ncentered_square_size = 15\n);\nThe window is defined by\nX1 = x - 15/2\nY1 = y - 15/2\nX2 = x + 15/2\nY2 = y + 15/2\nPerforming the normal density operations the generated window layer is defined\nas shown in\nFigure 263  in gradient_density.\nmagnitude_density()", "boundary": "Optional. Specifies how to process a delta_window  subwindow that overlaps\nthe boundary of the extents of a window layer polygon. The default is CLIP.\n\u2022 CLIP. Truncates the subwindow at the limits of the window layer.\nif the x_edge_process_amount  or y_edge_process_amount  argument is not\nequal to -1 when the boundary  argument is CLIP, then\n\u25e6 If the overhang is less than the x_edge_process_amount  or\ny_edge_process_amount  value, a clip is performed.\n\u25e6 If the overhang is equal to or greater than the x_edge_process_amount\nor y_edge_process_amount  value, an align is performed.\n\u25e6 If the overhang in the horizontal direction is less than the\nx_edge_process_amount  value, then clip the subwindow along the\nwindow layer.\n\u25e6 If the overhang in the horizontal direction is equal to or greater than\nthe x_edge_process_amount  value, then align the subwindow with the\nwindow layer\n\u25e6 If the overhang in the vertical direction is less than\ny_edge_process_amount  value, then clip the u along the window layer\n\u25e6 If the overhang in the vertical direction is equal or more than\ny_edge_process_amount  value, then align the subwindow with the\nwindow layer\nFigure 263  shows how a subwindow is clipped.\n\u2022 ALIGN. If a subwindow overlaps the right side or top edge of the window\nlayer, shifts the window left or down until it no longer overlaps the window\nlayer. The density calculation is performed after the window is shifted.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is ALIGN.\nFigure 263  shows how a subwindow is aligned.\n\u2022 IGNORE. If a subwindow overlaps the right or top edges of the window\nlayer boundary, ignores the subwindow and does not output data for that\nsubwindow location.\nmagnitude_density()\nNote:\nBoth x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is IGNORE.\nFigure 263  shows when the subwindow is ignored.\n\u2022 REPLICATE_WINDOW. To simulate density measurements on a die, replicates\nthe input layers to properly measure density at the boundary of the chip. if\na window overlaps the right or top edges of the window layer polygons, the\nwindow layer extent and its data is duplicated and added to the right or top\nside of the original bounding box. The density measurement on the boundary\nsubwindow is calculated considering the original data and the duplicated\ndata.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is\nREPLICATE_WINDOW.\nFigure 263  shows a replicated subwindow.\n\u2022 BACKUP. Shifts the overlapping subwindow the same way the ALIGN  option\nshifts it.", "output_type": "Optional. Specifies the type of output generated. The default is DELTA_WINDOW.\n\u2022 DELTA_WINDOW. Outputs the delta_window  subwindow saved by the\nmden_save_window()  utility function.\n\u2022 CLIPPED_DELTA_WINDOW. Outputs the intersection between the subwindow\nand the window_layer  polygon. This intersection is performed after\nthe remote window function calculations are completed. This option\nensures all output subwindows are inside the boundaries of nonrectangular\nwindow_layer  polygons.\n\u2022 CENTER. Outputs the rectangle placed at the center of the subwindow\nsaved by the\nmden_save_window()  utility function. The dimensions of the\nrectangle are specified by the output_center_dimensions  argument.\nAn error is given when the output_type  argument is CENTER  and the\noutput_center_dimensions  argument is {0, 0}.\n\u2022 CLIPPED_CENTER. Output the intersection between the rectangle placed\nat the center of the subwindow and the window_layer  polygon. This\nmagnitude_density()\nintersection is performed after the remote window function calculations\nare completed. This option ensures all center subwindows are inside the\nboundaries of the window_layer  polygons.", "output_center_dimensions": "Optional. Specifies the dimensions of the rectangle output when the\noutput_type  argument is CENTER.", "process_delta_windows": "Optional. Controls the handling of delta_window  subwindow processing within\nthe extents of a window layer polygon. The default is OVERLAPPING.\n\u2022 OVERLAPPING. Specifies to process only subwindows that overlap the window\nlayer polygon.\n\u2022 ALL. Specifies to process all subwindows that fall within the extent of the\nwindow layer polygon.\nWhen using the ALL  option,\n\u25e6 Do not set the output_type  argument to CLIPPED_DELTA_WINDOW  or\nCLIPPED_CENTER.\n\u25e6 Do not use the area_clip_delta_percent  argument.\nSee\nFigure 263  in the density()  function for more information.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "traverse_boundary": "Optional. Specifies the type of delta_window  subwindow traversal to be\nperformed. The default is POLYGON_EXTENT.\n\u2022 POLYGON_EXTENT. Specifies that the extents of the current window_layer\npolygon define the boundary in which the delta windows are traversed. The\ntraversal starts at the left-bottom corner of the current window layer polygon\nextent and ends at the right-top corner of the polygon extent.\n\u2022 VERTICAL_TRAPEZOID_EXTENTS. Specifies that each vertically fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each vertical trapezoid extent and ends at the right-top corner of the\ntrapezoid extent.\nmagnitude_density()\n\u2022 HORIZONTAL_TRAPEZOID_EXTENTS. Specifies that each horizontally fractured\ntrapezoid of the current window_layer  polygon defines a boundary in which\nthe delta windows are traversed. The traversal starts at the left-bottom corner\nof each horizontal trapezoid extent and ends at the right-top corner of the\ntrapezoid extent."}, "summary": "The magnitude_density()  function checks\nlayout density\nlayout density changes (gradients)\nbetween a delta_window  subwindow and all other delta_window  subwindows within a\nwindow_layer  boundary based on user-programmable density equations.", "function_name": "magnitude_density()"}
{"description": "The map_capacitor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of capacitor device instances and to provide device mappings between the\ntwo netlists being compared. In the netlist-versus-netlist flow, references to the schematic\nrefer to the netlist imported by the\nschematic()  function, while references to the layout\nrefer to the netlist imported by the read_layout_netlist()  function.", "syntax": "map_capacitor(\nstate                = compare_state,\ndevice_name          = \"string\",\nterminal_a           = \"string\",                            //optional\nterminal_b           = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false     //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the capacitor in the layout netlist.\nmap_capacitor()", "terminal_a": "Optional. Specifies terminal \"a\" of the device in the layout netlist. The default is\n\"A\".", "terminal_b": "Optional. Specifies terminal \"b\" of the device in the layout netlist. The default is\n\"B\".", "optional_pins": "Optional. Lists additional pins of the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_capacitor()  function.\nmap_capacitor()\n- The schematic pin names do not match the pin names provided in\nthe terminal_a, terminal_b, or optional_pins  arguments of the\nmap_capacitor()  function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe optional_pins  list of structures argument of the map_capacitor()\nfunction.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_capacitor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the map_capacitor()  function, that pin can be specified with\nthe ignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\nmap_capacitor()\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_capacitor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of capacitor device instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_capacitor()"}
{"description": "The map_gendev()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of generic device instances and to provide device mappings between the\ntwo netlists being compared. In the netlist-versus-netlist flow, references to the schematic\nrefer to the netlist imported by the\nschematic()  function, while references to the layout\nrefer to the netlist imported by the read_layout_netlist()  function.", "syntax": "map_gendev(\nstate                = compare_state,\ndevice_name          = \"string\",\nterminals            = {{pin_name     = \"string\",\npin_compared = true  | false}, ...},\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name = \"string\",\nterminals   = {\"string\", ...},\nignore_pins = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false           //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the generic device in the layout netlist.", "terminals": "Required. Lists the pins that define the terminals.\n\u2022 pin_name. Required. Specifies the pin name.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\nmap_gendev()\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Specifies lists pins that can be swapped for a successful comparison\nwith the schematic device. By default, no pins can be swapped.\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_gendev()  function.\n- The schematic pin names do not match the pin names provided in\nthe terminals  argument of the map_gendev()  function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminals. Optional. Specifies the terminals.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the terminals  list, that pin\nis ignored both in the layout and schematic. This behavior is similar to the\npin_compared  option of the terminals  argument of the map_gendev()\nfunction.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the map_gendev()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.\nmap_gendev()", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_gendev()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of generic device instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_gendev()"}
{"description": "The map_inductor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of inductor device instances and to provide device mappings between the\ntwo netlists being compared. In the netlist-versus-netlist flow, references to the schematic\nrefer to the netlist imported by the\nschematic()  function, while references to the layout\nrefer to the netlist imported by the read_layout_netlist()  function.", "syntax": "map_inductor(\nstate                = compare_state,\ndevice_name          = \"string\",\nterminal_a           = \"string\",                            //optional\nterminal_b           = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false            //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the inductor in the layout netlist.\nmap_inductor()", "terminal_a": "Optional. Specifies terminal \"a\" of the device in the layout netlist. The default is\n\"A\".", "terminal_b": "Optional. Specifies terminal \"b\" of the device in the layout netlist. The default is\n\"B\".", "optional_pins": "Optional. Lists additional pins of the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_inductor()  function.\nmap_inductor()\n- The schematic pin names do not match the pin names provided in\nthe terminal_a, terminal_b, or optional_pins  arguments of the\nmap_inductor()  function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe optional_pins  list of structures argument.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_inductor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the map_inductor()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\nmap_inductor()\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_inductor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of inductor device instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_inductor()"}
{"description": "The map_nmos()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NMOS device instances and to provide device mappings between the\ntwo netlists being compared.\nThe map_pmos()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of PMOS device instances and to provide device mappings between the\ntwo netlists being compared.\nIn the netlist-versus-netlist flow, references to the schematic refer to the netlist imported\nby the\nschematic()  function, while references to the layout refer to the netlist imported by\nthe read_layout_netlist()  function.", "syntax": "map_nmos(\nstate                = compare_state,\ndevice_name          = \"string\",\ndrain                = \"string\",                            //optional\ngate                 = \"string\",                            //optional\nsource               = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\ndrain         = \"string\",\ngate          = \"string\",\nsource        = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nmap_layout_device     = true | false                          //optional\n);\nmap_pmos(\nstate                = compare_state,\ndevice_name          = \"string\",\ndrain                = \"string\",                            //optional\ngate                 = \"string\",                            //optional\nsource               = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nmap_nmos() and map_pmos()\nschematic_devices    = {{device_name   = \"string\",\ndrain         = \"string\",\ngate          = \"string\",\nsource        = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nmap_layout_device     = true | false                 //optional\nmulti_equate_principle_device: boolean = false          //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the MOS device in the layout netlist.", "drain": "Optional. Specifies the drain of the device in the layout netlist. The default is\n\"DRN\".", "gate": "Optional. Specifies the gate of the device in the layout netlist. The default is\n\"GATE\".", "source": "Optional. Specifies the source in the layout netlist. The default is \"SRC\".", "optional_pins": "Optional. Lists additional pins of the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\nmap_nmos() and map_pmos()\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cSRC\u201d and \u201cDRN\u201d can be swapped. Use\nan empty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_nmos()  and map_pmos()  functions.\n- The schematic pin names do not match the pin names provided\nin the drain, gate, source, or optional_pins  arguments of the\nmap_nmos()  and map_pmos()  functions.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 drain. Optional. Specifies the first terminal of the device. The default is\n\"DRN\".\n\u2022 gate. Optional. Specifies the second terminal of the device. The default is\n\"GATE\".\n\u2022 source. Optional. Specifies the source of the device. The default is \"SRC\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond\nto the optional_pins  list of structures argument of the map_nmos()  and\nmap_pmos()  functions.\nmap_nmos() and map_pmos()\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_nmos()  and map_pmos()  functions.\nIf the schematic device has an optional pin that does not correspond to any\npin in the map_nmos()  and map_pmos()  functions, that pin can be specified\nwith the ignore_pins. Otherwise, this optional pin produces an error during\nthe compare operation.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\nThe default is\n{{\"SRC\",{\"AS\",\"PS\",\"NRS\"}},{\"DRN\",{\"AD\",\"PD\",\"NRD\"}}}.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\n\u2022 true. Specifies that the schematic devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.\nmap_nmos() and map_pmos()", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_nmos()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NMOS device instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_nmos()"}
{"description": "The map_np()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NP diode instances and to provide device mappings between the two\nnetlists being compared.\nThe map_pn()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of PN diode instances and to provide device mappings between the two\nnetlists being compared.\nIn the netlist-versus-netlist flow, references to the schematic refer to the netlist imported\nby the\nschematic()  function, while references to the layout refer to the netlist imported by\nthe read_layout_netlist()  function.", "syntax": "map_np(\nstate                = compare_state,\ndevice_name          = \"string\",\nanode                = \"string\",                            //optional\ncathode              = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\nanode         = \"string\",\ncathode       = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\n);\nmap_pn(\nstate                = compare_state,\ndevice_name          = \"string\",\nanode                = \"string\",                            //optional\ncathode              = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\nanode         = \"string\",\ncathode       = \"string\",\nmap_np() and map_pn()\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false       //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the diode in the layout netlist.", "anode": "Optional. Specifies the anode of the device in the layout netlist. The default is\n\"ANODE\".", "cathode": "Optional. Specifies the cathode of the device in the layout netlist. The default is\n\"CATHODE\".", "optional_pins": "Optional. Lists additional pins for the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.\nmap_np() and map_pn()", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, no pins can be swapped.\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_np()  and map_pn()  functions.\n- The schematic pin names do not match the pin names provided in\nthe anode, cathode, or optional_pins  arguments of the map_np()\nand map_pn()  functions.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 anode. Optional. Specifies the anode terminal of the device. The default is\n\"ANODE\".\n\u2022 cathode. Optional. Specifies the cathode terminal of the device. The default\nis \"CATHODE\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond\nto the optional_pins  list of structures argument of the map_np()  and\nmap_pn()  functions.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_np()  and map_pn()  functions.\nIf the schematic device has an optional pin that does not correspond to any\npin in the map_np()  and map_pn()  functions, that pin can be specified with\nthe ignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.\nmap_np() and map_pn()", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_np()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NP diode instances and to provide device mappings between the two\nnetlists being compared.", "function_name": "map_np()"}
{"description": "The map_npn()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NPN transistor instances and to provide device mappings between the\ntwo netlists being compared.\nThe map_pnp()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of PNP transistor instances and to provide device mappings between the\ntwo netlists being compared.\nIn the netlist-versus-netlist flow, references to the schematic refer to the netlist imported\nby the\nschematic()  function, while references to the layout refer to the netlist imported by\nthe read_layout_netlist()  function.", "syntax": "map_npn(\nstate                = compare_state,\ndevice_name          = \"string\",\ncollector            = \"string\",                            //optional\nbase                 = \"string\",                            //optional\nemitter              = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\ncollector     = \"string\",\nbase          = \"string\",\nemitter       = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\n);\nmap_pnp(\nstate                = compare_state,\ndevice_name          = \"string\",\ncollector            = \"string\",                            //optional\nbase                 = \"string\",                            //optional\nemitter              = \"string\",                            //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nmap_npn() and map_pnp()\nschematic_devices    = {{device_name   = \"string\",\ncollector     = \"string\",\nbase          = \"string\",\nemitter       = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false     //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the bipolar transistor in the layout netlist.", "collector": "Optional. Specifies the collector of the device in the layout netlist. The default is\n\"COLL\".", "base": "Optional. Specifies the base of the device in the layout netlist. The default is\n\"BASE\".", "emitter": "Optional. Specifies the emitter of the device in the layout netlist. The default is\n\"EMIT\".", "optional_pins": "Optional. Lists additional pins of the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\nmap_npn() and map_pnp()\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, no pins can be swapped.\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_npn()  and map_pnp()  functions.\n- The schematic pin names do not match the pin names provided in\nthe collector, base, emitter, or optional_pins  arguments of the\nmap_npn()  and map_pnp()  functions.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 collector. Optional. Specifies the collector terminal of the device. The\ndefault is \"COLL\".\n\u2022 base. Optional. Specifies the base terminal of the device. The default is\n\"BASE\".\n\u2022 emitter. Optional. Specifies the emitter terminal of the device. The default is\n\"EMIT\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond\nto the optional_pins  list of structures argument of the map_npn()  and\nmap_pnp()  functions.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nmap_npn() and map_pnp()\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_npn()  and map_pnp()  functions.\nIf the schematic device has an optional pin that does not correspond to any\npin in the map_npn()  and map_pnp()  functions, that pin can be specified with\nthe ignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nmap_npn() and map_pnp()\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_npn()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of NPN transistor instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_npn()"}
{"description": "The map_resistor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of resistor device instances and to provide device mappings between the\ntwo netlists being compared. In the netlist-versus-netlist flow, references to the schematic\nrefer to the netlist imported by the\nschematic()  function, while references to the layout\nrefer to the netlist imported by the read_layout_netlist()  function.", "syntax": "map_resistor(\nstate                = compare_state,\ndevice_name          = \"string\",\nterminal_a           = \"string\",  //optional\nterminal_b           = \"string\",  //optional\noptional_pins        = {{pin_name     = \"string\",\npin_compared = true  | false},\n...},                               //optional\nswappable_pins       = {{\"string\", ...}, ...},              //optional\nschematic_devices    = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                               //optional\nswappable_properties = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                               //optional\nmap_layout_device     = true | false                          //optional\nmulti_equate_principle_device : boolean = false      //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "device_name": "Required. Specifies the resistor in the layout netlist.\nmap_resistor()", "terminal_a": "Optional. Specifies terminal \"a\" of the device in the layout netlist. The default is\n\"A\".", "terminal_b": "Optional. Specifies terminal \"b\" of the device in the layout netlist. The default is\n\"B\".", "optional_pins": "Optional. Lists additional pins of the device in the layout netlist.\n\u2022 pin_name. Optional. Specifies the pin. The default is \"BULK\".\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "swappable_pins": "Optional. Specifies lists pins that can be swapped for a successful comparison\nwith the schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the map_resistor()  function.\nmap_resistor()\n- The schematic pin names do not match the pin names provided in\nthe terminal_a, terminal_b, or optional_pins  arguments of the\nmap_resistor()  function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond\nto the optional_pins  list of structures argument of the map_resistor()\nfunction.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nmap_resistor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the map_resistor()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "map_layout_device": "Optional. Specifies if this argument is used to map an existing layout device to\nschematic_devices for comparison. The default is false.\nmap_resistor()\n\u2022 true. Specifies that the schematic_devices are mapped to an existing layout\ndevice name. The pin names and the swappable settings honor the original\nsettings in the existing LVS device configuration functions. You only need to\nspecify the schematic_devices  argument.\nNote:\nIf the specified device name does not exist, IC Validator ignores\nthis argument.\n\u2022 false. Specifies that this argument is used for NVN device mapping.", "multi_equate_principle_device": "Optional. Specifies if the specified layout device is a principle device. Any\nlayout device equivalent to the principle device honors the swappable_pins,\nswappable_properties  and other compare settings of the principle device,\nregardless of whether the principle device is actually extracted or not."}, "summary": "The map_resistor()  function is used in netlist-versus-netlist compare runsets to specify\ncharacteristics of resistor device instances and to provide device mappings between the\ntwo netlists being compared.", "function_name": "map_resistor()"}
{"description": "The map_stitch_links_error()  function creates center_to_center errors based on the\ninput error layer and the stitch-edge layer. For each error in layer1, if the edge_to_edge\nerror consists of two vertical error edges or two horizontal error edges, this function\nfinds the orthogonal layer2  edges that interact (point-touch included), and creates\ncenter_to_center errors based on the following rules.\nIf none of the error edges in the error interact with any orthogonal layer2  edges, the\nerror is skipped. If any one of the error edges in the error interacts with more than one\northogonal layer2  edge, the error is skipped. This function generates a center_to_center\nerror only when there is at least one error edge in the error that interacts exactly with one\northogonal layer2  edge, and the other error edges in the error either interact with one\northogonal layer2  edge or does not interact with any orthogonal layer2  edges.\n1. If one error edge in the layer1  error does not interact with any orthogonal layer2\nedges, the error edge midpoint is P. The other error edge must interact with one\northogonal layer2  edge. You can generate two center_to_center errors: one from point\nP to the starting point of the layer2  edge and one from point P to ending point of the\nlayer2  edge.\n\u25e6 If the layer1  error projection length is 0, only one of the center_to_center errors is\noutput with a longer center_to_center distance.\n\u25e6 If the layer1  error projection length is greater than 0, both center_to_center errors\nare output.\ngreen = map_stitch_links_error(red, blue);\n2. If both error edges in the layer1  error interact with one orthogonal layer2  edge,\nwhere one layer2  edge is horizontal and the other layer2  edge is vertical:\n\u25e6 Edge 1 is the orthogonal layer2  edge interacting with error edge 1 in the error.\n\u25e6 Edge 2 is the orthogonal layer2  edge interacting with error edge 2 in the error.\nmap_stitch_links_error()\nYou can generate four center_to_center errors: for each point from two points of edge\n1 and each point from two points of edge 2, or from the center_to_center error between\ntwo points from two edges. The center_to_center error with the shortest distance\nis removed with the remaining three center_to_center errors (If there are multiple\ncenter_to_center errors with the same shortest distance, one of the center_to_center\nerrors with the same shortest distance is arbitrarily removed.).\ngreen = map_stitch_links_error(red, blue);\n3. If both error edges in the layer1  error interact with one orthogonal layer2  edge, and\nthe two layer2  edges are either both horizontal edges or both vertical edges:\n\u25e6 Edge 1 is the orthogonal layer2  edge interacting with error edge 1 in the error.\n\u25e6 Edge 2 is the orthogonal layer2  edge interacting with error edge 2 in the error.\nYou can generate two center_to_center errors: one from a point with a smaller x,y in\nedge 1 to a point with a larger x,y in edge 2; the other from a point with a larger x,y in\nedge 1 to a point with a smaller x,y in edge2.\ngreen = map_stitch_links_error(red, blue);\nmap_stitch_links_error()", "syntax": "map_stitch_links_error(\nlayer1  = error_layer,\nlayer2  = edge_layer,\nname    = \"layer_label\", //optional\nlayer3  = edge_layer    //optional\n);", "returns": "error layer", "arguments": {"layer1": "Required. Specifies the error layer.", "layer2": "Required. Specifies the edge layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "layer3": "Optional. Specifies that If layer3  is provided, the interaction between layer1\nand layer3  is checked first to determine if center_to_center errors (consider\nonly orthogonal edges and edge_to_edge error consisting of two parallel\northogonal error edges) can be created. The interaction includes point-touch.\nThe checks are in the following order:\n1. If one error edge in the layer1  error interacts with exactly one orthogonal\nlayer3  edge, and the other error edge in the layer1  error does not interact\nwith any orthogonal layer2  or layer3  edges:\nFor the layer1  error edge that does not interact with any orthogonal\nlayer2  or layer3  edges, assume its midpoint is P. For the layer3  edge\nthat interacts with the layer1  error, the layer3  edge must interact with at\nleast one orthogonal layer2  edge (can be multiple). One of the orthogonal\nlayer2  edges interacting with a layer3  edge is arbitrarily chosen to\ngenerate two center_to_center errors: one from point P to the starting point\nof the layer2  edge and one from point P to the ending point of the layer2\nedge.\nmap_stitch_links_error()\n2. If one error edge in the layer1  error interacts with exactly one orthogonal\nlayer3  edge, and the other error edge in the layer1  error interacts with\nexactly one orthogonal layer2  edge:\nFor the layer3  error edge that interacts with layer1, it must interact with at\nleast one orthogonal layer2  edge (can be multiple). One of the orthogonal\nlayer2  edges is arbitrarily chosen and combined with the layer2  edge that\ninteracts the other layer1  error edge, and four center_to_center errors are\ngenerated by the endpoints of two layer2  edges.\n3. If both error edges in the layer1  error interact with exactly one orthogonal\nlayer3  edge, for each layer3  edge, it must interact with exactly one\northogonal layer2  edge (can be multiple). One of the orthogonal layer2\nedges is arbitrarily chosen, and four center_to_center errors are generated\nby the endpoints of two layer2  edges are generated.\nmap_stitch_links_error()\nIf layer3  does not match any of the conditions above, the original\nbehavior of checking the interaction between layer1  and layer2, to see if\ncenter_to_center errors can be created, is used."}, "summary": "The map_stitch_links_error()  function creates center_to_center errors based on the\ninput error layer and the stitch-edge layer.", "function_name": "map_stitch_links_error()"}
{"description": "The optional marker_merge()  function converts a marker layer to a polygon layer.\nA marker layer is returned by the pattern_learn()  and pattern_match()\nfunctions, and can be processed only by the marker_merge(),\nselect_marker_by_string_property(), select_marker_by_double_property(),\ndrc_feature_marker(), write_gds(), and write_oasis()  functions.", "syntax": "marker_merge(\nlayer1 = marker_layer,\nname    = \"layer_label\"  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the marker layer from which polygons are selected.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The optional marker_merge()  function converts a marker layer to a polygon layer.", "function_name": "marker_merge()"}
{"description": "The optional match()  function defines rules for matching equivalence cells, such as cell-\nlevel port swappability. You can also use this function to configure errors and warnings,\nsuch as for texted port matching.", "syntax": "match(\nstate                   = compare_state,\ndetect_permutable_ports = true | false,                     //optional\nmatch_by_net_name       = true | false,                     //optional\nmatch_condition         = {condition  = ERROR | WARNING | NONE,\n...},                            //optional\nno_explode_condition     = NONE  | PROPERTY_ERRORS_ONLY |\nPORT_TOPOLOGY_MATCHED |\nPORT_TEXT_MATCHED,                //optional\nreport_black_box_errors  =\n{extra_layout_ports    = NONE | WARNING | ERROR_NO_ABORT  | ERROR,\nuntexted_layout_ports = NONE  | WARNING | ERROR_NO_ABORT | ERROR,\nextra_schematic_ports = NONE | WARNING | ERROR_NO_ABORT  | ERROR},\n//optional\nequiv_cells             = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                             //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the match()  function is added.", "detect_permutable_ports": "Optional. Specifies how to handle independent or dependent swappability\nwithout additional input. When set to true, the IC Validator tool extracts\nsymmetries for the cell to which it is applied. It does not affect whether the cells\ncompare. This information is applied in determining equivalence for the parent\ncell. Therefore, when the detect_permutable_ports  argument is specified\nglobally, it does not operate on the top-level cell. To extract symmetries for\nthe top-level cell, you must explicitly invoke the match()  function using the\nmatch()\ndetect_permutable_ports  argument for the top-level cell. The default is\nfalse.", "match_by_net_name": "Optional. Specifies if text is used to resolve swappability. The default is false.\n\u2022 true. Uses text to resolve port swappability.\n\u2022 false. Does not use text to resolve port swappability.", "match_condition": "Optional. Specifies the conditions\nerror messages, selectable conditionswarnings, selectable conditions\nthat can be reported as errors or warnings, or\nnot reported. Table 46  lists the conditions along with the default setting of each\ncondition.\nTable 46 Match Conditions\nCondition Description Default\nproperty_mismatch Devices, connections, and properties within a cell\nmust all match to successfully compare the layout\nstructure and schematic module. The percentage\ndifference allowed between the layout and schematic\nproperty values is determined by the tolerance\noption set in the property_function  argument of the\ncheck_property()  function.\nERROR\nmissing_required_property Reports a missing property for a device. Invalid\nproperty values, such as inf and NaN, are also\nconsidered missing property errors.\nERROR\nillegal_multiplier An invalid M value is found. (A valid M value is a\npositive integer.)\nThe original, illegal M values are kept and are\naccessible in user functions. However, illegal values\nare ignored (effectively set to 1) in predefined property\ncomputations for merged devices.\nERROR\nblack_box_duplicates_equiv Controls the error or warning status when an\nequivalence pair duplicates the black-box pair.\nWARNING\nequate_by_net_name_fails The net name, found in both the schematic and layout,\nwas not used as an initial match reference point\nbecause the number of connections to the net is not\nthe same between the two cells. Nets with different\nnumbers of connections never match. This match\ncondition is checked when the match_by_net_name\nargument of the match()  function is true.\nWARNING\nmatch()\nTable 46 Match Conditions  (Continued)\nCondition Description Default\nequate_nets_fails The net pair set in the equate_nets  argument of\nthe equiv_options()  function was not used as an\ninitial match reference point because the number of\nconnections to the net is not the same between the two\ncells. Nets with different numbers of connections never\nmatch.\nWARNING\nfiltered_schematic_devices The specified instance of a schematic device was\nfiltered. While layout devices are commonly filtered,\ntypically schematic devices are not filtered.\nWARNING\nmatches_must_be_assumed The specified number of matches (devices and nets)\nwas assumed to allow progress for symmetrical\nportions of the circuitry. This message is output only if\nmatches were assigned.\nWARNING\nmerging_without_pwr_gnd Indicates any cell where series or path merging occurs\nbut no power or ground nets exist as specified by the\nschematic_power  and schematic_ground  arguments\nof the\nnet_options()  function. These situations often\nresult in excessive traversal of certain unspecified\nglobal nets.\nWARNING\nmissing_black_box_cell The cell specified in the black-box file does not exist in\nthe corresponding netlist. The black-box cell is ignored.\nWARNING\nmissing_black_box_port The port specified for a black-box cell does not exist on\nthat cell in the netlist.\nWARNING\nmissing_pin_connection The indicated device instance has no net connection\nspecified in the netlist for the specified pin. As a result,\nthe compare process automatically assigns a net name\nbeginning with the prefix No Connect# followed by a\nunique positive integer.\nWARNING\nnew_cell_created An empty placeholder cell was created to correspond\nwith an undefined cell in a specified black box.\nWARNING\nno_global_nets_found The compare process attempted to automatically\ndetermine power and ground of schematic and layout\nnets, but was unsuccessful.\nWARNING", "undefined_property_for_merged": "_device\nUser properties cannot be compared on merged\ndevices (unless you create merge property functions\nfor this device) because the values of those properties\nare undefined in certain merging scenarios.\nWARNING\nzero_value_property If the value of the property is zero, this warning is\nwritten to summary files.\nWARNING\nmatch()\nTable 46 Match Conditions  (Continued)\nCondition Description Default", "empty_cell_not_defined_as_dev": "", "ice": "Empty cells that are not defined as a device are\nreported.\nNONE", "properties_contradict_connect": "", "ions": "The external gate connections and the inner device\nproperties are not consistent between two schematic\nand layout composite devices.\nNONE", "nets_matched_with_different_n": "", "ame": "Specifies whether layout texted nets with no matching\nnames on the schematic side should be reported as\nerrors, warnings, or not reported.\nNONE", "top_layout_port_net_match_non_port_net": "conditions are also specified.\nNONE", "top_schematic_port_net_match_": "", "non_port_net": "For the top cell, reports any schematic port nets\nthat are matched to nets that are not port nets in the\nlayout. No messages are written for mismatches that\noccur within cells beneath the top cell unless the\nport_net_match_non_port_net  condition is also\nspecified.\nNONE", "top_layout_port_net_match_non": "_port_net\nFor the top cell, reports any layout port nets that\nare matched to nets that are not port nets in the\nschematic. No messages are written for mismatches\nthat occur within cells beneath the top cell unless the\nport_net_match_non_port_net  condition is also\nspecified.\nNONE\nmatch()\nTable 46 Match Conditions  (Continued)\nCondition Description Default", "ports_matched_with_different_": "", "name": "For cells below the top cell, reports any texted port\nnets in the layout that match port nets having different\nnet names in the schematic. No messages are written\nfor mismatches that occur on top cell ports unless the\ntop_ports_matched_with_different_name  condition\nis also specified.\nNote:\nFor a real texted net or a compound that contains\none or more text nets, there must be at least one\ncommon text name between the text nets to PASS\nthe name checking phase.\nNONE", "top_ports_matched_with_differ": "", "ent_name": "For the top cell, reports any texted port nets in the\nlayout that match port nets having different net\nnames in the schematic. No messages are written for\nmismatches that occur within cells beneath the top cell\nunless the ports_matched_with_different_name\ncondition is also specified.\nThat is, when either net, from schematic or layout, is\nnot texted, this condition does not report a difference.\nFor example, these names result in a reported error:\n\u2022 Schematic net name is \u201cA\u201d and layout net name is\n\u201cB\u201d.\nThese names result in a clean report:\n\u2022 Schematic net name is \u201cA\u201d and layout net name is\n\u201cA\u201d.\nThese names result in a clean report because the\nnames are not checked:\n\u2022 Schematic net name is \u201cA\u201d and layout net name is a\nnon-text name, N_2.\n\u2022 Schematic net name is a non-text name, N_3, and\nlayout net name is \u201cB\u201d.\nSee the layout_ports_without_name  and\ntop_layout_ports_without_name  conditions for more\ninformation.\nNote:\nFor a real texted net or a compound that contains\none or more text nets, there must be at least one\ncommon text name between the text nets to PASS\nthe name checking phase.\nNONE", "top_schematic_ports_matched_w": "", "ith_different_or_missing_name": "For the top cell, reports all schematic ports which\nmatch to different text and untext layout ports.\nSchematic generated ports are excluded\nNONE\nmatch()\nTable 46 Match Conditions  (Continued)\nCondition Description Default\none_connection_non_port_net The indicated net contains only one connection, and\nthe net is not a port of the cell. This condition indicates\nthat the net is dangling because it only connects to a\nsingle device pin.\nNONE\nzero_connection_net The indicated net contains no connections to devices\nin the cell. This condition occurs for nets that are\ndeclared as ports but do not connect to any devices in\nthe netlist description of the cell.\nNONE\nchild_equiv_unmatched_ports Controls the error or warning status when an\nequivalence has child equivalences that have\nunmatched ports. Reports those child instances and\ntheir unmatched port connections.\nNONE\npin_connected_and_dangling The indicated pin is connected on the schematic side,\nbut the layout ports are connected and dangling.\nNONE", "pin_connected_and_dangling_su": "", "ppress_layers": "Suppress the port during\npin_connected_and_dangling  checking.", "layout_net_without_matching_n": "", "no_explode_condition": "Optional. Determines if this equivalence is retained as a device when comparing\nits parent equivalence. The default is NONE.\n\u2022 NONE. Retains only compare-clean equivalences.\n\u2022 PROPERTY_ERRORS_ONLY. Retains the equivalence only if all nodes match\nand there is a property error.\n\u2022 PORT_TOPOLOGY_MATCHED. Retains if port nets match topologically, thus\nchecking to ensure that all port connections match.\n\u2022 PORT_TEXT_MATCHED. Retains only matching text and port counts. The port\nnets do not need to match topologically.", "report_black_box_errors": "Optional. Determines how the IC Validator tool behaves when cells are treated\nas black boxes during LVS compare. You can change the messages or errors\ngenerated when extra ports are found on black-box structures in the layout or\nmatch()\nschematic netlist, and you have additional control when black boxes have extra\nports that are not texted.\n\u2022 extra_layout_ports. Applies only to texted nets. The default is\nERROR_NO_ABORT.\n\u2022 untexted_layout_ports. Applies to untexted nets. The default is NONE.\n\u2022 extra_schematic_ports. Applies only to texted nets. The default is\nERROR_NO_ABORT.\nThe settings for these options are:\n\u2022 NONE. Ignores extra ports and removes connections to them. No messages\nare written to the log files about these actions.\n\u2022 WARNING. Ignores extra ports during the compare operation. A warning\nmessage is written to the cell_lvs.log file.\n\u2022 ERROR_NO_ABORT. Ignores any extra ports. At the top level, however, the\ndesign fails LVS compare because extra ports were found on LVS black-box\nstructures. This option you to compare the design but be alerted that you\nneed to investigate why extra ports are being formed on the black boxes.\nThe log files give the error information:\n\u25e6 The cell.LVS_ERRORS file shows that the design failed.\n\u25e6 In the first priority cells, any cell that contained a black-box cell with extra\nports is be listed. The error message tells you to check the black-box cells\nplaced in the equivalence point and to check the extra ports on the cell in\nthe lvs.log file.\n\u25e6 The sum.cell.cell  file shows black-box cells inside of an equivalence point\nthat had extra ports. The error summary shows the number of black-box\ncells that had extra ports.\n\u25e6 In the cell_lvs.log file, for each equivalence point that has black-box cells\nwith extra ports, a message says that the equivalence point has black-box\ncells with extra ports.\n\u2022 ERROR. If extra ports are found, writes an error to the cell_lvs.log file and the\nrun stops.", "equiv_cells": "Optional. Specifies schematic and layout cell name pairs for which the\nmatch()  function applies. You must specify the equiv_cells  pairs in the\nequiv_options()  function before calling the match()  function. If only one cell\nname in the pair is specified, the names are assumed to be the same.\nmatch()\nNote:\nThe match()  instruction is observed only when comparing each listed\nequivalence cell pair. If an equivalence cell pair is exploded into the\nparent equivalence cell pair while comparing the parent, the match()\ninstruction is discarded for the content of the exploded cell."}, "summary": "The optional match()  function defines rules for matching equivalence cells, such as cell-\nlevel port swappability.", "function_name": "match()"}
{"description": "The merge_net_properties()  function combines properties from the property connect\nsequences to the main connect sequence.", "syntax": "merge_net_properties()\nmain_connect_sequence       = connect_database,\nproperty_connect_sequences  = {connect_database, ...},\nsync_name                   = string\n);", "returns": "connect_database", "arguments": {"main_connect_sequence": "Specifies the connect database that contains no properties, that is, it is not\nderived from property_to_net()  function.", "property_connect_sequences": "Specifies the connect database properties. Any connect database defined\nin property_connect_sequences  must be derived from the same connect\ndatabase as main_connect_sequence. Additionally, when two connect\ndatabases in property_connect_sequences  contain properties with the same\nname, the IC Validator tool produces an error.", "sync_name": "The connect database defined in property_connect_sequences  must\ncontain this net-id property. merge_net_properties()  uses this property\ndefined by sync_name  to create sync property just like property_to_net\n(sync_net) for downstream voltage_filter = {delta_method = SYNC_NET/\nSYNC_NET_MODE2}  used by external1_error()  and external2_error()."}, "summary": "The merge_net_properties()  function combines properties from the property connect\nsequences to the main connect sequence.", "function_name": "merge_net_properties()"}
{"description": "The merge_parallel()  function defines the criteria for merging devices connected in\nparallel during the compare operation.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "merge_parallel(\nstate              = compare_state,\ndevice_type        = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names       = {\"string\", ...},                       //optional\nexclude_tolerances = {{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type = RELATIVE  | ABSOLUTE},\n...},                                 //optional\nexclude_function   = \"string\",                              //optional\nproperty_functions = {{property_function = \"string\",\nproperty          = \"string\"}, ...}, //optional\nequiv_cells        = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...},                                 //optional\nxref_parallel_map_property = \"string\"                       //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the merge_parallel()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that are merged. Each device must\nmatch a device specified in a device_name  argument of a device configuration\nfunction.\nmerge_parallel()\nOnly devices with a matching name are merged.\nNote:\nWhen device names are specified but not declared by a device or\nmap_*  function, IC Validator automatically creates equates for these\ndevices when possible. Exceptions where device names do not\nautomatically create equates are when merge_series()  is used with\ngendev_series_pins  and filter()  is used with short_pins.", "exclude_tolerances": "Optional. Lists the tolerance settings that exclude candidate devices from being\nmerged based on the property values of the devices.\n\u2022 property. Required. Specifies the property name. When none of the merged\ncandidates contain a property, the exclude condition does not apply.\n\u2022 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies if the tolerance is\na percentage (default) or absolute value. The default is [-10,+10].\nThe minimum resolution allowed for tolerance checking is as follows:\n\u25e6 When schematic_property !=0, the minimum resolution value is\nabsolute_value(schematic_property*1e-6)\n\u25e6 When schematic_property ==0, the minimum resolution value is\nabsolute_value(layout_property*1e-6)\nIf the specified tolerance range is less than this minimum value, for example,\n[-0,0], the property  option is checked for violations according to the\nminimum resolution.\n\u2022 tolerance_type. Optional. Checks property tolerances based on a relative\nor absolute property difference. The default is RELATIVE.\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the\nlvs_user_unit  argument of\nthe run_options()  function.", "exclude_function": "Optional. Specifies the remote function that defines exclusions based on\nproperty tolerances. If one of the exclusions is satisfied, the devices listed\nin the device_names  argument are removed. The default is the predefined\nmerge_parallel()\nexclude_device_by_tolerance  function,. This function excludes devices that\ndo not meet the specified tolerance.\nSee\nCompare Utility Functions  for more information about the utility functions\nyou can use to define a remote function.", "property_functions": "Optional. Lists the functions that define how a merged property for a merged\ndevice is calculated. The default is the internal merge functions. See the\nfollowing tables for more information.\n\u2022 property_function. Optional. Specifies the remote function that calculates\nproperties.\nSee\nCompare Utility Functions  for more information about the utility functions\nyou can use to define a remote function.\nThe available predefined functions are as follows:\n\u25e6 sum_merge_method. Adds the property values of the individual devices\ntogether.\n\u25e6 average_merge_method. Averages the property values of the individual\ndevices.\n\u25e6 min_merge_method. Takes the smallest property value of all individual\ndevices.\n\u25e6 max_merge_method. Takes the largest property value of all individual\ndevices.\n\u2022 property. Optional. Specifies the property that must satisfy the tolerance\nrange.\nNote:\nThe property name is needed here only if you are using one of the\npredefined functions: sum_merge_method, min_merge_method,\naverage_merge_method, or max_merge_method. If you are using\na user-defined function, the property is specified in the property\nfunction.\nThe default property calculations are shown in the following tables.\nTable 47\nshows the calculations for NMOS, PMOS, and generic device parallel merging\ndevice properties.\nmerge_parallel()\nTable 47 NMOS, PMOS, and Generic Device Parallel Merging Device\nProperties\nProperty Conditions (if any) Merging device properties1\nl (length)\nw (width)\nm (multiplier)\nnrs and nrd\nTable 48  shows the calculations for NP and PN parallel merging device\nproperties.\nTable 48 NP and PN Parallel Merging Device Properties\nProperty Conditions (if any) Merging device properties2\nl (length)\nw (width)", "area": "m (multiplier)\nTable 50  shows the calculations for resistor parallel merging device properties.\nTable 50 Resistor Parallel Merging Device Properties\nProperty Conditions (if any) Merging device properties4\nr (resistance)\nl (length) Unequal widths && unequal lengths L is not legal\nl (length) Only lengths are given && unequal", "lengths": "L is not legal\nl (length) Equal widths && unequal lengths\nl (length) Equal lengths\nw (width) Only widths are given && unequal", "widths": "W is not legal\nw (width) Equal widths && unequal lengths\nw (width) Equal lengths", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which the\nmerge_parallel()  function applies. You must specify the equiv_cells  pairs in\nthe equiv_options()  function before calling the merge_parallel()  function.\nIf only one cell name in the pair is specified, the names are assumed to be the\nsame.\n4. Mi  = 1 if multiplier is not specified\n5. Mi  = 1 if multiplier is not specified\nmerge_parallel()\nNote:\nThe merge_parallel()  instruction is observed only when comparing\neach listed equivalence cell pair. If an equivalence cell pair is\nexploded into the parent equivalence cell pair while comparing\nthe parent, the merge_parallel()  instruction is discarded for the\ncontent of the exploded cell.", "xref_parallel_map_property": "Optional. Specifies the property name that is used for mapping members of the\nmerged devices. The property name is case-sensitive. If this argument is an\nempty string, cross-reference parallel mapping is not processed. The default is\nan empty string (\u201d\u201d).\nLimitations:\n\u2022 For m  schematic member devices and n  layout member devices,\n1. If m  is greater than or equal to n, only N:1  mappings are applied; that is,\nno N:1  mapping occurs between multiple schematic devices to a single\nlayout device. In this case, N  is greater than or equal to 1. For example,\nExample 1: (m = n)\nSchematic 2 devices.\nM1(w=1)\nM2(w=2)\nLayout 2 devices\nm1 (w=1)\nm2 (w=2)\nThe device numbers are equal(m = n). Therefore, IC Validator maps M1\nto m1, and M2  to m2  in the cross-reference database.\n2. If m  is less than n, only 1:N  mappings are applied; that is, no 1:N  mapping\noccurs between a single schematic device to multiple layout devices. In\nthis case, N  is greater than or equal to 1. For example,\nExample 2: (m < n)\nSchematic 2 devices.\nM1 (w=4)\nM2 (w=6)\nLayout 4 devices\nm1 (w=1)\nm2 (w=2)\nm3 (w=1)\nm4 (w=6)\nmerge_parallel()\nThe device numbers on the schematic side are smaller (m < n).\nTherefore, IC Validator assumes 1:N  mapping. M1  is mapped to m2, m3,\nand m3  in the cross-reference database. M2  is mapped to M4  in the cross-\nreference database.\n\u2022 Only single layer parallel composite devices are considered. Hierarchical\ncomposite cases (parallel+series) are excluded from mapping.\n\u2022 Only zero-tolerance devices are applied. If any member device contains a\nnon-zero tolerance, the entire composite device is skipped from mapping.\n\u2022 Only applied to MOS devices."}, "summary": "The merge_parallel()  function defines the criteria for merging devices connected in\nparallel during the compare operation.", "function_name": "merge_parallel()"}
{"description": "The merge_parallel_off()  function disables parallel merging for specific devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "merge_parallel_off(\nstate        = compare_state,\ndevice_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names = {\"string\", ...},                             //optional\nequiv_cells  = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                        //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the merge_parallel_off()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that are not merged. Each device must\nmatch a device specified in a device_name  argument of a device configuration\nfunction.", "equiv_cells": "Optional. Specifies the schematic and layout cell name pairs for which\nthe merge_parallel_off()  function applies. You must specify the\nequiv_cells  pairs in the equiv_options()  function before calling the\nmerge_parallel_off()  function. If only one cell name in the pair is specified,\nthe names are assumed to be the same.\nmerge_parallel_off()\nNote:\nThe merge_parallel_off()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell pair\nis exploded into the parent equivalence cell pair while comparing the\nparent, the merge_parallel_off()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The merge_parallel_off()  function disables parallel merging for specific devices.", "function_name": "merge_parallel_off()"}
{"description": "The merge_series()  function defines the criteria for merging devices connected in series\nduring the compare operation.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.\nNote:\nA device can be merged by the merge_series()  function or recognized by the\nrecognize_gate()  function, but not both in the same runset.", "syntax": "merge_series(\nstate                 = compare_state,\ndevice_type           = NMOS | PMOS | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC,\ndevice_names          = {\"string\", ...},                    //optional\nexclude_tolerances    = {{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type = RELATIVE  | ABSOLUTE},\n...},                              //optional\nexclude_function      = \"string\",                           //optional\nproperty_functions    = {{property_function = \"string\",\nproperty = \"string\"}, ...},       //optional\nmerge_connected_gates = true | false,                       //optional\nmultiple_paths        = true | false,                       //optional\nequiv_cells           = {{schematic_cell = \"string\",\nlayout_cell     = \"string\"},\n...},                               //optional\ngendev_series_pins    = {pin_a = \"string\",\npin_b = \"string\"}                  //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the merge_series()  function is added.\nmerge_series()", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that are merged. Each device must\nmatch a device specified in a device_name  argument of a device configuration\nfunction.\nOnly devices with a matching name are merged.\nNote:\nWhen device names are specified but not declared by a device or\nmap_*  function, IC Validator automatically creates equates for these\ndevices when possible. Exceptions where device names do not\nautomatically create equates are when merge_series()  is used with\ngendev_series_pins  and filter()  is used with short_pins.", "exclude_tolerances": "Optional. Lists the functions that exclude candidate devices from being merged\nbased on their property values.\n\u2022 property. Required. Specifies the property for which to check the tolerance\nrange. When none of the merged candidates contain a property, the exclude\ncondition does not apply.\n\u2022 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies if the tolerance is\na percentage (default) or absolute value. The default is [-10,+10].\nThe minimum resolution allowed for tolerance checking is as follows:\n\u25e6 When schematic_property !=0, the minimum resolution value is\nabsolute_value(schematic_property*1e-6)\n\u25e6 When schematic_property ==0, the minimum resolution value is\nabsolute_value(layout_property*1e-6)\nIf the specified tolerance range is less than this minimum value, for example,\n[-0,0], the property  option is checked for violations according to the\nminimum resolution.\n\u2022 tolerance_type. Optional. Checks property tolerances based on a relative\nor absolute property difference. The default is RELATIVE.\nmerge_series()\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the lvs_user_unit  argument of\nthe run_options()  function.", "exclude_function": "Optional. Specifies the remote function that defines exclusions based on\nproperty tolerances. If one of the exclusions is satisfied, the devices listed\nin the device_names  argument are removed. The default is the predefined\nexclude_device_by_tolerance  function. This function excludes devices that\ndo not meet the specified tolerance.\nSee\nCompare Utility Functions  on page 2988 for more information about the\nutility functions you can use to define a remote function.", "property_functions": "Optional. Lists the functions that define how a merged property for a merged\ndevice is calculated.\n\u2022 property_function. Optional. Specifies the remote function that calculates\nproperties.\nSee\nCompare Utility Functions  on page 2988 for more information about the\nutility functions you can use to define a remote function.\nThe available predefined functions are as follows:\n\u25e6 sum_merge_method. Adds the property values of the individual devices\ntogether.\n\u25e6 average_merge_method. Averages the property values of the individual\ndevices.\n\u25e6 min_merge_method. Takes the smallest property value of all individual\ndevices.\n\u25e6 max_merge_method. Takes the largest property value of all individual\ndevices.\nIf no function is specified, the IC Validator tool uses the default functions\nlisted in the following tables.\nmerge_series()\n\u2022 property. Optional. Specifies the property that must satisfy the tolerance\nrange.\nNote:\nThe property name is needed here only if you are using one of the\npredefined functions: sum_merge_method, min_merge_method,\naverage_merge_method, or max_merge_method. If you are using\na user-defined function, the property is specified in the property\nfunction.\nThe default property calculations are shown in the following tables.\nTable 52\nshows the calculations for NMOS and PMOS series merging device properties.\nTable 52 NMOS and PMOS Series Merging Device Properties\nProperty Conditions (if any) Merging device properties6\nl (length) merge_connected_gates = false List of lengths of member devices. 7\nl (length) merge_connected_gates = true\nw (width) merge_connected_gates = false List of widths of member devices.7\nw (width) merge_connected_gates = true\nm (multiplier) List of multipliers of member devices. 7\nnrs and nrd\nTable 53  shows the calculations for resistor series merging device properties.\n6. Mi  = 1 if multiplier is not specified\n7. Property list can be compared for devices by gate order and values. Certain properties cannot be combined into a\nsingle value for a merged device. For example, the length and width properties are maintained as separate values\nfor MOS devices merged into series and path devices. The number of values in the property list corresponds to\nthe number of MOS devices that are members of the merged element.\nmerge_series()\nTable 53 Resistor Series Merging Device Properties\nProperty Conditions (if any) Merging device properties8\nr (resistance)\nl (length) Unequal widths && unequal lengths L is not legal\nl (length) Only lengths are given && unequal", "lengths": "L is not legal\nl (length) Equal widths\n8. Mi  = 1 if multiplier is not specified\n9. Mi  = 1 if multiplier is not specified\nmerge_series()\nTable 54 Capacitor Series Merging Device Properties  (Continued)\nProperty Conditions (if any) Merging device properties9\nl (length) Unequal widths && equal lengths\nw (width) Only widths are given && unequal", "widths": "W is not legal\nw (width) Equal widths\nw (width) Unequal widths && equal lengths", "merge_connected_gates": "Optional. Specifies whether connected gate pins of series-merged transistors\nare merged. The default is false.\n\u2022 true. If connected gate pins of series-merged transistors are tied to the\nsame net, the gate pins are merged into a gate pin.\n\u2022 false. If connected gate pins of series-merged transistors are tied to the\nsame net, the gate pins are not merged into a gate pin.", "multiple_paths": "Optional. Specifies when transistors are combined. The default is false.\n\u2022 true. Searches the schematic and layout netlists for stacks of NMOS or\nPMOS devices that can be rearranged to create a logically equivalent\nstructure. When two or more transistors are found in a path, they are\ncombined into a single device with logically equivalent gate-pin inputs.\nRecognition of these constructs allows devices in the schematic to be\nequated to devices in the layout that are logically equivalent even though\ntheir implementations might not match.\n\u2022 false. Does not search for these paths.", "equiv_cells": "Optional. Specifies the schematic and layout cell name pairs for which the\nmerge_series()  function applies. You must specify the equiv_cells  pairs in\nthe equiv_options()  function before calling the merge_series()  function. If\nonly one cell name in the pair is specified, the names are assumed to be the\nsame.\n9. Mi  = 1 if multiplier is not specified\nmerge_series()\nNote:\nThe merge_series()  instruction is observed only when comparing\neach listed equivalence cell pair. If an equivalence cell pair is\nexploded into the parent equivalence cell pair while comparing the\nparent, the merge_series()  instruction is discarded for the content\nof the exploded cell.", "gendev_series_pins": "Optional. Specifies the names of the two pins being connected in series of a\ngeneric device.\nThe gendev_series_pins  argument is required when the device_type\nargument is set to GENERIC. It is not necessary when device_type  is set to a\nprimitive device type, such as NMOS, PMOS, or RESISTOR.\n\u2022 pin_a. Optional. Specifies the name of the first pin in the series to be\nmerged.\n\u2022 pin_b. Optional. Specifies the name of the second pin in the series to be\nmerged.\nNote:\nThe series pins can only be swapped among themselves. The\nswappable pins are defined in the gendev()  and map_gendev()\nfunctions."}, "summary": "The merge_series()  function defines the criteria for merging devices connected in series\nduring the compare operation.", "function_name": "merge_series()"}
{"description": "The merge_series_off()  function disables series merging for specific devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "merge_series_off(\nstate        = compare_state,\ndevice_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names = {\"string\", ...},                             //optional\nequiv_cells  = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                        //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the merge_series_off()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices that are not merged. Each device must\nmatch a device specified in a device_name  argument of a device configuration\nfunction.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which the\nmerge_series_off()  function applies. You must specify the equiv_cells  pairs\nin the equiv_options()  function before calling the equiv_options()  function.\nIf only one cell name in the pair is specified, the names are assumed to be the\nsame.\nmerge_series_off()\nNote:\nThe merge_series_off()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell\npair is exploded into the parent equivalence cell pair while comparing\nthe parent, the merge_series_off()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The merge_series_off()  function disables series merging for specific devices.", "function_name": "merge_series_off()"}
{"description": "The milkyway_library()  function defines a Milkyway library name and returns a handle\nto be used by the output_library  argument of the\nwrite_milkyway()  function.\nNote:\nThe milkyway_library()  function cannot be called more than one time with\nthe same library_name  and library_path  arguments. The result, however,\ncan be used in more than one write_milkyway()  function.", "syntax": "milkyway_library(\nlibrary_name = \"string\",\nlibrary_path = \"string\"   //optional\n);", "returns": "milkyway_library_handle\nmilkyway_library_handle", "arguments": {"library_name": "Required. Specifies the Milkyway library name. See the output_library\nargument of the\nwrite_milkyway()  function for more information.", "library_path": "Optional. Specifies the path to the Milkyway library. The default is \".\"."}, "summary": "The milkyway_library()  function defines a Milkyway library name and returns a handle\nto be used by the output_library  argument of the\nwrite_milkyway()  function.", "function_name": "milkyway_library()"}
{"description": "The milkyway_merge_library_options()  function specifies a mapping from the master\nand reference Milkyway libraries to replacement GDSII, OASIS. and OpenAccess libraries\nthat are read in with Milkyway data at the start of a verification run. This function can be\ncalled only one time in a runset.\nYou can use the -ml  command-line option to override the settings in the\nmilkyway_merge_library_options()  function. See the Command-Line Options section\nin the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more information.\nFor example, if cell \u201cA\u201d has a FRAM view and a CEL view in the Milkyway library, the CEL\nview is replaced with the GDSII or OASIS data for cell \u201cA\u201d. If cell \u201cA\u201d only has a FRAM view\nin the Milkyway library, the missing CEL view data is created with data from the GDSII or\nOASIS replacement library.\nWhen using the milkyway_merge_library_options()  function, read all required\nGDSII, OASIS, OpenAccess, and Milkyway data during an IC Validator run to emulate\nthe complete mask data set for a designated top-level structure. The lower-level cells in\nthe replacement data are not permanently merged into the input Milkyway library. Data is\ntemporarily merged for only this run.\nNote:\nThe master Milkyway library and top-level cell are identified in the\nrunset by the\nlibrary()  function. The mapping specified in the\nmilkyway_merge_library_options()  function never looks for a replacement\nof the top cell.\nNote:\nMILKYWAY is no longer supported as an input format starting in X-2025.06.\nWhen using the milkyway_merge_library_options()  function, you should be familiar\nwith\n\u2022 Master Milkyway libraries and reference libraries, and the order in which Milkyway\nsearches these libraries to find a cell. See the Milkyway Database Application Note,\nwhich is available on SolvNetPlus.\n\u2022 The\nmilkyway_options()  function. Use this function to control the reading of FRAM\nand CEL views, and the reading of other Milkyway data.\n\u2022 The -lf  command-line option. Use this command-line option to specify mapping of the\nMilkyway layers to the runset layers. See the Command-Line Options section in the\n\u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more information.\nmilkyway_merge_library_options()\nYou can see the replacements in the run_details/hierarchy/top_cell.tree0 file. A tree file is\nshown in the Examples  section.", "syntax": "milkyway_merge_library_options(\nlibraries = {{library_name          = \"string\",\nlibrary_path          = \"string\",\nreplacement_libraries = {{\nfile             = \"string\",\nformat           = GDSII | OASIS | OPENACCESS,\ncell_name_map    = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},\nlayer_map_file   = \"string\",\nlayout_integrity = {{db_name = \"string\",\nmissing_db =\nABORT  | IGNORE,\ncell_name_map  =\n{{search_string  = \"string\",\nreplace_string = \"string\"},\n...}},\n...},\nopenaccess       = {library           = \"string\",\nview              = \"string\",\ncell_mapping_file = \"string\"}},\nobject_mapping_file = \"string\"}},\n...},\n...}},\nmissing_cell          = ABORT  | USE_MILKYWAY,               //optional\nicc_cell_map_file     = \"string\",                           //optional\nreport                = {USED_CELLS, UNUSED_CELLS,\nMISSING_CELLS, LAYER_MAPS,\nDUPLICATE_CELLS),                  //optional\nmissing_library       = ABORT  | CONTINUE,                   //optional\nlef_foreign_cell_name  = USE | IGNORE,                       //optional\nunmatched_reference_library       = ABORT | WARN            //optional\n);", "returns": "void", "arguments": {"libraries": "Required. Lists the Milkyway and replacement libraries.\nmilkyway_merge_library_options()\n\u2022 library_name. Required. Specifies the Milkyway library name. You only\nneed to list the Milkyway libraries for which you want to do replacements.\n\u2022 library_path. Optional. Specifies the Milkyway library path, which can be\neither relative or absolute. Use the library_path  argument if your library is\nnot in the run directory. The default is the current working directory.\n\u2022 replacement_libraries. Required. Specifies the replacement libraries.\nThe IC Validator tool searches the replacement libraries in the order specified\nlooking for cells. The first cell found is the one used.\nNote:\nA GDSII or OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool\nautomatically detects if a GDSII or OASIS file is gzipped.\n\u25e6 file. Specifies the replacement file. It is the library definition file when\nthe format  option is OPENACCESS.\n\u25e6 format. Specifies the format of the replacement libraries, GDSII, OASIS,\nor OpenAccess.\n\u25e6 cell_name_map. Optional. Specifies a list that tells how cell names are\nmapped as data is read in. Use this list when the GDSII, OASIS, or\nOpenAccess cell name does not match the corresponding Milkyway\ncell name. If you do not use this list to map duplicate cell names, the\nIC Validator tool automatically does the mapping and resolves all\nhierarchical references to the new name.\n- search_string. Specifies the cell name in the GDSII, OASIS, or\nOpenAccess data that is renamed.\n- replace_string. Specifies the new cell name given to the cell in the\nGDSII, OASIS, or OpenAccess data. This cell name is used within the\nIC Validator tool after the input data is read.\n\u25e6 layer_map_file. Optional. Specifies the layer mapping file for the\nreplacement library. You can map GDSII, OASIS, or OpenAccess data to\nMilkyway data.\nNote:\nWhen the OpenAccess layer mapping format is used,\nOpenAccess data is mapped directly to the runset. This\nbehavior differs from when the GDSII or OASIS layer mapping\nformats are used, as there is no standard layer mapping file\nformat from OpenAccess to Milkyway that supports color\nmapping.\nmilkyway_merge_library_options()\nNote:\nThe layer_map_file  option is required for the OpenAccess\nformat. For the OpenAccess layer map format, see the\ncell_mapping_file  argument of the\nopenaccess_options()\nfunction.\nThe file format for Milkyway is:\nMilkywayLayer[:MilkywayDatatype] SrcLayer[:SrcDatatype]\nNote:\nThe maximum layer and datatype values for Milkyway are 0\u2013\n255, inclusive, for libraries in normal layer mode or 0\u20134095,\ninclusive, for libraries in extended layer mode.\nComments are specified with a semicolon. All text following the semicolon\non the current line is part of the comment.\nFor example, to map\nGDSII layer 3 to the new layer 5:\n5 3\nGDSII layer 3, datatype 6 to layer 13 and datatype 16:\n13:16 3:6\nGDSII layer 3, all datatypes to layer 13 and datatype 0:\n13:0 3\n\u25e6 layout_integrity. Optional. Specifies the list of layout integrity\ndatabases that the IC Validator tool uses for layout integrity checking. By\ndefault, the IC Validator tool does not check layout integrity.\nNote:\nThe layout integrity database applies to cells in the\nreplacement library. Milkyway cells are checked against global\nlayout integrity options, if any.\n- db_name. Required. Specifies the path to the layout integrity database.\n- missing_db. Optional. Specifies the behavior when the IC Validator tool\ndoes not find the specified layout integrity database. The default is ABORT.\nABORT. Specifies that the run stops when the layout integrity database is\nnot found.\nmilkyway_merge_library_options()\nIGNORE. Continues the IC Validator run if the tool cannot find the layout\nintegrity database.\ncell_name_map. Optional. Specifies a list that tells how cell names are\nremapped as data is read from the layout integrity databases (LIDBs). By\ndefault, the IC Validator tool does not remap cell names.\nsearch_string. Required. Specifies the existing cell name in the input\nLIDB.\nreplace_string. Required. Specifies the cell name used for layout\nintegrity checking within IC Validator.\n\u25e6 openaccess. Required when the replacement library format is\nOpenAccess; that is when the format  option is OPENACCESS. (Do not\nuse this openaccess  option when the replacement library format is\nGDSII or OASIS.) Maps OpenAccess data to Milkyway data. See the\ncell_mapping_file  argument of the openaccess_options()  function\nfor more information.\n- library. Required. Specifies the OpenAccess library name that is in\nthe library definition file.\n- view. Optional. Specifies the view. The default is \"layout\".\n- cell_mapping_file. Optional. Specifies the OpenAccess cell mapping\nfile that allows you to specify the unique name that the IC Validator tool\nuses for a given library/cell/view triplet.\nNote:\nThis cell mapping file is applied, then the mapping specified in", "the": "cell_name_map  option is applied.\n- object_mapping_file. Optional. Specifies the OpenAccess object\nmapping file that allows you map OpenAccess objects to a runset layer\nand data type.\nNote:\nThe object_mapping_file  option does not map to NDM\nlayers and data types. This behavior is consistent with the\nbehavior of the OpenAccess layer mapping file.", "missing_cell": "Optional. Specifies the action taken if a cell is missing from the replacement file.\nThe default is ABORT.\nmilkyway_merge_library_options()\n\u2022 ABORT. Specifies if the run stops when a cell in the Milkyway library is not\nfound in a replacement file.\n\u2022 USE_MILKYWAY. If a cell in the Milkyway library is not found in a GDSII,\nOASIS, or OpenAccess replacement file, takes the Milkyway CEL view from\nthe Milkyway library.", "icc_cell_map_file": "Optional. Specifies the global cell map that applies to all GDSII, OASIS, or\nOpenAccess files. It maps GDSII and OASIS cells only and not Milkyway\ncells. The cell_name_map  option of the replacement_libraries  option\napplies to only one GDSII, OASIS, or OpenAccess file. You can use both the\ncell_name_map  option and the icc_cell_map_file  argument if the two maps\nare mutually exclusive; that is, the arguments do not define the same cell\nnames.\nBecause the master library is in Milkyway format, use this icc_cell_map_file\nargument instead of the cell_name_map  argument of the\ngds_options()\nor oasis_options()  function or the cell_mapping_file  argument of the\nopenaccess_options()  function. The gds_options(), oasis_options(), and\nopenaccess_options()  functions can be used only when a GDSII, OASIS, or\nOpenAccess library is the main library. See the library()  function for more\ninformation.\nThe IC Compiler cell mapping file format is:\nNewCellName OldCellName\nNote:\nIn the cell_name_map  option in this function and the cell_name_map\nargument in the gds_options()  or oasis_options()  function, the\nstrings are mapped in the reverse order, with the replacement string\nbeing in the second place.\nFor example, to map TOP.CEL to NEWTOP.CEL, enter:\nNEWTOP TOP", "report": "Optional. Specifies the information written to the\nmilkyway_merge_library_options.log file. The categories you can specify for\noutput are USED_CELLS, UNUSED_CELLS, MISSING_CELLS, LAYER_MAPS, and\nDUPLICATE_CELLS. The default output reports all categories.", "missing_library": "Optional. Specifies the IC Validator action when the replacement library does not\nexist. The default is ABORT.\nmilkyway_merge_library_options()\n\u2022 ABORT. Issues an error message when a replacement library does not exist.\n\u2022 CONTINUE. Behaves as if the replacement library was never specified and\ncontinues running.", "lef_foreign_cell_name": "Optional. Specifies if LEF (Library Exchange Format) foreign cell names are\nused for replacement cells. The default is IGNORE.\n\u2022 USE. Uses LEF foreign cell names for replacement cells.\n\u2022 IGNORE. Does not use LEF foreign cell names for replacement cells.", "unmatched_reference_library": "Optional. Specifies the IC Validator action when the reference library is\nunmatched. The default is WARN.\n\u2022 ABORT. Stops the run if the two Milkyway library names are the same, with\ntwo different paths in this function and in the reference libraries.\n\u2022 WARN. Writes a warning message in the milkyway_merge_library_options.log\nfile and continues to run."}, "summary": "The milkyway_merge_library_options()  function specifies a mapping from the master\nand reference Milkyway libraries to replacement GDSII, OASIS.", "function_name": "milkyway_merge_library_options()"}
{"description": "The milkyway_options()  function specifies the behavior of the IC Validator tool when\nreading a Milkyway library.\nNote:\nMILKYWAY is no longer supported as an input format starting in X-2025.06.", "syntax": "milkyway_options(\ndrc_black_box_cells     = {\"string\", ...},                  //optional\nlvs_black_box_cells     = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...},                            //optional\nmerge_fram_view          = NONE | PINS,                      //optional\nmissing_required_view   = IGNORE  | ABORT,                   //optional\ngenerate_pin_text       = NONE | TOP | ALL,                 //optional\nmerge_view_library_mode = ALL | MAIN | SAME,                //optional\nmerged_view_list        = {{name           = \"string\",\noutdated_views = ABORT  | USE | DISCARD},\n...},                            //optional\npin_text                = NET_NAME | PIN_NAME | REASSIGN,   //optional\nreplace_instance_name_characters = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                   //optional\nalternate_cel_view         = NONE | FRAM,                   //optional\ncell_types                 = {cell_type, ...},              //optional\nexclude_cell_types         = {cell_type, ...},              //optional\nnet_types                  = {net_type, ...},               //optional\nroute_guide_layers         = {layer_type, ...},             //optional\nroute_types                = {route_type, ...},             //optional\ngenerate_polygon_text      = NONE | TOP | ALL,              //optional\ndatatype_mappings           = {high_voltage_text = integer,\nlow_voltage_text  = integer}, //optional\nrule_name_delimiter         = {search_string = \"string\",\nignore_case = true | false},  //optional\ncut_table_datatype_mapping  = ALWAYS  | NEVER | DATATYPE_ZERO_ONLY,\n//optional\ninstance_names             = KEEP  | DISCARD                 //optional\n);", "returns": "void\nmilkyway_options()", "arguments": {"drc_black_box_cells": "DRC black-box cells\nOptional. Specifies the\nblack-box cellsDRCFRAM viewDRCCEL viewDRC\nblack-box cells for DRC. For these cells, polygon data\nfrom the FRAM view is read, and the CEL view is not read. For other cells,\npolygons from CEL view and pins from FRAM view are read. String matching\nusing metacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation.\nNote:\nIf DRC black-box cells are listed, the lvs_black_box_cells\nargument cannot be used. If neither DRC nor LVS black-box cells\nare specified, polygons from CEL view and pins from FRAM view are\nread. If the milkyway_merge_library_options()  function is used\nin the same IC Validator session, it has precedence over any of its\nreplacement cells that might also exist in the DRC black-box cell list.\nFor the top cell, all data from the CEL view is read. If the CEL view\ndoes not exist for the top cell, an error is reported and the run stops.", "lvs_black_box_cells": "LVS black-box cells\nOptional. Lists the\nblack-box cellsLVSFRAM viewLVSCEL viewLVS\nblack-box cells for LVS. For these cells, only pins from FRAM\nview are read. For other cells, polygons from CEL view and pins from FRAM\nview are read.\nNote:\nIf LVS black-box cells are listed, the drc_black_box_cells\nargument cannot be used. If neither DRC nor LVS black-\nbox cells are specified, pins from FRAM view are read. If the\nmilkyway_merge_library_options()  function is used in the same\nIC Validator session, it has precedence over any of its replacement\ncells that might also exist in the LVS black-box cell list.\nFor the top cell, all data from the CEL view is read. If the CEL view\ndoes not exist for the top cell, an error is reported and the run stops.", "merge_fram_view": "Optional. Controls the reading of the FRAM view\nFRAM viewcontrol reading of\nof cells that are not in the DRC\nor LVS black-box cells lists. The default is PINS.\nmilkyway_options()\nNote:\nIf a cell is either a DRC or LVS black-box cell, the FRAM view is read\nand the CEL view is not. The CEL view is always read for the top cell.\n\u2022 PINS. Reads pins from the FRAM view in addition to data from the CEL view.\n\u2022 NONE. Does not read the FRAM view.", "missing_required_view": "Optional. Specifies behavior if a cell is missing a required view, as defined by\nthe drc_black_box_cells  and lvs_black_box_cells  arguments. The default\nis IGNORE.\n\u2022 IGNORE. Continues the IC Validator run. A warning is reported and missing\nMilkyway cells are empty.\n\u2022 ABORT. Writes an error message and the run stops. If a cell is in either the\nDRC or LVS black-box cells list, the FRAM view is required for that cell. If the\ncell is not in a black-box cells list, the CEL view is required.", "generate_pin_text": "Optional. Specifies if pin text is generated. In some design styles, generating net\nnames from pin text can create false text-open error messages. To avoid these\nerror messages, set this argument to NONE  or TOP. The default is ALL.\n\u2022 NONE. Specifies that net names of pins in the hierarchy are not  converted to\ntext.\n\u2022 TOP. Specifies that only net names of pins in the top-level cell are converted\nto text.\n\u2022 ALL. Specifies that net names of all pins in the hierarchy are converted to\ntext.", "merge_view_library_mode": "Optional. Specifies the libraries to search to find a non-CEL cell. The default is\nSAME.\n\u2022 ALL. Searches all libraries.\n\u2022 MAIN. Specifies that only the main library for an associated cell is searched.\n\u2022 SAME. Searches for a non-CEL cell in the same library as the cell that\nreferences it (by placement or association).\nmilkyway_options()", "merged_view_list": "Optional. Lists the merging of views other than CEL and FRAM. These views of\nthe top cell of the design are read and merged into the top cell. By default, the\nIC Validator tool merges the FILL view.\n\u2022 name. Required. Specifies the view.\n\u2022 outdated_views. Optional. Specifies the behavior of the function if the\ntimestamp of the view is older than the timestamp of the CEL view. The\ndefault is ABORT.\n\u25e6 ABORT. If the timestamp of the specified view is older than the timestamp\nof the CEL view, an error is reported and the run stops.\n\u25e6 USE. If the timestamp of the specified view is older than the timestamp of\nthe CEL view, the view is read and the run continues.\n\u25e6 DISCARD. If the timestamp of the specified view is older than the\ntimestamp of the CEL view, a warning is reported, the view is not read,\nand the run continues.", "pin_text": "Optional. Determines where to get generated text for pins in the Milkyway\nlibrary. The default is NET_NAME.\n\u2022 NET_NAME. Reads texts from the net names of the pins.\n\u2022 PIN_NAME. Reads texts from the pin names.\n\u2022 REASSIGN. Reads texts from both the pin name and net name for pins. If\nthe pin name and net name are the same, the IC Validator tool uses the\npin name. If the pin name and net name are different, the IC Validator tool\nuses the net name and tags the text as an assigned net for hierarchical net\nassignment.\nSetting pin_text(REASSIGN)  has the same functionality as manually\nentering cell and net names in the reassign_text  argument of the\ntext_options()  function. Using pin_text(REASSIGN)  provides automated\nassignments when you are using a Milkyway library.", "replace_instance_name_characters": "Optional. Lists the strings to be replaced in instance names. Neither string\ncan use string matching. By default, the IC Validator tool does not replace any\ncharacters.\nmilkyway_options()\n\u2022 search_string. Required. Specifies the string to replace.\n\u2022 replace_string. Required. Specifies the replacement string. An empty\nstring (\"\") results in the removal of the specified search string.", "alternate_cel_view": "Optional. Specifies behavior if the CEL view is missing. The default is FRAM.\n\u2022 NONE. Applies the behavior specified by the missing_required_view\nargument.\n\u2022 FRAM. Reads the entire FRAM view of a cell if the CEL view is missing. If\nboth the CEL and FRAM views are missing, the behavior specified by the\nmissing_required_view  argument applies.\nNote:\nThe CEL view is always required for the top cell of the design.", "cell_types": "Optional. Specifies the cell types that determine which cells are read from\nthe Milkyway library. Using the milkyway  argument of the\nassign()  and\nassign_edge()  functions, you can specify the cell types for certain layers. You\ncan use the exclude_milkyway_cell_types()  function to obtain a list of all\npossible cell types except those specified by the exclude  argument. By default,\nthe IC Validator tool reads all cell types. Table 56  lists the cell types.\nTable 56 Milkyway cell_types Options\nANTENNA_CELL ARC_PLAN_CELL BV_CELL\nCHIP_CELL CLOCK_BUFFER_CELL CORNER_PAD_CELL\nCOVER_CELL DOUBLE_HEIGHT_STANDARD_CELL FC_BUMP_CELL\nFC_DRIVER_CELL FILLER_CELL FLIP_CHIP_PAD_CELL\nFLIP_FLOP_CELL GALAXY_AND_XO_CELL GALAXY_CELL\nIMAGE_CELL IO_PAD_CELL LATCH_CELL\nMACRO_CELL MODULE_CELL MORE_THAN_TRIPLE_HEIGHT_CELL\nNONE PAD_FILLER_CELL PG_PIN_ONLY_CELL\nRAM_CELL ROM_CELL SOFT_MACRO_IO_FIXED_CELL\nSOG_DESIGN_CELL SPECIAL_VIA_CELL STACK_VIA_CELL\nSTANDARD_CELL STANDARD_FILLER_CELL TAP_CELL\nTRIPLE_HEIGHT_STANDARD_CELL TSV_CELL UNKNOWN_L_MODEL_CELL\nmilkyway_options()\nTable 56 Milkyway cell_types Options  (Continued)\nXO_CELL", "exclude_cell_types": "Optional. Specifies the cell types that determine which cells are not read\nfrom the Milkyway library. If a cell type is listed in the cell_types  and\nexclude_cell_types  arguments, it is excluded. By default, the IC Validator tool\ndoes not exclude any cell types. See\nTable 56  for more information.\nNote:\nIf a cell type is excluded, no data is read from the cell and no\nsubtrees under the cell are placed.", "net_types": "Optional. Specifies the net types that are read from the Milkyway library.\nUsing the milkyway  argument of the\nassign()  and assign_edge()\nfunctions you can specify the net types for specific layers. You can use the\nexclude_milkyway_net_types()  function to obtain a list of all possible net\ntypes except those specified. By default, the IC Validator tool reads all net types.\nTable 57  lists the net types.\nTable 57 Milkyway net_types Options\nCLOCK CLOCK_AND_SPLIT_CLOCK FLIP_CHIP\nGROUND NON_CONT_PG NONE 10\nPOWER SIGNAL SLEEP_CONTROL\nSPECIAL_POWER SPLIT_CLOCK TIE_HIGH\nTIE_LOW UNCONNECTED11", "route_guide_layers": "Optional. Specifies the route guides that are read from the Milkyway library.\nRoute guides are rectangles on a specific layer that have a BlockLayer property\nset which defines the blocked layers. This argument filters based on the\nBlockLayer property. Using the milkyway  argument of the\nassign()  function\nyou can specify which route guides are read for specific layers. You can use", "the": "exclude_milkyway_route_guide_layers()  function to obtain a list of\n10. NONE  specifies that connected objects which do not have a set net type are read.\n11. UNCONNECTED  specifies that objects which do not have an associated net are read.\nmilkyway_options()\nall possible route guides except those specified by the exclude  argument. By\ndefault, the IC Validator tool reads all route guides. Table 58  lists the route guide\nlayers.\nTable 58 Milkyway route_guide_layers Options\nM1_ROUTE_GUIDE M10_ROUTE_GUIDE M11_ROUTE_GUIDE\nM12_ROUTE_GUIDE M13_ROUTE_GUIDE M14_ROUTE_GUIDE\nM15_ROUTE_GUIDE M2_ROUTE_GUIDE M3_ROUTE_GUIDE\nM4_ROUTE_GUIDE M5_ROUTE_GUIDE M6_ROUTE_GUIDE\nM7_ROUTE_GUIDE M8_ROUTE_GUIDE M9_ROUTE_GUIDE\nNONE12 POLY_ROUTE_GUIDE", "route_types": "Optional. Specifies the route types that are read from the Milkyway library.\nUsing the milkyway  argument of the\nassign()  and assign_edge()\nfunctions you can specify the route types for specific layers. You can use the\nexclude_milkyway_route_types()  function to obtain a list of all possible route\ntypes except those specified. By default, the IC Validator tool reads all route\ntypes.\nTable 59  lists the route types.\nNote:\nThe route type is only used for the shapes RECTANGLE, PATH,\nHORIZONTALWIRE, and VERTICALWIRE, as specified in the milkyway\nargument of the assign()  and assign_edge()  functions.\nTable 59 Milkyway route_types Options\nALIEN BUS CLOCK_0_SKEW\nCLOCK_RING CLOCK_STRIPE DYNAMIC_SHIELD\nFILL_TRACK FIXED HPB\nNONE13 PG_FOLLOW_PIN PG_PIN\nPG_RING PG_STRIPE SIGNAL_DETAIL\n12. NONE  specifies that polygons which do not have a BlockLayer property are read.\n13. NONE  specifies that objects that do not have a route type set are read. In the route type specified in layers  and\nerrors  arguments of the write_milkyway()  function, NONE  specifies to not set a route type even if writing\nrectangles to the FILL view.\nmilkyway_options()\nTable 59 Milkyway route_types Options  (Continued)\nSIGNAL_GLOBAL SIGNAL_USER", "generate_polygon_text": "Optional. Specifies if text points are generated from the net names of polygons.\nIn some design styles, generating text from polygon net names can create false\ntext-open error messages. To avoid these error messages, set this argument to\nNONE  or TOP. The default is ALL.\n\u2022 NONE. Specifies that net names of polygons in the hierarchy are not\nconverted to text.\n\u2022 TOP. Specifies that only net names of polygons in the top-level cell are\nconverted to text.\n\u2022 ALL. Specifies that net names of all polygons in the hierarchy are converted\nto text.", "datatype_mappings": "Optional. Specifies datatypes that identify the layers in the Milkyway library from\nwhich operating voltage text is selected.\n\u2022 high_voltage_text. Optional. Specifies the datatype for selecting the high\nvoltage text.\n\u2022 low_voltage_text. Optional. Specifies the datatype for selecting the low\nvoltage text.\nFor example,\nmilkyway_options(...,\ndatatype_mappings = {high_voltage_text = 231,\nlow_voltage_text  = 230}\n);\nYou can use the -lf  command-line option instead of the datatype_mappings\nargument to specify a layer mapping file that has voltage text mapping. For\ninformation about -lf, see the IC Validator Command-Line Options  section in\nthe \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide. For example,\nthe layer mapping could specify:\nPL * *:230\nPH * *:231\nPL indicates the low voltage text, and PH indicates the high voltage text.\nmilkyway_options()", "rule_name_delimiter": "Optional. Defines a delimiter for rule names. Use this argument to separate the\nrule name from the violation comment. The violation comment is truncated at the\nfirst instance of this delimiter for reporting in the icv_sdrc.conclude file.\nNote:\nThis delimiter is used only to determine the rule name for the\nMilkyway icv_sdrc.conclude file.\nIf the delimiter is not matched, the entire violation comment is reported in the\nicv_sdrc.conclude file. The violation comment might be truncated for length; the\nmaximum length of a violation comment is 1024 characters.\n\u2022 search_string. Specifies the delimiter. The search string must be a GNU\nextended regular expression. The default is\n\"[[:space:]]+:|[[:space:]]*:[[:space:]]\"\nThat is, the default is one of the following:\n\u25e6 One or more white space characters followed by a colon.\n\u25e6 Zero or more white space characters followed by a colon followed by one\nwhite space character.\n\u2022 ignore_case. Specifies if the character case in the violation comment is\nconsidered when matching the delimiter. The default is false.\n\u25e6 true. The search is case-sensitive.\n\u25e6 false. The search is not case-sensitive.", "cut_table_datatype_mapping": "Optional. Specifies how the IC Validator tool uses cutDataTypeTbl table\ndefinitions in the Milkyway technology file.\n\u2022 ALWAYS. Always uses the cut datatype table, if available in the Milkyway\ntechnology file, and sets datatypes for cut layer shapes as defined in the\ntable.\n\u2022 NEVER. Always uses the datatype of the shape stored in the Milkyway\ndatabase and does not change the datatype based on cut datatype table\ninformation in the technology file.\n\u2022 DATATYPE_ZERO_ONLY. Sets datatypes for cut layer shapes as defined in the\ncut datatype table only if the datatype of the Milkyway shape is zero. If the\ndatatype of a Milkyway shape is non-zero, the datatype is preserved.\nmilkyway_options()", "instance_names": "Optional. Specifies whether instance names from the input layout should be\nretained by the IC Validator tool. The instance names can be used for netlisting\nor possibly reused for the output layout. Retaining instance names could result\nin extra processing time during the reading of the input layout. The default is\nKEEP.\n\u2022 KEEP. Retains instance names from the input layout.\n\u2022 DISCARD. Does not retain instance names from the input layout."}, "summary": "The milkyway_options()  function specifies the behavior of the IC Validator tool when\nreading a Milkyway library.", "function_name": "milkyway_options()"}
{"description": "The milkyway_route_directives()  function provides better control over\nADR flow, automatic DRC repairautomatic DRC repair, ADR\nautomatic DRC\nrepair. (The ADR flow uses the signoff_autofix_drc  command within the IC Compiler\ntool.) The bounding boxes are output to the LAYOUT_ERRORS file, and VUE displays\nthe specified display markers. The directive layers specified in this function, including\ncombinations of add shapes, subtract shapes, and multiple error markers, are passed\ndirectly to the IC Compiler tool in the ADR flow.\nThis function is also compatible with IC Validator pattern matching.\nThe following restrictions apply to the milkyway_route_directives()  function:\n\u2022 All shapes altered by the route_directives  argument must be on the minimum\nmanufacturing grid. (The manufacturing grid is specified in the Milkyway technology\nfile.)\n\u2022 An add_layer  directive must not create a short, even if a subtract_layer  directive\nwould resolve it.\n\u2022 The result of a route directive must not be an open or floating shape.\n\u2022 A layer specified by a subtract_layer  argument must not interact with any via\nenclosure.\n\u2022 Any route_directives  layer must not overlap with power and ground straps, shapes\nthat have a route type of fixed or user enter, and pins.\n\u2022 A subtract layer can interact only with shapes having a route type of SIGNAL_DETAIL.\nNote:\nMILKYWAY InDesign ADR is no longer supported in X-2025.06.", "syntax": "milkyway_route_directives(\ndisplay_marker    = polygon_layer,\ngroup_marker      = polygon_layer,\nerror_layers      = {layername = polygon_layer, ...},        //optional\nroute_directives  = {{add_layer      = polygon_layer,\nsubtract_layer = polygon_layer}, ...}  //optional\n);", "returns": "void\nmilkyway_route_directives()", "arguments": {"display_marker": "Required. Specifies the layer that contains the shapes used to display the\nerrors.", "group_marker": "Required. Specifies the layer with the shapes that enclose the shapes defined\nby the display_marker, error_layers, and route_directives  arguments.", "error_layers": "Optional. Specifies the layers that are used to specify the errors. These\nlayers are interpreted by the signoff_autofix_drc  command as alternative\nrepresentations. Each of these layers is used in an independent fixing attempt in\nthe ADR flow.", "route_directives": "Optional. Specifies the layers that contain shapes which identify surgical\nfixes for the IC Compiler Zroute router. For a given set of add_layer  and\nsubtract_layer  shapes contained by a single group_marker  layer, the shapes\nare implemented by the Zroute router if they are allowed actions.\n\u2022 add_layer. The shapes on this layer are added, as if by an OR operator,\nto the database by the Zroute router, inheriting properties and connectivity\nbased on the shapes they are touching.\n\u2022 subtract_layer. The shapes on this layer are subtracted, as if by a NOT\noperator, from the database by the Zroute router, possibly leaving behind\npartial shapes in the database."}, "summary": "The milkyway_route_directives()  function provides better control over\nADR flow, automatic DRC repairautomatic DRC repair, ADR\nautomatic DRC\nrepair.", "function_name": "milkyway_route_directives()"}
{"description": "The mos_inside_outside_proximity_list()  function calculates the proximity values\nfrom two directions on two sides.", "syntax": "mos_inside_outside_proximity_list(\nbody  = polygon_set,\nprojection_datap = {{\npolygon_set = polygon_set,\ninside_data = {\norder = integer,\ninteraction = ENTERING | LEAVING | ENTERING_LEAVING,\nrange = double,\nprojection_length_a = {out_list_of_double, ...},\nprojection_length_b = {out_list_of_double, ...},\n}\noutside_data = {\n...\n},\n}},\ndirection                 = PARALLEL | PERPENDICULAR,\nprojection_length_method  = GEOMETRIC_MEAN  | ARITHMETIC_MEAN\n);", "returns": "void", "arguments": {"body": "Required. Specifies the base polygon set from which distances are measured.", "projection_data": "Required. Specifies the list of all input layers. Currently, the list size must be 1.\n\u2022 polygon_set. Measures the outside and inside projection distances.\n\u2022 inside_data. Specifies the parameters and output of the inside projection.\n\u25e6 order. Measures the number of projection distance.\n\u25e6 interaction. Determines the projection type to be measured.\nmos_inside_outside_proximity_list()\n\u25aa ENTERING. Measures the projections from body  that are entering a\npolygon_set  polygon.\n\u25aa LEAVING. Measures the projections from body  that are leaving a\npolygon_set  polygon.\n\u25aa ENTERING_LEAVING. Measures the projections from body  that are\neither entering or leaving a polygon_set  polygon.\n\u25e6 range. Specifies the maximum search area used to calculate the\nprojections.\n\u25e6 projection_length_a. Specifies the top or left direction distances.\n\u25e6 projection_length_b. Specifies the bottom or right direction distances.\n\u2022 outside_data. Specifies the parameters and output of the outside\nprojection.", "direction": "Required. Measures the parallel or perpendicular distance to the source-drain\nedge.\n\u2022 PARALLEL. Measures the parallel distance to the source-drain edge.\n\u2022 PERPENDICULAR. Measures the perpendicular distance to the source-drain\nedge.", "projection_length_method": "Required. Calculates the projection length using the geometric or arithmetic\nmethods. The default is GEOMETRIC_MEAN.\n\u2022 GEOMETRIC_MEAN. Calculates the projection length using geometric criteria.\n\u2022 ARITHMETIC_MEAN. Calculates the projection length using arithmetic criteria.\nFigure 440\ngeometric_mean:\nprojection_length =\narithmetic_mean:\nprojection_length =\nmos_inside_outside_proximity_list()\nFigure 441 projection_lengh_method"}, "summary": "The mos_inside_outside_proximity_list()  function calculates the proximity values\nfrom two directions on two sides.", "function_name": "pattern_match()"}
{"description": "The mos_select()  function selects device polygons from MOS devices on the specified\nlayers that fit the specified criteria. A remote function specifies arithmetic conditions\nrelative to MOS parameters.", "syntax": "mos_select(\ndrain               = polygon_layer,\ngate                = polygon_layer,\nsource              = polygon_layer,\nmos_func            = function,\noptional_pins       = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK},\n...},                                //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nrecognition_layer   = polygon_layer,                        //optional\nconnect_sequence    = connect_database,                     //optional\nsource_drain_config = {NORMAL, SINGLE},                     //optional\nprocessing_mode     = CELL_LEVEL | HIERARCHICAL |\nLEVEL_SOURCE_DRAIN                    //optional\n);", "returns": "polygon layer or error result", "arguments": {"drain": "Required. Specifies the drain layer of the MOS device. Drain and source\nterminal layers are required to determine the gate direction.", "gate": "Required. Specifies the gate layer of the MOS device.", "source": "Required. Specifies the source layer of the MOS device. Drain and source\nterminal layers are required to determine the gate direction.\nmos_select()", "mos_func": "Required. Specifies the remote function that selects devices based on geometric\ncriteria. See\nUtility Functions  for more information about the utility functions you\ncan use to define a remote function.", "optional_pins": "Optional. Lists additional bulk or terminal layers.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  functions for diagrams that illustrate the application of the range\nvalue.", "recognition_layer": "Optional. Specifies the layer used to form a MOS transistor when the gate\npolygon layer does not interact with all other terminal polygons. All polygons\nrequired to form a transistor must interact with a single polygon on this layer.\nmos_select()", "connect_sequence": "Optional. Specifies the connect database. If specified, the connection is\nconsidered in the device checking process.", "source_drain_config": "Optional. Specifies the MOS device types to be checked. The default is\n{NORMAL, SINGLE}.\n\u2022 SINGLE. Extracts only MOS devices that touch a single source or drain.\n\u2022 NORMAL. Extracts only MOS devices that have separate regions for source\nand drain.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\n\u2022 LEVEL_SOURCE_DRAIN. Specifies that MOS devices which hierarchically\nshare source or drain are brought into the same cell.\nNote:\nSource and drain properties that are hierarchically shared by MOS\ndevices are accurately calculated. This behavior can cause MOS\ndevices to be formed at a higher level and, therefore, can result in\ndifficulties during the compare process."}, "summary": "The mos_select()  function selects device polygons from MOS devices on the specified\nlayers that fit the specified criteria.", "function_name": "mos_select()"}
{"description": "The move()  function creates polygons by shifting all polygons on the input layer by the\nspecified offsets. See the\nprototype_options()  function for more information about\ndefining the criteria for the creation of prototype cells during hierarchical preprocessing.", "syntax": "move(\nlayer1           = polygon_layer,\nx               = double,\ny               = double,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "x": "Required. Specifies the offset in the x-direction.", "y": "Required. Specifies the offset in the y-direction.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nmove()"}, "summary": "The move()  function creates polygons by shifting all polygons on the input layer by the\nspecified offsets.", "function_name": "move()"}
{"description": "The move_edge()  function creates edges by shifting all edges on the input layer by the\nspecified offsets.", "syntax": "move_edge(\nlayer1          = edge_layer,\nx               = double,\ny               = double,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "x": "Required. Specifies the offset in the x-direction.", "y": "Required. Specifies the offset in the y-direction.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nmove_edge()"}, "summary": "The move_edge()  function creates edges by shifting all edges on the input layer by the\nspecified offsets.", "function_name": "move_edge()"}
{"description": "The mrc_adjust()  function makes the biased polygons change back to the original shape\nbefore biasing if the biased polygons violate the MRC (mask rule checking) criteria.", "syntax": "mrc_adjust(\nlayer1      = edge_layer,\nmain_layer  = polygon_layer,\nerrors      = {error_layer, ...}\n);", "returns": "polygon_layer", "arguments": {"layer1": "Required. Specifies the segments generated by the apply_bias_edge()\nfunction.", "main_layer": "Required. Specifies the polygon layer generated by the apply_bias()  function.", "errors": "Required. Specifies a list of error_layer  generated by the previous\ndimensional check error output. For example:\n\u2022 The return layer of mrc_adjust()  is the polygon layer formed by adjusted\nsegments.\n\u2022 The return layer of mrc_adjust_edge()  is the edge layer formed by adjusted\nsegments.\nmrc_adjust()"}, "summary": "The mrc_adjust()  function makes the biased polygons change back to the original shape\nbefore biasing if the biased polygons violate the MRC (mask rule checking) criteria.", "function_name": "mrc_adjust()"}
{"description": "The mrc_adjust_edge()  function makes the biased edges change back to the original\nshape before biasing if the biased edges violate the MRC (mask rule checking) criteria.", "syntax": "mrc_adjust_edge(\nlayer1      = edge_layer,\nmain_layer  = polygon_layer,\nerrors      = {error_layer, ...}\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the segments generated by the apply_bias_edge()\nfunction.", "main_layer": "Required. Specifies the polygon layer generated by the apply_bias()  function.", "errors": "Required. Specifies a list of error_layer  generated by the previous\ndimensional check error output. For example:\n\u2022 The return layer of mrc_adjust()  is the polygon layer formed by adjusted\nsegments.\n\u2022 The return layer of mrc_adjust_edge()  is the edge layer formed by adjusted\nsegments.\nSee the\nmrc_adjust()  function for more information."}, "summary": "The mrc_adjust_edge()  function makes the biased edges change back to the original\nshape before biasing if the biased edges violate the MRC (mask rule checking) criteria.", "function_name": "mrc_adjust_edge()"}
{"description": "The multidie_options()  function specifies multidie (3DIC) options.", "syntax": "multidie_options(\ninterchip_layer_map   =  {{label = \"string\",\nsource_layer = {layer_num =\ninteger, data_type = integer},\ndestination_layer = {layer_num =\ninteger, data_type = integer},\nseal_ring = true | false,\nscribe_line_remaining_width =\ntrue | false,\u2026},       // optional\n) returning void", "returns": "void", "arguments": {"interchip_layer_map": "Optional: Specified the layer mapping for interdie chiplets. The mapping\nis applied to library_import()  commands where label matches\nmultidie_label  in the library_import().\n\u2022 label. A pattern used to associate the mapping with library_import()\ncommands multidie_label  argument. The * wildcard is supported.\n\u2022 source_layer. Layer and datatype to read from the matching\nlibrary_import()  commands.\n\u2022 destination_layer. Layer and datatype to map the source layer to.\n\u2022 seal_ring. Set to true if the shapes read should be expanded by the\nmultidie_seal_ring_width  in the matching library_import()\ncommands.\n\u2022 scribe_line_remaining_width. Set to true if the shapes read should\nbe expanded by the multidie_ scribe_line_remaining_width  in the\nmatching library_import()  commands."}, "summary": "The multidie_options()  function specifies multidie (3DIC) options.", "function_name": "multidie_options()"}
{"description": "The ndm_library()  function defines an NDM library name and returns a handle to be\nused by the output_library  argument of the\nwrite_ndm()  function.\nNote:\nThe ndm_library()  function cannot be called more than one time with the\nsame library_name  and library_path  arguments. The result, however, can\nbe used in more than one write_ndm()  function.", "syntax": "ndm_library(\nlibrary_name  = \"string\",\nlibrary_path  = \"string\"\n);", "returns": "ndm_library_handle", "arguments": {"library_name": "Required. Specifies the NDM library name. See the output_library  argument\nof the\nwrite_ndm()  function for more information.", "library_path": "Optional. Specifies the path to the NDM library. The default is \".\"."}, "summary": "The ndm_library()  function defines an NDM library name and returns a handle to be\nused by the output_library  argument of the\nwrite_ndm()  function.", "function_name": "ndm_library()"}
{"description": "The ndm_merge_library_options()  function specifies a mapping from the master and\nreference NDM libraries to replacement GDSII and OASIS libraries that are read in with\nNDM data at the start of a verification run. This function can be called only one time in a\nrunset.\nNote:\nYou can use the -ml  command-line option to override the settings in the\nndm_merge_library_options()  function. See the Command-Line Options\nsection in the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for\nmore information.\nFor example, if cell \u201cA\u201d has a frame view and a design view in the NDM library, the design\nview is replaced with the GDSII or OASIS data for cell \u201cA\u201d. If cell \u201cA\u201d only has a frame view\nin the NDM library, the missing design view data is created with data from the GDSII or\nOASIS replacement library.\nUsing the ndm_merge_library_options()  function, you can read all required GDSII,\nOASIS, and NDM data during an IC Validator run to emulate the complete mask data set\nfor a designated top-level structure. The lower-level cells in the replacement data is not\npermanently merged into the input NDM library. Data is temporarily merged for only this\nrun.\nNote:\nThe master NDM library and top-level cell are identified in the\nrunset by the\nlibrary()  function. The mapping specified in the\nndm_merge_library_options()  function never looks for a replacement of the\ntop cell.\nWhen using the ndm_merge_library_options()  function, you should be familiar with\n\u2022 Master NDM libraries and reference libraries, and the order in which NDM searches\nthese libraries to find a cell.\n\u2022 The\nndm_options()  function. Use this function to control the reading of frame and\ndesign views, and the reading of other NDM data.\n\u2022 The -lf  command-line option. Use this command-line option to specify mapping of\nthe NDM layers to the runset layers. See the Command-Line Options section in the\n\u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more information.\nYou can see the replacements in the run_details/hierarchy/top_cell.tree0 file. A tree file is\nshown in the Examples section.\nndm_merge_library_options()", "syntax": "ndm_merge_library_options(\nlibraries = {{library_name          = \"string\",\nlibrary_path          = \"string\",\nreplacement_libraries = {{\nfile               = \"string\",\nformat             = GDSII | OASIS | OPENACCESS,\nlayer_map_file     = \"string\",\nopenaccess         = {library          = \"string\",\nview              = \"string\",\ncell_mapping_file = \"string\"}},\nobject_mapping_file =\n\"string\"}},\n...}},\n...},\nmissing_cell          = ABORT  | USE_NDM,                    //optional\nreport                = {USED_CELLS, UNUSED_CELLS,\nMISSING_CELLS, LAYER_MAPS,\nDUPLICATE_CELLS},                  //optional\nmissing_library       = ABORT  | CONTINUE,                   //optional\nlef_foreign_cell_name  = USE | IGNORE,                       //optional\nunmatched_reference_library         = ABORT | WARN,         //optional\ndefault_replacement_libraries       = {{file   = \"string\",\nformat = GDSII | OASIS |\nOPENACCESS,\nlayer_map_file = \"string\",\nopenaccess     =\n{library = \"string\",\nview    = \"string\",\ncell_mapping_file =\n\"string\",\nobject_mapping_file =\n\"string\"},\n...}},\n...}                  //optional\n);", "returns": "void", "arguments": {"libraries": "Required. Lists the NDM and replacement libraries.\nndm_merge_library_options()\n\u2022 library_name. Required. Specifies the NDM library name. You only need to\nlist the NDM libraries for which you want to do replacements.\n\u2022 library_path. Optional. Specifies the NDM library path, which can be either\nrelative or absolute. Use the library_path  argument if your library is not in\nthe run directory. The default is the current working directory.\n\u2022 replacement_libraries. Required. Specifies the replacement libraries.\nThe IC Validator tool searches the replacement libraries in the order specified\nlooking for cells. The first cell found is the one used.\nNote:\nA GDSII or OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool\nautomatically detects if a GDSII or OASIS file is gzipped.\n\u25e6 file. Specifies the replacement file.\n\u25e6 format. Specifies the format of the replacement libraries, GDSII, OASIS,\nor OPENACCESS.\n\u25e6 layer_map_file. Optional. Specifies the layer mapping file for the\nreplacement library. You can map GDSII, OASIS, or OpenAccess data to\nNDM data.\nNote:\nWhen the OpenAccess layer mapping format is used,\nOpenAccess data is mapped directly to the runset. This\nbehavior differs from when the GDSII or OASIS layer mapping\nformats are used, as there is no standard layer mapping file\nformat from OpenAccess to NDM or MILKYWAY that supports\ncolor mapping.\nThe NDM layer mapping format used for the replacement libraries is:\nndm_layer_no[:ndm_purpose][:use_type][:mask_type]\noasis_or_gdsii_layer_no[:oasis_or_gdsii_data_type]\nThe allowed values are\nndm_layer_no: 0 to 65535, inclusive\nndm_purpose: 0 to 32767, inclusive\nuse_type: signal, power, ground, clock, layer_boundary,\nhard_placement_blockage, soft_placement_blockage, and\nrouting_blockage.\nmask_type: mask_one, mask_two, mask_three, mask_same, and\nmask_none. The default is mask_none.\nndm_merge_library_options()\noasis_or_gdsii_layer_no: 0 to 65535, inclusive\noasis_or_gdsii_data_type: 0 to 65535, inclusive\nComments are specified with a semicolon. All text following the semicolon\non the current line is part of the comment.\nIn the following example, all the geometric and text data on layer 10 and\ndata type 2 in the GDSII or OASIS file are mapped to NDM layer 56 and\npurpose 4 as the power net type:\n56:4:power  10:2\n\u25e6 openaccess. Required when the replacement library format is\nOpenAccess; that is when the format  option is OPENACCESS. (Do\nnot use this openaccess  option when the replacement library format\nis GDSII or OASIS.) Maps OpenAccess data to NDM data. See the\ncell_mapping_file  argument of the\nopenaccess_options()  function\nfor more information.\n- library. Required. Specifies the OpenAccess library definition file that\nis in the library definition file.\n- view. Optional. Specifies the view. The default is \"layout\".\n- cell_mapping_file. Optional. Specifies the OpenAccess cell mapping\nfile that allows you to specify the unique name that the IC Validator tool\nuses for a given library/cell/view triplet.\nNote:\nThis cell mapping file is applied, then the mapping specified in\nthe cell_name_map  option is applied.\n- object_mapping_file. Optional. Specifies the OpenAccess object\nmapping file that allows you map OpenAccess objects to a runset layer\nand data type.\nNote:\nThe object_mapping_file  option does not map to NDM\nlayers and data types. This behavior is consistent with the\nbehavior of the OpenAccess layer mapping file.", "missing_cell": "Optional. Specifies the action taken if a cell is missing from the replacement file.\nThe default is ABORT.\nndm_merge_library_options()\n\u2022 ABORT. Specifies if the run stops when a cell in the NDM library is not found\nin a replacement file.\n\u2022 USE_NDM. If a cell in the NDM library is not found in a GDSII or OASIS\nreplacement file, takes the NDM design view from the NDM library.", "report": "Optional. Specifies the information written to the ndm_merge_library_options.log\nfile. The categories you can specify for output are USED_CELLS, UNUSED_CELLS,\nMISSING_CELLS, LAYER_MAPS, and DUPLICATE_CELLS. The default output\nreports all categories.\nThe ndm_merge_library_options.log file contains the information about cell\nusage during replacement, layer mapping, and cell name modifications caused\nby mapping. This file is in the run_details directory.\nNote:\nFor errors, the error messages are written to the summary file\n(cell.sum) and to the screen when you use the -verbose  option, but\nnot listed in the ndm_merge_library_options.log file.", "missing_library": "Optional. Specifies the IC Validator action when the replacement library does not\nexist. The default is ABORT.\n\u2022 ABORT. issues an error message when a replacement library does not exist.\n\u2022 CONTINUE. Behaves as if the replacement library was never specified and\ncontinues running.", "lef_foreign_cell_name": "Optional. Specifies if LEF (Library Exchange Format) foreign cell names are\nused for replacement cells. The default is IGNORE.\n\u2022 USE. Uses LEF foreign cell names for replacement cells.\n\u2022 IGNORE. Does not use LEF foreign cell names for replacement cells.", "unmatched_reference_library": "Optional. Specifies the IC Validator action when the reference library is\nunmatched. The default is WARN.\n\u2022 ABORT. Stops the run if the two NDM library names are the same, with two\ndifferent paths in this function and in the reference libraries.\n\u2022 WARN. Writes a warning message in the ndm_merge_library_options.log file\nand continues to run.\nndm_merge_library_options()", "default_replacement_libraries": "Optional. Specifies the replacement libraries to be used for all NDM\nlibraries that are not specified in the libraries  argument of the\nndm_merge_library_options()  function.\n\u2022 file. Specifies the replacement file.\n\u2022 format. Specifies the format of the replacement libraries, GDSII, OASIS, or\nOPENACCESS.\n\u2022 layer_map_file. Optional. Specifies the layer mapping file for replacement\nlibrary. You can map GDSII, OASIS, OpenAccess data to NDM data.\nNote:\nWhen the OpenAccess layer mapping format is used,\nOpenAccess data is mapped directly to the runset. This behavior\ndiffers from when the GDSII or OASIS layer mapping formats\nare used, as there is no standard layer mapping file format from\nOpenAccess to NDM or Milkyway that supports color mapping.\nThe NDM layer mapping format used for the replacement libraries is:\nndm_layer_no[:ndm_purpose][:use_type][:mask_type]\noasis_or_gdsii_layer_no[:oasis_or_gdsii_data_type]\nThe allowed values are\n\u25e6 ndm_layer_no: 0 to 65535, inclusive\n\u25e6 ndm_purpose: 0 to 32767, inclusive\n\u25e6 use_type: signal, power, ground, clock, layer_boundary,\nhard_placement_blockage, soft_placement_blockage, and\nrouting_blockage.\n\u25e6 mask_type: mask_one, mask_two, mask_three, mask_same, and\nmask_none. The default is mask_none.\n\u25e6 oasis_or_gdsii_layer_no: 0 to 65535, inclusive\n\u25e6 oasis_or_gdsii_data_type: 0 to 65535, inclusive\nComments are specified with a semicolon. All text following the semicolon on\nthe current line is part of the comment.\nIn the following example, all the geometric and text data on layer 10 and data\ntype 2 in the GDSII or OASIS file are mapped to NDM layer 56 and purpose\n4 as the power net type:\n56:4:power  10:2\nndm_merge_library_options()\n\u2022 openaccess. Required when the replacement library format is OpenAccess;\nthat is when the format  option is OPENACCESS. (Do not use this openaccess\noption when the replacement library format is GDSII or OASIS.) Maps\nOpenAccess data to NDM data. See the cell_mapping_file  argument of", "the": "openaccess_options()  function for more information.\n\u25e6 library. Required. Specifies the OpenAccess library definition file that is\nin the library definition file.\n\u25e6 view. Optional. Specifies the view. The default is \"layout\".\n\u25e6 cell_mapping_file. Optional. Specifies the OpenAccess cell mapping\nfile that allows you to specify the unique name that the IC Validator tool\nuses for a given library/cell/view triplet.\nNote:\nThis cell mapping file is applied, then the mapping specified in\nthe cell_name_map  option is applied.\n\u25e6 object_mapping_file. Optional. Specifies the OpenAccess object\nmapping file that allows you map OpenAccess objects to a runset layer\nand data type.\nNote:\nThe object_mapping_file  option does not map to NDM\nlayers and data types. This behavior is consistent with the\nbehavior of the OpenAccess layer mapping file."}, "summary": "The ndm_merge_library_options()  function specifies a mapping from the master and\nreference NDM libraries to replacement GDSII and OASIS libraries that are read in with\nNDM data at the start of a verification run.", "function_name": "ndm_merge_library_options()"}
{"description": "The ndm_input_library()  function returns a handle to the NDM input library to be used\nas the output_library  argument of the\nwrite_ndm()  function. If the input layout was not\nNDM this function aborts with an error.\nNote:\nThe ndm_input_library()  function cannot be called more than one\ntime. If the ndm_input_library()  function is called, there cannot be an\nndm_library()  function called with the library_name  and library_path\nof the NDM input library. The result of the ndm_input_library()  function,\nhowever, can be used in more than one write_ndm()  function.", "syntax": "ndm_input_library(\n);", "returns": "ndm_library_handle", "summary": "The ndm_input_library()  function returns a handle to the NDM input library to be used\nas the output_library  argument of the\nwrite_ndm()  function.", "function_name": "write_ndm()", "arguments": {}}
{"description": "The ndm_options()  function specifies the behavior of the IC Validator tool when reading\nan NDM library. By default, the tool reads the design view of a cell if it is present. If\nthe design view is missing, the tool looks for a frame view based on the setting of the\nalternate_view  argument. If, after looking for the alternate view, the cell cannot be\nfound, the tool either continues with an empty cell or aborts, depending on the setting of\nthe missing_cell  argument.\nThis function can be called only one time in a runset.", "syntax": "ndm_options(\ngenerate_pin_text     = NONE | TOP | ALL,                   //optional\npin_text              = NET_NAME  | PIN_NAME |\nREASSIGN | PORT_NAME,               //optional\ngenerate_polygon_text = NONE  | TOP | ALL,                   //optional\nreplace_instance_name_characters = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                   //optional\nrule_name_delimiter   = \"string\",                           //optional\ndrc_black_box_cells    = {\"string\", ...},                    //optional\nlvs_black_box_cells    = {\"string\", ...},                    //optional\nalternate_view         = NONE | FRAME_VIEW  | DESIGN_VIEW,    //optional\nmissing_cell           = ABORT | IGNORE,                     //optional\ndesign_types           = {ndm_design_type, ...},             //optional\nexclude_design_types   = {ndm_design_type, ...},             //optional\ninternal_designs       = {{use = FILL_USE | FILL_BLOCKAGE_USE,\nout_of_date = ABORT  | USE | DISCARD,\nread_from = TOP | ALL}, ...},     //optional\nsearch_path            = \"string\",                           //optional\ndesign_label          = \"string\",                           //optional\ncut_table_datatype_mapping  = ALWAYS  | NEVER | DATATYPE_ZERO_ONLY,\n//optional\nmerge_blockage_with_layer  = {views = {view_type, ...},\ncells = {\"string\", ...}},\n//optional\nmask_shifted_cell_name_suffix = {name      = \"string\",\nextension = NONE | LAYER_NUM_SHIFT},\n//optional\ninstance_names             = KEEP  | DISCARD,                //optional\nlayout_view_cells          = {\"string\", ...},               //optional\nmerge_blockage_with_layer_before_layer_map = true |false   //optional\n);", "returns": "void\nndm_options()", "arguments": {"generate_pin_text": "Optional. Specifies if pin text is generated. In some design styles, generating net\nnames from pin text can create false text-open error messages. To avoid these\nerror messages, set this argument to NONE  or TOP. The default is ALL.\n\u2022 NONE. Specifies that net names of pins in the hierarchy are not  converted to\ntext.\n\u2022 TOP. Specifies that only net names of pins in the top-level cell are converted\nto text.\n\u2022 ALL. Specifies that net names of all pins in the hierarchy are converted to\ntext.", "pin_text": "Optional. Determines where to get generated text for pins in the NDM library.\nThe default is NET_NAME.\n\u2022 NET_NAME. Reads texts from the net names of the pins.\n\u2022 PIN_NAME. Reads texts from the pin names.\n\u2022 REASSIGN. Reads texts from both the pin name and net name for pins. If\nthe pin name and net name are the same, the IC Validator tool uses the\npin name. If the pin name and net name are different, the IC Validator tool\nuses the net name and tags the text as an assigned net for hierarchical net\nassignment.\nSetting pin_text(REASSIGN)  has the same functionality as manually\nentering cell and net names in the reassign_text  argument of the\ntext_options()  function. Using pin_text(REASSIGN)  provides automated\nassignments when you are using an NDM library.\n\u2022 PORT_NAME. Reads texts from the port names.", "generate_polygon_text": "Optional. Specifies if text points are generated from the net names of polygons\nin the input library when IC Validator reads these polygons. The default is NONE.\n\u2022 NONE. Does not generate text from polygons in the input library.\n\u2022 TOP. Generates polygon text only for the top cell of the design.\n\u2022 ALL. Generates polygon text for all cells in the hierarchy.\nndm_options()", "replace_instance_name_characters": "Optional. Lists the strings to be replaced in instance names. Neither string\ncan use string matching. By default, the IC Validator tool does not replace any\ncharacters.\n\u2022 search_string. Required. Specifies the string to replace.\n\u2022 replace_string. Required. Specifies the replacement string. An empty\nstring (\"\") results in the removal of the specified search string.", "rule_name_delimiter": "Optional. Defines a delimiter for rule names. Use this argument to separate the\nrule name from the violation comment. The violation comment is truncated at the\nfirst instance of this delimiter for reporting in the icv_sdrc.conclude file.\nNote:\nThis delimiter is used only to determine the rule name for the NDM\nicv_sdrc.conclude file and used for the IC Compiler II error browser in\nIn-Design runs.\nIf the delimiter is not matched, the entire violation comment is reported in the\nicv_sdrc.conclude file. The violation comment might be truncated for length; the\nmaximum length of a violation comment is 1024 characters.\n\u2022 search_string. Specifies the delimiter. The search string must be a GNU\nextended regular expression. The default is\n\"[[:space:]]+:|[[:space:]]*:[[:space:]]\"\nThat is, the default is one of the following:\n\u25e6 One or more white space characters followed by a colon.\n\u25e6 Zero or more white space characters followed by a colon followed by one\nwhite space character.\n\u2022 ignore_case. Specifies if the character case in the violation comment is\nconsidered when matching the delimiter. The default is false.\n\u25e6 true. The search is case-sensitive.\n\u25e6 false. The search is not case-sensitive.", "drc_black_box_cells": "Optional. Specifies the\nblack-box cellsDRC\nblack-box cells for DRC. For these cells, the tool first\ntries to read the frame view. If the frame view cannot be found, the tool looks for\na design view. If still no views can be found for the cell, the tool continues with\nan empty cell. The tool reads all objects from the frame view. String matching\nndm_options()\nusing metacharacters is allowed. See String Matching  on page 3353 for more\ninformation.\nNote:\nIf DRC black-box cells are listed, the lvs_black_box_cells\nargument cannot be used. If neither DRC nor LVS black-box cells\nare specified, polygons from design view and pins from frame view\nare read. If the ndm_merge_library_options()  function is used\nin the same IC Validator session, it has precedence over any of its\nreplacement cells that might also exist in the DRC black-box cell list.\nFor the top cell, all data from the design view is read. If the design\nview does not exist for the top cell, an error is reported and the run\nstops.", "lvs_black_box_cells": "Optional. Lists the\nblack-box cellsLVS\nblack-box cells for LVS. If the frame view cannot be found,\nthe tool looks for a design view. If still no views can be found for the cell, the\ntool continues with an empty cell. The tool reads only pins from the frame view.\nString matching using metacharacters is allowed. See\nString Matching  on\npage 3353 for more information.\nNote:\nIf LVS black-box cells are listed, the drc_black_box_cells\nargument cannot be used. If neither DRC nor LVS black-\nbox cells are specified, pins from frame view are read. If the\nndm_merge_library_options()  function is used in the same\nIC Validator session, it has precedence over any of its replacement\ncells that might also exist in the LVS black-box cell list.", "alternate_view": "Optional. Specifies the behavior if the design view is missing. The default is\nFRAME_VIEW.\n\u2022 NONE. Applies the behavior specified by the missing_cell  argument.\n\u2022 FRAME_VIEW. Reads the entire frame view of a cell if the design view is\nmissing. If both the design and frame views are missing, the behavior\nspecified by the missing_cell  argument applies.\nNote:\nThe design view is always required for the top cell of the design.\n\u2022 DESIGN_VIEW.\nndm_options()", "missing_cell": "Optional. Specifies the behavior if a cell is missing a required view, as defined\nby the drc_black_box_cells  and lvs_black_box_cells  arguments. The\ndefault is IGNORE.\n\u2022 IGNORE. Continues the IC Validator run. A warning is reported and missing\nNDM cells are empty.\n\u2022 ABORT. Writes an error message and the run stops. If a cell is in either the\nDRC or LVS black-box cells list, the frame view is required for that cell. If the\ncell is not in a black-box cells list, the design view is required.", "design_types": "Optional. Specifies the design types that determine which cells are read from\nthe NDM library. It does not apply to the top cell. Using the ndm  argument of", "the": "assign()  and assign_edge()  functions, you can specify the design types\nfor certain layers. You can use the exclude_ndm_design_types()  function to\nobtain a list of all possible design types except those specified by the exclude\nargument. By default, the IC Validator tool reads all design types. Table 20  in the\nassign()  function lists the design types.", "exclude_design_types": "Optional. Specifies the design types that determine which cells are not read\nfrom the NDM library. It does not apply to the top cell. If a design type is listed in\nthe design_types  and exclude_design_types  arguments, it is excluded. By\ndefault, the IC Validator tool does not exclude any design types.\nTable 20  in the\nassign()  function lists the design types.\nNote:\nIf a cell type is excluded, no data is read from the cell and no\nsubtrees under the cell are placed.", "internal_designs": "Optional. Specifies the data that is read from internal designs. It is only used for\nfill. The default is\n{{use = FILL_USE, out_of_date = ABORT, read_from = ALL}}\nNote:\nThe fill internal design is read by default. To disable the reading of all\ninternal design settings including fill, set internal_designs = {}.\n\u2022 use. Optional. Specifies the class of internal designs are read.\nWhen using the ndm  argument of the\nassign()  and assign_edge()\nfunctions, you can specify the internal design settings for certain layers.\nndm_options()\n\u25e6 FILL_USE. Specifies reading internal designs that are for fill. These\ninternal designs have the extension .FILL.\n\u25e6 FILL_BLOCKAGE_USE. Specifies reading internal designs that are\nfor fill blockage or guidance. These internal designs have the\nextension, .FILLBLKG.\nNote:\nWhen reading internal designs from NDM, the IC Validator tool\napplies the internal design use designation from the top-most\nparent internal design to all of its descendants. For example, the\ntool recognizes an internal design ending with the .FILL suffix\nas fill. Anything placed underneath that internal design is also\ndesignated as fill, regardless of its suffix.\n\u2022 out_of_date. Optional. Specifies the action taken by the tool if the\ntimestamp of the internal design is earlier than that of the parent design it\nis being read from. The timestamp is only checked on the first level internal\ndesign underneath a given parent design view. The default is ABORT.\n\u25e6 ABORT. Stop the run if the internal design timestamp is earlier than the\ndesign view.\n\u25e6 USE. Reads the internal design regardless of timestamp.\n\u25e6 DISCARD. Discards the internal design if the internal design timestamp is\nearlier than the design view. A warning is reported.\n\u2022 read_from. Optional. Specifies the design view cells that the tool reads\ninternal designs from. The default is TOP.\n\u25e6 TOP. Looks for the internal design only in top cells.\n\u25e6 ALL. Looks for the internal design in each design view.", "search_path": "Optional. Specifies the paths to search for reference libraries. The paths are\nsearched in the order listed. This option is equivalent to the search_path\nvariable within the IC Compiler II tool.", "design_label": "Optional. Specifies the design label of the top cell. The default is no design\nlabel. This option might be overridden by the -ndm_design_label  command-\nline option.\nndm_options()", "cut_table_datatype_mapping": "Optional. Specifies how the IC Validator tool uses cutDataTypeTbl table\ndefinitions in the NDM library. The default is ALWAYS.\n\u2022 ALWAYS. Always uses the cut datatype table, if available in the NDM library,\nand sets datatypes for cut layer shapes as defined in the table.\n\u2022 NEVER. Always uses the datatype of the shape stored in the NDM library and\ndoes not change the datatype based on cut datatype table information.\n\u2022 DATATYPE_ZERO_ONLY. Sets datatypes for cut layer shapes as defined in\nthe cut datatype table only if the datatype of the NDM shape is zero. If the\ndatatype of an NDM shape is non-zero, the datatype is preserved.", "merge_blockage_with_layer": "Optional. Specifies that routing blockages with the isZeroSpacing  attribute set\nto false  are merged with the associated routing layer and treated as routing\nmetal. Only routing blockages in the specified views and cells are considered for\nmerging with the routing layer.\n\u2022 views. Specifies the list of NDM views to consider for merging blockages.\nSee\nTable 16  in the assign()  function section for a list of views. By default,\nno views are considered for merging blockages.\n\u2022 cells. Specifies the list of NDM cells to consider for merging blockages.\nString matching using metacharacters is allowed. For more information, see\nString Matching  on page 3353. By default, all cells are included when views\nare specified.", "mask_shifted_cell_name_suffix": "Optional. Specifies how the cell name suffix is generated for new cells created\nfrom mask shifting on instance placements.\n\u2022 name. Specifies the name to use for the suffix. The default is SHIFT.\n\u2022 extension. Specifies whether to add an additional extension based on\nlayer and shift values to make the final cell name unique. The default is\nLAYER_NUM_SHIFT.\n\u25e6 NONE. Specifies that no additional extension is used.\n\u25e6 LAYER_NUM_SHIFT. Specifies that an additional extension is added based\non layer number and shift amount.\nTable 61  shows the default:\nmask_shifted_cell_name_suffix={\"SHIFT\", LAYER_NUM_SHIFT}\nndm_options()\nTable 61 mask_shifted_cell_name_suffix Default\nOriginal cell name Shifted layers Shifted amount Final cell name\nA 15 15 by 1 A_SHIFT_15_1\nB 17 17 by 1 B_SHIFT_17_1\nC 15, 17 Both 15 and 17 by 1 C_SHIFT_15_1_17_1\nmask_shifted_cell_name_suffix={\"MYSHIFT\", NONE}\nTable 62  shows the shifted cell name changes:\nTable 62 mask_shifted_cell_name_suffix Shifted Cell Names\nOriginal cell name Shifted layers Shifted amount Final cell name\nA 15 15 by 1 A_MYSHIFT\nB 17 17 by 1 B_MYSHIFT\nC 15, 17 Both 15 and 17 by 1 C_MYSHIFT", "instance_names": "Optional. Specifies whether instance names from the input layout should be\nretained by the IC Validator tool. The instance names can be used for netlisting\nor possibly reused for the output layout. Retaining instance names could result\nin extra processing time during the reading of the input layout. The default is\nKEEP.\n\u2022 KEEP. Retains instance names from the input layout.\n\u2022 DISCARD. Does not retain instance names from the input layout.", "layout_view_cells": "Optional. Specifies the layout view that is used for the cell name. For these cells,\nthe tool reads the layout view first. If a layout view cannot be found, the tool\nlooks for a design view. If still no views can be found for the cell, the tool looks\nfor a frame view. The tool reads all objects from the frame view. String matching\nusing metacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. The default is an empty string (\"\").\nndm_options()\nNote:\nThe layout view cells are always specified before DRC or LVS black-\nbox cells, but not before their GDSII or OASIS replacement cells.", "merge_blockage_with_layer_before_layer_map": "Optional. Specifies whether the merge_blockage_with_layer  argument takes\nprecedence over layer mapping. The default is false.\n\u2022 true. Specifies that the merge_blockage_with_layer  argument takes\nprecedence over layer mapping.\n\u2022 false. Specifies that layer mapping takes precedence over the\nmerge_blockage_with_layer  argument."}, "summary": "The ndm_options()  function specifies the behavior of the IC Validator tool when reading\nan NDM library.", "function_name": "ndm_options()"}
{"description": "The negate()  function creates the inverse of the input layer. The boundaries of the\ninverse can be either the layer or chip extents, and can be adjusted with an explicit border.\nA boundary with a negative area results in an empty output layer.", "syntax": "negate(\nlayer1  = polygon_layer,\nextents = LAYER  | CHIP,   //optional\nborder  = double,         //optional\nname    = \"layer_label\"   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "extents": "Optional. Specifies the extent used. The default is LAYER.\n\u2022 LAYER. Uses the extents of the input layer.\n\u2022 CHIP. Uses the extents of the entire chip, as defined by the layers specified\nin assign functions.", "border": "Optional. Specifies the value for sizing the extents box. A negative value shrinks\nthe extents; a positive value expands the extents. The default is 0.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The negate()  function creates the inverse of the input layer.", "function_name": "negate()"}
{"description": "The negate_in_window()  function creates the inverse of the layer1  layer that is within\nthe specified window.", "syntax": "negate_in_window(\nlayer1 = polygon_layer,\nwindow = {left  = double, bottom = double,\nright = double, top = double},\nborder = double,                            //optional\nname   = \"layer_label\"                      //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "window": "Required. Specifies the window used for the negate. The window coordinates\nare in the context of the top cell.", "border": "Optional. Specifies the value for sizing the extents box. A negative value shrinks\nthe extents; a positive value expands the extents. The default is 0.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The negate_in_window()  function creates the inverse of the layer1  layer that is within\nthe specified window.", "function_name": "negate_in_window()"}
{"description": "The net_color_check()  function checks the specified nets to determine if the\ncolor of the net is expected. In the runset, you must call this function after the\ncolor_conflict_layers()  function.", "syntax": "net_color_check(\nconnect_sequence               = connect_database,\ncolor_db                       = color_database,\ncolor_file                     = \"string\",\nreport_file                    = color_report_handle,\nxref_db                        = xref_database_handle,  //optional\nerror_net_output               = ONE  | ALL,             //optional\nreport_errors                  = {UNMATCHED_TEXT},      //optional\nignore_missing_color          = true | false,          //optional\nignore_terminal_missing_color  = true | false,          //optional\nname                          = \"layer_label\"          //optional\n);", "returns": "void", "arguments": {"connect_sequence": "Required. Specifies the connect database. If you are using the", "xref_db": "Optional. Specifies the handle of the database from which all the cell names and\nnet names in the color file are interpreted as schematic names. If an xref_db  is\nnot provided, all of the names are interpreted as layout names. The handle must\nbe previously defined by the\ncompare()  function.", "color_db": "Required. Specifies the color database generated by the\ncolor_conflict_layers()  function. The color database describes the colors\nof all interested layers. All layers in the color database must be connected in the\nconnect database.", "color_file": "Required. Specifies the color rules file, which is an ASCII file. This file defines\nthe rules that the net_color_check()  function checks.", "report_file": "Required. Specifies the handle of the color report. This report includes all errors\nand a summary of the violations for the execution of the net_color_check().\nnet_color_check()\nThe color_report_handle must be defined by the net_color_report_file()\nfunction before you call the net_color_check()  function.", "error_net_output": "Optional. Specifies the coordinates used for error reporting. The default is ONE.\nThe net_color_check()  function checks each color rule based on the input\ncolor database and connectivity from the connect database. The checking of\neach rule is independent.\nEach color rule specifies the expected colors of one net. If the target net\nconnects to an unexpected color, it is considered as a conflict color layer and\nviolations are reported.\n\u2022 ONE. Reports only one coordinate from each conflict color layer.\n\u2022 ALL. Reports all coordinates of each conflict color layer.", "report_errors": "Optional. Specifies the types of additional errors to report. The default is an\nempty list.\n\u2022 UNMATCHED_TEXT. Reports an error if the net is not texted with a net\nname that is in the color rules file. The color rules file is specified with the\ncolor_file  argument. This option is available only when you specify a\ndatabase with the xref_db  argument.", "ignore_missing_color": "Optional. Specifies how missing layers are treated if a device terminal. The\ndefault is false.\n\u2022 true. Ignores missing layers.\n\u2022 false. Treats missing layers as an error.", "ignore_terminal_missing_color": "Optional. Specifies how missing layers are treated if a device terminal does not\ninteract with any conflict or correct colors. The default is false.\n\u2022 true. Ignores missing layers.\n\u2022 false. Treats missing layers as an error.\nnet_color_check()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The net_color_check()  function checks the specified nets to determine if the\ncolor of the net is expected.", "function_name": "net_color_check()"}
{"description": "The net_color_report_file()  function defines a file where the\nnet_color_check()\nfunction reports error data.\nNote:\nYou must define a unique error report file for\nnet_color_check()  function.", "syntax": "net_color_report_file(\nfile  = \"string\"\n);", "returns": "color_report_handle", "arguments": {"file": "Required. Names the error report file."}, "summary": "The net_color_report_file()  function defines a file where the\nnet_color_check()\nfunction reports error data.", "function_name": "net_color_report_file()"}
{"description": "The net_device_count()  function selects polygons from nets in the device database that\nfit the specified criteria.", "syntax": "net_device_count(\ndevice_db          = device_database,\ncount              = integer,                               //optional\ndevices            = {{device_name   = \"string\",\ndevice_layers = {polygon_layer, ...},\ndevice_type   = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC |\nALL},\n...},                                     //optional\nconnected_to_any   = {polygon_layer, ...},                  //optional\nnet_type           = NOT_TEXTED | TEXTED | ALL,             //optional\ntexted_with        = {\"string,\" ...},                       //optional\noutput_from_layers = {polygon_layer, ...},                  //optional\nerror_coordinates  = TEXT | POLYGON,                        //optional\nprocessing_mode    = CELL_LEVEL | HIERARCHICAL              //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.", "count": "Optional. Specifies the number of unique devices that must be on a net for the\nnet to be selected. These values must be nonnegative. See\nConstraints  on\npage 3344 for more information. The default is 0.\n\u2022 If count  is 0, a net is selected if there are no devices connected to the net.\n(This net is a floating net.)\n\u2022 If count  is 1, a net is selected if there is only one device connected to the\nnet. (This net is a one-connection net.)\nnet_device_count()", "devices": "Optional. Lists the devices and layers that determine if a net is connected to a\ndevice. The default is all devices.\n\u2022 device_name. Required. Specifies the device, which must be defined in the\ndevice_db  argument.\n\u2022 device_layers. Optional. Specifies the layers that must be defined for a\nparticular device. When the layer list is empty, all terminal layers are used.\n\u2022 device_type. Optional. Specifies the device type. The default is ALL.", "connected_to_any": "Optional. Specifies the layers to be selected for output. At least one of these\nlayers must be on the net. By default, the IC Validator tool does not require any\nspecific layers.", "net_type": "Optional. Specifies the net types to be considered for selection. The default is\nALL.\n\u2022 NOT_TEXTED. Specifies that only untexted nets are considered.\n\u2022 TEXTED. Specifies that only texted nets are considered.\n\u2022 ALL. Specifies that both texted and untexted nets are considered.", "texted_with": "Optional. Specifies the text strings. To be selected for output, one of these\nstrings must text the net. String matching using metacharacters is allowed. See\nString Matching  on page 3353 for more information. By default, the IC Validator\ntool considers all nets for selection.", "output_from_layers": "Optional. Specifies the layers from which polygons are collected from selected\nnets. These layers must be in the connect database that is in the device\ndatabase.\nBy default, the IC Validator tool collects polygons from all layers specified in the\nconnected_to_any  argument. If the connected_to_any  argument is empty,\nthen polygons from all layers in the connect database are collected.", "error_coordinates": "Optional. Coordinates used for error reporting. The default is POLYGON.\nnet_interact()\nNote:\nThis argument is used only for error reporting. It does not affect the\nderived layer.\n\u2022 POLYGON. Reports an arbitrary coordinate on an arbitrary polygon from an\narbitrary layer in the output_from_layers  argument on the selected nets.\n\u2022 TEXT. Reports the coordinate of the text on the selected nets. If there is no\ntext on the net, then the error_coordinates  argument setting reverts to\nPOLYGON.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell."}, "summary": "The net_device_count()  function selects polygons from nets in the device database that\nfit the specified criteria.", "function_name": "net_device_count()"}
{"description": "The net_interact()  function checks the net interactions between two polygon\nlayers. For each net in layer1, the net_interact()  function calculates the number of\nnet_interact()\ninteractions with layer2  polygons on distinct nets. A layer1  net is selected when this\nnumber meets the count  constraint.", "syntax": "net_interact(\nconnect_sequence   = connect_database,\nlayer1             = polygon_layer,\nlayer2             = polygon_layer,\ncount              = integer_constraint,    //optional\ninclude_touch      = NONE  | EDGE,           //optional\nnet_output         = ONE | ALL,             //optional\nname                = \"layer_label\"          //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "layer1": "Required. Specifies a polygon layer. It must be in the connect database.", "layer2": "Required. Specifies a polygon layer. It must be in the connect database.", "count": "Optional. Specifies the number of layer2  nets that must be interacted with. See\nConstraints  on page 3344 for more information. The default is >0. For a net, if\nany layer1  polygons interact with a layer2  polygon on any net, the two nets\nform an interaction. An interaction is counted even if both polygons are on the\nsame net.", "include_touch": "Optional. Specifies the types of touches that provide a net interaction. The\ndefault is NONE.\n\u2022 NONE. Specifies that nets must share active area to form a net interaction.\n\u2022 EDGE. Specifies that outside edge touches also form a net interaction.", "net_output": "Optional. Specifies the polygons used for output for each selected net. The\ndefault is ALL.\nnet_interact()\n\u2022 ONE. Reports an arbitrary layer1  polygon for each interacted layer2  net.\n\u2022 ALL. Reports every layer1  polygon.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The net_interact()  function checks the net interactions between two polygon\nlayers.", "function_name": "net_interact()"}
{"description": "The net_number()  function returns the integer value of a given net ID. This function can\nbe used by any remote function that has access to net ID identifiers.", "syntax": "net_number(\nin_net_id  = net_id\n);", "returns": "An integer value representing the net number associated with the specified net ID.\nnet_number()", "arguments": {"in_net_id": "Required. Specifies the net ID for which the integer net number is to be\nreturned."}, "summary": "The net_number()  function returns the integer value of a given net ID.", "function_name": "net_select()"}
{"description": "The net_options()  function controls the declaration of schematic power, ground, and\nglobal nets in the schematic netlist. Netlists can be modified to join nets\nnets, joiningjoining nets\nin both the\nschematic and layout netlists. This function must be called before assign functions.\nYou can choose the source of the global nets:\nNote:\nThe global net settings in the\nschematic()  function add global netlists into the\ntranslated netlist. The read_netlist_global  argument of the net_options()\nfunction controls if the global netlists are used during the compare operation.\n\u2022 Do not use any global nets by setting\nschematic_global = { }\nread_netlist_global = false\n\u2022 Use only runset global nets by setting\nschematic_global = { VDD, GND }\nread_netlist_global = false\n\u2022 Use netlist global nets only by setting\nschematic_global = { }\nread_netlist_global = true\n\u2022 Use both the runset and netlist global nets by setting\nschematic_global = { VDD, GND }\nread_netlist_global = true", "syntax": "net_options(\nschematic_power      = {\"string\", ...},          //optional\nschematic_ground     = {\"string\", ...},          //optional\nschematic_global     = {\"string\", ...},          //optional\nschematic_join_net    = {{\"string\", ...}, ...},   //optional\nlayout_join_net      = {{\"string\", ...}, ...},   //optional\nread_netlist_global   = true  | false,             //optional\nreport_coordinates    = {DEVICE_PIN, EQUIV_PORT},  //optional\nignore_metacharacters= NONE  | BRACKET  //optional\n);\nnet_options()", "returns": "void", "arguments": {"schematic_power": "Optional. Specifies the net names used to name a power net in the schematic.\nThese names are used by compare during merging and filtering operations.\nThe following characters are not allowed in net names: space, tab, and the\nreserved characters\n= { } , \"", "schematic_ground": "Optional. Specifies the net names used to name the ground net in the\nschematic. These names are used by compare during merging and filtering\noperations.\nThe following characters are not allowed in net names: space, tab, and the\nreserved characters\n= { } , \"", "schematic_global": "Optional. Specifies the schematic net names that are treated as global during\nnetlist comparison. These nets are also referred to as runset global nets.\nTypically, these nets are power and ground nets, which are assumed to be\nglobally connected. If no nets are specified in an LVS runset, the compare\nprocess attempts to automatically produce them based on global net information\nin the schematic netlist and typical global net names. Global schematic nets not\nspecified as global are treated as local nets.\nThe following characters are not allowed in net names: space, tab, and the\nreserved characters\n= { } , \"", "schematic_join_net": "Optional. Lists the individual schematic net names to be joined to form single\nnets. You can only join top-level nets.", "layout_join_net": "Optional. Lists the individual layout net names to be joined to form single nets.\nYou can only join top-level nets.\nnet_options()", "read_netlist_global": "Optional. Selects the reading and processing of global nets from the input\nschematic or layout netlist. The default is true.\nNote:\nThe IC Validator tool uses global nets from the netlist independent of\nthe schematic_global  argument of the net_options()  function and\nthe promote_text  argument of the text_options()  function.\nIf the read_netlist_global  argument is true  and the runset specifies a non-\nempty list for the schematic_global  argument of the net_options()  function\nor the promote_text  argument of the text_options()  function, the list of\nglobal nets is the concatenation of the runset specified values and the values\nread from the global nets in the netlist.\n\u2022 true. Reads the global nets from the netlist for schematic global texts. Also,\nreads layout global texts from the specified layout file if the layout_file\nargument of the read_layout_netlist()  function is used. This information\nis used for propagating global nets inside the netlist.\n\u2022 false. Ignores the global nets from the specified netlist if the layout_file\nargument of the read_layout_netlist()  function is used.", "report_coordinates": "Optional. Controls the reporting of equivalence cell port coordinates in the\nsum.cell.cell  file and the highlighting of equivalence cell ports in VUE. By default,\nthe IC Validator tool does not display or report any port or pin coordinates.\n\u2022 EQUIV_PORT. Reports equivalence cell port coordinates in the sum.cell.cell\nfile and highlights equivalence cell ports in VUE.\n\u2022 DEVICE_PIN. Reports device pin coordinates in the sum.cell.cell  file and\nhighlights device pins in VUE.", "ignore_metacharacters": "Optional. Controls how metacharacters are handled in text names. This option\nprovides two settings:\n\u2022 NONE. All metacharacters are not ignored. This is the default behavior,\nmeaning that metacharacters like [ and ]  in text names require escaping\nwith //  to be processed correctly.\n\u2022 BRACKET: Only the [ and ]  characters are ignored. When this setting is\nused, text names containing [ and ]  can be directly input without needing to\nescape them with //. However, for cell names, the [ and ]  characters still\nrequire escaping with //.\nnet_options()"}, "summary": "The net_options()  function controls the declaration of schematic power, ground, and\nglobal nets in the schematic netlist.", "function_name": "net_options()"}
{"description": "The net_path_check()  function selects polygons from nets on the specified path,\npath_to  argument, of the device database that fit the specified criteria. This function\nchecks nets to determine if a path exists to a power or ground net through resistor devices\nand the source or drain of MOS devices. All nets are processed within the context of the\ntop cell.", "syntax": "net_path_check(\ndevice_db          = device_database,\ndevices            = {\"string\", ...},         //optional\npower              = {\"string\", ...},         //optional\nground             = {\"string\", ...},         //optional\nother_nets         = {\"string\", ...},         //optional\nfilter_nets        = {TOP_PORT, FLOATING, POWER, GROUND,\nOTHER_NETS, BREAK_PATH},\n//optional\npath_to            = NONE  | POWER | GROUND | POWER_AND_GROUND |\nPOWER_OR_GROUND | POWER_XOR_GROUND | OTHER_NETS,\n//optional\nunused_device      = CONNECT  | IGNORE,\n//optional\noutput_from_layers = {polygon_layer, ...},\n//optional\nbreak_path          = {{texts = {\"string\", ...},\ncells = {\"string\", ...}},...},  //optional\nfilter_devices      = {{device_type = NMOS | PMOS | NPN | PNP |\nPN | NP |  RESISTOR |\nCAPACITOR | INDUCTOR |\nGENERIC,}\ndevice_names = {\"string\", ...},\n//optional\n...},\nconnect_sequence     = connect_database                 //optional\n);", "returns": "polygon layer or error result", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.\nnet_path_check()", "devices": "Optional. Locates the net paths using the specified devices. The default is all\ndevices of the NMOS, PMOS, and RES  types.", "power": "Optional. Determines the text for the power net in the layout using the specified\nstrings. String matching using metacharacters is allowed. See\nString Matching\non page 3353 for more information.\nIf no text is specified here, by default, the IC Validator tool uses the text\nspecified in the layout_power  argument of the\ntext_options()  function. A\nrunset error occurs if no text is specified in the layout_power  argument of the\ntext_options()  function.\nNote:\nThe net_path_check  function searches for power text only in the top\ncell.", "ground": "Optional. Specifies the text strings for the ground net in the layout. String\nmatching using metacharacters is allowed. See\nString Matching  on page 3353\nfor more information.\nIf no text is specified here, the default ({}) is to use the text specified in\nthe layout_ground  argument of the\ntext_options()  function. A runset\nerror occurs if no text is specified in the layout_ground  argument of the\ntext_options()  function.\nNote:\nThe net_path_check()  function searches for ground text in only the\ntop cell.", "other_nets": "Optional. Specifies the text strings for additional nets when the path_to\nargument is NONE  or OTHER_NETS. String matching using metacharacters is\nallowed. See String Matching  on page 3353 for more information.\nNote:\nThe net_path_check()  function searches for text in additional nets\nonly in the top cell.", "filter_nets": "Optional. During output, ignores the specified net types. The default is no\nfiltering.\nnet_path_check()\n\u2022 TOP_PORT. Ignores nets that are connected to top-level ports.\n\u2022 FLOATING. Ignores nets that are floating (not connected to any device).\n\u2022 POWER. Ignores power nets.\n\u2022 GROUND. Ignores ground nets.\n\u2022 OTHER_NETS. Ignores additional nets when the path_to  argument is NONE.\nSee the other_nets  argument for more information.\n\u2022 BREAK_PATH. Ignores the net defined in break_path  argument.", "path_to": "Optional. Specifies the connections required for a net to be selected. The default\nis NONE.\n\u2022 NONE. Specifies that the net does not connect to the specified power, ground,\nor other nets.\n\u2022 POWER. Specifies that the net connects only to power.\n\u2022 GROUND. Specifies that the net connects only to ground.\n\u2022 POWER_AND_GROUND. Specifies that the net connects to both power and\nground.\n\u2022 POWER_XOR_GROUND. Specifies that the net connects to power or ground but\nnot both.\n\u2022 POWER_OR_GROUND. Specifies that the net connects to power or ground, or\nboth.\n\u2022 OTHER_NETS. Specifies that the net connects to other_nets  but not power or\nground.", "unused_device": "Optional. Specifies if unused devices are used in forming paths. The default is\nCONNECT.\n\u2022 CONNECT. Specifies that unused devices form connections.\n\u2022 IGNORE. Specifies that unused devices do not form connections.\nThe unused devices for the net_path_check()  function are:\n\u2022 MOS devices with source or drain shorted\n\u2022 MOS devices with ground, source, or drain floating\n\u2022 PMOS device with gate connected to power\nnet_path_check()\n\u2022 PMOS with source or drain connected to power\n\u2022 NMOS with gate connected to ground\n\u2022 NMOS with source or drain connected to ground", "output_from_layers": "Optional. Specifies the layers from which polygons are collected from selected\nnets to create the output layer or report errors. These layers must be in the\nconnect database that is in the device database.\nBy default, the IC Validator tool collects polygons from all layers in the connect\ndatabase.", "break_path": "Optional. Lists the text on specified cells that breaks path propagation.\n\u2022 texts. Required. Specifies the text strings that break path propagation.\nString matching using metacharacters is allowed. See\nString Matching  on\npage 3353 for more information.\n\u2022 cells. Optional. Specifies the cells from which text from the texts  option\nbreaks propagation. String matching using metacharacters is allowed.\nSee\nString Matching  on page 3353 for more information. By default, path\nbreaking applies to the top cell for text specified in the texts  option. To\nspecify all cells, set {\u201d*\u201d} to the cells  argument.", "filter_devices": "Optional. Sets the devices to filter, but excludes the devices set to\nnet_path_check(). Use the return value of the", "get_filtered_devices": "function or manually set the filter_devices  argument.\n\u2022 device_type. Specifies the device type.\n\u2022 device_names. Specifies the layout devices. Each device must match a\ndevice specified in a device_name  argument of a device configuration\nfunction.", "connect_sequence": "Optional. Specifies the derived connectivity other than device_db. When this\nargument is set, the net_path_check()  function honors the connectivity in this\ndatabase over the device database. This connectivity must be derived from\nthe device database in the get_netlist_connect_database()  function. The\nstamp()  function can be applied to generate the derived connect database for\na specific use. If there is no derived connectivity, it is recommended that you do\nnot set this argument. The default is NULL_CONNECT_DATABASE.\nnet_path_check()"}, "summary": "The net_path_check()  function selects polygons from nets on the specified path,\npath_to  argument, of the device database that fit the specified criteria.", "function_name": "net_path_check()"}
{"description": "The net_polygon_by_property()  function makes a copy of a polygon layer with\nproperties collected from net information. A remote function is executed one time for each\npolygon specified in the output_from_layer  argument. The remote function specifies the\nproperties to be written for each polygon.\nNote:\nProperties on a polygon layer are only recognized by the drc_features(),\nnet_polygon_by_property(), and select_by_double_property()\nfunctions. All other functions ignore properties on a polygon layer and do not\npropagate the properties to their result.\nFor example, you can use this function for a metal spacing based on text check:\n1. Call the\ntext_to_double_property()  function to convert text to properties.\n2. Use the connect()  function to add the output of the text_to_double_property()\nfunction to the connect database.\n3. Use a remote function called in the net_polygon_by_property()  function to\naccumulate net properties for each polygon.\n4. Perform spacing checks using the IC Validator functions.\n5. Use the\ndrc_features()  function to check the properties on the polygons associated\nwith each spacing violation.", "syntax": "net_polygon_by_property(\nconnect_sequence      = connect_database,\noutput_from_layer     = polygon_layer,\nnet_polygon_function  = function,\nlayer_groups          = {\"string\" => {polygon_layer, ...}, ...},\nname                  = \"layer_label\"                       //optional\n);", "returns": "polygon layer", "arguments": {"connect_sequence": "Required. Specifies the connect database.\nnet_polygon_by_property()", "output_from_layer": "Required. Specifies the layer used for selecting polygons for the output. This\nlayer must be in the connect database.", "net_polygon_function": "Required. Specifies the remote function containing the conditions relative\nto net properties and characteristics. The function calculates and saves the\nproperties. This function is called one time for every polygon specified in the\noutput_from_layer  argument. See\nNet Polygon by Property Utility Functions\nfor more information about the utility functions you can use to define this remote\nfunction.", "layer_groups": "Required. Specifies a hash of string to polygon layers. The strings are used by\nthe remote function to access the layer-based properties on a given net. All of\nthese layers must be connected.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The net_polygon_by_property()  function makes a copy of a polygon layer with\nproperties collected from net information.", "function_name": "net_polygon_by_property()"}
{"description": "The net_polygon_select()  function selects polygons from nets in the specified connect\ndatabase that fit the specified criteria.\nThe function creates two distinct outputs:\n\u2022 The function returns a layer that is created by selecting polygons from the input\nproperty layer, which is specified by the in_property_layer  argument, that fit the\nspecified constraints.\n\u2022 Also, the function can create a property layer, which is specified by the\nout_property_layer  argument, by selecting polygons from the input property layer\nthat fit the specified constraints. The property layer polygons have specific properties\nattached to them.\nA remote function specifies arithmetic conditions relative to net parameters and polygon\nproperties. To be selected, a polygon must meet all specified constraints and must be\nsaved in the remote function.\nFor example, accumulation of charge on the gate layer of a CMOS design can be\nrepresented by saving property values to gate layer polygons, adding additional\nconnectivity, and then reading the polygon properties and including them into new\ncalculations.\nErrors for the selected polygons are reported to the LAYOUT_ERRORS file, and appear\nas an X in VUE.", "syntax": "net_polygon_select(\nconnect_sequence         = connect_database,\nin_property_layer        = property_layer,\nout_property_layer       = out_property_layer,\nnet_polygon_function     = function,\nlayer_groups             = {\"string\" => {polygon_layer, ...},\n...},                           //optional\nconnected_to_all         = c            //optional\nnot_connected_to_all     = {polygon_layer, ...},            //optional\nconnected_to_any         = {polygon_layer, ...},            //optional\nnot_connected_to_any     = {polygon_layer, ...},            //optional\nnet_type                 = NOT_TEXTED | TEXTED | ALL,       //optional\ntexted_with              = {\"string\", ...},                 //optional\ntexted_at                = TOP_OF_NET  | ANY_LEVEL | HIGHEST_TEXT,\n//optional\noutput_from_layers       = {polygon_layer, ...},            //optional\ngroup_errors             = true | false,                    //optional\nname                     = \"layer_label\",          //optional\nnet_polygon_select()\nsave_layer_properties     = true | false,                  //optional\nnet_double_property_constraints  = {{\"property name\",\nconstraint of double}..},      //optional\nlayer_names               = {\"string\", ...}     //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "in_property_layer": "Required. Specifies the property layer where previously stored properties are\npassed to the net_polygon_function  argument. This layer is created by a\nprevious net_polygon_select()  function or by the\ninitialize_property()\nfunction.", "out_property_layer": "Required. Specifies the output property layer where properties are stored when", "the": "nps_save_property()  utility function is called. This layer can be the input\nproperty layer of a subsequent call to the net_polygon_select()  function.", "net_polygon_function": "Required. Specifies the remote function containing the arithmetic conditions for\nlayer parameters on a net that must be met in order for a polygon or net to be\nselected. It also provides access to storing and retrieving properties. See\nNet\nPolygon Select Utility Functions  for more information about the utility functions\nyou can use to define a remote function.", "layer_groups": "Optional. Specifies the hash of string to polygon layers. The strings are used by\nthe remote function to access the layer-based parameters on a given net. The\ndefault is an empty hash ({}).", "connected_to_all": "Optional. Specifies the layers. To be selected for output, all of these layers must\nbe on the net. By default, the IC Validator tool does not require any specific\nlayers.\nnet_polygon_select()", "not_connected_to_all": "Optional. Specifies the layers. If all layers are on the net, the net is not selected.\nBy default, the IC Validator tool does not exclude any layers.", "connected_to_any": "Optional. Specifies the layers. To be selected for output, at least one of these\nlayers must be on the net. By default, the IC Validator tool does not require any\nspecific layers.", "not_connected_to_any": "Optional. Specifies the layers. If any one of the layers is on the net, the net is not\nselected. By default, the IC Validator tool does not exclude any layers.", "net_type": "Optional. Specifies the net types to be checked. The default is ALL.\n\u2022 NOT_TEXTED. Checks only untexted nets.\n\u2022 TEXTED. Checks only texted nets.\n\u2022 ALL. Checks both texted and untexted nets.", "texted_with": "Optional. Specifies the text strings. To be selected for output, the text must\nmatch at least one of these strings. String matching using metacharacters is\nallowed. See\nString Matching  on page 3353 for more information. Specifying {}\nignores all text. The default ({*}) is all texted nets.", "texted_at": "Optional. Specifies where to search for the text. The default is TOP_OF_NET.\nNote:\nIf the net_type  argument is NOT_TEXTED, the texted_with  argument\nis ignored.\n\u2022 TOP_OF_NET. Searches only in the top hierarchical level of each net for text.\nIf text is not found at the top hierarchical location, the net_select()  function\nconsiders this net as untexted.\n\u2022 ANY_LEVEL. Searches nets at all hierarchical levels for text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\nnet_polygon_select()\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "output_from_layers": "Optional. Specifies the layers from which polygons are collected from selected\nnets to create the output layer or report errors. These created errors honor the\nlimit defined in error_options(polygon_limit_per_net)These layers must\nbe in the connect database.\nIf you specify an empty list ({}), the in_property_layer  polygons are output.\nThe default is the layers specified in layer_groups  argument. If it is empty, all\nlayers in the connect database are used.", "group_errors": "Optional. Specifies the type of sorting (grouping) to perform on the errors\nreported to the LAYOUT_ERRORS file. The default is false.\n\u2022 true. Sorts errors by their net ID within a given cell.\n\u2022 false. Does not sort errors.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "save_layer_properties": "Optional. Specifies if the tool saves the properties on the property layer. The\ndefault is false.", "net_double_property_constraints": "Optional. Specify the names of net double properties and their corresponding\nconstraints. These net properties should be saved by a preceding\nproperty_to_net(). To be selected for output, a net must retain net double\nproperties with the specified names and their property values must qualify the\ncorresponding constraints. When the corresponding net property of a given\nname cannot be found for a net, the value is 0 (zero) is used for the qualification.\nnet_polygon_select()", "layer_names": "Optional. Specifies the layer names for each group_name  in the layer_groups\nhash. The default is empty, which automatically builds a string-to-string hash\nbased on layer_groups  option."}, "summary": "The net_polygon_select()  function selects polygons from nets in the specified connect\ndatabase that fit the specified criteria.", "function_name": "net_polygon_select()"}
{"description": "The net_property_select()  function selects polygons from nets in the connect\ndatabase that meet the criteria specified in the function arguments and remote function.\nA remote function is used to read and write net properties as well as specify arithmetic\nconditions relative to net parameters. To be selected, a net must fit all specified constraints\nand must be saved in the remote function.\nFor example, you can use the net_property_select()  function to detect antenna\nviolations. The ratio of area or perimeter of one layer to another layer is calculated and\nsummed using the net-based properties for several increments of connect databases. The\nremote function can be coded to output errors when the cumulative antenna ratio exceeds\na certain threshold.\nErrors are reported to the LAYOUT_ERRORS file, and appear as an X in VUE.", "syntax": "net_property_select(\nconnect_sequence      = connect_database,\nin_property            = net_property,\nout_property          = out_net_property,\nnet_property_function = function,\nlayer_groups          = {\"string\" => {polygon_layer, ...},\n...},                               //optional\nconnected_to_all      = {polygon_layer, ...},               //optional\nnot_connected_to_all  = {polygon_layer, ...},               //optional\nconnected_to_any      = {polygon_layer, ...},               //optional\nnot_connected_to_any  = {polygon_layer, ...},               //optional\nnet_type              = NOT_TEXTED | TEXTED | ALL,          //optional\ntexted_with           = {\"string\", ...},                    //optional\ntexted_at             = TOP_OF_NET  | ANY_LEVEL | HIGHEST_TEXT,\n//optional\noutput_from_layers    = {polygon_layer, ...},               //optional\ngroup_errors          = true | false,                       //optional\nerror_net_output      = ONE  | ALL | TEXT,                   //optional\nname                  = \"layer_label\"                       //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies a connect database.\nnet_property_select()", "in_property": "Required. Specifies the net-based property layer. Use the\ninitialize_net_property()  function to initialize the property.", "out_property": "Required. Specifies the updated net-based property layer.", "net_property_function": "Required. Specifies the remote function containing the conditions relative to\nnet properties and net layers that must be met for a net to be selected. This\nfunction is called one time for every net that meets the constraints specified by\nthe net_property_select()  function. See\nNet Property Select Utility Functions\nfor more information about the utility functions you can use to define this remote\nfunction.", "layer_groups": "Optional. Specifies the hash of string to polygon layers. The strings are used by\nthe remote function to access the layer-based properties on a given net. The\ndefault is an empty hash.", "connected_to_all": "Optional. Specifies the layers. To be selected for output, all of these layers must\nbe on the net. By default, the IC Validator tool does not require any specific\nlayers.", "not_connected_to_all": "Optional. Specifies the layers. If all layers are on the net, the net is not selected.\nBy default, the IC Validator tool does not exclude any layers.", "connected_to_any": "Optional. Specifies the layers. To be selected for output, at least one of these\nlayers must be on the net. By default, the IC Validator tool does not require any\nspecific layers.", "not_connected_to_any": "Optional. Specifies the layers. If any one of the layers is on the net, the net is not\nselected. By default, the IC Validator tool does not exclude any layers.", "net_type": "Optional. Specifies the net types to be checked. The default is ALL.\nnet_property_select()\n\u2022 NOT_TEXTED. Checks only untexted nets.\n\u2022 TEXTED. Checks only texted nets.\n\u2022 ALL. Checks both texted and untexted nets.", "texted_with": "Optional. Specifies the strings. To be selected for output, the text must match at\nleast one of these strings. String matching using metacharacters is allowed. See\nString Matching  on page 3353 for more information. Specifying {}  ignores all\ntext. By default, the IC Validator tool selects all text nets.\nNote:\nTo select only texted nets, the net_type  argument must be set to\nTEXTED.\nIf the net_type  argument is left at the default setting of ALL, the\nnet_property_select()  function returns both texted and untexted\nnets. For example, if you set texted_with={\"VCC\"}  but do not\nspecify the net_type  argument, then the net_property_select()\nfunction returns all nets texted with VCC and all untexted nets.\nIf the net_type  argument is NOT_TEXTED, the texted_with  argument\nis ignored.", "texted_at": "Optional. Specifies where to search for the text. The default is TOP_OF_NET.\n\u2022 TOP_OF_NET. Searches only in the top hierarchical level of each net for text.\nIf text is not found at the top hierarchical location, the net_select()  function\nconsiders this net as untexted.\n\u2022 ANY_LEVEL. Searches nets at all hierarchical levels for text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.\nnet_property_select()", "output_from_layers": "Optional. Specifies the layers from which polygons are collected from selected\nnets to create the output layer or report errors. These layers must be in the\nconnect database.\nThe default is the layers specified in layer_groups  argument. If it is empty, all\nlayers in the connect database are used.", "group_errors": "Optional. Specifies the type of sorting (grouping) to perform on the errors\nreported to the LAYOUT_ERRORS file. The default is false.\n\u2022 true. Sorts errors by their net ID within a given cell.\n\u2022 false. Does not sort errors.", "error_net_output": "Optional. Specifies the coordinates used for error reporting. The default is ONE.\nNote:\nThis argument is used only for error reporting and does not affect\nthe derived layer. To filter derived layers, see the\ndata_filter()\nfunction.\n\u2022 ONE. Reports an arbitrary coordinate on an arbitrary polygon from an arbitrary\nlayer listed in the output_from_layers  argument on the selected nets.\n\u2022 ALL. Reports an arbitrary coordinate on every polygon from each layer listed\nin the output_from_layers  argument on the selected nets.\n\u2022 TEXT. Reports a coordinate of the text on the selected nets.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The net_property_select()  function selects polygons from nets in the connect\ndatabase that meet the criteria specified in the function arguments and remote function.", "function_name": "net_property_select()"}
{"description": "The net_select_error()  function selects error layer polygons that fit the specified\ncriteria. A remote function determines which error layer polygons are selected based on\ncoupling information in the specified connect database and other criteria defined by the\nnet_function  argument.\nYou can use a remote function to access and process layer-based net\nparameters. To select information for output, you must specify an error layer in the\noutput_from_coupled_layers  argument and use the ns_save_coupled_layer()  utility\nfunction in the net_select_error()  remote function. The output can be written as an\nerror result to the LAYOUT_ERRORS file or to a runset error layer that can be processed\nby another error-layer-processing function, such as the drc_features()  function.\nThe net_select_error()  function can use any of the net select functions with the\nfollowing exceptions:\n\u2022 You cannot use the ns_save_net()  and ns_save_all_nets()  functions.\n\u2022 You cannot use the ns_coupled_layer_area()  function to return the area information\nof an error layer defined in the coupled_layer  argument.", "syntax": "net_select_error(\nconnect_sequence     = connect_database,\nnet_function         = function,\ncoupled_layers       = {{layers   = {\"string\" => geometry_layer},\nby_layer = geometry_layer}, ...},\noutput_from_coupled_layers  = {error_layer},\nlayer_groups         = {\"string\" => {polygon_layer, ...},\n...},                               //optional\nconnected_to_all     = {polygon_layer, ...},                //optional\nnot_connected_to_all = {polygon_layer, ...},                //optional\nconnected_to_any     = {polygon_layer, ...},                //optional\nnot_connected_to_any = {polygon_layer, ...},                //optional\nnet_type             = NOT_TEXTED | TEXTED | ALL,           //optional\ntexted_with          = {\"string\", ...},                     //optional\ntexted_at            = TOP_OF_NET  | ANY_LEVEL | HIGHEST_TEXT,\n//optional\nname                 = \"string\",                            //optional\nschematic_nets        = {\"string\", ...},                     //optional\nschematic_nets_file   = \"string\",                            //optional\ntexted_with_file      = \"string\",                            //optional\nxref_db              = xref_database_handle,                //optional\nreport_net_names      = true | false,                        //optional\nnetlist_db           = perc_netlist_ndb,                    //optional\nreport_string_properties   = {{error_name = \"string\",\nnet_select_error()\nproperty_name = \"string\",\nappend_to_vue_description =\ntrue  |\nfalse}},        //optional\npredicate        = true  | false                        //optional\n);", "returns": "error layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database. If you are using the", "xref_db": "Optional. Specifies the handle of the database from which the layout hierarchical\nnet corresponding to the names specified in the schematic_nets  argument is\nselected. The handle must be previously defined by the\ncompare()  function.\nSee Example 2: Using the xref_db Argument  for more information.", "net_function": "Required. Specifies the remote function containing the conditions, relative to\nthe parameters of layers on a net, that must be met for a net to be selected.\nThis function is called one time for each net that meets the constraints specified\nby the following arguments: connected_to_all, not_connected_to_all,\nconnected_to_any, not_connected_to_any, net_type, texted_with,\ntexted_with_file, schematic_nets, schematic_nets_file, and\noutput_from_coupled_layers.\nBy default, the remote function is called one time for each net touching the error\nlayer specified in the output_from_coupled_layers  argument.\nSee\nNet Select Utility Functions  for more information about the utility\nfunctions you can use to define a remote function. However, do not use the\nns_save_net()  utility function because the net_select_error()  function does\nnot have an output_from_layer  argument.", "coupled_layers": "Required. Specifies a list of hash of string to polygon and error layers, which is\nused to define the coupling relationships between different nets for certain types\nof checks.\nEach hash in this argument contains two options, a required layers  option and\nan optional by_layer  option. The layers  option should contain all of the layers\nneeded to define the coupling relationship between two nets. Use the by_layer\noption to specify an unconnected polygon layer or error layer that defines the\ncoupling relationship between the connected layers listed in the layers  option.\nnet_select_error()\nThe coupled_layers  argument supports two different usage models. When a\nby layer is not specified, the layers  option must contain two connected layers.\nThese connected layers are considered to be coupled at locations where they\ninteract. When a by layer is specified, the layers  option must contain one or\ntwo connected layers and the by layer. The connected layers are considered\nto be coupled at locations where they touch the by layer. With this usage,\nthe unconnected by layer establishes the coupling relationship between the\nconnected layers.\n\u2022 layers.\nLists the hash of string to polygon layer. Each hash element can contain two\nor three layers that establish a coupling relationship between different nets.\nThe remote function specified in the net_function  argument uses the layer\nname strings to access layer-based parameters on a net. If you use the\nby_layer  option, you must specify the by layer in the layers  option.\nFigure 449  demonstrates the creation of a coupling relationship between the\nall_mos_gates layer and the all_moss_diff layers. The coupling relationship\nis established through the all_mos_gates layer because it touches both of\nthe all_mos_diff layers.\ncoupled_layers = {layers = {\"GATE\" => all_mos_gates,\n\"SD\" => all_mos_diff}, ...},\nIn this example, the all_mos_gates and all_moss_diff layers must all be in\nthe connected database because they are listed as layers in the layers\noption. No by layer is needed because the layers all touch each other.\nFigure 449 Touching Layer Example\n\u2022 by_layer.\nSpecifies an optional layer that provides coupling between the connected\nlayers provided in the layers  option. This by layer acts as a bridge between\ntwo connected layers without forming a connection between the layers.\nnet_select_error()\nThe by layer must be either a polygon layer or an error layer and must not\nbe used in the connection database specified by the connect_sequence\nargument. If you use the by_layer  option, you must specify the by layer in\nthe layers  option.\nNote:\nThe error layer polygon in the by layer must contain only\northogonal shapes. Due to a rounding issue, the error edges and\nmetal layers cannot be exactly matched.\nFigure 450  demonstrates the creation of a coupling relationship between the\ntwo separate all_moss_diff layers. The coupling relationship is established\nthrough the all_mos_gates layer because it touches both of the all_mos_diff\nlayers. The all_mos_gates layer is needed as a by layer because it touches\nboth of the all_mos_diff layers and these layers do not touch each other.\ncoupled_layers = {layers = {\"GATE\" => all_mos_gates,\n\"SD\" => all_mos_diff},\nby_layer = all_mos_gates}, ...},\nIn this example, the all_mos_diff layer must be in the connected database\nbecause it is listed as a layer in the layers  option. Because the\nall_mos_gates layer is listed as a by layer in the by_layer  option, it does not\nneed to be connected to anything and can be used as demonstrated in this\ncase.\nFigure 450 By Layer Example With 2 Layers\nFigure 451  demonstrates the creation of a coupling relationship between\nthe M1 and M2 layers. The coupling relationship is established through\nthe M1_M2_err layer because it touches both the M1 and M2 layers. The\nnet_select_error()\nM1_M2_err layer is needed as a by layer because it touches both the M1\nand M2 layers and these layers do not touch each other.\ncoupled_layers = {layers = {\"M1\" => M1, \"M2\" => M2,\n\"ERR\" => M1_M2_err},\nby_layer = M1_M2_err}, ...},\nIn this example, both the M1 and M2 layers must be in the connect database\nbecause they are listed as layers in the layers  option and are not by layers.\nBecause the M1_M2_err layer is listed as a by layer in the by_layer  option,\nit does not need to be connected to anything.\nFigure 451 By Layer Example With 3 Layers", "output_from_coupled_layers": "Required. Specifies the error layer that is used for output.", "layer_groups": "Optional. Specifies the hash of string to polygon layers. The strings are used by\nthe remote function to access the layer-based parameters on a given net. The\ndefault is an empty hash.", "connected_to_all": "Optional. Specifies the layers. To be selected for output, all of these layers must\nbe on the net. By default, the IC Validator tool does not require any specific\nlayers.\nnet_select_error()", "not_connected_to_all": "Optional. Specifies the layers. If all layers are on the net, the net is not selected.\nBy default, the IC Validator tool does not exclude any layers.", "connected_to_any": "Optional. Specifies the layers. To be selected for output, at least one of these\nlayers must be on the net. By default, the IC Validator tool does not require any\nspecific layers.", "not_connected_to_any": "Optional. Specifies the layers. If any one of the layers is on the net, the net is not\nselected. By default, the IC Validator tool does not exclude any layers.", "net_type": "Optional. Specifies the net types to be checked. The default is ALL.\n\u2022 NOT_TEXTED. Checks only untexted nets.\n\u2022 TEXTED. Checks only texted nets.\n\u2022 ALL. Checks both texted and untexted nets.", "texted_with": "Optional. Specifies the text strings. To be selected for output, the text must\nmatch at least one of these strings. String matching using metacharacters is\nallowed. See\nString Matching  on page 3353 for more information. Specifying {}\nignores all text. By default, the IC Validator tool selects all text nets.\nNote:\nTo select only texted nets, the net_type  argument must be set to\nTEXTED.\nIf the net_type  argument is left at the default setting of ALL, the\nnet_select()  function returns both texted and untexted nets. For\nexample, if you set texted_with={\"VCC\"}  but do not specify the\nnet_type  argument, then the net_select()  function returns all nets\ntexted with VCC and all untexted nets.", "texted_at": "Optional. Specifies where to search for the text. The default is TOP_OF_NET.\nNote:\nIf the net_type  argument is NOT_TEXTED, the texted_with  argument\nis ignored.\nnet_select_error()\n\u2022 TOP_OF_NET. Searches only in the highest hierarchical level of each\nnet for text. If text is not found at the highest hierarchical location, the\nnet_select_error()  function considers this net as untexted.\n\u2022 ANY_LEVEL. Searches nets at all hierarchical levels for text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "schematic_nets": "Optional. Specifies hierarchical schematic net names to select target layout nets\nbased on LVS comparison results. That is, nets that matched during LVS are\nsupported; any nets that did not match during LVS are not supported. Note that\nports of LVS exploded cells are not supported. For example, \"X1/N1\" selects the\nlayout net that LVS found which matches the N1 schematic net under the X1\nschematic cell instance.\nThis argument works in conjunction with other arguments of the\nnet_select_error()  function, such as connected_to_all,\nnot_connected_to_all, texted_with, and net_type. To select only specified\nschematic nets, set those arguments so that they not select data.\nSee the schematic_nets  argument of the\nnet_select()  function for an\nexample.", "schematic_nets_file": "Optional. Specifies a file that contains the schematic nets to be checked. The\nnets in this file are equivalent to the nets selected by the schematic_nets\nargument.\nnet_select_error()\nThe schematic_net_file  argument can be used with the schematic_nets\nargument. If a net is declared in both the schematic_net_file  and\nschematic_nets  arguments, the net is considered only one time.\nThe file format is the same for both the schematic_net_file  and\ntexted_with_file  arguments. The format is:\n\u2022 There is one net or text string per line.\n\u2022 Each mapping relation must appear on a new line.\nThe following is an example of a net name file:\n1 /I1/I2/N3\n2 /I1/I2/N4\n3 /I1/I2/I5/N6\n4 /I1/I2/I5/N7", "texted_with_file": "Optional. Specifies a file that contains the text strings to be considered by the\nnet_select()  function. The text strings in this file are equivalent to the text\nstrings specified by the texted_with  argument.\nThe texted_with_file  argument can be used with the texted_with\nargument. If a text string is declared in both the texted_with_file  and\ntexted_with  arguments, the text is considered only one time. If the\ntexted_with  argument is used with the default, that is, all text strings are\nconsidered, then text strings specified by the texted_with_file  argument are\nignored.\nSee the schematic_nets_file  argument for the file format. See\nTable 64.\nTable 64 texted_with_file Argument Used With texted_with Argument\ntexted_with texted_with_file Text selected\nNot specified Not specified All text\nSpecified Not specified Text strings specified by texted_with  statement\nNot specified Specified All text\nSpecified Specified All unique text strings from both texted_with  and\ntexted_with_file  statements\nNote:\nTo enable only text strings from the texted_with_file  argument,\nset the texted_with  argument to an empty string (\"\").\nnet_select_error()", "report_net_names": "Optional. Specifies whether layout and schematic net names are added to the\nLAYOUT_ERRORS file. This argument is used only for error reporting. For each\nerror selected from the ns_save_coupled_layer()  function, the names of the\nnets that it couples are included in the error report. If the xref_db  argument is\nnot specified, only layout net names are included. The default is false.", "netlist_db": "Specifies the netlist database to show schematic representation by the PERC\nVUE interface.", "report_string_properties": "Optional. Specifies the string property name for each error and attaches a new\nstring value to the violation entry.\nThe report_string_properties  argument can only be used with the error\nreport version argument.\n\u2022 error_name. Specifies the error name that is written to the\nLAYOUT_ERRORS file.\n\u2022 property_name. Specifies the user-defined name of the property.\n\u2022 append_to_vue_description. Specifies the string property content to the\nerror description that is shown in VUE. The default is true.\n\u25e6 true. Specifies the message that is appended to the Netlist Visualizer\ninterface.\n\u25e6 false. Does not specify the message that is appended to the Netlist\nVisualizer interface.", "predicate": "Optional. Specifies a predicate_handle  for empty layer optimization. The\npredicate controls the operation as follows:\n\u2022 true. Default. The function operates as normal.\n\u2022 false. The function produces an empty output.\nnet_select_error()\nFor example:\nerr_M1_coupled1 =\nnet_select_error(connect_sequence = cdb,\nnet_function = my_coupled_net,\ncoupled_layers = {{{\"GATE\" => GATE, \"SD\" => SD}},\n{{\"M1\" => M1, \"err_M1\" => err_M1},\nby_layer = err_M1},\n{{\"GATE\" => GATE, \"SD\" => SD}, by_layer =\nGATE}},\noutput_from_coupled_layers = {err_M1},\npredicate = [[metal1]]);\nIf the metal1  layer is empty, the net_select_error()  function is skipped and\nerr_M1_coupled1  is empty."}, "summary": "The net_select_error()  function selects error layer polygons that fit the specified\ncriteria.", "function_name": "net_select_error()"}
{"description": "The net_select_inside_of_layer()  function selects net polygons inside a layer in the\nspecified connect database. Only polygons that fit the specified criteria and are located\ninside the layer specified by the inside_of_layer  argument are selected.\nA remote function can be used to specify arithmetic conditions relative to the portion of the\nnet inside each specified polygon or cluster of polygons with the same net. The polygons\nare saved if the net parameters fit all of the constraints specified in the remote function.\nThe portion of net areas is also available for user-defined equations implemented in the\nremote function.\nNote:\nIf the remote function calls the nsil_save_double_property()  utility function,\nany net polygons that are not enclosed by the inside_of_layer  polygon are\ndiscarded.\nErrors are reported to the LAYOUT_ERRORS file and appear as an X in VUE.", "syntax": "net_select_inside_of_layer(\nconnect_sequence     = connect_database,\nnet_function         = function,\nlayer_groups         = {\"string\" => {polygon_layer, ...},\n...},\ninside_of_layer      = polygon_layer,\noutput_from_layers   = {polygon_layer, ...},\nmode                 = BY_SHAPE  | BY_NET,                   //optional\nconnected_to_all     = {polygon_layer, ...},                //optional\nnot_connected_to_all = {polygon_layer, ...},                //optional\nconnected_to_any     = {polygon_layer, ...},                //optional\nnot_connected_to_any = {polygon_layer, ...},                //optional\nname                 = \"layer_label\"                        //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.\nnet_select_inside_of_layer()", "net_function": "Required. Specifies the remote function that contains the conditions relative to\nthe parameters of layers on a net inside the polygon (or cluster of polygons with\nsame net) specified by theinside_of_layer  argument. This function is called\none time for each portion of each selected net.\nSee\nNet Select Inside of Layer Utility Functions  for more information about the\nutility functions you can use to define a remote function.", "layer_groups": "Required. Specifies the hash of string to polygon layers. You must specify at\nleast one layer group in the hash.", "inside_of_layer": "Required. Specifies the layer inside of which the polygons are selected. If mode\nis set to BY_NET, this layer must be in the connect database.", "output_from_layers": "Required. Specifies the layers where polygons are collected from selected nets\nto create the output layer or report errors. These layers must be in the connect\ndatabase.", "mode": "Optional. Specifies how the inside_of_layer  argument gathers the net\npolygons. The default is BY_SHAPE.\n\u2022 BY_SHAPE. Selects the net polygons from each shape in the layer specified\nby inside_of_layer.\n\u2022 BY_NET. Selects the net polygons that touch polygons connected to the same\nnet in the layer specified by inside_of_layer.\nFor example, you can apply net_select_inside_of_layer()  to determine if a\nnet contains polygons from multiple connected layers inside a specified shape,\nby default, or shapes that belong to the same net when mode  is set to BY_NET.\nIn\nFigure 452, the net_select()  function would select both net1 and net2.\nHowever, the net_select_inside_of_layer()  function, with the specified\nlayer inside_layer = I, has no output because the net polygons A and B from\nlayer I are checked separately inside two individual shapes, P1 and P2, and\nneither shape contains both A and B from a net.\nnet_select_inside_of_layer()\nFigure 452 Selecting Net Polygons by Shape\nFigure 453  shows a similar example in which P1 and P2 are connected. If you\nset the mode  argument to BY_SHAPE  to select a cluster of polygons with the same\nnet, the net_select_inside_of_layer()  function selects both net1 and net2.\nFigure 453 Selecting Net Polygons by Net", "connected_to_all": "Optional. Specifies the layers. To be selected for output, all of these layers must\nbe on the net. By default, the IC Validator tool does not require any specific\nlayers.", "not_connected_to_all": "Optional. Specifies the layers. If all layers are on the net, the net is not selected.\nBy default, the IC Validator tool does not exclude any layers.", "connected_to_any": "Optional. Specifies the layers. To be selected for output, at least one of these\nlayers must be on the net. By default, the IC Validator tool does not require any\nspecific layers.\nnet_select_inside_of_layer()", "not_connected_to_any": "Optional. Specifies the layers. If any one of the layers is on the net, the net is not\nselected. By default, the IC Validator tool does not exclude any layers.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The net_select_inside_of_layer()  function selects net polygons inside a layer in the\nspecified connect database.", "function_name": "net_select_inside_of_layer()"}
{"description": "The net_texted_with()  function selects polygons from nets that are texted with the\nspecified strings.\nThe net_not_texted_with()  function selects polygons from nets that are not texted with\nthe specified strings.", "syntax": "net_texted_with(\nconnect_sequence   = connect_database,\ntext               = {\"string\", ...},\noutput_from_layers = {polygon_layer, ...},                  //optional\ntexted_at          = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                          //optional\ncolon_text         = EQUATE_NETS | REGULAR_TEXT,            //optional\nprocessing_mode    = CELL_LEVEL | HIERARCHICAL,             //optional\nname               = \"layer_label\",                         //optional\ntext_property_with          = {\"string\", ...},               //optional\ntext_property_at           = TOP_CELL | ANY_LEVEL  |\nHIGHEST_TEXT                   //optional\n);\nnet_not_texted_with(\nconnect_sequence   = connect_database,\ntext               = {\"string\", ...},\noutput_from_layers = {polygon_layer, ...},                  //optional\ntexted_at          = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                          //optional\ncolon_text         = EQUATE_NETS | REGULAR_TEXT,            //optional\nprocessing_mode    = CELL_LEVEL | HIERARCHICAL,             //optional\nname               = \"layer_label\",                         //optional\ntext_property_with          = {\"string\", ...},               //optional\ntext_property_at           = TOP_CELL | ANY_LEVEL  |\nHIGHEST_TEXT                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.\nnet_texted_with() and net_not_texted_with()", "text": "Required. Specifies the strings that determine the text used for selection. String\nmatching using metacharacters is allowed. See\nString Matching  on page 3353\nfor more information.", "output_from_layers": "Optional. Specifies the layers from which polygons are collected to create the\noutput layer or error report. These layers must be in the connect database. By\ndefault, polygons are collected from all layers in the connect database.", "texted_at": "Optional. Specifies where to look for the text specified with the text  argument.\nThe default is ANY_LEVEL.\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text.\nNote:\nWith this setting, the net_not_texted_with()  function is not\nthe complement of the net_texted_with()  function. When the\ntexted_at  argument is TOP_CELL, both functions only select\npolygons from top cell nets.\n\u2022 TOP_OF_NET. Looks at all cells on the highest hierarchical level on the net\nfor the specified text. The tool selects the net whose text on the highest\nlevel matches the specified text; the net does not have higher hierarchical\nlevels. This option is not available when the processing_mode  argument is\nCELL_LEVEL.\n\u2022 ANY_LEVEL. Looks at all cells on the net for the specified text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "colon_text": "Optional. Specifies how the colon ( : ) is processed. The default is\nREGULAR_TEXT.\nnet_texted_with() and net_not_texted_with()\n\u2022 EQUATE_NETS. For net text, ignores the colon and characters following it.\nFor example, \"a:\", \"a:a\", and \"a:xyz\"  all match the text \u201ca\u201d. This setting\napplies only when the text_options()  function is called with colon_text =\nEQUATE_NETS.\n\u2022 REGULAR_TEXT. Retains the colon and does not give the colon special\nprocessing.", "processing_mode": "Optional. Specifies how the polygons are collected from selected nets. The\ndefault is HIERARCHICAL.\n\u2022 CELL_LEVEL. Specifies that only polygons in the cell with the matching text\nare collected.\n\u2022 HIERARCHICAL. Specifies that polygons are collected from any hierarchical\nlocation on the selected nets.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "text_property_with": "Optional. Specifies the text strings. To be selected for output, text properties\nof a net must match at least one of these strings. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. Specifying {}  ignores all text. By default, the IC Validator tool\nselects all nets with text properties.\nNote:\nTo select only nets with text properties, the text_property  argument\nmust be set to EXIST.\nIf the text_property  argument is left at the default setting of ALL,\nthe net_select()  function returns both nets with and without text\nproperties. For example, if you set text_property_with={\"VCC\"}\nbut do not specify the text_property  argument, the net_select()\nfunction returns all nets with the text property VCC and all nets\nwithout text properties.", "text_property_at": "Optional. Specifies where to look for the text properties specified with the\ntext_property_with  argument. The default is ANY_LEVEL.\nnet_texted_with() and net_not_texted_with()\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text\nproperties. If text properties are not found at this location, the net_select()\nfunction considers this net as one without text properties.\n\u2022 ANY_LEVEL. Searches nets at all hierarchical levels for text properties.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL."}, "summary": "The net_texted_with()  function selects polygons from nets that are texted with the\nspecified strings.", "function_name": "net_texted_with()"}
{"description": "The net_texted_with()  function selects polygons from nets that are texted with the\nspecified strings.\nThe net_not_texted_with()  function selects polygons from nets that are not texted with\nthe specified strings.", "syntax": "net_texted_with(\nconnect_sequence   = connect_database,\ntext               = {\"string\", ...},\noutput_from_layers = {polygon_layer, ...},                  //optional\ntexted_at          = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                          //optional\ncolon_text         = EQUATE_NETS | REGULAR_TEXT,            //optional\nprocessing_mode    = CELL_LEVEL | HIERARCHICAL,             //optional\nname               = \"layer_label\",                         //optional\ntext_property_with          = {\"string\", ...},               //optional\ntext_property_at           = TOP_CELL | ANY_LEVEL  |\nHIGHEST_TEXT                   //optional\n);\nnet_not_texted_with(\nconnect_sequence   = connect_database,\ntext               = {\"string\", ...},\noutput_from_layers = {polygon_layer, ...},                  //optional\ntexted_at          = TOP_CELL | TOP_OF_NET | ANY_LEVEL |\nHIGHEST_TEXT,                          //optional\ncolon_text         = EQUATE_NETS | REGULAR_TEXT,            //optional\nprocessing_mode    = CELL_LEVEL | HIERARCHICAL,             //optional\nname               = \"layer_label\",                         //optional\ntext_property_with          = {\"string\", ...},               //optional\ntext_property_at           = TOP_CELL | ANY_LEVEL  |\nHIGHEST_TEXT                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.\nnet_texted_with() and net_not_texted_with()", "text": "Required. Specifies the strings that determine the text used for selection. String\nmatching using metacharacters is allowed. See\nString Matching  on page 3353\nfor more information.", "output_from_layers": "Optional. Specifies the layers from which polygons are collected to create the\noutput layer or error report. These layers must be in the connect database. By\ndefault, polygons are collected from all layers in the connect database.", "texted_at": "Optional. Specifies where to look for the text specified with the text  argument.\nThe default is ANY_LEVEL.\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text.\nNote:\nWith this setting, the net_not_texted_with()  function is not\nthe complement of the net_texted_with()  function. When the\ntexted_at  argument is TOP_CELL, both functions only select\npolygons from top cell nets.\n\u2022 TOP_OF_NET. Looks at all cells on the highest hierarchical level on the net\nfor the specified text. The tool selects the net whose text on the highest\nlevel matches the specified text; the net does not have higher hierarchical\nlevels. This option is not available when the processing_mode  argument is\nCELL_LEVEL.\n\u2022 ANY_LEVEL. Looks at all cells on the net for the specified text.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL.\nNote:\nMultiple texts are classified as HIGHEST_TEXT  for nets that are\nuntexted higher up and have hierarchically connected sibling\nbranches with different net names.\nSee\nFigure 448  in the net_select()  function for an example of the\nHIGHEST_TEXT  option.", "colon_text": "Optional. Specifies how the colon ( : ) is processed. The default is\nREGULAR_TEXT.\nnet_texted_with() and net_not_texted_with()\n\u2022 EQUATE_NETS. For net text, ignores the colon and characters following it.\nFor example, \"a:\", \"a:a\", and \"a:xyz\"  all match the text \u201ca\u201d. This setting\napplies only when the text_options()  function is called with colon_text =\nEQUATE_NETS.\n\u2022 REGULAR_TEXT. Retains the colon and does not give the colon special\nprocessing.", "processing_mode": "Optional. Specifies how the polygons are collected from selected nets. The\ndefault is HIERARCHICAL.\n\u2022 CELL_LEVEL. Specifies that only polygons in the cell with the matching text\nare collected.\n\u2022 HIERARCHICAL. Specifies that polygons are collected from any hierarchical\nlocation on the selected nets.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "text_property_with": "Optional. Specifies the text strings. To be selected for output, text properties\nof a net must match at least one of these strings. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. Specifying {}  ignores all text. By default, the IC Validator tool\nselects all nets with text properties.\nNote:\nTo select only nets with text properties, the text_property  argument\nmust be set to EXIST.\nIf the text_property  argument is left at the default setting of ALL,\nthe net_select()  function returns both nets with and without text\nproperties. For example, if you set text_property_with={\"VCC\"}\nbut do not specify the text_property  argument, the net_select()\nfunction returns all nets with the text property VCC and all nets\nwithout text properties.", "text_property_at": "Optional. Specifies where to look for the text properties specified with the\ntext_property_with  argument. The default is ANY_LEVEL.\nnet_texted_with() and net_not_texted_with()\n\u2022 TOP_CELL. Looks only in the top cell of each net for the specified text\nproperties. If text properties are not found at this location, the net_select()\nfunction considers this net as one without text properties.\n\u2022 ANY_LEVEL. Searches nets at all hierarchical levels for text properties.\n\u2022 HIGHEST_TEXT. Looks for the highest hierarchical level on the net for the\nspecified text. The tool selects the net whose highest level text matches the\nspecified text even if the net continues untexted higher up. This option is not\navailable when the processing_mode  argument is CELL_LEVEL."}, "summary": "The net_texted_with()  function selects polygons from nets that are texted with the\nspecified strings.", "function_name": "net_not_texted_with()"}
{"description": "The nmos()  function collects extraction configuration information about N-type MOS\ntransistors that have a gate layer, source layer, drain layer, and optional pin layers. The\npmos()  function collects extraction configuration information about P-type MOS transistors\nthat have a gate layer, source layer, drain layer, and optional pin layers. The configuration\ninformation, which contains terminal layers, property extraction information, schematic\ndevice mappings, and pin handling instructions, is stored in the device matrix that is\npassed to the\nextract_devices()  function.\nThe source or drain area of a MOS transistor with a shared source/drain is\narea =\n(total area)*(gate width)/(sum all gate widths touching shared area)\nWhen the shape is a simple rectangle, the area is simply divided in half.", "syntax": "nmos(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndrain                  = polygon_layer,\ngate                   = polygon_layer,\nsource                 = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE,\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL},\nscale_mode        =\nMULTIPLY  | UNIT,\nnmos() and pmos()\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\ndrain         = \"string\",\ngate          = \"string\",\nsource        = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\ncontact_layers         = {polygon_layer, ...},              //optional\nsource_drain_config    = {NORMAL, SINGLE},                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\norientation  =          = {compare_pass    = RELATIVE  | ABSOLUTE,\nsimulation_pass = RELATIVE  | ABSOLUTE},\n//optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false,               //optional\ndevice_body            = polygon_layer                       //optional\n);\npmos(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndrain                  = polygon_layer,\ngate                   = polygon_layer,\nsource                 = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties          = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE,\nnmos() and pmos()\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE | NETLIST |\nNETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL},\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                    //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\ndrain         = \"string\",\ngate          = \"string\",\nsource        = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\ncontact_layers         = {polygon_layer, ...},              //optional\nsource_drain_config    = {NORMAL, SINGLE},                  //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\norientation  =          = {compare_pass    = RELATIVE  | ABSOLUTE,\nsimulation_pass = RELATIVE  | ABSOLUTE},\n//optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false,               //optional\ndevice_body            = polygon_layer                       //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.\nnmos() and pmos()", "device_name": "Required. Specifies the MOS device. A device name can be reused across\nmultiple calls of the nmos()  function and pmos()  function, but not across the two\nfunctions, if all calls have\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.\nSee\nDevice Names  for the device_name  argument restrictions.", "drain": "Required. Specifies the drain layer of the MOS device. The pin name generated\nby the IC Validator tool is \u201cDRN\u201d.", "gate": "Required. Specifies the gate layer of the MOS device. The pin name generated\nby the IC Validator tool is \u201cGATE\u201d.", "source": "Required. Specifies the source layer of the MOS device. The pin name\ngenerated by the IC Validator tool is \u201cSRC\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named \u201cBULK\u201d.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\nnmos() and pmos()\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nFigure 454  illustrates both the interaction method of selection, that is, a\nrange value of -1, and the window method of selection, that is, a range value\n>0.\nnmos() and pmos()\nFigure 454 Interaction and Window Methods of Selection\nnmos() and pmos()\nFigure 455  shows the selected polygon set when this setting is used:\nprocessing_layer_hash = { \"poly\" => {poly, 1.0}, \"NW\" => {NW,\n-1.0}}\nFigure 455 Example of Selected Polygon Set", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultnmos and pmos\nThe default is\nproperties = {{\"l\",   DOUBLE,  MICRO},\n{\"w\",   DOUBLE,  MICRO}}\n\u2022 name. Required. Specifies the property name. See \u201cPredefined Name\nMatches\u201d in Chapter 7, \u201cCompare Functions Basics\u201d of the IC Validator\nLVS User Guide  for the names and associated matches that are predefined\nduring LVS compare.\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Optional. Specifies the data type of the property. The default is\nDOUBLE.\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\nnmos() and pmos()\n\u2022 scale. Optional. Specifies the scale factor applied to the property\nvalues output by the write_spice(), write_xref_spice(),\npex_generate_results(), and write_annotation_file()  functions. The\ndefault is NONE, which means no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\nnmos() and pmos()\n- The output netlist (cell.net) by the netlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the\nnetlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\nnmos() and pmos()\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nFor example, for a property \u201cw\u201c of value of 3.0,\nUsing MULTIPLY  in the runset:\nnmos(properties = {{\"w\", DOUBLE, MICRO, scale_mode =\nMULTIPLY}})\nExample result in output netlist:   w=0.000003\nnmos() and pmos()\nUsing UNIT  in the runset:\nnmos(properties = {{\"w\", DOUBLE, MICRO, scale_mode =\nUNIT}})\nExample result in output netlist:   w=3u\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric\nproperties for each extracted device. The default calculations are for the\nlength of the gate region (l) and the width of the gate region (w). The default\ncalc_mos_properties()  function is defined in the device_public.rh header file.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon.\nnmos() and pmos()\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cSRC\u201d and \u201cDRN\u201d can be swapped. Use\nan empty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the standard \u201cDRN\u201d,\n\u201cGATE\u201d, \u201cSRC\u201d, and \u201cBULK\u201d pin names, in addition to optional pin\nnames provided in the optional_pins  list of structures argument of\nthe device configuration function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 drain. Optional. Specifies the drain terminal of the device. The default is\n\"DRN\".\n\u2022 gate. Optional. Specifies the gate terminal of the device. The default is\n\"GATE\".\n\u2022 source. Optional. Specifies the source terminal of the device. The default is\n\"SRC\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin_name  option in the optional_pins  argument.\nnmos() and pmos()\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is similar\nto the pin_compared  option of the optional_pins  argument of the nmos()\nand pmos()  functions.\nIf the schematic device has an optional pin that does not correspond to any\npin in the nmos()  and pmos()  functions, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "x_card": "Optional. Specifies if the instance name prefix is replaced. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with an X-card. This option facilitates the use of SPICE SUBCKT\nmodels to represent devices in simulation.\n\u2022 false. The default instance name prefix for the layout extracted device is not\nreplaced.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  on page 2894 for more information.", "contact_layers": "Optional. Specifies the additional layers that are used for accurately calculating\nthe nrs and nrd properties.", "source_drain_config": "Optional. Specifies the MOS type to be checked. The default is {NORMAL,\nSINGLE}.\n\u2022 SINGLE. Extracts only MOS devices that touch a single source or drain.\n\u2022 NORMAL. Extracts only MOS devices that have separate regions for source\nand drain.\nNote:\nFor NORMAL, the device width is calculated using the average of the\nwidths where each of the source and drain terminals touches the\ngate. For SINGLE, the width is equivalent only to the value of the\nsingle terminal touching gate.\nnmos() and pmos()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Optional. Specifies the user-derived string used by the remote property function.\nThe unique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe strings are valid and unique. (The IC Validator tool does not check values to\nensure that they are unique.) The default is an empty string (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped.\nThe default is\n{{\"SRC\",{\"AS\",\"PS\",\"NRS\"}},{\"DRN\",{\"AD\",\"PD\",\"NRD\"}}}.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nnmos() and pmos()\nSee the swappable_properties  argument of the capacitor()  function for an\nexample.", "orientation": "Optional. Controls the orientation of the measurements. The default is\nRELATIVE.\nNote:\nAn error occurs when the orientation  argument of the\nmos_proximity_list()  function is ABSOLUTE  and the orientation\nargument of the nmos()  or pmos()  function is RELATIVE.\n\u2022 RELATIVE. Specifies that the orientation is relative to the source and drain\nlayers of the gate.\n\u2022 ABSOLUTE. Specifies that the orientation is relative to the body within the\ncoordinate space of the top cell.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nPEX runset report file, which is used by the StarRC tool. The device name is not\nchanged.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement data\nto external libraries. See the \u201cDynamic-Link Library Support\u201d chapter in the\nIC Validator User Guide  and\nDynamic Linking Utility Functions  on page 2897 for\nmore information.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee\nTable 40  for more information about the behavior of the\ntop_simulation_properties  argument.", "device_body": "Optional. Specifies the body layer of the MOS device. When this argument is not\nspecified, the gate becomes the body layer of the MOS device.\nnmos() and pmos()\nNote:\nPreviously, the nmos()  and pmos()  functions used gate  as both the\ndevice body and terminal pin when device_body  was not specified.\nNow when device_body  is specified, the gate  becomes a pure\nterminal pin and device_body  is the body. This behavior affects the\nfollowing Device Utility Functions:\ndev_body()\ndev_body_coordinate_list()\nAll mos_length_*() functions\nAll mos_width_*() functions\nmos_proximity_corner_list()\nmos_proximity_list()\nAll mos_drain_*() functions\nAll mos_source_*() functions\ndev_parallel_device_width()\ndev_parallel_device_length()\ndev_parallel_device_area()\ndev_parallel_device_body()\ndev_parallel_device_polygon_count()\nAll mos_gate_*() functions\nmos_contact_diffusion_area_list()\nmos_nrd()\nmos_nrs()\nmos_get_dfm_double()"}, "summary": "The nmos()  function collects extraction configuration information about N-type MOS\ntransistors that have a gate layer, source layer, drain layer, and optional pin layers.", "function_name": "nmos()"}
{"description": "The not()  function creates polygons that represent the layer1  polygons that are not\ncommon to the layer2  polygons. Any layer1  polygons that overlap with layer2  polygons\nhave the overlapping portion removed in the output.", "syntax": "not(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The not()  function creates polygons that represent the layer1  polygons that are not\ncommon to the layer2  polygons.", "function_name": "not()"}
{"description": "These functions are used to check multiple containment specifications for rectangles using\na logical operation.\nThe not_contained_by()  function selects rectangles from the layer1  layer that do not fit\ncontainment specifications within layer2. This function selects\n\u2022 The layer1  rectangles that do not fit the containment enclosure specifications within\nlayer2.\n\u2022 The layer1  polygons that are not inside layer2.\n\u2022 The layer1  data that is not rectangular.\nThe contained_by()  function selects rectangles from the layer1  layer\nthat fit containment specifications within layer2. It is the complement of the\nnot_contained_by()  function.\nFour check regions are specified using a distance and extension, one for each edge of the\nenclosed rectangles. These check regions are combined to form a containment region for\neach rectangle. A selection rule is shown in the\nExamples  section.\n\u2022 For the not_contained_by()  function,\n\u25e6 If the containment region cannot fit inside layer2, in any orientation, the rectangle\ndoes not fit the containment specification and is selected for output.\n\u25e6 If any orientation of the containment region fits inside layer2, the rectangle is not\nselected.\n\u2022 For the contained_by()  function,\n\u25e6 If any orientation of the containment region fits inside layer2, the rectangle is\nselected.\n\u25e6 If the containment region cannot fit inside layer2, in any orientation, the rectangle\ndoes not fit the containment specification and is not  selected for output.", "syntax": "not_contained_by(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\nnot_contained_by() and contained_by()\ndistance2 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);\ncontained_by(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "polygon layer or error result\nnot_contained_by() and contained_by()", "arguments": {"layer1": "Required. Specifies the polygon layer.", "layer2": "Required. Specifies the polygon layer.", "distances": "Required. Lists the distances and extensions for check regions. The distances\ncan be applied in either clockwise or counterclockwise order. That is, a rectangle\nfits the specification if the four minimum distances can be satisfied in at least\none of the eight possible permutations: four possible rotations, in forward or\nreverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the containment\nvalues, one for each side of the layer1  rectangle. The distances must be\npositive values.\n\u2022 extension. Optional. Specifies the endpoint extension for the check region.\nThe default is NONE.\n\u25e6 NONE. Does not extend the check region.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the edges\nusing the extension_distance  value with a rectangle. See the\ndiagram in the extension  argument of the\nenclose()  function for more\ninformation.\nFigure 459  illustrates a rectangle and the check regions for a single\npermutation of the given distances using the various extension settings.\nnot_contained_by() and contained_by()\nFigure 459 Extension Settings\nThe contained_by()  and not_contained_by()  functions are not spacing\nchecks. A rectangle might not fit the containment specification even though\nthere are no spacing violations. In\nFigure 460,\nmagenta = not_contained_by(blue, red,\n{{{.2, SQUARE}, {.4, SQUARE}, {.2, SQUARE}. {.4,\nSQUARE}}}\n);\nFigure 460 not_contained_by() Function Example\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  argument is RECTANGLE. The value must be\nnonnegative. The default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nnot_contained_by() and contained_by()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "These functions are used to check multiple containment specifications for rectangles using\na logical operation.", "function_name": "not_contained_by()"}
{"description": "These functions are used to check multiple containment specifications for rectangles using\na logical operation.\nThe not_contained_by()  function selects rectangles from the layer1  layer that do not fit\ncontainment specifications within layer2. This function selects\n\u2022 The layer1  rectangles that do not fit the containment enclosure specifications within\nlayer2.\n\u2022 The layer1  polygons that are not inside layer2.\n\u2022 The layer1  data that is not rectangular.\nThe contained_by()  function selects rectangles from the layer1  layer\nthat fit containment specifications within layer2. It is the complement of the\nnot_contained_by()  function.\nFour check regions are specified using a distance and extension, one for each edge of the\nenclosed rectangles. These check regions are combined to form a containment region for\neach rectangle. A selection rule is shown in the\nExamples  section.\n\u2022 For the not_contained_by()  function,\n\u25e6 If the containment region cannot fit inside layer2, in any orientation, the rectangle\ndoes not fit the containment specification and is selected for output.\n\u25e6 If any orientation of the containment region fits inside layer2, the rectangle is not\nselected.\n\u2022 For the contained_by()  function,\n\u25e6 If any orientation of the containment region fits inside layer2, the rectangle is\nselected.\n\u25e6 If the containment region cannot fit inside layer2, in any orientation, the rectangle\ndoes not fit the containment specification and is not  selected for output.", "syntax": "not_contained_by(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\nnot_contained_by() and contained_by()\ndistance2 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);\ncontained_by(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "polygon layer or error result\nnot_contained_by() and contained_by()", "arguments": {"layer1": "Required. Specifies the polygon layer.", "layer2": "Required. Specifies the polygon layer.", "distances": "Required. Lists the distances and extensions for check regions. The distances\ncan be applied in either clockwise or counterclockwise order. That is, a rectangle\nfits the specification if the four minimum distances can be satisfied in at least\none of the eight possible permutations: four possible rotations, in forward or\nreverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the containment\nvalues, one for each side of the layer1  rectangle. The distances must be\npositive values.\n\u2022 extension. Optional. Specifies the endpoint extension for the check region.\nThe default is NONE.\n\u25e6 NONE. Does not extend the check region.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the edges\nusing the extension_distance  value with a rectangle. See the\ndiagram in the extension  argument of the\nenclose()  function for more\ninformation.\nFigure 459  illustrates a rectangle and the check regions for a single\npermutation of the given distances using the various extension settings.\nnot_contained_by() and contained_by()\nFigure 459 Extension Settings\nThe contained_by()  and not_contained_by()  functions are not spacing\nchecks. A rectangle might not fit the containment specification even though\nthere are no spacing violations. In\nFigure 460,\nmagenta = not_contained_by(blue, red,\n{{{.2, SQUARE}, {.4, SQUARE}, {.2, SQUARE}. {.4,\nSQUARE}}}\n);\nFigure 460 not_contained_by() Function Example\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  argument is RECTANGLE. The value must be\nnonnegative. The default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nnot_contained_by() and contained_by()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "These functions are used to check multiple containment specifications for rectangles using\na logical operation.", "function_name": "contained_by()"}
{"description": "The not_covered_by()  function checks multiple enclosure specifications for rectangles\nusing a spacing check. This function selects\n\u2022 The layer1  rectangles that do not fit the enclosure specifications within layer2.\n\u2022 The layer1  polygons that are not inside layer2.\n\u2022 The layer1  data that is not rectangular.\nWhen evaluating enclosure specifications, spacing is not  checked between the following\nedge pairs:\n\u2022 Between collinear edges; that is, edges along the same line.\nFigure 463  shows an\nexample.\nFigure 463 Collinear Edges\n\u2022 Between perpendicular edges, or any edges forming an angle greater than 90 degrees.\nFigure 464  shows an example.\nnot_covered_by()\nFigure 464 Perpendicular Edges\n\u2022 Between a layer1  edge and any outside layer2  edge. Figure 465  shows an example.\nFigure 465 Outside Edge\nFor any extension  argument setting other than NONE, a point touch satisfies only a\ndistance of 0. Figure 466  shows an example.\nnot_covered_by()\nFigure 466 Point Touch\nMore information about selection rules and check region examples are shown in the\nExamples  section.", "syntax": "not_covered_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances       = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nintersecting     = {ACUTE, POINT_TOUCH, TOUCH},              //optional\nnot_inside       = FAIL  | IGNORE,                            //optional\nname             = \"layer_label\"                             //optional\n);\nnot_covered_by()", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "layer2": "Required. Specifies the enclosing polygon layer.", "distances": "Required. Lists the distances and extensions for check regions. The distances\ncan be applied in either clockwise or counterclockwise order. That is, a rectangle\nfits the specification if the four minimum distances can be satisfied in at least\none of the eight possible permutations: four possible rotations, in forward or\nreverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the minimum\nenclosure values, one for each side of the layer1  rectangle. The distances\nspecify the minimum distance from the outside of layer1  to the inside of\nlayer2. The distances must be positive values. A distance of 0 indicates that\nthe layers can be touching.\nNote:\nFor the not_covered_by()  function, the distances must be less\nthan (<) the values.\n\u2022 extension. Optional. Specifies the endpoint extension for the check region.\nThe default is NONE.\n\u25e6 NONE. Does not extend the check region; only layer1  and layer2  edges\nwith a positive perpendicular projection between them are measured.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the layer1  edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the layer1\nedges using the extension_distance  value with a rectangle. The\nnot_covered_by()\nboundary of the check region is inclusive or exclusive depending on\nthe constraint of the distance value. See the diagram in the extension\nargument of the\nenclose()  function for more information.\nFigure 467  illustrates a rectangle and the check regions for a single\npermutation of the given distances using the various extension  argument\nsettings.\nFigure 467 extension Argument Examples\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance for the extension  argument when it is RECTANGLE. The value must\nbe nonnegative. The default is 0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "intersecting": "Optional. Specifies the intersecting edge types that are included in the\nmeasurement. By default, the IC Validator tool includes all intersecting edge\ntypes in the measurement.\nNote:\nIntersection edges that are not measured pass the enclosure\nspecification automatically. For example, if TOUCH  is not included\nin this list, touching edges pass without measurement and only the\nremaining nontouching edges must fit the enclosure specification for\nthe rectangle to pass.\nnot_covered_by()\n\u2022 ACUTE. Specifies that intersecting edges that form acute angles fail any\nnonzero distance.\n\u2022 POINT_TOUCH. Specifies that intersecting edges that point touch fail any\nnonzero distance when the extension  argument is not NONE.\n\u2022 TOUCH. Specifies that intersecting edges that edge touch fail any nonzero\ndistance.", "not_inside": "Optional. Specifies whether layer1  rectangles that are not enclosed in layer2\nare selected. The default is FAIL.\n\u2022 FAIL. Selects rectangles that are not inside layer2.\n\u2022 IGNORE. Ignores rectangles that are not inside layer2.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The not_covered_by()  function checks multiple enclosure specifications for rectangles\nusing a spacing check.", "function_name": "not_covered_by()"}
{"description": "The not_edge()  function selects the portion of all layer1  edges that are outside the\nlayer2  polygons.", "syntax": "not_edge(\nlayer1           = data_layer,\nlayer2           = polygon_layer,\ncoincident       = true  | false,               //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",              //optional\ncoincident_edges  = INSIDE | OUTSIDE  | BOTH     //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "coincident": "Optional. When set to true, outside coincident is included in the result. The\ndefault is true.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nnot_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincident_edges": "Optional. Specifies which edges must be included in the output result. This\nargument works only when coincident=true. The default is OUTSIDE.\n\u2022 INSIDE. Keeps the inside coincident edges in the output.\n\u2022 OUTSIDE. Keeps the outside coincident edges in the output.\n\u2022 BOTH. Keeps all of the inside and outside coincident edges in the output."}, "summary": "The not_edge()  function selects the portion of all layer1  edges that are outside the\nlayer2  polygons.", "function_name": "not_edge()"}
{"description": "The not_enclosed_by()  function checks whether rectangles are enclosed. The\ncomplement of this function is the enclosed_by()  function.\nThe order of filtering and checks of the not_enclosed_by()  function for LCC and SEC\nflows is shown in\nFigure 479.\nnot_enclosed_by() and enclosed_by()\nFigure 479 Workflow for not_enclosed_by() Function\nnot_enclosed_by() and enclosed_by()", "syntax": "not_enclosed_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nintersecting_failures  = {ACUTE, PERPENDICULAR, POINT_TOUCH,\nTOUCH},                            //optional\nnon_orthogonal         = CHECK  | FAIL | IGNORE,\nnot_inside             = FAIL | CHECK,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,          //optional\nname                  = \"layer_label\"                       //optional\n);\nenclosed_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nnot_enclosed_by() and enclosed_by()\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nintersecting_failures  = {ACUTE, PERPENDICULAR, POINT_TOUCH,\nTOUCH},                            //optional\nnon_orthogonal         = CHECK  | FAIL | IGNORE,\nnot_inside             = FAIL | CHECK,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,          //optional\nname                  = \"layer_label\"                       //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected. This is\nthe enclosed layer.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked. This is the enclosing layer.", "distances": "Required. Lists the distances and extensions for check regions.\n\u2022 For a logical containment check, only distance  values are used.\n\u2022 For a spatial enclosure check, distance, extension, and\nextension_distance  are all used.\nThe distances can be applied in either clockwise or counterclockwise order.\nThat is, a rectangle fits the specification if the four minimum distances can\nbe satisfied in at least one of the eight possible permutations: four possible\nrotations, in forward or reverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the minimum\ndistance values, one for each side of the layer1  rectangle. The distances\nspecify the minimum distance from the outside of layer1  to the inside of\nlayer2.\nThe distances must be positive values. A distance of 0 indicates that the\nlayers can be touching.\n\u2022 extension. Optional. Specifies the endpoint extension for the check region.\nThe default is NONE.\nnot_enclosed_by() and enclosed_by()\n\u25e6 NONE. Does not extend the check region. Only layer1  and layer2  edges\nwith a positive perpendicular projection between them are measured.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the layer1  edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the layer1\nedges using the extension_distance  value with a rectangle. The\nboundary of the check region is inclusive or exclusive depending on\nthe constraint of the distance value. See the diagram in the extension\nargument of the\nenclose()  function for more information.\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  argument is RECTANGLE. The value must be\nnonnegative. The default is 0.", "intersecting_failures": "Optional. Specifies the intersecting types that are forbidden. If a rectangle\nintersects its enclosing layer with a forbidden intersecting type, the rectangle\nis placed in the output layer. By default, the IC Validator tool includes all\nintersecting types in the measurement.\n\u2022 ACUTE. Specifies that intersecting edges that form acute angles fail.\n\u2022 PERPENDICULAR. Specifies that intersecting edges that form right angles fail.\n\u2022 POINT_TOUCH. Specifies that intersecting edges that point touch fail.\n\u2022 TOUCH. Specifies that intersecting edges that edge touch fail.", "non_orthogonal": "Optional. Specifies how non-orthogonal rectangles are processed. The default is\nCHECK.\n\u2022 CHECK. Checks nonorthogonal data during the workflow of this function. See\nFigure 479.\n\u2022 FAIL. Puts nonorthogonal data directly into the output layer.\n\u2022 IGNORE. Ignores nonorthogonal data during the workflow of this function.\nnot_enclosed_by() and enclosed_by()", "not_inside": "Optional. Specifies how to process the inside and not-inside rectangles. The\ndefault is CHECK.\n\u2022 FAIL. Puts directly into the output layer all rectangles that are not fully inside\nthe enclosing layer.\n\u2022 CHECK. For spatial enclosure checks, checks the sections of rectangles inside\nthe enclosing layer. If a rectangle is completely outside its enclosing polygon,\nthen it is not written into the output layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The not_enclosed_by()  function checks whether rectangles are enclosed.", "function_name": "not_enclosed_by()"}
{"description": "The not_enclosed_by()  function checks whether rectangles are enclosed. The\ncomplement of this function is the enclosed_by()  function.\nThe order of filtering and checks of the not_enclosed_by()  function for LCC and SEC\nflows is shown in\nFigure 479.\nnot_enclosed_by() and enclosed_by()\nFigure 479 Workflow for not_enclosed_by() Function\nnot_enclosed_by() and enclosed_by()", "syntax": "not_enclosed_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nintersecting_failures  = {ACUTE, PERPENDICULAR, POINT_TOUCH,\nTOUCH},                            //optional\nnon_orthogonal         = CHECK  | FAIL | IGNORE,\nnot_inside             = FAIL | CHECK,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,          //optional\nname                  = \"layer_label\"                       //optional\n);\nenclosed_by(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ndistances = {{distance1 = {distance = double,\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance2 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance3 = {distance = double,\nextension =\nNONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\ndistance4 = {distance = double,\nnot_enclosed_by() and enclosed_by()\nextension = NONE  | RADIAL |\nSQUARE | INTERSECTION |\nRECTANGLE,\nextension_distance = double},\n...},\nintersecting_failures  = {ACUTE, PERPENDICULAR, POINT_TOUCH,\nTOUCH},                            //optional\nnon_orthogonal         = CHECK  | FAIL | IGNORE,\nnot_inside             = FAIL | CHECK,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,          //optional\nname                  = \"layer_label\"                       //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected. This is\nthe enclosed layer.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked. This is the enclosing layer.", "distances": "Required. Lists the distances and extensions for check regions.\n\u2022 For a logical containment check, only distance  values are used.\n\u2022 For a spatial enclosure check, distance, extension, and\nextension_distance  are all used.\nThe distances can be applied in either clockwise or counterclockwise order.\nThat is, a rectangle fits the specification if the four minimum distances can\nbe satisfied in at least one of the eight possible permutations: four possible\nrotations, in forward or reverse order.\n\u2022 distance1, distance2, distance3, distance4. Specify the minimum\ndistance values, one for each side of the layer1  rectangle. The distances\nspecify the minimum distance from the outside of layer1  to the inside of\nlayer2.\nThe distances must be positive values. A distance of 0 indicates that the\nlayers can be touching.\n\u2022 extension. Optional. Specifies the endpoint extension for the check region.\nThe default is NONE.\nnot_enclosed_by() and enclosed_by()\n\u25e6 NONE. Does not extend the check region. Only layer1  and layer2  edges\nwith a positive perpendicular projection between them are measured.\n\u25e6 RADIAL. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a radial curve.\n\u25e6 SQUARE. Extends the check region with the distance value past the\nendpoints of the layer1  edge being checked, forming a square box.\n\u25e6 INTERSECTION. Extends the check region with the adjacent distance\nvalue past the endpoints of the layer1  edge being checked.\n\u25e6 RECTANGLE. Extends the check region past the endpoints of the layer1\nedges using the extension_distance  value with a rectangle. The\nboundary of the check region is inclusive or exclusive depending on\nthe constraint of the distance value. See the diagram in the extension\nargument of the\nenclose()  function for more information.\n\u2022 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  argument is RECTANGLE. The value must be\nnonnegative. The default is 0.", "intersecting_failures": "Optional. Specifies the intersecting types that are forbidden. If a rectangle\nintersects its enclosing layer with a forbidden intersecting type, the rectangle\nis placed in the output layer. By default, the IC Validator tool includes all\nintersecting types in the measurement.\n\u2022 ACUTE. Specifies that intersecting edges that form acute angles fail.\n\u2022 PERPENDICULAR. Specifies that intersecting edges that form right angles fail.\n\u2022 POINT_TOUCH. Specifies that intersecting edges that point touch fail.\n\u2022 TOUCH. Specifies that intersecting edges that edge touch fail.", "non_orthogonal": "Optional. Specifies how non-orthogonal rectangles are processed. The default is\nCHECK.\n\u2022 CHECK. Checks nonorthogonal data during the workflow of this function. See\nFigure 479.\n\u2022 FAIL. Puts nonorthogonal data directly into the output layer.\n\u2022 IGNORE. Ignores nonorthogonal data during the workflow of this function.\nnot_enclosed_by() and enclosed_by()", "not_inside": "Optional. Specifies how to process the inside and not-inside rectangles. The\ndefault is CHECK.\n\u2022 FAIL. Puts directly into the output layer all rectangles that are not fully inside\nthe enclosing layer.\n\u2022 CHECK. For spatial enclosure checks, checks the sections of rectangles inside\nthe enclosing layer. If a rectangle is completely outside its enclosing polygon,\nthen it is not written into the output layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The not_enclosed_by()  function checks whether rectangles are enclosed.", "function_name": "enclosed_by()"}
{"description": "Creates a polygon layer that represents the active area of the polygons of the layer2s\nlayers list that are not within the specified distance of the layer1  polygons in the same\nset. These sets are defined by polygon properties.", "syntax": "not_within_distance_by_property(\nlayer1            = polygon_layer,\nlayer2s            = {layers         = {polygon_layer, ...},\nproperty_index = integer},\ndouble_properties = {\"string\", ...},\ndistance          = double,\ncorner_extension  = INTERSECTION | RADIAL_OUTSIDE |\nRADIAL_INSIDE | NONE,                   //optional\nradial_sectors     = integer,                                //optional\nname              = \"layer_label\",                          //optional\nmerge_layer1_by_property_range  = double,                    //optional\nerror_property_mapping_file  = \"string\"                      //optional\n);", "returns": "void", "arguments": {"layer1": "Required. Specifies the polygon layer from which distance is checked.\nOnly those layer1  polygons with a double property for every string in the\ndouble_properties  list are included in the check.", "layer2s": "Required. Specifies a list of structures\n\u2022 layers. Specifies the layers from which polygons are checked for their\nproximity to layer1.\n\u2022 property_index. Specifies the index (i) of the applicable property in the\ndouble_properties  list for a given list of layers. The default is 0.", "double_properties": "Required. Specifies the user-defined double properties for the polygon sets. The\ntotal number of property values determines the number of polygon sets. Data\nsets are formed by layer1  polygons with a unique value for every property in\nnot_within_distance_by_property()\ndouble_properties, grouped with polygons from the layers of layer2s, which\nhave the same value for the property indicated by property_index.", "distance": "Required. Specifies the maximum distance.", "corner_extension": "Optional. Specifies how the corners are processed. The default is\nINTERSECTION.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 RADIAL_OUTSIDE. Forms a radial corner using an approximation curve that\nis generated by a regular polygon circumscribed by a circle with the radius\ndistance.\n\u2022 RADIAL_INSIDE. Forms a radial corner using an approximation curve that is\ngenerated by a regular polygon inscribed by a circle with the radius distance.\n\u2022 NONE. Does not extend corners.", "radial_sectors": "Optional. Specifies the number of radial sectors used to approximate a quadrant\nat the right corner. The effect of this argument on the sizing depends on the\nvalue of the corner_extension  argument.\nThe minimum value is 0, and the maximum value is 32. The value must be\ngreater than 0 if the corner_extension  argument is RADIAL_INSIDE  or\nRADIAL_OUTSIDE. The default is 0.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "merge_layer1_by_property_range": "Optional. Merges polygons of the same device. You can provide a range for\nidentifying nearby polygons of the same device.", "error_property_mapping_file": "Optional. The error_property_mapping_file  is a JSON file containing maps\nfor double properties. The order of given mappings must be same as the order\nof double_properites. For example, if double_properites = {\"ground\",\nnot_within_distance_by_property()\n\"power\"}, then the content of mapping file is [{\"VSS\": 1.0, \"VSS2\": 2.0,\n\"GD\": 3.0}, {\"VDD\": 1.0, \"VDD2\": 2.0, \"VDD3\": 3.0}]."}, "summary": "Creates a polygon layer that represents the active area of the polygons of the layer2s\nlayers list that are not within the specified distance of the layer1  polygons in the same\nset.", "function_name": "not_within_distance_by_property()"}
{"description": "The np()  function collects extraction configuration information about NP diodes extracted\nfrom the specified device body layer. The pn()  function collects extraction configuration\ninformation about PN diodes extracted from the specified device body layer. The\nconfiguration information, which contains device body and terminal layers, property\nextraction information, schematic device mappings, and pin handling instructions, is\nstored in the device matrix that is passed to the\nextract_devices()  function. For the\nNP or PN device to be recognized, the device body layer polygons must interact with\none polygon from each terminal layer and from each specified optional pins layer. If\nan optional pin layer with the pin_type  option set to BULK  is specified, the required\nrelationship between the pin layer polygon and the device body layer polygon is defined by\nthe bulk_relationship  argument. If an optional pin layer with the pin_type  option set\nto TERMINAL  is specified, the optional pin layer polygon must interact with the device body\nlayer polygon but is not required to enclose the device body layer polygon.\nNote:\nSee\nDevice Names  on page 3350 for the device_name  argument restrictions.", "syntax": "np(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndevice_body            = polygon_layer,\nanode                  = polygon_layer,\ncathode                = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nnp() and pn()\nNETLIST | NETLIST_SPICE | AUTO  |\nNETLIST_SKIP_PCELL,\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\nanode         = \"string\",\ncathode       = \"string\",\nbulk_terms    = {\"string\", ...},\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nextract_shorted_device = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false                //optional\n);\npn(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndevice_body            = polygon_layer,\nanode                  = polygon_layer,\ncathode                = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nnp() and pn()\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL},\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\nanode         = \"string\",\ncathode       = \"string\",\nbulk_terms    = {\"string\", ...},\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nextract_shorted_device = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false                //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.", "device_name": "Required. Specifies the diode. A device name can be reused across multiple\ncalls of the np()  function or pn()  function, but not across both functions, if all\ncalls have\nnp() and pn()\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.", "device_body": "Required. Specifies the body layer of the diode.", "anode": "Required. Specifies the anode layer of the diode. The pin name generated by\nthe IC Validator tool is \u201cANODE\u201d.", "cathode": "Required. Specifies the cathode layer of the diode. The pin name generated by\nthe IC Validator tool is \u201cCATHODE\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named \u201cBULK\u201d.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nnp() and pn()\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  functions for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultnp and pn\nThe default is\nproperties   = {{\"area\", DOUBLE, PICO},\n{\"pj\", DOUBLE, MICRO}},\n\u2022 name. Specifies the property name. See \u201cPredefined Name Matches\u201d in\nChapter 7, \u201cCompare Functions Basics\u201d of the IC Validator LVS User Guide\nfor the names and associated matches that are predefined during LVS\ncompare.\nnp() and pn()\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Specifies the data type of the property. The default is DOUBLE.\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\nnp() and pn()\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST. Writes the corresponding property to\nnp() and pn()\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\nnp() and pn()\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the nmos() and pmos()  functions for an example.\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric\nproperties for each extracted diode. The default calculations are for the\narea of the diode (area) and the perimeter of the junction (pj). The default\ncalc_diode_properties()  function is defined in the device_public.rh header\nfile.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon.\nnp() and pn()\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, no pins can be swapped.\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the standard \u201cANODE\u201d,\n\u201cCATHODE\u201d, and \u201cBULK\u201d pin names, in addition to optional pin\nnames provided in the optional_pins  list of structures argument of\nthe device configuration function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 anode. Optional. Specifies the anode terminal of the device. The default is\n\"ANODE\".\n\u2022 cathode. Optional. Specifies the cathode terminal of the device. The default\nis \"CATHODE\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin_name  option in the optional_pins  argument.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is similar\nto the pin_compared  option of the optional_pins  argument of the np()  and\npn()  functions.\nnp() and pn()\nIf the schematic device has an optional pin that does not correspond to\nany pin in the np()  and pn()  functions, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "x_card": "Optional. Specifies if the instance name prefix is replaced. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with an X-card. This option facilitates the use of SPICE SUBCKT\nmodels to represent devices in simulation.\n\u2022 false. The default instance name prefix for the layout extracted device is not\nreplaced.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  on page 2894 for more information.", "extract_shorted_device": "Optional. Specifies whether shorted diodes, that is, diodes with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted diodes.\n\u2022 false. Reports shorted diodes as error devices.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Specifies the user-derived string used by the remote property function. The\nunique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe strings are valid and unique. (The IC Validator tool does not check values to\nensure that they are unique.) The default is an empty string (\"\").\nnp() and pn()\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped. By default, the IC Validator tool does not\nmap swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nrunset report file. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement data\nto external libraries. See the \u201cDynamic-Link Library Support\u201d chapter in the\nIC Validator User Guide  and\nDynamic Linking Utility Functions  on page 2897 for\nmore information.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\nnp() and pn()\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee the Table 40  table for more information about the behavior of the\ntop_simulation_properties  argument."}, "summary": "The np()  function collects extraction configuration information about NP diodes extracted\nfrom the specified device body layer.", "function_name": "np()"}
{"description": "The npn()  function collects extraction configuration information about NPN-type bipolar\ntransistors that consist of an emitter layer, base layer, collector layer, and an optional\nbulk layer. The pnp()  function collects extraction configuration information about PNP-\ntype bipolar transistors that consist of an emitter, base, collector, and optional bulk layer.\nThe configuration information, which contains device body and terminal layers, property\nextraction information, schematic device mappings, and pin handling instructions, is stored\nin the device matrix that is passed to the\nextract_devices()  function. When multiple\nemitter (or collector) polygons are found that interact with the same base and collector (or\nemitter) polygons, multiple NPN-type and PNP-type bipolar transistors are extracted.\nNote:\nSee\nDevice Names  for the device_name  argument restrictions.", "syntax": "npn(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ncollector              = polygon_layer,\nbase                   = polygon_layer,\nemitter                = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL},\nscale_mode        = MULTIPLY| UNIT},\npex_string_property_double_quotes =\ntrue  |\nfalse},\n},                                 //optional\nnpn() and pnp()\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\ncollector     = \"string\",\nbase          = \"string\",\nemitter       = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nbody_position          = EMITTER | BASE | COLLECTOR |\nDEVICE_BODY,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false,               //optional\ndevice_body             = polygon_layer                       //optional\n);\npnp(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ncollector              = polygon_layer,\nbase                   = polygon_layer,\nemitter                = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK,\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL,\nnpn() and pnp()\nscale_mode        = MULTIPLY| UNIT},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\ncollector     = \"string\",\nbase          = \"string\",\nemitter       = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nbody_position          = EMITTER | BASE | COLLECTOR\nDEVICE_BODY,                       //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false,               //optional\ndevice_body             = polygon_layer                       //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.", "device_name": "Required. Specifies the bipolar transistor. A device name can be reused across\nmultiple calls of the npn()  function orpnp()  function, but not across both\nfunctions, if all calls have\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\nnpn() and pnp()\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.", "collector": "Required. Specifies the collector layer of the transistor device. The pin name\ngenerated by the IC Validator tool is \u201cCOLL\u201d.", "base": "Required. Specifies the base layer of the transistor device. The pin name\ngenerated by the IC Validator tool is \u201cBASE\u201d.", "emitter": "Required. Specifies the emitter layer of the transistor device. The pin name\ngenerated by the IC Validator tool is \u201cEMIT\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named \u201cBULK\u201d.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.\nnpn() and pnp()", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  function for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultnpn and pnp\nThe default is\nproperties = {{\"area\", DOUBLE, PICO}},\n\u2022 name. Specifies the property name. See \u201cPredefined Name Matches\u201d in\nChapter 7, \u201cCompare Functions Basics\u201d of the IC Validator LVS User Guide\nfor the names and associated matches that are predefined during LVS\ncompare.\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Specifies the data type of the property. The default is DOUBLE.\nnpn() and pnp()\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\nnpn() and pnp()\n- The annotation file by the write_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the\nnetlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nnpn() and pnp()\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the\nnmos() and pmos()  functions for an example.\nnpn() and pnp()\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric properties\nfor each extracted device. The default calculation is for the active area. The\ndefault calc_bjt_properties()  function is defined in the device_public.rh\nheader file.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon.\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, no pins can be swapped.\nnpn() and pnp()\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals used for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the standard COLL, BASE,\nEMIT, and BULK  pin names, in addition to optional pin names provided\nin the optional_pins  list of structures argument of the device\nconfiguration function.\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 collector. Optional. Specifies the collector terminal of the device. The\ndefault is \"COLL\".\n\u2022 base. Optional. Specifies the base terminal of the device. The default is\n\"BASE\".\n\u2022 emitter. Optional. Specifies the emitter terminal of the device. The default is\n\"EMIT\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin name in the optional_pins  argument.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is similar\nto the pin_compared  option of the optional_pins  argument of the npn()\nand pnp()  functions.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the npn()  and pnp()  functions, that pin can be specified with\nthe ignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.\nnpn() and pnp()", "x_card": "Optional. Specifies if the instance name prefix is replaced. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with an X-card. This option facilitates the use of SPICE SUBCKT\nmodels to represent devices in simulation.\n\u2022 false. The default instance name prefix for the layout extracted device is not\nreplaced.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  function. See\nFlexible Netlisting Utility Functions  on page 2894 for more information.", "body_position": "Optional. Specifies the body layer of the bipolar transistor. The default is\nEMITTER.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Specifies the user-derived string used by the remote property function. The\nunique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe strings are valid and unique. (The IC Validator tool does not check values to\nensure that they are unique.) The default is an empty string (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.\nnpn() and pnp()", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped. By default, the IC Validator tool does not\nmap swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nrunset report file. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement data\nto external libraries. See the \u201cDynamic-Link Library Support\u201d chapter in the\nIC Validator User Guide  and\nDynamic Linking Utility Functions  on page 2897 for\nmore information.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee\nTable 40  for more information about the behavior of the\ntop_simulation_properties  argument.", "device_body": "Optional. Specifies the body layer of the NPN-type or PNP-type bipolar\ntransistor. When specified, body_position  is overwritten by DEVICE_BODY."}, "summary": "The npn()  function collects extraction configuration information about NPN-type bipolar\ntransistors that consist of an emitter layer, base layer, collector layer, and an optional\nbulk layer.", "function_name": "npn()"}
{"description": "The oasis_library()  function defines an OASIS file name and returns a file handle to be\nused by the output_library  argument of the\nwrite_oasis_global_options()  function.\nNote:\nThe oasis_library()  function cannot be called more than one time with\nthe same file argument. The result, however, can be used in more than one\nwrite_oasis()  function, in which case the file is overwritten.", "syntax": "oasis_library(\nfile = \"string\"\n);", "returns": "oasis_library_handle\noasis_library_handle", "arguments": {"file": "Required. OASIS file name. See the\nwrite_oasis_global_options()  function\nfor more information."}, "summary": "The oasis_library()  function defines an OASIS file name and returns a file handle to be\nused by the output_library  argument of the\nwrite_oasis_global_options()  function.", "function_name": "oasis_library()"}
{"description": "The oasis_options()  function specifies the behavior of the IC Validator tool when\nreading an OASIS file.", "syntax": "oasis_options(\nduplicate_cell         = REPLACE | DROP | MERGE,            //optional\ncell_name_map          = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                             //optional\nforce_cell_name_case   = UPPER | LOWER | MIXED,             //optional\nmerge_references       = true | false,                      //optional\ncircles                = DROP | CONVERT_TO_POLYGON  | ABORT, //optional\nabort_path_extension_3 = true | false,                      //optional\ngenerate_property_text  = NONE  | TOP | ALL,                  //optional\ntext                   = {objects    = {PROPERTY_TEXT, TEXT},\nproperties = {integer, ...}},     //optional\nnamed_property_map     = {{name = \"string\",\nnumber = integer}, ...},         //optional\nreplace_instance_name_characters = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                  //optional\nmissing_cell            = REPORT  | ABORT,                   //optional\ncircle_vertices         = VERTICES_32  | VERTICES_64\nVERTICES_256 | VERTICIES_AUTO,    //optional\npath_width_multiple_check      = {multiple = 1,\naction   = KEEP| KEEP_AND_WARN |\nDROP | DROP_AND_WARN |\nABORT},        //optional\npath_extension_multiple_check  = {multiple = 1,\naction   = KEEP| KEEP_AND_WARN |\nDROP | DROP_AND_WARN |\nABORT}         //optional\n);", "returns": "void", "arguments": {"duplicate_cell": "Optional. Specifies how the duplicate cells are processed when reading multiple\nOASIS input files.\noasis_options()\n\u2022 REPLACE. Replaces any previously read cells of the same name with the last\ncell read for any duplicate cells.\n\u2022 DROP. Does not replace the first cell read with any subsequently read cells of\nthe same name.\n\u2022 MERGE. Merges all geometric data into a single cell. References, however, are\nfurther controlled by the merge_references  argument.", "cell_name_map": "Optional. Specifies a list that tells how cell names are remapped as data is read\nin. By default, the IC Validator tool does not remap cell names.\n\u2022 search_string. Required. Specifies the existing cell name in the input\nstream.\n\u2022 replace_string. Required. Specifies the cell name as it exists within the\nIC Validator tool after the input stream is read.", "force_cell_name_case": "Optional. Forces the character case of cell names. The default is MIXED.\n\u2022 UPPER. Converts all cell names to uppercase characters when the OASIS file\nis read.\n\u2022 LOWER. Converts all cell names to lowercase characters when the OASIS file\nis read.\n\u2022 MIXED. Maintains the character case that cell names have in the OASIS file.", "merge_references": "Optional. Specifies the merging of cell references when duplicate cells are found\nin multiple OASIS input files.\nThe merge_references  argument applies only when the duplicate_cell\nargument is MERGE. If the duplicate_cell  argument is REPLACE, the references\nin the last cell read replace any previously read cells of the same name. If the\nduplicate_cell  argument is DROP, the references of the first cell read are\nused. The default is true.\n\u2022 true. Merges cell references into existing cells when duplicate cells are\nfound.\n\u2022 false. Does not merge cell references into duplicate cells.", "circles": "Optional. Specifies the conversion of circles from the input OASIS file to\npolygons. The default is CONVERT_TO_POLYGON.\noasis_options()\n\u2022 DROP. Does not convert circles to polygons.\n\u2022 CONVERT_TO_POLYGON. Converts circles to 32-point polygons depending on\nthe value of the circle_vertices  argument.\n\u2022 ABORT. Stops the run if a circle is encountered.", "abort_path_extension_3": "Optional. Specifies when the run stops. When set to true, the run stops when\nencountering a path with a variable extension (type 3). The default is false.", "generate_property_text": "Optional. Specifies if text points are generated from polygon properties in the\ninput library. The default is NONE.\n\u2022 NONE. Does not generate text from properties in the input library.\n\u2022 TOP. Generates property text only for the top cell of the design.\n\u2022 ALL. Generates property text for all cells in the hierarchy.", "text": "Optional. Controls the reading of text from an OASIS input library for each\nassigned text layer. If generate_property_text  is TOP  or ALL, text points are\ngenerated for polygons with associated properties. The text is located on the\npolygon and has the same layer and datatype.\nNote:\nThis global option is overwritten by selections made in the oasis\nargument of the\nassign_text()  function.\n\u2022 objects. Optional. Assigns the specified text types to a layer when reading\nan OASIS library. The default is TEXT.\n\u25e6 PROPERTY_TEXT. Assigns automatically generated text for polygons.\n\u25e6 TEXT. Assigns OASIS text points from the input database.\n\u2022 properties. Optional. Specifies the property numbers to use when objects\ncontains PROPERTY_TEXT. The property numbers must be in the range of 0\u2013\n255, inclusive. If this list is empty, no property text is assigned.", "named_property_map": "Optional. Lists the name and number pairs that support the reading of named\nproperties from an OASIS stream. For each pair, properties of the given name\nare read as GDSII-compatible numbered properties of the given number.\noasis_options()\n\u2022 name. Specifies the property name.\n\u2022 number. Specifies the number to assign to the property. The property\nnumbers must be in the range of 0\u2013255, inclusive.\nFor example, this argument reads property \u201cNet\u201d onto property 2:\noasis_options(named_property_map = {\"Net\", 2});", "replace_instance_name_characters": "Optional. Lists the strings to be replaced in instance names. Neither string\ncan use string matching. By default, the IC Validator tool does not replace any\ncharacters.\n\u2022 search_string. Required. Specifies the string to replace.\n\u2022 replace_string. Required. Specifies the replacement string. An empty\nstring (\"\") results in the removal of the specified search string.", "missing_cell": "Optional. Specifies the behavior if a referenced cell is missing. The default is\nREPORT.\n\u2022 REPORT. Issues a warning message about the missing cell and reports it in\nthe block.LAYOUT_ERRORS file.\n\u2022 ABORT. Reports an error message for the missing cell.", "circle_vertices": "Optional. Specifies if circles are approximated by 64-point polygons. This\nargument is used only if oasis_options(circles = CONVERT_TO_POLYGON)  is\nalso set. The default is VERTICES_32.\n\u2022 VERTICES_32. Approximates OASIS circles with 32-point polygons.\n\u2022 VERTICES_64. Approximates OASIS circles with 64-point polygons.\n\u2022 VERTICES_256. Approximates OASIS circles with 256-point polygons.\n\u2022 VERTICIES_AUTO. Automatically chooses the number of points based on the\nradius of the circle:\n64 points if circle radius < 9 microns\n256 points if circle radius >= 9 microns", "path_width_multiple_check": "Optional. Checks that the width value of path records is an even multiple of a\nspecific constraint value.\noasis_options()\n\u2022 multiple. Specifies the integer constraint to identify the problematic path\nwidth. The default is 1.\n\u2022 action. Specifies whether the problematic path record is kept, kept and a\nwarning issued, dropped, dropped and a warning issued, or if IC Validator\nshould terminate. The default is KEEP.\n\u25e6 KEEP. Keeps the problematic path record.\n\u25e6 KEEP_AND_WARN. Keeps the problematic path record and issues a\nwarning.\n\u25e6 DROP. Drops the problematic path record.\n\u25e6 DROP_AND_WARN. Drops the problematic path record and issues a\nwarning.\n\u25e6 ABORT. Specifies that IC Validator should terminate.", "path_extension_multiple_check": "Optional. Checks that the extension value of path records are an even multiple\nof a specific constraint value.\n\u2022 multiple. Specifies the integer constraint to identify the problematic path\nextension. The default is 1.\n\u2022 action. Specifies whether the problematic path record is kept, kept and a\nwarning issued, dropped, dropped and a warning issued, or if IC Validator\nshould stop. The default is KEEP.\n\u25e6 KEEP. Keeps the problematic path record.\n\u25e6 KEEP_AND_WARN. Keeps the problematic path record and issues a\nwarning.\n\u25e6 DROP. Drops the problematic path record.\n\u25e6 DROP_AND_WARN. Drops the problematic path record and issues a\nwarning.\n\u25e6 ABORT. Specifies that IC Validator should terminate."}, "summary": "The oasis_options()  function specifies the behavior of the IC Validator tool when\nreading an OASIS file.", "function_name": "oasis_options()"}
{"description": "The octagon()  function checks the diameter of an octagon, given a specified CAD layer.", "syntax": "octagons(\nlayer1           = polygon_layer,\ndiameter         = double_constraint, //optional\ntolerance        = double, //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label\",\npredicate        = true  | false\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies a polygon layer.", "diameter": "Optional. Specifies the diameter of the minimum enclosing octagon, which\nencloses the nonpeak points. See\nConstraints  for more information.", "tolerance": "Optional. Specifies the expansion values to the original <diameter>  constraint.\noctagons()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Specifies the name used by the IC Validator tool for the output layer. This\nname is displayed in various output log files, such as the summary, tree, and\ndistributed processing log files. It is used only for log files; runset variables are\nnot changed. The default is the name of the layer being created.", "predicate": "Specifies a predicate_handle  for empty layer optimization. The predicate\ncontrols the operation as follows:\n\u2022 true. The function operates as normal.\n\u2022 false. The function produces empty output."}, "summary": "The octagon()  function checks the diameter of an octagon, given a specified CAD layer.", "function_name": "octagons()"}
{"description": "The off_grid()  function creates squares that indicate vertices and cell placements that\nare off the specified grid. This function is a cell-level operation.", "syntax": "off_grid(\nlayer1     = data_layer,\nresolution = double,\nshape_size = double,        //optional\nname       = \"layer_label\"  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "resolution": "Required. Specifies the resolution value for the grid check.", "shape_size": "Optional. Specifies the size of the output squares. The value must be positive.\nIt is rounded to the nearest even multiple of the internal resolution, with a\nminimum value of twice the internal resolution. The internal_resolution\nargument of the\nresolution_options()  function sets the internal resolution.\nThe default is DRC_ERROR_BOX, which has a default of 0.1.\nNote:\nThe shape_size  argument only takes effect when the output is a\npolygon layer. When the output is an error result, the function returns\na point.\nFigure 481  shows the effect of the resolution  argument setting with the\noff_grid()  function.\noff_grid()\nFigure 481 resolution Argument Example With the off_grid() Function\nFigure 482  shows the effect of the shape_size  argument setting with the\noff_grid()  function.\nFigure 482 shape_size Argument Example With the off_grid() Function", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The off_grid()  function creates squares that indicate vertices and cell placements that\nare off the specified grid.", "function_name": "off_grid()"}
{"description": "The off_grid_directional_edge()  function checks grid locations of input layer1\nedges within an enclosing reference layer. Input layer1  edges that are enclosed or\ncoincident with the enclosing reference layer are checked. Measurements are taken from\nlayer1  edges to the extents of enclosing reference_layer  polygons.", "syntax": "off_grid_directional_edge(\nlayer1          = data_layer,\nreference_layer = polygon_layer,\ngrid_checks      = {{distance = double,\ngrid       = double,\ndirection  = {NORTH | SOUTH |\nEAST | WEST},\ncheck_side = {OUTSIDE | INSIDE |\nBOTH}}, ... },\nname            = \"layer_label\"  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "reference_layer": "Required. Specifies the name of the polygon layer enclosing the layer1  edges.", "grid_checks": "Required. Specifies the list of directional measurement criteria.\n\u2022 distance. Required. Specifies the nonnegative floating-point number in user\nunits, which specifies the initial enclosure distance interval measured from a\nlayer1  edge.\n\u2022 grid. Required. Specifies the nonnegative floating-point number in user\nunits, which specifies the enclosure distance value that is added in integral\nmultiples to the distance value to define the measurement checking grid.\n\u2022 direction. Specifies the keyword which determines the direction of\nmeasurement from the layer1  edges.\noff_grid_directional_edge()\n\u2022 check_side. Specifies the keyword which determines the measurement\nfrom a layer1  edge based on the direction the edge faces. By default, the\ndirection an edge faces is not considered. For edge layer1  consisting of\nlines, direction is not considered.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The off_grid_directional_edge()  function checks grid locations of input layer1\nedges within an enclosing reference layer.", "function_name": "off_grid_directional_edge()"}
{"description": "The off_grid_directional_error()  function checks grid locations of input layer1\nedges within an enclosing reference layer. Input layer1  edges that are enclosed or\ncoincident with the enclosing reference layer are checked. Measurements are taken from\nlayer1  edges to the extents of enclosing reference_layer  polygons.", "syntax": "off_grid_directional_error(\nlayer1          = data_layer,\nreference_layer = polygon_layer,\ngrid_checks      = {{distance = double,\ngrid       = double,\ndirection  = {NORTH | SOUTH |\nEAST | WEST},\ncheck_side = {OUTSIDE | INSIDE |\nBOTH}}, ... },\nname            = \"layer_label\"  //optional\n);", "returns": "error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "reference_layer": "Required. Specifies the name of the polygon layer enclosing the layer1  edges.", "grid_checks": "Required. Specifies the list of directional measurement criteria.\n\u2022 distance. Required. Specifies the nonnegative floating-point number in user\nunits, which specifies the initial enclosure distance interval measured from a\nlayer1  edge.\n\u2022 grid. Required. Specifies the nonnegative floating-point number in user\nunits, which specifies the enclosure distance value that is added in integral\nmultiples to the distance value to define the measurement checking grid.\n\u2022 direction. Specifies the keyword which determines the direction of\nmeasurement from the layer1  edges.\noff_grid_directional_error()\n\u2022 check_side. Specifies the keyword which determines the measurement\nfrom a layer1  edge based on the direction the edge faces. By default, the\ndirection an edge faces is not considered. For edge layer1  consisting of\nlines, direction is not considered.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The off_grid_directional_error()  function checks grid locations of input layer1\nedges within an enclosing reference layer.", "function_name": "off_grid_directional_error()"}
{"description": "The off_grid_xy()  function supports grid checking in the x- and y-directions relative\nto either a reference layer or the origin of the layout coordinate system. It can check the\ncenter of rectangles, polygons, and edges, as well as polygon and edge vertices.", "syntax": "off_grid_xy(\nlayer1          = data_layer,\nx_resolution    = double,\ny_resolution    = double,\ncoordinates     = VERTICES  | CENTER,                        //optional\nshape_size      = double,                                   //optional\nreference_layer  = polygon_layer,                            //optional\nname            = \"layer_label\",                            //optional\nreference_origin          = LEFT_BOTTOM  | RIGHT_TOP,        //optional\nreference_origin_x_offset = double,                         //optional\nreference_origin_y_offset = double,                         //optional\nreference_grid   = LAYER1 | REFERENCE_LAYER  |\nREFERENCE_LAYER_EXTENTS                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "x_resolution": "Required. Specifies the x-coordinate resolution value for the grid check.", "y_resolution": "Required. Specifies the y-coordinate resolution value for the grid check.", "coordinates": "Optional. Specifies how to check for off-grid coordinates. The default is\nVERTICES.\n\u2022 VERTICES. Checks edge or polygon vertices.\n\u2022 CENTER. Checks the center of edges or polygons.\noff_grid_xy()", "shape_size": "Optional. Specifies the size of the output squares. The value must be positive.\nThe value is rounded to the nearest even multiple of the internal resolution, with\na minimum value of twice the internal resolution. The internal_resolution\nargument of the\nresolution_options()  function sets the internal resolution.\nThe default is DRC_ERROR_BOX, which has a default of 0.1.\nNote:\nThe shape_size  argument only takes effect when the output is a\npolygon layer. When the output is an error result, the function returns\na point.", "reference_layer": "Optional. Specifies the reference layer. Only polygons specified by the layer1\nargument that are enclosed by the reference layer are processed. The reference\nfor grid checking is the lower-left coordinate of the extent of each reference layer\npolygon.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "reference_origin": "Optional. Specifies from which corner of the reference layer polygon to perform\ngrid checking. The default is LEFT_BOTTOM.\n\u2022 LEFT_BOTTOM. Specifies that the origin of the reference layer polygon is the\nleft bottom corner.\n\u2022 RIGHT_TOP. Specifies that the origin of the reference layer polygon is the\nright top corner.", "reference_origin_x_offset": "Optional. Specifies the offset in the x-direction from the specified corner of the\nreference layer polygon. The default is 0.0.", "reference_origin_y_offset": "Optional. Specifies the offset in the y-direction from the specified corner of the\nreference layer polygon. The default is 0.0.", "reference_grid": "Optional. Specifies how the grid origin is determined. The default is\nREFERENCE_LAYER.\noff_grid_xy()\n\u2022 LAYER1. Specifies that grid origin is determined by the total rectangular\nextent of layer1  objects inside of the reference_layer  polygon.\n\u2022 REFERENCE_LAYER. Specifies that grid origin is determined by the extent of\nthe reference_layer  polygon.\n\u2022 REFERENCE_LAYER_EXTENTS. Specifies that grid origin is determined by the\nextents of the reference_layer. The layer1  objects are not checked for\nenclosure by the reference_layer."}, "summary": "The off_grid_xy()  function supports grid checking in the x- and y-directions relative\nto either a reference layer or the origin of the layout coordinate system.", "function_name": "off_grid_xy()"}
{"description": "The openaccess_library()  function defines an OpenAccess library definition file\nname and returns a file handle to be used by the output_library  argument of the\nwrite_openaccess()  function.\nNote:\nThe openaccess_library()  function cannot be called more than one time with\nthe same file argument. The result, however, can be used in more than one\nwrite_openaccess()  function.", "syntax": "openaccess_library(\nlibrary_definition_file = \"string\"\n);", "returns": "openaccess_library_handle\nopenaccess_library_handle", "arguments": {"library_definition_file": "Required. OpenAccess file name. See the\nwrite_openaccess()  function for\nmore information."}, "summary": "The openaccess_library()  function defines an OpenAccess library definition file\nname and returns a file handle to be used by the output_library  argument of the\nwrite_openaccess()  function.", "function_name": "openaccess_library()"}
{"description": "The openaccess_merge_library_options()  function specifies a mapping from the\nmaster and reference OpenAccess libraries to replacement GDSII and OASIS libraries\nthat are read in with OpenAccess data at the start of a verification run. This function can\nbe called only one time in a runset.\nYou can use the -ml  command-line option to override the settings in the\nopenaccess_merge_library_options()  function. See the Command-Line Options\nsection in the \u201cIC Validator Basics\u201d chapter of the IC Validator User Guide  for more\ninformation.\nFor example, if cell ref1.A.layout is in the OpenAccess library, the layout view is replaced\nwith the GDSII or OASIS data for cell A.\nWhen using the openaccess_merge_library_options()  function, read all required\nGDSII and OASIS data during an IC Validator run to emulate the complete mask data set\nfor a designated top-level structure. The lower-level cells in the replacement data is not\npermanently merged into the input OpenAccess library. Data is temporarily merged for\nonly this run.\nNote:\nThe master OpenAccess library and top-level cell are identified in\nthe runset by the\nlibrary()  function. The mapping specified in the\nopenaccess_merge_library_options()  function never looks for a\nreplacement of the top cell.\nWhen using the openaccess_merge_library_options()  function, you should be familiar\nwith OpenAccess library/cell/view triples.", "syntax": "openaccess_merge_library_options(\nlibraries = {{library_name          = \"string\",\nview_name             = \"string\",\nreplacement_libraries = {{\nfile             = \"string\",\nformat           = GDSII | OASIS,\ncell_name_map    = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},\nlayer_map_file   = \"string\",\nlayout_integrity = {{db_name = \"string\",\nmissing_db =\nABORT  | IGNORE,\ncell_name_map  =\n{{search_string  = \"string\",\nreplace_string = \"string\"},\nopenaccess_merge_library_options()\n...}},\n...},\n},\n...},\n...}},\nmissing_cell    = ABORT  | USE_OPENACCESS,                   //optional\nreport          = {USED_CELLS, UNUSED_CELLS,\nMISSING_CELLS, LAYER_MAPS,\nDUPLICATE_CELLS},                        //optional\nmissing_library = ABORT  | CONTINUE                          //optional\n);", "returns": "void", "arguments": {"libraries": "Required. Lists the OpenAccess and replacement libraries.\n\u2022 library_name. Required. Specifies the OpenAccess library name. You only\nneed to list the OpenAccess libraries for which you want to do replacements.\n\u2022 view_name. Optional. Specifies the OpenAccess view name for cells being\nreplaced. Use this option if you want to set the view name for these cells to\nsomething other than the default view of \u201clayout.\u201d\n\u2022 replacement_libraries. Required. Specifies the replacement libraries.\nThe IC Validator tool searches the replacement libraries in the order specified\nlooking for cells. The first cell found is the one used.\nNote:\nA GDSII or OASIS file can be gzipped\nGDSII filezipped\n. The IC Validator tool\nautomatically detects if a GDSII or OASIS file is gzipped.\n\u25e6 file. Specifies the replacement file.\n\u25e6 format. Specifies the format of the replacement libraries, GDSII or\nOASIS.\n\u25e6 cell_name_map. Optional. Specifies a list that tells how cell names are\nmapped as data is read in. Use this list when the GDSII or OASIS cell\nname does not match the corresponding OpenAccess cell name. If you\ndo not use this list to map duplicate cell names, the IC Validator tool\nautomatically does the mapping and resolves all hierarchical references\nto the new name.\n- search_string. Specifies the cell name in the GDSII or OASIS data\nthat is renamed.\nopenaccess_merge_library_options()\n- replace_string. Specifies the new cell name given to the cell in the\nGDSII or OASIS data. This cell name is used within the IC Validator tool\nafter the input data is read.\n\u25e6 layer_map_file. Optional. Specifies the layer mapping file for this set of\nlibraries. You can map GDSII or OASIS data to OpenAccess data. The file\ncan be a basic layer/datatype mapping or OpenAccess format:\nBasic format:\nDestinationLayer[:DestinationDatatype] SrcLayer[:SrcDataty\npe]\nAll the geometric and text data on SrcLayer  and SrcDatatype  are moved\nto DestinationLayer  and DestinationDatatype.\nWhen using this format, the layer/datatype are mapped from the\nreplacement GDSII or OASIS file directly to the runset assigns.\nOpenAccess format:\n\uff0clayer_name  layerPurpose   layerNo.   layerDataType\nlayer1      layerPurpose1  layerNo1   layerDataType1\nlayer2      layerPurpose2  layerNo2   layerDataType2\n...\nAll the geometric and text data on layerNo1  and layerDataType1  in\nGDSII and OASIS are moved to the OpenAccess layer1  layer and the\nlayerPurpose1  purpose.\nWhen using this format, the layer/datatype are mapped from the\nreplacement GDSII or OASIS file to OpenAccess layer/purpose in the\nmain OpenAccess database. If a layer mapping file is provide in the\nopenaccess_options()  function, then that mapping is applied after\nthe mapping specified with this layer_map_file  option to map from\nOpenAccess layer/purpose to the runset layer/datatype.\nSee the layer_mapping_file  argument of the\nopenaccess_options()\nfunction for more information.\n\u25e6 layout_integrity. Optional. Specifies the list of layout integrity\ndatabases that the IC Validator tool uses for layout integrity checking. By\ndefault, the IC Validator tool does not check layout integrity.\nNote:\nThe layout integrity database applies to cells in the\nreplacement library. OpenAccess cells are checked against\nglobal layout integrity options, if any.\nopenaccess_merge_library_options()\n- db_name. Required. Specifies the path to the layout integrity database.\n- missing_db. Optional. Specifies the behavior when the IC Validator tool\ndoes not find the specified layout integrity database. The default is ABORT.\nABORT. Specifies that the run stops when the layout integrity database is\nnot found.\nIGNORE. Continues the IC Validator run if the tool cannot find the layout\nintegrity database.\n- cell_name_map. Optional. Specifies a list that tells how cell names are\nremapped as data is read from the layout integrity databases (LIDBs). By\ndefault, the IC Validator tool does not remap cell names.\n- search_string. Required. Specifies the existing cell name in the input\nLIDB.\n- replace_string. Required. Specifies the cell name used for layout\nintegrity checking within IC Validator.", "missing_cell": "Optional. Specifies the action taken if a cell is missing from the replacement file.\nThe default is ABORT.\n\u2022 ABORT. Specifies if the run stops when a cell in the OpenAccess library is not\nfound in a replacement file.\n\u2022 USE_OPENACCESS. If a cell in the OpenAccess library is not found in a GDSII\nor OASIS replacement file, then the tool uses the OpenAccess cell that is\nsupposed to be replaced.", "report": "Optional. Specifies the information written to the\nopenaccess_merge_library_options.log file. The categories you can specify\nfor output are USED_CELLS, UNUSED_CELLS, MISSING_CELLS, LAYER_MAPS, and\nDUPLICATE_CELLS. The default output reports all categories. This file is in the\nrun_details directory.", "missing_library": "Optional. Specifies the IC Validator action when the replacement library does not\nexist. The default is ABORT.\n\u2022 ABORT. issues an error message when a replacement library does not exist.\n\u2022 CONTINUE. Behaves as if the replacement library was never specified and\ncontinues running.\nopenaccess_merge_library_options()"}, "summary": "The openaccess_merge_library_options()  function specifies a mapping from the\nmaster and reference OpenAccess libraries to replacement GDSII and OASIS libraries\nthat are read in with OpenAccess data at the start of a verification run.", "function_name": "openaccess_merge_library_options()"}
{"description": "The openaccess_options()  function specifies the behavior of the IC Validator tool when\nreading OpenAccess input.\nIn an OpenAccess database, every cell is specified by library, cell, and view. When reading\nOpenAccess, each library/cell/view triplet is read into a unique cell in IC Validator. In the\nIC Validator output files, the naming scheme for cells is\n\u2022 The name of any cell that is part of the original library and view of the top cell is used\nunmodified.\n\u2022 The name of any cell with a different library or view name from the top cell is renamed\nas\nlibrary.cell.view\n\u2022 If this new name conflicts with an existing cell in the design or if it is very long, the\nIC Validator tool ensures a unique name by further renaming.\nLayer-purpose names for blockage and boundary OpenAccess objects are not predefined.\nTo extract polygon layer objects from the OpenAccess oaBoundary and oaBlockage\nfamily objects, use the pr_boundary, area_blockage, area_halo, area_boundary,\nlayer_blockage, and layer_halo  arguments. If you do not specify these objects in the\nopenaccess_options()  function, they are not read by the IC Validator tool.", "syntax": "openaccess_options(\nview                              = \"string\",                //optional\nlayer_mapping_file                = \"string\",                //optional\ngenerate_pin_text                = NONE | TOP | ALL,        //optional\npin_text                         = NET_NAME | PIN_NAME | REASSIGN,\n//optional\nreplace_instance_name_characters = {{search_string  = \"string\",\nreplace_string = \"string\"},\n...},                   //optional\ngenerate_polygon_text            = NONE | TOP | ALL,        //optional\nmerged_view_list  = {{view = \"string\",\ncell = \"string\",\nlibrary = \"string\",\noutdated_views = ABORT  | USE | DISCARD},\n...},                                  //optional\npr_boundary        = {layer_name    = \"string\",\npurpose_name  = \"string\"},             //optional\narea_blockage      = {layer_name    = \"string\",\npurpose_name  = \"string\"},             //optional\narea_halo          = {layer_name    = \"string\",\npurpose_name  = \"string\"},             //optional\nopenaccess_options()\narea_boundary      = {layer_name    = \"string\",\npurpose_name  = \"string\"},             //optional\nlayer_blockage     = \"string\",                               //optional\nlayer_halo         = \"string\",                               //optional\ncell_mapping_file  = \"string\",                               //optional\ngenerate_terminal_text = NONE | TOP | ALL,                  //optional\nterminal_text          = NET_NAME  | TERMINAL_NAME,          //optional\ntriplet_naming          = LIBRARIES_AND_VIEWS  | CONFLICT,    //optional\ninstance_names         = KEEP  | DISCARD,                    //optional\nobject_mapping_file    = \"string\",                          //optional\nmissing_cell            = ABORT | IGNORE                     //optional\n);", "returns": "void", "arguments": {"view": "Optional. Specifies the view to be read for the top cell of the design. The default\nis \"layout\".", "layer_mapping_file": "Optional. Specifies the OpenAccess layer mapping file that specifies which\nlayer/purpose pairs are read from the OpenAccess database and the layer/\ndatatype numbers onto which the pairs are read. This file is required if you use\nthe assign(), assign_edge(), or assign_text()  functions for OpenAccess\ndata. If an object is mapped in the layer mapping file as well as the object\nmapping file, the object mapping file takes precedence.\nIn the OpenAccess layer mapping file,\n\u2022 Each mapping relation must appear on a new line.\n\u2022 Each attribute on a line must be separated with a space.\n\u2022 Comments are specified with a pound sign (#). All text following the pound\nsign on the current line is part of the comment.\n\u2022 If there are duplicate rows, the IC Validator tool uses the last row in the file.\nOpenAccess layer mapping filelayer mapping file, OpenAccess\nThe OpenAccess layer mapping file contains data columns in a table-like\nstructure, where each row defines the relationship between the layer/purpose\npairs and the corresponding layer/datatype numbers.\nopenaccess_options()\nNote:\nIf a row contains any of the three optional OpenAccess attributes,\nwhich come after the four required attributes, the optional attributes\nare ignored by IC Validator.\nThe format of the OpenAccess layer mapping file for shapes which have a layer\nname and purpose name is:\n\uff0clayer_name  layerPurpose   layerNo    layerDataType\nlayer1      layerPurpose1  layerNo1   layerDataType1\nlayer2      layerPurpose2  layerNo2   layerDataType2\n...\nThe format of the OpenAccess layer mapping file for objects, which do not have\na purpose name or layer name, except for layer blockages which do have layer\nnames is:\n\uff0clayerName    layerPurpose   layerNo.   layerDataType\n\uff0cMap for PR Boundary objects\npr_boundary   boundary   layerNo     layerDataType\n\uff0cMap for Snap Boundary objects\nsnap          boundary   layerNo1    layerDataType1\n\uff0cMap for Area Blockage objects\nPinBorder      blockage   layerNo2   layerDataType2\n\uff0cMap for Layer Blockage objects\nlayer_name    blockage   layerNo3   layerDataType3\n...\nThe pr_boundary, snap, PinBorder, boundary, and blockage  strings are literal\nvalues.\nYou cannot have multiple mappings of the PR Boundary, Snap Boundary, or\nArea Blockage objects.\nFor example, the first mapping means that nwell  layer and drawing  purpose are\nmoved to geometries and texts at layer1  and datatype0.\n\uff0clayerName    layerPurpose   layerNo    layerDataType\nnwell        drawing        1          0\ndiff         drawing        2          0\npplus        drawing        4          0\nnplus        drawing        5          0\npr_boundary  boundary       6          0\nsnap         boundary       7          0\nPinBorder    blockage       8          0\nM1           blockage       9          0\nM2           blockage       10         0\nopenaccess_options()\nIn addition to these basic mappings, the IC Validator tool supports some\nstandard extensions to the layer mapping file for layer mapping based on\nmultiple patterning color attributes. These extensions appear as extra columns\nafter the layer and datatype numbers, and they have one of two formats:\nmask1Color|mask2Color|mask3Color [locked|unlocked]\ncolor:<colorname> [locked|unlocked]\nExample using color names:\nmetal1 drawing 10 0\nmetal1 drawing 10 1 color:red\nmetal1 drawing 10 2 color:green locked\nmetal1 drawing 10 3 color:green unlocked\nmetal1 drawing 10 4 color:same\nExample using mask color keywords:\nmetal1 drawing 10 0\nmetal1 drawing 10 1 mask1Color\nmetal1 drawing 10 2 mask2Color locked\nmetal1 drawing 10 3 mask2Color unlocked\nThe IC Validator tool also supports a standard extension to the OpenAccess\nlayer mapping file, which can map cut layer rectangles of specified dimensions\nto certain layer and datatype numbers. The cut size specification comes after\nthe layer and datatype numbers (and typically after the optional \u201cmaterial\u201d\nspecifier), and it has the following format:\ncutsize:<width>:<height>\nwhere width and height are floating point numbers representing the dimensions\nof the rectangle to be mapped in microns. For example:\nvia1 drawing 51 0 cut\nvia1 drawing 51 1 cut cutsize:0.05:0.05\nvia1 drawing 51 2 cut cutsize:0.10:0.20\nThis example maps via1 rectangles that are 0.05x0.05 microns to layer 51:1,\nvia1 rectangles that are 0.10x0.20 microns to layer 51:2, and all other via1\nrectangles to layer 51:0.", "generate_pin_text": "Optional. Specifies if pin text is generated. In some design styles, generating net\nnames from pin text can create false text-open error messages. To avoid these\nerror messages, set this argument to NONE  or TOP. The default is ALL.\nopenaccess_options()\n\u2022 NONE. Specifies that net names of pins in the hierarchy are not  converted to\ntext.\n\u2022 TOP. Specifies that only net names of pins in the top-level cell are converted\nto text.\n\u2022 ALL. Specifies that net names of all pins in the hierarchy are converted to\ntext.", "pin_text": "Optional. Determines where to get generated text for pins in the OpenAccess\ndatabase. The default is NET_NAME.\n\u2022 NET_NAME. Reads texts from the net names of the pins.\n\u2022 PIN_NAME. Reads texts from the pin names.\n\u2022 REASSIGN. Reads texts from both the pin name and net name for pins. If\nthe pin name and net name are the same, the IC Validator tool uses the\npin name. If the pin name and net name are different, the IC Validator tool\nuses the net name and tags the text as an assigned net for hierarchical net\nassignment.\nSetting pin_text(REASSIGN)  has the same functionality as manually\nentering cell and net names in the reassign_text  argument of the\ntext_options()  function. Using pin_text(REASSIGN)  provides automated\nassignments when you are using an OpenAccess database.", "replace_instance_name_characters": "Optional. Lists the strings to be replaced in instance names. Neither string\ncan use string matching. By default, the IC Validator tool does not replace any\ncharacters.\n\u2022 search_string. Required. Specifies the string to replace.\n\u2022 replace_string. Required. Specifies the replacement string. An empty\nstring (\"\") results in the removal of the specified search string.", "generate_polygon_text": "Optional. Specifies if text points are generated from the net names of polygons.\nIn some design styles, generating text from polygon net names can create false\ntext-open error messages. To avoid these error messages, set this argument to\nNONE  or TOP. The default is NONE.\nopenaccess_options()\n\u2022 NONE. Specifies that net names of polygons in the hierarchy are not\nconverted to text.\n\u2022 TOP. Specifies that only net names of polygons in the top-level cell are\nconverted to text.\n\u2022 ALL. Specifies that net names of all polygons in the hierarchy are converted\nto text.", "merged_view_list": "Optional. Specifies a list used for the merging of views. These views of the\ntop cell of the design are read and merged into the top cell. By default, the IC\nValidator tool does not merge any views.\n\u2022 view. Required. Specifies the view to be merged.\n\u2022 cell. Optional. Specifies the cell to be merged. The default is the top cell\nname of the design.\n\u2022 library. Optional. Specifies the library name for the view  to be merged.\nThe default is the top library of the design.\n\u2022 outdated_views. Optional. Specifies the behavior of the function if the\ntimestamp of the merged view  is older than the timestamp of the top cell\nview. The default is ABORT.\n\u25e6 ABORT. If the merged view  is older than the top cell view, the run stops.\n\u25e6 USE. If the merged view  is older than the top cell view, the newer view is\nread and the run continues.\n\u25e6 DISCARD. If the merged view  is older than the top cell view, the merged\nview is not read, and the run continues.", "pr_boundary": "Optional. Specifies the layer name and purpose name pair of an oaPRBoundary\nobject. To read an oaPRBoundary object, both the layer and purpose must\nbe specified. Polygons representing the oaPRBoundary are created on the\nspecified layer and purpose. These polygons can be used in an assign()  or\nassign_openaccess()  function.\nFor example,\nopenaccess_options(pr_boundary = {\"prBoundary\",\"prBoundary\"});\nUsing assign_openaccess():\nprBoundary =\nassign_openaccess({{{\"prBoundary\"},{\"prBoundary\"}}});\nopenaccess_options()\nUsing assign()  with the OpenAccess layer mapping file having\nprBoundary prBoundary  50 0\nThe runset has\nprBoundary = assign({{50,0}});", "area_blockage": "Optional. Specifies the layer name and purpose name pair of an\noaAreaBlockage object. This object is a blockage not associated with a\nspecific layer. To read oaAreaBlockage objects, both the layer and purpose\nmust be specified. Polygons representing the oaAreaBlockage are created\non the specified layer. These polygons can be used in an\nassign()  or\nassign_openaccess()  function.\nNote:\nYou can filter by blockage type in the assign()  and\nassign_openaccess()  functions.\nFor example,\nopenaccess_options(area_blockage = {\"area\",\"blockage\"});\nUsing assign_openaccess():\narea_blockages = assign_openaccess({{{\"area\"},{\"blockage\"}}});\nplacement_blockages = assign_openaccess(\n{{{\"area\"},{\"blockage\"}}},\nblockage_types = {PLACEMENT_BLOCKAGE}\n);\nUsing assign()  with the OpenAccess layer mapping file having:\narea blockage 100 100\nThe runset has:\narea_blockages = assign({{100,100}});\nplacement_blockages = assign({{100,100}},\nopenaccess = {blockage_types = {PLACEMENT_BLOCKAGE}}\n);", "area_halo": "Optional. Specifies the layer name and purpose name pair of an oaAreaHalo\nobject. This object is an oversized ring around an instance or PRBoundary. To\nread oaAreaHalo objects, both the layer and purpose must be specified. The\nobject around which the halo is created must be rectilinear. The halo specifies\noffsets for top, left, right, and bottom. Polygons representing the oaAreaHalo are\nopenaccess_options()\ncreated on the specified layer and purpose. These polygons can be used in an\nassign()  or assign_openaccess()  function.\nNote:\nYou can filter by blockage type in the assign()  and\nassign_openaccess()  functions.\nFor example,\nopenaccess_options(area_halo = {\"area\",\"halo\"});\nUsing assign_openaccess():\narea_halo = assign_openaccess({{{\"area\"},{\"halo\"}}});\nUsing assign()  with the OpenAccess layer mapping file having:\narea halo 100 200\nThe runset has\narea_halo = assign({{100,200}});", "area_boundary": "Optional. Specifies the layer name and purpose name pair of an\noaAreaBoundary object. To read an oaAreaBoundary object, both the layer and\npurpose must be specified. Polygons representing the oaAreaBoundary are\ncreated on the specified layer and purpose. These polygons can be used in an\nassign()  or assign_openaccess()  function.\nNote:\nYou can filter area boundaries by name in the assign()  and\nassign_openaccess()  functions.\nFor example,\nopenaccess_options(area_boundary = {\"area\",\"boundary\"});\nUsing assign_openaccess():\nall_area_boundaries =\nassign_openaccess({{{\"area\"},{\"boundary\"}}});\nUsing assign()  with the OpenAccess layer mapping file having:\narea boundary  51 0\nThe runset has\nall_area_boundaries = assign({{51,0}});\nopenaccess_options()", "layer_blockage": "Optional. Specifies the purpose name of an oaLayerBlockage object, which is\nneeded because an oaLayerBlockage is associated with a given layer but not\na specific purpose. Polygons representing the oaLayerBlockage objects are\ncreated on their associated layer and the purpose given here. These polygons\ncan be used in an\nassign()  or assign_openaccess()  function.\nNote:\nYou can filter by blockage type in the assign()  and\nassign_openaccess()  functions.\nFor example, to read metal1 fill blockages:\nopenaccess_options(layer_blockage = \"blockage\");\nUsing the assign_openaccess()  function:\nm1_fill_blockage = assign_openaccess(\n{{{\"m1\"},{\"blockage\"}}},\nblockage_types = {FILL_BLOCKAGE}\n);\nUsing the assign()  function with the OpenAccess layer mapping file having:\nM1 drawing 17 0\nM1 blockage 17 100\nThe runset has:\nM1_fill_blockage = assign(\n{{17,100}},\nopenaccess = {blockage_types = {FILL_BLOCKAGE}}\n);", "layer_halo": "Optional. Specifies the purpose name of an oaLayerHalo object. This object\nis an oversized ring around an instance or PRBoundary. The purpose name\nis needed because an oaLayerHalo is associated with a given layer, but not a\nspecific purpose. Polygons representing the oaLayerHalo objects are created on\ntheir associated layer and the purpose specified here. These polygons can be\nused in an\nassign()  or assign_openaccess()  function.\nNote:\nYou can filter by blockage type in the assign()  and\nassign_openaccess()  functions.\nFor example,\nopenaccess_options(layer_halo = \"halo\");\nopenaccess_options()\nUsing the assign_openaccess()  function:\nm1_halo = assign_openaccess({{{\"m1\"},{\"halo\"}}});\nUsing the assign()  function with the OpenAccess layer mapping file having:\nm1 drawing  17 0\nm1 halo 17 200\nThe runset has\nm1_halo = assign({{17,200}});", "cell_mapping_file": "Optional. Specifies the OpenAccess cell mapping file that allows you to specify\nthe unique name IC Validator tool uses for a given library/cell/view triplet. The\nIC Validator tool creates a unique name for each library/cell/view triplet read\nfrom an OpenAccess layout. If the IC Validator tool encounters a library/cell/view\ntriplet in the OpenAccess database that is not defined in the cell mapping file, it\nuses the default cell naming scheme described in the openaccess_options()\ndescription.\nIn the OpenAccess cell mapping file:\n\u2022 Each mapping relation must appear on a new line.\n\u2022 Each attribute on a line must be separated with a space.\n\u2022 Comments are specified with a pound sign (#). All text following the pound\nsign on the current line is part of the comment.\n\u2022 The IC Validator tool issues an error message if the same unique name is\nused more than one time.\nThe OpenAccess cell mapping file contains data columns in a table-like\nstructure. Each row defines the relationship between a library/cell/view triplet\nand the unique cell name used by the IC Validator tool for that triplet. The format\nof the OpenAccess cell mapping file is:\n\uff0c library  cell   view   unique_name\nlibrary1   cell1  view1  unique1\nlibrary2   cell2  view2  unique2\nlibrary3   cell1  view3  unique3\nFor example,\n\uff0c library  cell  view    unique_name\nmainlib    inv   layout  inv\nreflib1    inv   layout  inv_ref1\nmainlib    buf   layout  buf\nopenaccess_options()\nThe -oa_cell_map  command-line option overrides this name. See the\nCommand-Line Options section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.", "generate_terminal_text": "Optional. Specifies which terminal names are converted to text. In some design\nstyles, generating text from terminal names can create false text-open error\nmessages. To avoid these error messages, set this argument to NONE  or TOP.\nThe default is NONE.\n\u2022 NONE. Does not convert terminal names of polygons in the hierarchy to text.\n\u2022 TOP. Converts only terminal names of polygons in the top-level cell to text.\n\u2022 ALL. Converts terminal names of all polygons in the hierarchy to text.", "terminal_text": "Optional. Selects the type of text used for instance terminals in the OpenAccess\ndatabase. To use the text, set the objects  argument to TERMINAL_TEXT  in the\nOpenAccess assign function. The default is NET_NAME.\n\u2022 NET_NAME. Reads texts from the net names of the pins.\n\u2022 TERMINAL_NAME. Reads texts from the terminals.", "triplet_naming": "Optional. Specifies how the IC Validator tool determines a unique name for\nOpenAccess cells. The default is LIBRARIES_AND_VIEWS.\n\u2022 LIBRARIES_AND_VIEWS. Renames cells in libraries or views except those of\nthe top cell of the design with the full triplet, library.cell.view. Any remaining\nconflicts in cell names are resolved by appending a suffix.\n\u2022 CONFLICT. Uses the original cell name as the unique cell name in the IC\nValidator tool. Conflicting cell names are renamed using the full triplet,\nlibrary.cell.view. Any remaining conflicts in cell names are resolved by\nappending a suffix.", "instance_names": "Optional. Specifies whether instance names from the input layout should be\nretained by the IC Validator tool. The instance names can be used for netlisting\nor possibly reused for the output layout. Retaining instance names could result\nin extra processing time during the reading of the input layout. The default is\nKEEP.\n\u2022 KEEP. Retains instance names from the input layout.\n\u2022 DISCARD. Does not retain instance names from the input layout.\nopenaccess_options()", "object_mapping_file": "Optional. Specifies the OpenAccess object mapping file. If an object is mapped\nin the layer mapping file as well as the object mapping file, the object mapping\nfile takes precedence.\nThe format of the OpenAccess object mapping file is:\n\uff0cobjectType      subType      layerNo    layerDataType\n\uff0cMap for PR Boundary objects\nBoundary         PR           layerNo    layerDataType\n\uff0cMap for Snap Boundary objects\nBoundary         Snap         layerNo1   layerDataType1\n\uff0cMap for Area Blockage objects\nBoundary         Area         layerNo2   layerDataType2\n\uff0cMap for wiring Layer Blockage objects\nlayerBlockage    Wiring       layerNo3   layerDataType3\n\uff0cMap for fill Layer Blockage objects\nlayerBlockage    fill         layerNo4   layerDataType4\n\uff0cMap for slot Layer Blockage objects\nlayerBlockage    slot         layerNo5   layerDataType5\n\uff0cMap for pin Layer Blockage objects\nlayerBlockage    pin          layerNo6   layerDataType6\n\uff0cMap for feedthru Layer Blockage objects\nlayerBlockage    feedthru     layerNo7   layerDataType7\n\uff0cMap for screen Layer Blockage objects\nlayerBlockage    screen       layerNo8   layerDataType8\n\uff0cMap for viaRounting Layer Blockage objects\nlayerBlockage    viaRouting   layerNo9   layerDataType9\n\uff0cMap for routing Layer Blockage objects\nlayerBlockage    routing      layerNo10  layerDataType10\n...\nThe Boundary, layerBlockage, and all subType  strings are literal values.\nYou cannot have multiple mappings of the Boundary or Layer Blockage objects.\nFor example, the first mapping means that nwell  layer and drawing  purpose are\nmoved to geometries and texts at layer1  and datatype0.\n\uff0cobjectType   subType        layerNo    layerDataType\nnwell        drawing        1          0\ndiff         drawing        2          0\nopenaccess_options()\npplus        drawing        4          0\nnplus        drawing        5          0\nBoundary     boundary       6          0\nPR           boundary       7          0\nSnap         blockage       8          0\nArea         blockage       9          0\nwiring       blockage       10         0\nfill         blockage       11         0\nslot         blockage       12         0\npin          blockage       13         0\nfeedthru     blockage       14         0\nscreen       blockage       15         0\nviarouting   blockage       16         0\nrouting      blockage       17         0\nThe -oa_object_map  command-line option overrides this name. See the\nCommand-Line Options section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.", "missing_cell": "Optional. Specifies the behavior if a referenced cell is missing. The default is\nIGNORE.\n\u2022 IGNORE. Continues the IC Validator run. A warning is reported and missing\nOpenAccess cells are empty.\n\u2022 ABORT. Writes an error message and the run stops."}, "summary": "The openaccess_options()  function specifies the behavior of the IC Validator tool when\nreading OpenAccess input.", "function_name": "openaccess_options()"}
{"description": "The optional_pattern_markers()  function returns the optional pattern markers for\nmatched patterns. The optional pattern markers are attached to patterns during pattern\nlibrary creation and might vary in size and location when retrieved, as compared with\nthe original pattern markers in the pattern library. This function is useful for post pattern-\nmatching processes, such as error filtering and passing the user-defined fixing guidance to\nthe router for the ADR flow.", "syntax": "optional_pattern_markers(\npattern_library_name   = \"string\",\npattern_marker         = marker_layer,\npattern_library_handle = NULL_PATTERN_LIBRARY         //optional\n);", "returns": "list of polygon layers", "arguments": {"pattern_library_name": "Required. Specifies the pattern library used for performing pattern matching with\nthe pattern_match()  function.", "pattern_marker": "Required. Specifies the marker layer, which is returned by the\npattern_match()  function.", "pattern_library_handle": "Optional. Specifies the handle of the pattern library that is used for performing\npattern matching with the pattern_match()  function. The handle must be\npreviously defined by the pattern_library()  function.\nNote:\nThe pattern_library_name  argument has backward\ncompatible support for previous pattern matching runset. The\npattern_library_handle  argument is selected if defined."}, "summary": "The optional_pattern_markers()  function returns the optional pattern markers for\nmatched patterns.", "function_name": "optional_pattern_markers()"}
{"description": "The or()  function creates a polygon that represents the union of the polygons on the two\ninput layers.\nNote:\nIf you want to OR a list of layers, use the\nor_list()  function.", "syntax": "or(\nlayer1  = polygon_layer,\nlayer2  = polygon_layer,\nname   = \"layer_label\"   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or()  function creates a polygon that represents the union of the polygons on the two\ninput layers.", "function_name": "or()"}
{"description": "The or_edge()  function combines the edges of the two input layers. Redundant data\npoints are removed.", "syntax": "or_edge(\nlayer1 = edge_layer,\nlayer2 = edge_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "layer2": "Required. Specifies the edge layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_edge()  function combines the edges of the two input layers.", "function_name": "or_edge()"}
{"description": "The or_error()  function combines the errors of the two input layers. Redundant data\npoints are removed.", "syntax": "or_error(\nlayer1 = error_layer,\nlayer2 = error_layer,\nname   = \"layer_label\"  //optional\n);", "returns": "error layer", "arguments": {"layer1": "Required. Specifies an error layer.", "layer2": "Required. Specifies an error layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_error()  function combines the errors of the two input layers.", "function_name": "or_error()"}
{"description": "The or_list()  function creates a polygon that represents the union of the polygons on\nthe input layers.", "syntax": "or_list(\nlayers = {polygon_layer, ...},\nname   = \"layer_label\"          //optional\n);", "returns": "polygon layer or error result", "arguments": {"layers": "Required. Specifies a list of polygon layers.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_list()  function creates a polygon that represents the union of the polygons on\nthe input layers.", "function_name": "or_list()"}
{"description": "The or_list_edge()  function creates an edge layer by merging a list of edge layers. The\noutput is an orphan edge layer.", "syntax": "or_list_edge(\nlayers = {edge_layer, ...},\nname   = \"layer_label\"          //optional\n);", "returns": "edge layer or void", "arguments": {"layers": "Required. Specifies the edge layers to be merged.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_list_edge()  function creates an edge layer by merging a list of edge layers.", "function_name": "or_list_edge()"}
{"description": "The or_list_error()  function creates an error layer by combining a list of error layers.", "syntax": "or_list_error(\nlayers = {error_layer, ...},\nname   = \"layer_label\"          //optional\n);", "returns": "error layer or void", "arguments": {"layers": "Required. Specifies the error layers to be merged.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_list_error()  function creates an error layer by combining a list of error layers.", "function_name": "or_list_error()"}
{"description": "The or_list_marker()  function creates a marker layer by combining a list of marker\nlayers.", "syntax": "or_list_marker(\nlayers = {marker_layer1, marker_layer2,...},\nname   = \"layer_label\"                              //optional\n);", "returns": "marker layer", "arguments": {"layers": "Required. Specifies the marker layers to be concatenated.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The or_list_marker()  function creates a marker layer by combining a list of marker\nlayers.", "function_name": "or_list_marker()"}
{"description": "The or_list_property()  function performs the same operation as the or_list()\nfunction, and it preserves user-defined properties. It creates a polygon layer that\nrepresents the union of input layers, and the output polygons are given the union of the\nproperties from the overlapping input polygons. Conflicting property values are resolved\nbased on argument settings. Conflicting property types are resolved based on layer order.\nProperty mismatch\nEach polygon of output layer always retains the complete list of user-defined properties\nthat are present on each of the input layers. The rules for mismatching property sets\nfollows:\n\u2022 Different property types for a given property name\nOverloaded property types, that is, a given property name associated with more than\none type, are not propagated to the output layer. For each property name, the type\nused is based on the order of the input layer list. The first occurrence of a property\nname in the layer list determines the selected type. Any properties that do not match\nthe selected type for a given name are discarded. This also applies to two-dimensional\nlists with a differing number of columns. This process occurs even when there is no\ngeometric overlap / abutment.\n\u2022 Missing properties\nIf an output polygon does not have a value for a given property, a default is used. The\nvalue is dependent on the type of property:\n\u25e6 Numeric : 0\n\u25e6 string : \u201c\u201d (empty string)\n\u25e6 net_id : NULL_NET_ID (see below)\n\u25e6 list_of_list_double : {{0}}\n\u25e6 list_of_list_string : {{\u201c\u201d}}\n\u25e6 list_of_list_net_id : {{NULL_NET_ID}}", "syntax": "or_list_property(\nlayers            = {polygon_layer1, polygon_layer2,...},\nmerge_operator    = AUTO | FIRST | CONCATENATE,\nconnect_sequence  = connect_database,                 //optional\nprocessing_mode   = CELL_LEVEL | HIERARCHICAL,        //optional\nname              = \"layer_label\",                    //optional\nor_list_property()\npredicate         = true  | false                      //optional\n);", "returns": "polygon layer or violation", "arguments": {"layers": "Required. Specifies the polygon layers to be merged. If there is only one layer,\nthe CONCATENATE  operator creates a two-dimensional list (one row by one\ncolumn) of the property values (if not already a two-dimensional list). The\nremaining operators result in a copy of the input.", "merge_operator": "Required. Specifies how conflicting properties are resolved when polygons are\nmerged. A conflict occurs when overlapping or abutting polygons have different\nvalues for a given property. The scalar type refers to non-composite types:\ndouble, string, net_ID.\n\u2022 AUTO. Specifies that properties are combined depending on the type of the\nproperty.\n\u25e6 Numeric values are summed.\n\u25e6 Lists are concatenated, as in CONCATENATE.\n\u25e6 Non-numeric scalar values (strings or net-IDs) are chosen, as in FIRST.\n\u2022 FIRST. Specifies that a single value is chosen from one of the input polygons\nthat are merged. The polygons are prioritized by the order of the layers  list.\n\u2022 CONCATENATE. Specifies that all output properties are a two-dimensional\nlist. The property value for a given output polygon is a two-dimensional list\ncontaining all of the values of the input polygons that are merged.\n\u25e6 If the input property is a scalar, the output is a two-dimensional list of the\ngiven type, with n  rows by 1 column, where n is the number of polygons\nbeing merged. For example, if \u201cvhigh\u201d is the name of a double property in\nthe input, \u201cvhigh\u201d is the name of a list_of_list_of_double_property in the\noutput.", "connect_sequence": "Optional. Specifies the connect database for net-ID properties. If this is not\nset to a valid connect_database, all net-ID properties are set to the default,\nNULL_NET_ID.\nor_list_property()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "predicate": "Optional. Specifies a predicate_handle for empty layer optimization. The\npredicate controls the operation as follows:\n\u2022 true. The function operates as normal.\n\u2022 false. The function produces empty output."}, "summary": "The or_list_property()  function performs the same operation as the or_list()\nfunction, and it preserves user-defined properties.", "function_name": "or_list_property()"}
{"description": "The outside()  function selects layer1  polygons that do not share any of their active area\nwith layer2  polygons. Outside touching is considered outside. The complement of this\nfunction is the not_outside()  function.", "syntax": "outside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_outside(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\noutside() and not_outside()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The outside()  function selects layer1  polygons that do not share any of their active area\nwith layer2  polygons.", "function_name": "outside()"}
{"description": "The outside_point_touching_edge()  function selects entire layer1  edges that have\nthe specified outside point touching with layer2  edges. The complement of this function is\nthe not_outside_touching_edge()  function.\nSee the description section of the inside_point_touching_edge()  function for more\ninformation.", "syntax": "outside_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_outside_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\noutside_point_touching_edge() and not_outside_point_touching_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The outside_point_touching_edge()  function selects entire layer1  edges that have\nthe specified outside point touching with layer2  edges.", "function_name": "not_outside_point_touching_edge()"}
{"description": "The outside_touching()  function selects polygons that do not share active area with\nlayer2  and outside touch a layer2  polygon. The complement of this function is the\nnot_outside_touching()  function.", "syntax": "outside_touching(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ncount            = integerconstraint,          //optional\npoint_touch      = true | false,               //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity      = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence  = connect_database,           //optional\nname             = \"layer_label\"               //optional\n);\nnot_outside_touching(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ncount            = integerconstraint,          //optional\npoint_touch      = true | false,               //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity      = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence  = connect_database,           //optional\nname             = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "count": "Optional. Specifies the number of layer2  polygons that must touch layer1. See\nConstraints  on page 3344 for more information. The default is >0.\noutside_touching() and not_outside_touching()\nFigure 491  shows the effect of the count  argument settings with the\noutside_touching()  function.\nFigure 491 count Argument Example With the outside_touching() Function\nFigure 492  shows the effect of the count  argument settings with the\nnot_outside_touching()  function.\nFigure 492 count Argument Example With the not_outside_touching() Function", "point_touch": "Optional. Specifies whether point touch is considered a touch. The default is\nfalse.\nFigure 493  shows the effect of the point_touch  argument settings with the\noutside_touching()  function.\nFigure 493 point_touch Argument Example With the outside_touching() Function\noutside_touching() and not_outside_touching()\nFigure 494  shows the effect of the point_touch  argument settings with the\nnot_outside_touching()  function.\nFigure 494 point_touch Argument Example With the not_outside_touching()\nFunction", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and count_parity  is EVEN, the layer1\npolygons that interact with four, six, or eight layer2  polygons are selected.", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\noutside_touching() and not_outside_touching()\n\u2022 NET. Selects a layer1  polygon if it touches with distinct nets on the layer2\nlayer the number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it touches the layer2  layer the number\nof times specified by the count  argument.\nRefer to Figure 495  for the following examples.\nFigure 495 count_by Argument Example\nThe following commands select polygon B of layer L1.\n\u2022 Nets 1, 2, and 3 are not counted because only outside touching polygons are\nconsidered. Net 4 is counted one time because the count_by  argument is\nNET. Therefore, polygon B meets the count=1  restriction.\noutside_touching (L1, L2, count==1, count_by=NET,\nconnect_sequence=cdb);\n\u2022 Nets 1, 2, and 3 are not counted because only outside touching polygons\nare considered. Net 4 is counted two times. Therefore, polygon B meets the\ncount=2  restriction.\noutside_touching (L1, L2, count==2);", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.\noutside_touching() and not_outside_touching()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The outside_touching()  function selects polygons that do not share active area with\nlayer2  and outside touch a layer2  polygon.", "function_name": "outside_touching()"}
{"description": "The outside_touching()  function selects polygons that do not share active area with\nlayer2  and outside touch a layer2  polygon. The complement of this function is the\nnot_outside_touching()  function.", "syntax": "outside_touching(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ncount            = integerconstraint,          //optional\npoint_touch      = true | false,               //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity      = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence  = connect_database,           //optional\nname             = \"layer_label\"               //optional\n);\nnot_outside_touching(\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\ncount            = integerconstraint,          //optional\npoint_touch      = true | false,               //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\ncount_parity      = ALL  | ODD | EVEN,           //optional\ncount_by          = SHAPE  | NET,                //optional\nconnect_sequence  = connect_database,           //optional\nname             = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the polygon layer against which the layer1  layer is\nchecked.", "count": "Optional. Specifies the number of layer2  polygons that must touch layer1. See\nConstraints  on page 3344 for more information. The default is >0.\noutside_touching() and not_outside_touching()\nFigure 491  shows the effect of the count  argument settings with the\noutside_touching()  function.\nFigure 491 count Argument Example With the outside_touching() Function\nFigure 492  shows the effect of the count  argument settings with the\nnot_outside_touching()  function.\nFigure 492 count Argument Example With the not_outside_touching() Function", "point_touch": "Optional. Specifies whether point touch is considered a touch. The default is\nfalse.\nFigure 493  shows the effect of the point_touch  argument settings with the\noutside_touching()  function.\nFigure 493 point_touch Argument Example With the outside_touching() Function\noutside_touching() and not_outside_touching()\nFigure 494  shows the effect of the point_touch  argument settings with the\nnot_outside_touching()  function.\nFigure 494 point_touch Argument Example With the not_outside_touching()\nFunction", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "count_parity": "Optional. Specifies the parity of the number of layer2  polygons that must touch\nlayer1  polygons. The default is ALL.\n\u2022 EVEN. Specifies that the layer1  polygons must have an even number of\ninteractions with layer2  data.\n\u2022 ODD. Specifies that the layer1  polygons must have an odd number of\ninteractions with layer2  data.\n\u2022 ALL. Does not check the parity based on the number of interactions.\nThe count  argument can be used with the count_parity  argument. For\nexample, when count = [4, 9]  and count_parity  is EVEN, the layer1\npolygons that interact with four, six, or eight layer2  polygons are selected.", "count_by": "Optional. Provides selection by net feature. The default is SHAPE.\noutside_touching() and not_outside_touching()\n\u2022 NET. Selects a layer1  polygon if it touches with distinct nets on the layer2\nlayer the number of times specified by the count  argument.\n\u2022 SHAPE. Selects a layer1  polygon if it touches the layer2  layer the number\nof times specified by the count  argument.\nRefer to Figure 495  for the following examples.\nFigure 495 count_by Argument Example\nThe following commands select polygon B of layer L1.\n\u2022 Nets 1, 2, and 3 are not counted because only outside touching polygons are\nconsidered. Net 4 is counted one time because the count_by  argument is\nNET. Therefore, polygon B meets the count=1  restriction.\noutside_touching (L1, L2, count==1, count_by=NET,\nconnect_sequence=cdb);\n\u2022 Nets 1, 2, and 3 are not counted because only outside touching polygons\nare considered. Net 4 is counted two times. Therefore, polygon B meets the\ncount=2  restriction.\noutside_touching (L1, L2, count==2);", "connect_sequence": "Optional. Specifies the connect database that has the layer2  connection. The\ndatabase is used when the count_by  argument is NET.\noutside_touching() and not_outside_touching()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The outside_touching()  function selects polygons that do not share active area with\nlayer2  and outside touch a layer2  polygon.", "function_name": "not_outside_touching()"}
{"description": "The outside_touching_edge()  function selects entire layer1  edges that have\nany outside coincidence with layer2  edges. The complement of this function is the\nnot_outside_touching_edge()  function.", "syntax": "outside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_outside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional: Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, polygons are counted. If layer2  is an\nedge layer, individual edges are counted. See\nConstraints  on page 3344 for\nmore information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\noutside_touching_edge() and not_outside_touching_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The outside_touching_edge()  function selects entire layer1  edges that have\nany outside coincidence with layer2  edges.", "function_name": "outside_touching_edge()"}
{"description": "The outside_touching_edge()  function selects entire layer1  edges that have\nany outside coincidence with layer2  edges. The complement of this function is the\nnot_outside_touching_edge()  function.", "syntax": "outside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_outside_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional: Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, polygons are counted. If layer2  is an\nedge layer, individual edges are counted. See\nConstraints  on page 3344 for\nmore information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\noutside_touching_edge() and not_outside_touching_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The outside_touching_edge()  function selects entire layer1  edges that have\nany outside coincidence with layer2  edges.", "function_name": "not_outside_touching_edge()"}
{"description": "The partition()  function breaks complex shapes into regular rectangles. The IC\nValidator tool finds the maximum number of largest rectangles in the region being\npartitioned. The output partitions interact by no more than a point touch.", "syntax": "partition(\nlayer1       = polygon_layer,\nmin_space    = double,                                       //optional\nmin_width    = double,                                       //optional\noutput_type  = {HORIZONTAL, VERTICAL, SQUARE},               //optional\nname        = \"layer_label\",                                //optional\norientation  = NONE  | HORIZONTAL | VERTICAL,                 //optional\nmin_space_x  = double,                                       //optional\nmin_space_y  = double,                                       //optional\nmin_height  = double,                                       //optional\nmin_rectangle_space_x  = double,                             //optional\nmin_rectangle_space_y  = double,           //optional\nmin_space_mode  = LOCAL  | GLOBAL                 //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer that is partitioned.", "min_space": "Optional. Specifies the minimum spacing between partitions. The value must be\ngreater than 0.0. If the min_space_x  and min_space_y  arguments are specified,\nthe min_space  argument is ignored. If the orientation  argument specifies a\nhorizontal or vertical orientation, the min_space  value applies only the direction\nthat is perpendicular to the orientation.", "min_width": "Optional. Specifies the minimum length of a partition side. Each side of a\nrectangular partition must have a length of at least the minimum width value.\nThe default is 0.0.\nWhen you specify a min_width  value greater than 0.0, the IC Validator tool\npartitions the input layer based on the shapes specified by the output_type\nargument. If you do not specify a min_width  value, the tool partitions the layer\npartition()\nbased on the direction specified by the orientation  argument and ignores the\noutput_type  argument.", "output_type": "Optional. Specifies the shapes of partitions selected for output. The default\nis {HORIZONTAL, VERTICAL, SQUARE}, which means that all rectangles are\nselected irrespective of their aspect ratio. At least one option must be selected;\nthat is, an empty list is not allowed.\n\u2022 HORIZONTAL. Selects partitions with a dimension in the x-direction that is\ngreater than the dimension in the y-direction.\n\u2022 VERTICAL. Selects partitions with a dimension in the y-direction that is\ngreater than the dimension in the x-direction.\n\u2022 SQUARE. Selects partitions with a dimension in the x-direction that equals the\ndimension in the y-direction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "orientation": "Optional. Controls the direction in which the IC Validator tool partitions the input\nlayer. The default is NONE.\nWhen you specify a horizontal or vertical orientation, the min_space  value\napplies only to the direction that is perpendicular to the orientation.\n\u2022 NONE. Partitions the layer based on the shapes specified by the output_type\nargument.\n\u2022 HORIZONTAL. Partitions the layer in the x-direction along the horizontal\nedges.\n\u2022 VERTICAL. Partitions the layer in the y-direction along the vertical edges.", "min_space_x": "Optional. Specifies the minimum spacing between partitions in the x-direction.\nThe value must be greater than 0.0. If the min_space_x  and min_space_y\narguments are specified, the min_space  argument is ignored.\npartition()", "min_space_y": "Optional. Specifies the minimum spacing between partitions in the y-direction.\nThe value must be greater than 0.0. If the min_space_x  and min_space_y\narguments are specified, the min_space  argument is ignored.", "min_height": "Optional. Specifies the minimum height of each partition. The value must\nbe greater than 0.0 and can be used only when the min_width  argument is\nspecified.", "min_rectangle_space_x": "Optional. Specifies the distance in the x-direction between fill rectangles.\nThe value must be greater than 0.0 and can be used only when the\nmin_rectangle_space_y  argument is specified.", "min_rectangle_space_y": "Optional. Specifies the distance in the y-direction between fill rectangles.\nThe value must be greater than 0.0 and can be used only when the\nmin_rectangle_space_x  argument is specified.", "min_space_mode": "Optional. Specifies if you guarantee the minimum spacing between different\npolygons. The default is LOCAL."}, "summary": "The partition()  function breaks complex shapes into regular rectangles.", "function_name": "partition()"}
{"description": "The partition_chip()  function breaks the extents of the top-level cell into a specified\nnumber of horizontal or vertical partitions with equal areas of the input polygon layer.", "syntax": "partition_chip(\nlayer               = polygon_layer,\nmax_partitions      = integer,\noverlap             = double,\nmin_partition_size  = double,\norientation         = HORIZONTAL  | VERTICAL,\nexclude_layers      = {polygon_layer, ...}   //optional\n);", "returns": "list of polygon layers", "arguments": {"layer": "Required. Specifies the polygon layer used to calculate the area considered for\npartitioning.", "max_partitions": "Required. Specifies the number of partitions. This value must be greater than 1.", "overlap": "Required. Specifies the size of the overlap between adjacent partitions. This\nvalue should always be greater than 0 (zero).", "min_partition_size": "Required. Specifies the minimum size of the partition (the partition height\nif orientation = HORIZONTAL  or the partition width if orientation =\nVERTICAL).", "orientation": "Required. Specifies the direction of the partition. The default is HORIZONTAL.", "exclude_layers": "Optional. Specifies a list of polygon layers to exclude from the layer  argument.\npartition_chip()"}, "summary": "The partition_chip()  function breaks the extents of the top-level cell into a specified\nnumber of horizontal or vertical partitions with equal areas of the input polygon layer.", "function_name": "partition_chip()"}
{"description": "The pattern_extract()  function retrieves unique pattern information from a pattern of a\npattern library.", "syntax": "pattern_extract(\npattern_library_name   = \"string\",\npattern_marker         = marker_layer,\npattern_library_handle = NULL_PATTERN_LIBRARY,\noutput_type            = PM_OPTIONAL_MARKERS  | PM_LAYERS |\nPM_IGNORE_REGIONS | PM_EXTENT      //optional\n);", "returns": "list of polygon layers", "arguments": {"pattern_library_name": "Required. Specifies the pattern library used for retrieving pattern information.\nNote:\nThe pattern_library_name  argument has backward\ncompatible support for the previous pattern matching runset. The\npattern_library_handle  argument is selected if defined.", "pattern_marker": "Required. Specifies the pattern marker layer.", "pattern_library_handle": "Required. Specifies the pattern library used for retrieving pattern information.\nThe handle must be previously defined by the pattern_library()  function.", "output_type": "Optional. Specifies the type of pattern information to be retrieved. The default is\nPM_OPTIONAL_MARKERS.\n\u2022 PM_OPTIONAL_MARKERS. Returns all of the optional pattern markers.\n\u2022 PM_LAYERS. Returns all of the pattern layers.\n\u2022 PM_IGNORE_REGIONS. Returns all of the ignore regions.\n\u2022 PM_EXTENT. Returns the pattern extent.\npattern_extract()"}, "summary": "The pattern_extract()  function retrieves unique pattern information from a pattern of a\npattern library.", "function_name": "pattern_extract()"}
{"description": "The pattern_learn()  function creates a new pattern library or updates an existing\npattern library with source patterns. It can be called multiple times within a runset.\nFor pattern library generation, two types of results are reported to the\ncell.LAYOUT_ERRORS file: patterns that fail to be registered to the pattern library due to\ninvalid input and patterns that are successfully registered to the pattern library. For more\ninformation about types of invalid input, see the descriptions of the pattern_layers,\npattern_marker, edge_tolerance_layers, pattern_type, and pattern_extent\narguments.", "syntax": "pattern_learn(\npattern_library_handle   = pattern_library_handle,\npattern_layers           = {polygon_layer, ...},\npattern_marker           = polygon_layer,\npattern_text_id          = text_layer,                      //optional\npattern_extent           = polygon_layer,                   //optional\nignore_region_layers      = {polygon_layer, ...},            //optional\nedge_tolerance_layers    = {polygon_layer, ...},            //optional\nmatch_ambit              = {left=double, bottom=double,\nright=double, top=double},      //optional\nambit_mode               = PM_MARKER_CENTER  | PM_MARKER_EDGE,\n//optional\npattern_fuzziness        = PM_EXACT | PM_EDGE_UNIFORM |\nPM_EDGE_NONUNIFORM,              //optional\nuniform_fuzzy_size       = double,                          //optional\nedge_jog_size            = double,                          //optional\npattern_reflect          = true | false,                    //optional\npattern_rotate           = true | false,                    //optional\nignore_extra_polygons     = true | false,                    //optional\noutput_pattern_xml       = true | false,                    //optional\npattern_prefix            = \"string\",                //optional\nanchor                   = FIRST_PATTERN_LAYER  | AUTO |\nPATTERN_SPECIFIC,                //optional\noptional_pattern_markers  = {polygon_layer, ...},            //optional\npattern_text_properties   = {{property_name       = \"string\",\nproperty_text_layer = text_layer,\nproperty_type       = STRING  | DOUBLE},\n...},                           //optional\npattern_type              = PM_TWO_DIMENSIONAL  | PM_ONE_DIMENSIONAL,\n//optional\noptional_region_layers    = {polygon_layer, ...},     //optional\npattern_naming_mode      = PM_NAME_SEQUENTIAL  | PM_NAME_UNIQUE,\n//optional\npattern_anchor_optimization  = PM_ALL | PM_SIZE | PM_ANGLE |\nPM_ENCLOSE | PM_CENTER,      //optional\npattern_learn()\noptional_pattern_marker_type = FIXED | DYNAMIC,             //optional\npattern_run_length           = ALL | RUN_LENGTH_GE,         //optional\nviolations_per_pattern                    = ALL| ONE,       //optional\nreport_individual_pattern_violation_count  = true| false,    //optional\ncritical_region_layers        = {polygon_layer, ...}         //optional\n);", "returns": "marker layer or error result\nThe marker layer is an unmerged layer under the geometry layer. The marker layer can be\nconverted to a polygon layer using the marker_merge()  function.", "arguments": {"pattern_library_handle": "Required. Specifies the handle of a pattern library to be created or updated. The\nhandle must be previously defined by the pattern_library()  function.\nThe pattern_learn()  function writes pattern information to a binary file named\npattern.dat. It also records pattern library creation parameters and pattern\nstatistics to a text file named log. Both files are saved to the directory defined by\nthe pattern_library_handle  argument.\nNote:\nWhen you add new patterns to an existing pattern library, the new\npattern library must have the same set of arguments and values as\nthe existing pattern library. Otherwise, a runtime error occurs.\nThe pattern_library_handle  argument replaces the previous\npattern_library_name  argument for better usability, but it breaks\nthe backward compatibility of the previous runset, which is defined\nusing the pattern_library_name  argument.", "pattern_layers": "Required. Lists the input layers. A multiple-layer source pattern, such as a\npattern consisting of a metal layer and a via layer, is supported. A maximum of\n32 layers can be specified.\nNote:\nDo not use different layer names for the same pattern layer in the\npattern layer list. This can cause the IC Validator run to stop.", "pattern_marker": "Required. Specifies the layer that contains polygons placed on each source\npattern. The pattern marker specifies the location of interest, such as the pinch\npattern_learn()\nand bridge locations of a lithographic hotspot or a DRC violation location. This\nmarker is output to report the match between the pattern in the pattern library\nand the input design captured by the pattern_match()  function.", "pattern_text_id": "Optional. Specifies the text layer that contains the text ID of the source patterns.\nTo be recognized, the coordinates of the text ID must be located inside the\npattern extent. If the text ID is not defined, or defined but resides outside of the\npattern extent, a tool-generated text ID is attached to each pattern registered to\nthe pattern library. The pattern_match()  function reports the pattern ID to the\nerror database and cell.LAYOUT_ERRORS file.\nIf the same text ID is used for different source patterns, the text ID of the\ncorresponding registered patterns in the pattern library is suffixed by a sequence\nnumber to resolve the name conflict. For example, if hs_1 is used for three\ndifferent source patterns, the three patterns are named hs_1, hs_1_1, and\nhs_1_2.\nIf a different text ID is used for the same source pattern, only one text ID is kept\nfor the registered pattern in the pattern library.", "pattern_extent": "Optional. Specifies the layer that contains polygons that define the bounding\nregion of a source pattern. The pattern layers inside the bounding region are\nprocessed and registered to the pattern library. When the pattern_extent\nargument is set, the match_ambit  argument is ignored. Pattern extent can also\nbe defined using the match_ambit  and ambit_mode  arguments.\nThe following situations can cause the corresponding source pattern to not be\nadded to the pattern library and be reported in the cell.LAYOUT_ERRORS file\nas invalid input.\n\u2022 Nonrectangular pattern extent.\n\u2022 Unpaired pattern marker and pattern extent, such as a pattern extent\ninteracting with no pattern marker or more than one pattern marker.\nFigure 498  illustrates the use of the pattern_extent  argument to define a\npattern during pattern library creation.\npattern_learn()\nFigure 498 Defining a Pattern With the pattern_extent  Argument\nNote:\nThe pattern extent must not exceed 50 \u03bcm on every side or the IC\nValidator tool reports an invalid input to the cell.LAYOUT_ERRORS\nfile.\n---------------------------------------\nViolation/Invalid input: pattern extent > 50 \u03bcm is not", "supported": "pattern_learn ...................................... 1", "violation": "found.\n---------------------------------------", "ignore_region_layers": "argument, are not supported with the optional region layers for a one-\ndimensional pattern type.\npattern_learn()\n\u2022 The pattern layer must be completely inside of the optional region layer for it\nto be selected as optional for matching.\n\u2022 The pattern_library_read()  function does not return the optional region\nlayers. The converted pattern library contains all the enumerations.", "in": "Figure 500, the edge tolerance of the right vertical edge of the source pattern\nis lost after pattern registration. This edge tolerance loss can cause missing\npatterns during pattern matching.\npattern_learn()\nFigure 500 Defining Ignore Regions on a Source Pattern With Edge Tolerance.", "edge_tolerance_layers": "Optional. Lists the input layers that contain polygons which define the edge\nplacement variation of each pattern edge. This argument applies only when\nthe pattern_fuzziness  argument is PM_EDGE_NONUNIFORM. Any pattern on a\ndesign with all edges falling inside of the edge tolerance layers is reported as a\nmatch by the pattern_match()  function.\nThis argument supports both one-dimensional and two-dimensional pattern\ntypes.\nThe restrictions for using the argument are:\n\u2022 You must specify the edge tolerance layer list in the same order as in the\npattern layer list.\n\u2022 The edge tolerance layer list must be either empty or contain the same\nnumber of layers as that of the pattern layer list.\npattern_learn()\n\u2022 The following incorrect edge tolerance definitions are reported as invalid\ninput and can cause the corresponding source pattern to not be registered to\nthe pattern library.\n\u25e6 Any edge of a pattern layer interacting with any nonrectangular polygon\non the corresponding edge tolerance layer.\n\u25e6 Any edge of a pattern layer interacting with more than one polygon on the\ncorresponding edge tolerance layer.\n\u25e6 For a one-dimensional pattern type, the edge tolerance layer must be\none-dimensional and on the same direction as the pattern layer.\nFigure 501  illustrates the use of the edge_tolerance_layers  argument to\ndefine a pattern during pattern library creation.\nFigure 501 Defining a Pattern With the edge_tolerance_layers  Argument", "match_ambit": "Optional. Specifies the extensions for generating the pattern extent based\non the pattern marker in the direction order of left, bottom, right, and top.\nThe default is 0. Set match_ambit  to >0  when the ambit_mode  argument\nis PM_MARKER_CENTER. See\nFigure 502  for an example of how to use the\nmatch_ambit  argument with the ambit_mode  argument to define a pattern\nextent during pattern library creation. The pattern extent can also be specified\nusing the pattern_extent  argument.\nThis argument supports only the two-dimensional pattern type.\nNote:\nThe x-direction extensions can be different from the y-direction\nextensions, but extensions in the same direction must be the same.\npattern_learn()", "ambit_mode": "Optional. Specifies the starting point for the ambit extension specified in the\nmatch_ambit  argument. The default is PM_MARKER_CENTER.\n\u2022 PM_MARKER_CENTER. Starts from the center of the pattern marker.\n\u2022 PM_MARKER_EDGE. Starts from each of the four edges of the pattern marker.\nThis argument supports only the two-dimensional pattern type.\nFigure 502  shows how to use the match_ambit  and ambit_mode  arguments to\ndefine a pattern during pattern library creation.\nFigure 502 Defining a Pattern With the match_ambit  and ambit_mode  Arguments", "pattern_fuzziness": "Optional. Specifies the pattern matching mode of the pattern library. The\npattern_match()  function performs the pattern matching. The default is\nPM_EXACT.\n\u2022 PM_EXACT. Reports as a match when all pattern edges of an input pattern fall\nexactly on the edges of a library pattern.\nThis matching mode supports both one-dimensional and two-dimensional\npattern types.\npattern_learn()\n\u2022 PM_EDGE_UNIFORM. Reports as a match when all pattern edges of an input\npattern fall within the uniform edge placement variation, as defined by the\nuniform_fuzzy_size  argument, of a library pattern.\nThis matching mode supports only the two-dimensional pattern type.\n\u2022 PM_EDGE_NONUNIFORM. Reports as a match when all pattern edges of an\ninput pattern fall within the edge placement variations, as defined by the\nedge_tolerance_layers  argument, of a library pattern.\nThis matching mode supports both one-dimensional and two-dimensional\npattern types.\nFor the two-dimensional pattern type, the PM_EDGE_NONUNIFORM  option\nsupports the following two applications:\n\u25e6 Fixed pattern extent. This pattern extent is fixed in size. The edge\ntolerance can either be defined by the edge_tolerance_layers\nargument or in the generated pattern.xml file. The edge-to-edge\nconstraint is specified in the pattern.xml file.\n\u25e6 Dynamic pattern extent. The pattern extent can be flexible in size when\na locking constraint is specified between a pattern edge and an extent\nedge. As shown in\nFigure 503, the top edge of the pattern extent is tied\nto the edge tolerance constrained pattern edge, e1. As the pattern edge\nmoves within the edge tolerance, the top extent edge also moves to\nsatisfy the locking constraint.\nFigure 503 Dynamic Pattern Extent\npattern_learn()\nThe restrictions for using the dynamic pattern extent application are:\n\u25e6 The output_pattern_xml  argument must be true  to generate the\npattern.xml file.\n\u25e6 The pattern extent to the pattern edge constraint must be specified in\nthe pattern.xml file using the <Edge2Extent> element. See the Examples\nsection for more information about how to define the edge-to-extent\nconstraint.\n\u25e6 Pattern extent edges are named as top, bottom, left, and right,\naccordingly.\n\u25e6 One pattern extent edge can only be tied one time and with only one\npattern edge.\n\u25e6 Supports only dynamic optional pattern markers. The IC Validator tool\nerrors out when the optional pattern markers are a fixed type.\nFor the one-dimensional pattern type, the PM_EDGE_NONUNIFORM  option\nsupports the following two applications:\n\u25e6 Fixed pattern extent with edge tolerance being defined by the\nedge_tolerance_layers  argument, as shown in\nFigure 504.\nThe restrictions for using the application are:\n- Edge tolerance can only be defined with the edge_tolerance_layers\nargument.\n- Does not generate the pattern.xml file, and therefore does not\nsupport defining the edge tolerance and edge-to-edge constraint in the\npattern.xml file.\npattern_learn()\nFigure 504 One-Dimensional Fixed Pattern Boundary Matching Mode\n\u25e6 Flexible pattern extent with the edge-to-edge constraint being defined in\nthe generated pattern.xml file, as shown in\nFigure 505.\nThe restrictions for using the application are:\n- The edge_tolerance_layers  argument must be set to empty layers.\nThis enables the IC Validator tool to set the output_pattern_xml\nargument to TRUE.\n- User-defined edge-to-edge constraint in the generated pattern.xml file\nafter pattern library creation. The edge-to-edge constraint can only be\ndefined between neighboring edges.\nFor example, the pattern in\nFigure 505  must be specified in the\npattern.xml file as follows:\n</Pattern>\n<Pattern key=\"0003AM000NwQ0M3rh00gwwAz\"\ntext_id=\"pattern_6\">\n<Edge2Edge>{e6-e8=[60,80]}</Edge2Edge>\n</Pattern>\npattern_learn()\n- Edges next to the pattern extent must be fixed edges.\n- Edges that are not specified with the edge-to-edge constraint are treated\nas fixed edges.\n- Edge tolerance definition in the generated pattern.xml file is not\nsupported.\nFigure 505 One-Dimensional Flexible Pattern Boundary Matching Mode", "uniform_fuzzy_size": "Optional. Specifies the uniform placement variation for edges of all pattern\nlayers. The variation is applied on both sides of each edge. This argument is\napplied only when the pattern_fuzziness  argument is PM_EDGE_UNIFORM. The\ndefault is 0.\nThis argument supports only the two-dimensional pattern type.", "edge_jog_size": "Optional. Specifies the minimum jog size. This jog size is used only when the\npattern_fuzziness  argument is PM_EDGE_NONUNIFORM. A jog smaller than the\nedge jog size is smoothed before pattern matching occurs. The two adjacent\nedges of the jog are aligned to the longer one. The default is 0.", "pattern_reflect": "Optional. Specifies whether to match reflected patterns during pattern matching.\nThe default is true, which allows the following reflections:\n\u2022 Zero orientation (R0)\n\u2022 Flipped in x-direction (FX)\npattern_learn()\n\u2022 Flipped in y-direction (FY)\n\u2022 Flipped in both x- and y-directions (R180)\nThese reflections are shown in Figure 506.\nFigure 506 Pattern Reflections\nNote:\nIn the IC Validator tool,\n- The pattern orientation is reported in the LAYOUT_ERRORS file.\n- The zero orientation (R0) might not be the original orientation of the\ninput source patterns.\n- The original orientation of an input source pattern is kept as zero\norientation only when the pattern_reflect  argument is false  and\nthe pattern_rotate  argument is false.\n- To match an orientation that is not supported by the\npattern_learn()  function, generate a pattern library with this\nspecific orientation and set both the pattern_reflect  and\npattern_rotate  arguments to false.", "pattern_rotate": "Optional. Specifies whether to match rotated patterns during pattern matching.\nThe default is true, which allows the following rotations:\n\u2022 Zero orientation (R0)\n\u2022 Flipped in x-direction (FX)\n\u2022 Flipped in y-direction (FY)\n\u2022 Rotated 180 degrees (R180)\n\u2022 Rotated 90 degrees (R90)\n\u2022 Rotated 270 degrees (R270)\n\u2022 Rotated 90 degrees and flipped in y-direction (R90FY)\n\u2022 Rotated 90 degrees and flipped in x-direction (R90FX)\npattern_learn()\nThese rotations are shown in Figure 507.\nFigure 507 Pattern Rotations\nSee the note in the pattern_reflect  argument for more information.", "ignore_extra_polygons": "Optional. Excludes polygons that do not exist in the pattern library from\nmatching with the pattern_match()  function when set to true. The default is\nfalse.\nNote:\nThe ignore_region_layers  and the ignore_extra_polygons\narguments are mutually exclusive.\nFigure 508  shows that a matched pattern when the ignore_extra_polygons\nargument is true.\npattern_learn()\nFigure 508 Matched Pattern With the ignore_extra_polygons Argument", "output_pattern_xml": "Optional. Specifies whether to generate the pattern.xml file. The default is true.\nThe pattern.xml file contains general information about a pattern library and the\nedge placement variations, which are defined by the edge_tolerance_layers\nargument, and the supported edge specification elements based on the\ndefinition of the pattern_fuzziness  argument, in XML format.\nNote:\nYou can use only the edge specification elements generated by the\nXML file to define a new edge specification or modify an existing\none. Elements not listed in the generated XML file indicate that the\ncorresponding edge specification is not allowed in this pattern library.\nFor example, in the following pattern.xml file, the only supported edge\nspecification is OpmEdgePair, which defines the edge pair between\nthe optional pattern marker and the pattern layer for the dynamic\noptional pattern marker.\npattern_learn()\n<?xml version=\"1.0\"?>\n<PatternMatch unit=\"nm\" DBU=\"0.5\" pattern_type=\"1D\"\npattern_fuzziness=\"PM_EDGE_NONUNIFORM\">\n<Pattern key=\"000Ojq0009tK19uHug03sjV8\"\ntext_id=\"pattern_1\">\n<OpmEdgePair>{}</OpmEdgePair>\n</Pattern>\n<Pattern key=\"000WuO000Fbv3Sm4WO1RjcID\"\ntext_id=\"pattern_2\">\n<OpmEdgePair>{}</OpmEdgePair>\n</Pattern>\n</PatternMatch>\nIn the generated pattern.xml file, you can\n\u2022 Add a new or modify the existing edge tolerance using the <EdgeTolerance>\nelement.\n\u2022 Add definitions for edge-to-edge dimensional constraints as an additional\nfuzziness specification for the existing pattern library using the <Edge2Edge>\nelement.\n\u2022 Specify the edge pair between the optional pattern marker edge and pattern\nlayer edge for enabling the optional pattern marker as a dynamic type for a\none-dimensional pattern library using the <OpmEdgePair>  element.\n\u2022 Specify the locking constraint between a pattern edge and a pattern extent\nedge to allow the pattern extent edge to dynamically move along with the\npattern edge using the <Edge2Extent>  element.\nThe pattern.xml file is part of the pattern library. Changes made to the file are\nretained when changes are valid and you do not change the file name.\nSee the\nExamples  section for more information about the format and use of the\npattern.xml file.", "pattern_prefix": "Optional. Specifies the prefix of the tool-generated pattern text ID when the\npattern_text_id  argument is not user-defined. If the pattern_prefix\nargument is not user-defined, the tool-generated pattern text ID is named with\nthe default followed by a sequence number, that is, pattern_1, pattern_2, and so\non.\nNote:\nThe \u201c#\u201d is not allowed to be used in defining the pattern prefix when\nthe pattern_naming_mode  argument is set to PM_NAME_UNIQUE\noption.\npattern_learn()", "anchor": "Optional. Specifies how IC Validator tool selects the anchor layer when there\nare multiple pattern layers for a two-dimensional pattern type. The IC Validator\ntool requires that the anchor layer have at least one corner inside the pattern\nextent on every source pattern. The failed source patterns are reported in the\ncell.LAYOUT_ERRORS file. The default is FIRST_PATTERN_LAYER.\n\u2022 FIRST_PATTERN_LAYER. Selects the anchor layer to be the first pattern layer\nspecified by the pattern_layers  argument.\n\u2022 AUTO. Identifies automatically the anchor layer candidate that generates\nthe least invalid pattern, and is therefore chosen as the anchor layer in the\npattern matching stage.\nNote:\nWhen anchor = AUTO, the pattern_anchor_optimization\nargument must be set to PM_ALL.\n\u2022 PATTERN_SPECIFIC. Selects a different anchor layer for different patterns\nwhen there is no common anchor layer among all of the source patterns.\nPattern matching performance might be degraded in this mode.", "optional_pattern_markers": "Optional. Lists the input layers that contain the polygons placed on the source\npatterns. Unlike the required pattern marker, these pattern markers are optional.\nThey are used to define other information that a source pattern might carry,\nsuch as hotspot severity, hotspot type, pattern extent, and user-defined fixing\nguidance that can be passed to the router for fixing hotspots. These markers\ncan be retrieved using the optional_pattern_markers()  function after the\npattern_match()  function in the runset.\nOptional pattern markers can be fixed or dynamic. See the\noptional_pattern_marker_type  argument for more information. Optional\npattern markers support both the one-dimensional and two-dimensional pattern\ntypes.\nThe following restriction is for one-dimensional pattern types:\n\u2022 The optional pattern markers must be one-dimensional.\nIn the following example, two optional pattern marker layers are used to specify\nthe hotspot severity during pattern library creation.\nTEST_CASE_Mx = pattern_library (\nlibrary_name = \"TEST_CASE_Mx\",\nlibrary_path = \"./pattern_lib\"\n);\npattern_learn()\nlevel_one_hotspot = layer_one;\nlevel_two_hotspot = layer_two;\nhotspot_location = level_one_hotspot or level_two_hotspot;\npattern_learn (\npattern_library_handle = TEST_CASE_Mx,\npattern_layers = {metal},\npattern_marker = hotspot_location,\noptional_pattern_markers = {level_one_hotspot,\nlevel_two_hotspot},\n...\n);\nSee the optional_pattern_markers()  function for information about how\nto return the hotspot severity information after pattern matching with the\npattern_match()  function.", "pattern_text_properties": "Optional. Lists the pattern properties that are attached to source pattern. A\npattern property is specified through a name, a text layer, and the type of the\ntext layer. The text must be placed inside the pattern extent in order for it to\nbe recognized and attached to the pattern library. Up to 31 properties can be\nspecified.\n\u2022 property_name. Specifies the property name. The name must be fewer than\n64 characters. It cannot contain the characters: space, = (equal sign), and ;\n(semicolon).\n\u2022 property_text_layer. Specifies the text layer that contains the value of the\nproperty. You can specify more than one value, and all values are appended\nto the same property name. The length of each property string must be fewer\nthan 1024 characters. See\nText Strings  on page 3351 for information about\ntext string rules.\n\u2022 property_type. Specifies the data type of the property. The default is\nSTRING.\n\u25e6 STRING. Specifies the data type as string.\n\u25e6 DOUBLE. Specifies the data type as double.\nNew text properties can be added incrementally to the same pattern, as\nshown in\nFigure 509. The locations of the properties in this figure are for\ndemonstration only. Same pattern is defined as having the same pattern\nlayers and the same size and location of the pattern marker.\npattern_learn()\nFigure 509 Adding New Property \u201ctype\" With Value of \u201cspace\u201d to pat_3\nThe new text property values can be appended to the same property name\nof the same pattern, as shown in\nFigure 510. The locations of the properties\nare for demonstration only.\nFigure 510 Appending New Property Value of \u201cB\u201d to Property \u201cGroup\u201d to pat_4\nNote:\nThe property_type  and property_text_layer  options must\nagree in data type. If not, IC Validator reports an invalid input in\nthe cell.LAYOUT_ERRORS file.\nSee the Examples section for an example of defining pattern properties.", "pattern_type": "Optional. Specifies the dimensional type of the source pattern. Types are\nmutually exclusive. The default is PM_TWO_DIMENSIONAL.\npattern_learn()\n\u2022 PM_TWO_DIMENSIONAL. Specifies the two-dimensional pattern type.\nThe following restriction is applied to the two-dimensional pattern type:\n\u25e6 At least one vertex of the first pattern layer of a source pattern must be\nwithin the pattern extent if the anchor  argument is the default.\n\u2022 PM_ONE_DIMENSIONAL. Specifies the one-dimensional pattern type and\nsupports both orthogonal and 45-degree one-dimensional patterns.\nThe following restrictions apply to the orthogonal one-dimensional pattern\ntype:\n\u25e6 All lines must be in the same direction, either horizontal or vertical.\n\u25e6 The pattern extent must be specified with the pattern_extent  argument.\n\u25e6 The ignore_extra_polygons  argument must be false.\n\u25e6 The first pattern layer cannot be empty.\n\u25e6 The jog size, which is set with the\nedge_jog_size  argument, must be 0\n(zero).\nThe following restrictions apply to the 45-degree one-dimensional pattern\ntype:\n\u25e6 Optional pattern markers cannot be specified.\n\u25e6 The ignore region cannot be specified.\n\u25e6 Pattern run length cannot be specified.\n\u25e6 The pattern extent must be specified with the pattern_extent  argument\nand parallel to the pattern lines.\n\u25e6 The pattern_matching_mode  argument must be PM_EXACT  or\nPM_EDGE_NONUNIFORM.\n\u25e6 The first pattern layer cannot be empty.\nWhen converting a one-dimensional pattern library into a graphic format\nusing the pattern_library_read()  function or the pdb_utility.pl script,\npatterns are output in the following format:\n\u25e6 Run length is used as the pattern extent.\n\u25e6 The pattern marker has the same extent as the pattern extent.\n\u25e6 Optional pattern markers reside the pattern extent.\npattern_learn()\nFigure 511  shows an example of these normalizations.\nFigure 511 Converted One-Dimensional Pattern Library", "optional_region_layers": "Optional. Specifies a list of polygon layers that define areas on the source\npattern that are optional in the\npattern_match()  function matching process.\nPattern layer polygons enclosed by an optional region layer are considered to be\nin the same optional group. A pattern layer polygon can belong to more than one\noptional group. The matched pattern reported by the pattern_match()  function\ncan have none, one, or more pattern layer polygons that are from the same\noptional group. See\nFigure 512  and Figure 513  for examples of two-dimensional\npatterns.\npattern_learn()\nFigure 512 Source Pattern for optional_region_layers Argument Example\nFigure 513 Matched Patterns for optional_region_layers Argument Example\nOptional region layers can also be applied to a one-dimensional pattern type.\nSee\nFigure 514  for an example of a source pattern and its enumerated patterns\nin the pattern library, which are matched with the pattern_match()  function\nwhen its pattern extent is set as the optional region layer.\npattern_learn()\nFigure 514 One-Dimensional Source Pattern for optional_region_layers Argument\nExample\nWhen using the optional_region_layers  argument:\n\u2022 A pattern must have a unique name that should be a valid input of the\npattern_text_id  argument.\n\u2022 A pattern name cannot use \u201c_icvpmoptreg_$index\u201d.\n\u2022 The pattern_fuzziness  argument must be PM_EXACT.\n\u2022 The pattern_type  argument must be PM_TWO_DIMENSIONAL.\n\u2022 The ignored region layers, which are defined with ignore_region_layers\nargument, cannot overlap the optional region layers for a two-dimensional\npattern type.\n\u2022 The ignored region layers, which are defined with", "pattern_naming_mode": "Optional. Specifies how to name the patterns. Pattern names are reported\nin LAYOUT_ERRORS file and saved in the pattern library. The default is\nPM_NAME_SEQUENTIAL.\n\u2022 PM_NAME_SEQUENTIAL. Specifies the tool-generated pattern names when the\npattern_text_id  argument is not user-defined. The pattern is named as\n{pattern_prefix}1, {pattern_prefix}2, and so on.\n\u2022 PM_NAME_UNIQUE. Specifies that a pattern is named with a unique text string.\nThe name is defined by the following format:\n{pattern_prefix}\uff0cstring\nNote:\nThe PM_NAME_UNIQUE  option supports only the exact matching\nmode using the tool-generated pattern extent for the two-\ndimensional pattern type for pattern library comparison\nor merging. See the pattern_library_merge()  and\npattern_library_compare()  functions for more information.", "pattern_anchor_optimization": "Optional. Specifies the anchor optimization method that is applied during pattern\nmatching using the pattern_match()  function to filter out irrelevant anchors for\ntwo-dimensional pattern types. The default is PM_ALL.\n\u2022 PM_ALL. Requires that all corners are used as anchors.\nNote:\nAnchor optimization is performed automatically during pattern\nmatching for pattern libraries where\n- pattern_anchor_optimization = PM_ALL\n- pattern_fuzziness = PM_EDGE_NONUNIFORM\n\u2022 PM_SIZE. Requires that all source patterns must have at least one complete\nrectangle shape in the first pattern layer. The rectangle shape size is\ncalculated during pattern library creation. During pattern matching, only\nthe corners of the rectangles within the shape size are used as anchors.\npattern_learn()\nOther corners are filtered out. See Figure 515  for an example of the PM_SIZE\nargument.\n\u2022 PM_ANGLE. Requires that all source patterns must have concave corner in the\nfirst pattern layer. During pattern matching. only concave corners are used as\nanchors. Other corners are filtered out. See\nFigure 516  for an example of the\nPM_ANGLE  argument.\n\u2022 PM_ENCLOSE. Requires that all source patterns have the first pattern layer\nas a via layer and the other pattern layers as metal layers. The via edge\nis enclosed by a metal line end that must be completely inside the pattern\nextent. The enclosing range is calculated during pattern library creation.\nDuring pattern matching, only the corners of the via edge, which is enclosed\nby a metal line end within the enclosing range, is used as an anchor. Other\ncorners are filtered out. See\nFigure 517  for an example of the PM_ENCLOSE\nargument.\n\u2022 PM_CENTER. Requires that all source patterns must have at least one\ncomplete rectangle shape in the first pattern layer. During pattern matching,\nonly the center of the rectangle shape within the shape-size range is used\nas an anchor. Corners are filtered out. See\nFigure 518  for an example of\nPM_CENTER  argument.\nFigure 515 Anchor Optimization With PM_SIZE\npattern_learn()\nFigure 516 Anchor Optimization With PM_ANGLE\nFigure 517 Anchor Optimization With PM_ENCLOSE\npattern_learn()\nFigure 518 Anchor Optimization With PM_CENTER", "optional_pattern_marker_type": "Optional. Specifies the type of optional pattern marker layers. The default is\nFIXED.\n\u2022 FIXED. Specifies that the output of optional pattern markers of a matched\npattern is fixed in size and location as they are defined in the pattern library.\n\u2022 DYNAMIC. Specifies that the output of optional pattern markers of a matched\npattern can vary in size and location compared with the optional pattern\nmarkers defined in the pattern library.\nTo enable DYNAMIC, the optional pattern marker must establish a certain\ncorrelation rule with one or more pattern polygons. This correlation rule is\ndifferent for one-dimensional and two-dimensional pattern types.\nThe following correlation rules apply to the two-dimensional pattern type:\n\u2022 Optional pattern markers that do not share any corner with a pattern polygon\nare treated as fixed types even if the optional_pattern_marker_type\nis DYNAMIC. See\nFigure 519  for output examples of fixed optional pattern\nmarkers.\n\u2022 Optional pattern markers that share corners with one or\nmore pattern polygons are enabled to be dynamic when the\noptional_pattern_marker_type  is DYNAMIC. The shared corner\nof an optional pattern marker moves accordingly with its associated\npattern corner when an optional pattern marker is retrieved with the\npattern_learn()\noptional_pattern_marker()  function following pattern matching. See\nFigure 520  for output examples of dynamic optional pattern markers.\nFigure 519 Fixed Optional Pattern Markers\nFigure 520 Dynamic Optional Pattern Markers\nThe following correlation rules apply to the one-dimensional pattern type:\n\u25e6 Optional pattern markers are correlated to pattern polygons through\nedges. This edge pair correlation is defined by the user in the pattern.xml\nfile.\n\u25e6 Edge labels are generated during pattern library creation and defined\nby the tool along the run length direction for both pattern edges and\npattern_learn()\noptional pattern marker edges. Pattern edges on pattern boundaries are\nnot labeled.\n\u25e6 One optional pattern marker edge can only be paired with one pattern\nedge. Unpaired optional pattern marker edges are treated as fixed edges.\n\u25e6 When an optional pattern marker is retrieved using the\noptional_pattern_marker()  function, its edges shift with its paired\npattern edges by maintaining a constant distance between the edge pair\nthat is specified in the pattern library. See\nFigure 521  for an edge pair\ncorrelation example.\nSee the Examples section for more information about the format and use\nof the pattern.xml file to define the edge pair between the optional pattern\nmarker and the pattern polygon.\nFigure 521 Edge Pair Correlation\nThe following restrictions apply to the dynamic optional pattern marker:\n- The pattern_fuzziness  argument must be PM_EDGE_NONUNIFORM.\n- The FIXED  and the DYNAMIC  settings are mutually exclusive for one\npattern library.\n- The dynamic optional pattern markers must be rectangles, and they are\nlimited to 64 rectangles per pattern.\n- The dynamic optional pattern markers must not interact with the pattern\nextent for two-dimensional pattern types.\npattern_learn()", "pattern_run_length": "Optional. Specifies whether to check the run length for one-dimensional patterns\nduring pattern matching. The default is ALL.\n\u2022 All. Specifies that run length is not checked. The pattern_match()  function\noutputs a matched pattern regardless of its run length.\n\u2022 RUN_LENGTH_GE. Specifies run length is checked. The pattern_match()\nfunction outputs only a matched pattern that has a run length greater than\nor equal to the run length of its referenced pattern captured during pattern\nlibrary creation.\nSee\nFigure 522  for an example of the pattern_run_length  argument.\nFigure 522 Pattern Matching Using Pattern Run Length", "violations_per_pattern": "Optional. Controls the output violation number. The default is ALL.\n\u2022 All. Specifies that the pattern_learn()  function outputs all violations.\n\u2022 ONE. Specifies that the pattern_learn()  function outputs one violation for\neach pattern.", "report_individual_pattern_violation_count": "Optional. Controls whether violations are reported by pattern id. The default is\ntrue.\npattern_learn()\n\u2022 true. Specifies that the pattern_learn()  function reports violations by\npattern id in the ERROR SUMMARY and ERROR DETAILS sections of the\nLAYOUT_ERRORS and VUE files.\n\u2022 false. Specifies that the pattern_learn()  function does not report\nviolations by pattern id in either section of the LAYOUT_ERRORS and VUE\nfiles.", "critical_region_layers": "Optional. Specifies the critical regions of each pattern layer. There must be at\nleast one polygon of any shape within every critical region for pattern matching\nto be successful."}, "summary": "The pattern_learn()  function creates a new pattern library or updates an existing\npattern library with source patterns.", "function_name": "pattern_learn()"}
{"description": "The pattern_library()  function defines the name and path of a pattern library and\nreturns a handle to be used by the pattern_library_handle  argument of all the pattern\nmatching functions.", "syntax": "pattern_library(\nlibrary_name = \"string\",\nlibrary_path = \"string\"\n);", "returns": "pattern_library_handle", "arguments": {"library_name": "Required. Specifies the pattern library name.", "library_path": "Required. Specifies the pattern library path."}, "summary": "The pattern_library()  function defines the name and path of a pattern library and\nreturns a handle to be used by the pattern_library_handle  argument of all the pattern\nmatching functions.", "function_name": "pattern_library()"}
{"description": "The pattern_library_compare()  function compares two pattern libraries and outputs\na text report. The ASCII file handle is defined using the fopen()  function before calling\nthis function. This function applies only to the pattern libraries generated when the\npattern_naming_mode  argument of the pattern_learn()  function is PM_NAME_UNIQUE.\nWhen you use the pattern_library_compare()function:\n\u2022 A placeholder GDSII or OASIS file is required as input. See the Examples section for\nan example of defining a placeholder file.\n\u2022 A placeholder ASSIGN section is required in the runset. See the Examples section for\nan example of a placeholder ASSIGN section.\nThe pdb_utility.pl script, which is in the contrib directory, allows you to perform the\nfunctionality of the pattern_library_compare()  function without executing a runset and\nwithout using a placeholder GDSII file. See the Examples section for how to run the script.", "syntax": "pattern_library_compare(\npattern_library1 = pattern_library_handle,\npattern_library2 = pattern_library_handle,\ncompare_report   = ascii_file_handle\n);", "returns": "void", "arguments": {"pattern_library1": "Required. Specifies the first pattern library to be compared with the\nsecond pattern library. The handle must be previously defined by the\npattern_library()  function.", "pattern_library2": "Required. Specifies the second pattern library to be compared with\nthe first pattern library. The handle must be previously defined by the\npattern_library()  function.", "compare_report": "Required. Specifies the ASCII file for the compare results.\npattern_library_compare()"}, "summary": "The pattern_library_compare()  function compares two pattern libraries and outputs\na text report.", "function_name": "pattern_library_compare()"}
{"description": "The pattern_library_lock()  function adds read and write protection to a pattern library.\nA locked pattern library is neither accessible by the\npattern_learn()  function for adding\nnew patterns nor by the pattern_library_read()  function for converting it to a graphical\nformat file.\nThe\npattern_library_lock()  function cannot reverse the locking process. The locked\npattern library is then delivered to the end user.\nWhen you use the pattern_library_lock()  function:\n\u2022 A placeholder GDSII or OASIS file is required as input. See the Examples section for\nan example of defining a placeholder file.\n\u2022 A placeholder ASSIGN section is required in the runset. See the Examples section for\nan example of a placeholder ASSIGN section.\nThe pdb_utility.pl script, which is in the contrib directory, lets you perform the functionality\nof the pattern_library_lock()  function without executing a runset and without a\nplaceholder GDSII file. See the pdb_utility.pl script for information about how to rerun the\nscript.", "syntax": "pattern_library_lock(\npattern_library_handle = pattern_library_handle\n);", "returns": "void", "arguments": {"pattern_library_handle": "Required. Specifies the pattern library or model file to be locked or encrypted.\nThe handle must be previously defined by the pattern_library()  function.\nNote:\nThe pattern_library_handle  argument replaces the previous\npattern_library_name  argument for better usability, but it breaks\nthe backward compatibility of the previous runset, which is defined\nusing the pattern_library_name  argument.\npattern_library_lock()"}, "summary": "The pattern_library_lock()  function adds read and write protection to a pattern library.", "function_name": "pattern_library_lock()"}
{"description": "The pattern_library_merge()  function merges a list of pattern libraries into one\npattern library. This function applies only to the pattern libraries generated when the\npattern_naming_mode  argument of the pattern_learn()  function is PM_NAME_UNIQUE.\nWhen you use the pattern_library_merge()function:\n\u2022 A placeholder GDSII or OASIS file is required as input. See the Examples section for\nan example of defining a placeholder file.\n\u2022 A placeholder ASSIGN section is required in the runset. See the Examples section for\nan example of a placeholder ASSIGN section.\nThe pdb_utility.pl script, which is in the contrib directory, allows you to perform the\nfunctionality of the pattern_library_merge()  function without executing a runset and\nwithout using a placeholder GDSII file. See the Examples section for how to run the script.", "syntax": "pattern_library_merge(\ninput_pattern_libraries  = {pattern_library_handle, ...},\noutput_pattern_library = pattern_library_handle\n);", "returns": "void", "arguments": {"input_pattern_libraries": "Required. Specifies the list of input pattern libraries to be merged. The handle\nmust be previously defined by the pattern_library()  function.", "output_pattern_library": "Required. Specifies the output pattern library to be merged. The handle must be\npreviously defined by the pattern_library()  function."}, "summary": "The pattern_library_merge()  function merges a list of pattern libraries into one\npattern library.", "function_name": "pattern_library_merge()"}
{"description": "The pattern_library_read()  function converts a pattern library to IC Validator group\nfiles. These files can then be written to a GDSII or OASIS file using the\nwrite_gds()\nfunction or the write_oasis_global_options()  function.\nThis function is required when converting a pattern library to GDSII or OASIS output with\nthe IC Validator tool.\nWhen you use the pattern_library_read()  function,\n\u2022 A placeholder GDSII or OASIS file is required. See the Examples section for an\nexample of defining a GDSII or OASIS file.\n\u2022 A placeholder ASSIGN section is required in the runset. See the Examples section for\nan example of an ASSIGN section.\n\u2022 The resolution in the write_gds()  and write_oasis()  functions must be equal\nto or finer than the pattern library resolution to avoid pattern snapping. See the\nresolution_options()  function for more information about how to specify a\nresolution other than the input library resolution. Also, see the write_gds()  or\nwrite_oasis()  functions for more information about how to specify an output\nresolution other than the input library resolution.\nThe pdb_utility.pl script, which is in the contrib directory, allows you to perform the\nfunctionality of the pattern_library_read()  function without executing a runset and\nwithout a placeholder GDSII file. See the pdb_utility.pl script for information about how to\nrun the script.", "syntax": "pattern_library_read(\npattern_library_name                      = \"string\",\npattern_text_id                           = out_text_layer,\npattern_marker                            = out_polygon_layer,\npattern_extent                            = out_polygon_layer,\npattern_layers                            = {out_polygon_layer, ...},\nedge_tolerance_layers                     = {out_polygon_layer, ...},\nignore_region_layers                       = {out_polygon_layer, ...},\nedge_label_layers                         = {out_text_layer, ...},\noptional_pattern_markers                  = {out_polygon_layer, ...},\nstring_property_layers                     = {out_text_layer, ...},\ndouble_property_layers                    = {out_text_layer, ...},\noptional_pattern_marker_edge_label_layers = {out_text_layer, ...},\npattern_library_handle                    = NULL_PATTERN_LIBRARY\n);\npattern_library_read()", "returns": "void", "arguments": {"pattern_library_name": "Required. Specifies the pattern library to be converted.", "pattern_text_id": "Required. Specifies the output layer that contains the pattern ID.", "pattern_marker": "Required. Specifies the output layer that contains the pattern markers.", "pattern_extent": "Required. Specifies the output layer that contains the pattern extent.", "pattern_layers": "Required. Lists the output layers that consist of one or more pattern layers.", "edge_tolerance_layers": "Required. Lists the output layers that contain the edge tolerance of each pattern\nlayer.", "ignore_region_layers": "Required. Lists the output layers that contain the ignored regions of each pattern\nlayer.", "edge_label_layers": "Required. Lists the output layers that consist of one or more edge-label layers.\nEdges of each pattern are labeled in clockwise order from the lower-left edge\nof the lower-left polygon, starting from zero. Edges touching either the pattern\nextent or the ignored region are treated as false edges and are not output.\nNote:\nThe edge-label layers are output only when the pattern_fuzziness\nargument of the pattern_learn()  function is PM_EDGE_NONUNIFORM.\nSee the output_pattern_xml  argument of the\npattern_learn()\nfunction for more information.", "optional_pattern_markers": "Required. Lists the output layers that contain optional pattern markers which are\nplaced on each pattern.\npattern_library_read()", "string_property_layers": "Required. Lists the output text layers that have a pattern property type\nof STRING. See the pattern_type_properties  argument of the\npattern_learn()  function for more information.", "double_property_layers": "Required. Lists the output text layers that have a pattern property type\nof DOUBLE. See the pattern_type_properties  argument of the\npattern_learn()  function for more information.", "optional_pattern_marker_edge_label_layers": "Required. Lists the output layers that consist of one or more edge-label\nlayers for optional pattern markers. Edges of each marker layer are labeled in\nclockwise order from the lower-left edge of the lower-left polygon, starting from\n0 (zero). To distinguish from the pattern edge label, the optional pattern marker\nedge label is prefixed with opm. For example, opm.e1 represents optional\npattern marker edge 1.\nNote:\nThe optional pattern marker edge-label layers are output only when\nthe pattern_fuzziness  argument of the pattern_learn()  function\nis PM_DIMENSION_UNBOUNDED.", "pattern_library_handle": "Required. Specifies the pattern library to be read. The handle must be\npreviously defined by the pattern_library()  function.\nNote:\nThe pattern_library_nameargument has backward\ncompatible support for the previous pattern matching runset. The\npattern_library_handle  argument is selected if defined."}, "summary": "The pattern_library_read()  function converts a pattern library to IC Validator group\nfiles.", "function_name": "pattern_library_read()"}
{"description": "The pattern_marker_filter()  function removes pattern markers using a specific\nfiltering mode.", "syntax": "pattern_marker_filter(\nlayer           = marker_layer,\nname            = \"layer_label\",      //optional\nfilter_mode     = KEEP_MIN_XOR_AREA                        //optional\n);", "returns": "marker layer", "arguments": {"layer": "Required. Marker layer that specifies the polygon, edge, or error output.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "filter_mode": "Optional. Specifies that when filter_mode = KEEP_MIN_XOR_AREA, for the\nsame bounding box markers, only the minimum XOR_AREA  marker is preserved.\nThe XOR_AREA  is the area of the XOR result between the pattern and target\nlayout. The default is KEEP_MIN_XOR_AREA.\nNote:\nWhen filter_mode=KEEP_MIN_XOR_AREA, the input\nmarker of the pattern_marker_filter()  must be the\noutput of the partial_match()  function. Otherwise, the\npattern_marker_filter()  function returns an error, as XOR_AREA\ncannot be found.\nIf two markers with the same bounding box and XOR_AREA  exist, the\nmarker with the smaller pattern name is preserved. if the names\nare also the same, the marker with the smaller pattern orientation is\npreserved.\npattern_marker_filter()"}, "summary": "The pattern_marker_filter()  function removes pattern markers using a specific\nfiltering mode.", "function_name": "pattern_marker_filter()"}
{"description": "The pattern_options()  function defines the path for the pattern library when\nthe pattern_library_name  argument of the\npattern_library_read(),\noptional_pattern_markers(), and pattern_match()  functions is used to specify the\npattern library. It can be called only one time within a runset.", "syntax": "pattern_options(\npattern_library_path       = \"string\"\n);", "returns": "void", "arguments": {"pattern_library_path": "Required. Specifies the pattern library path. An error occurs if the path does not\nexist."}, "summary": "The pattern_options()  function defines the path for the pattern library when\nthe pattern_library_name  argument of the\npattern_library_read(),\noptional_pattern_markers(), and pattern_match()  functions is used to specify the\npattern library.", "function_name": "pattern_options()"}
{"description": "The pattern_predict()  function identifies weak process points in a design using a\nprediction file. Pattern features, such as density vectors, are calculated based on potential\nuser-specified locations and layers for prediction purposes. The predict file can be a\nPython Machine Learning script.", "syntax": "pattern_predict(\nanchor            = geometry_layer,\nambit             = {X=double, Y=double},\npattern_layers    = {polygon_layer, ...},\npattern_predict_file       = \"string\",\ngenerate_density_values    =  true  | false,           //optional\ndensity_parameters  = {\nwindow_count_x = integer,\nwindow_count_y = integer,\n},                          //optional\noutput                = HOTSPOT | ALL,                 //optional\nattach_property_name  = \"Score\"                        //optional\n);", "returns": "polygon layer or error result", "arguments": {"anchor": "Required. Specifies the potential locations in a design that might be weak\nprocess points. The anchor layer can be of polygon or marker type.", "ambit": "Required. Specifies the extensions for generating the pattern extent based on\nthe anchor in the x- and y-directions. The ambit starts from the center of the\nanchor.", "pattern_layers": "Required. Specifies the input layers on which pattern features are calculated\nbased on the pattern extent generated. For this list, the size and order of the\npattern layer list must match the size and order of the pattern layer list used to\nbuild the prediction file.", "pattern_predict_file": "Required. Specifies the prediction file for identifying the weak process points.\npattern_predict()", "generate_density_values": "Optional. Specifies whether to generate the density vectors. The default is true.", "density_parameters": "Optional. Specifies density parameters that are used to generate the density\nvectors. For these parameters, their values must match the values of the same\nparameters used to build the prediction file.\n\u2022 window_count_x. Defines the number of the scanning window in the x-\ndirection. The default is 32.\n\u2022 window_count_y. Defines the number of the scanning window in the y-\ndirection. The default is 32.", "output": "Optional. Specifies the hotspot prediction results of the anchor polygons. The\ndefault is HOTSPOTS.\n\u2022 HOTSPOTS. Outputs only the anchor polygons whose clips are considered as\nhotspots.\n\u2022 ALL. Outputs all anchor polygons with attached score values, which\ncan be retrieved by the df_get_polygon_double_property()  and\ndf_get_polygon_sum_double_property()  utility functions.", "attach_property_name": "Optional. Defines the property name of the value that is attached to the output\npolygons of the pattern_predict()  function. The default is \u201cScore\u201d. This\nargument applies only when output = ALL."}, "summary": "The pattern_predict()  function identifies weak process points in a design using a\nprediction file.", "function_name": "pattern_predict()"}
{"description": "The pattern_predict_marker()  function outputs the optimized fixing guidance in a\ndesign using a prediction file. Pattern features, such as density vectors are calculated\nbased on potential user-specified locations and layers for prediction purposes. The predict\nfile can be a Python Machine Learning script. The optimized fixing guidance information is\nstored in the output of the pattern_predict_marker()  function, and it can be retrieved\nby using the optional_pattern_marker()  and pattern_extract()  functions.", "syntax": "pattern_predict_marker(\nanchor            = geometry_layer,\nambit             = {X=double, Y=double},\npattern_layers    = {polygon_layer, ...},\npattern_predict_file     = \"string\",\ngenerate_density_values  =  true  | false,                   //optional\ndensity_parameters       = {\nwindow_count_x = integer,\nwindow_count_y = integer,\n},                               //optional\npredict_value            = {LIST_OF_STRING, LIST_OF_INTEGER,\nLIST_OF_FLOAT}         //optional\n);", "returns": "marker layer or error result", "arguments": {"anchor": "Required. Specifies the marker layer that contains pattern information.", "ambit": "Required. Specifies ambit value in the x- and y-directions.", "pattern_layers": "Required. Specifies a list of polygon layers to be clipped for feature extraction.", "pattern_predict_file": "Required. Specifies the prediction file for fixing guidance prediction.", "generate_density_values": "Optional. Specifies whether to generate the density vectors. The default is true.\npattern_predict_marker()", "density_parameters": "Optional. Specifies density parameters that are used to generate the density\nvectors.\n\u2022 window_count_x. Defines the number of the scanning window in the x-\ndirection. The default is 32.\n\u2022 window_count_y. Defines the number of the scanning window in the y-\ndirection. The default is 32.", "predict_value": "Optional. Determines the type of return value of the predicted file. The default is\na list of string; the other types are list of integer and list of float.\n\u2022 LIST_OF_STRING. Defines the type of return value of the predicted file as a\nlist of strings.\n\u2022 LIST_OF_INTEGER. Defines the return value of the predicted file as a list of\nintegers.\n\u2022 LIST_OF_FLOAT. Defines the return value of the predicted file as a list of\nfloating-point numbers."}, "summary": "The pattern_predict_marker()  function outputs the optimized fixing guidance in a\ndesign using a prediction file.", "function_name": "pattern_predict_marker()"}
{"description": "The pattern_xor()  function creates a list of polygon layers that represent the unique\ndata between the input layout layers and the corresponding pattern layers of a pattern\nlibrary. Ignore regions are excluded from this operation. This function can be used for\ndebugging partially matched patterns.", "syntax": "pattern_xor(\npattern_library_name                      = \"string\",\npattern_layers                            = {polygon_layer, ...},\npattern_marker                            = marker_layer,\npattern_library_handle                    = NULL_PATTERN_LIBRARY\n);", "returns": "list of polygon layers", "arguments": {"pattern_layers": "Required. Lists the input layout pattern layers on which pattern matching is\nperformed. For this list,\n\u2022 The size of the pattern layer list must match the size of the pattern layer list\nused to generate the pattern library.\n\u2022 The pattern layer list must be in the same order as in the pattern layer list\nused to generate the pattern library.\nThe pattern_xor()  function does not support the following situations:\n\u2022 Pattern library with the ignore_extra_polygon  argument set to TRUE.\n\u2022 Pattern library with the pattern_fuzziness  argument set to\nPM_EDGE_UNIFORM  and PM_EDGE_NONUNIFORM.\n\u2022 Pattern library with the pattern_type  argument set to\nPM_ONE_DIMENSIONAL.\n\u2022 Patterns with multiple pattern markers in a pattern library.", "pattern_marker": "Required. Specifies the pattern marker layer.\npattern_xor()", "pattern_library_name": "Required. Specifies the pattern library used for retrieving pattern information.\nNote:\nThe pattern_library_name  argument has backward\ncompatible support for the previous pattern matching runset. The\npattern_library_handle  argument is selected if defined.", "pattern_library_handle": "Required. Specifies the pattern library used for retrieving pattern information.\nThe handle must be previously defined by the pattern_library()  function."}, "summary": "The pattern_xor()  function creates a list of polygon layers that represent the unique\ndata between the input layout layers and the corresponding pattern layers of a pattern\nlibrary.", "function_name": "pattern_xor()"}
{"description": "The perc_analyze_netlist()  function executes a Programmable Electrical Rule\nChecking (PERC) Python remote function for netlist processing. Use this function to\naccomplish either or both of the following operations:\n\u2022 Preprocess an input netlist and save the resulting netlist for additional processing in\nanother perc_analyze_netlist()  remote block.\nPreprocessing often includes setting useful tags, possibly propagating them throughout\nthe netlist, and can also include saving netlist attributes. This type of preprocessing is\nuseful when multiple rules can take advantage of these operations. You can also use\npreprocessing to select a section of circuitry and copy it into a holding cell for further\nprocessing. The resulting netlist has only the holding cell, which accelerates further\nprocessing of this circuitry.\n\u2022 Perform netlist processing to generate shapes associated with certain netlist objects.\nYou can use netlist processing to select circuitry of interest. You can save the\nassociated nets and devices to the results database, from which you can generate\nthe shapes associated with these netlist objects for further processing in the geometry\nengine. See the PERC create layer functions (\nperc_create_device_layer(),\nperc_create_device_list_layer(), and perc_create_net_layer()).\nThe perc_analyze_netlist()  function also performs netlist processing to check\nelectrical rules and report errors or generate netlist statistics. The utility functions that you\ncan use in the Python remote block called by perc_analyze_netlist()  offer a set of\nnetlist processing capabilities. In addition, all of the features of the Python language are\navailable, including writing files with a format that you specify.\nMost of the runset code for netlist processing is in the remote blocks called by the\nperc_analyze_netlist()  functions. The remote block is written in Python and exists in\nseparate Python module files. The Web is a good source for Python language reference\nmaterial. For information about the PERC utility functions, see\nPERC Utility Functions.\nNote:\nThe IC Validator embedded Python interpreter ignores the PYTHONPATH\nenvironment variable to avoid conflicting with other Python configurations on\nyour system. Use ICV_PYTHONPATH instead to control the Python module\nsearch path.", "syntax": "perc_analyze_netlist(\nmodule_file             = \"string\",\nfunction_expression     = \"string\",\nperc_analyze_netlist()\ninput_netlist_db        = perc_netlist_database,         //optional\ninput_paths_db          = perc_paths_database,           //optional\nviolation_definitions   = {{\"string\" => \"string\"}, ...}, //optional\nexecution_dependencies  = {\n{netlist_db = perc_netlist_database,\nresults_db = perc_results_database},\n...},                                                   //optional\ndisable_pruning         = true  | false, //optional\ninfo_rule_definitions   = {{\"string\" =>\n\"string\"}, ...} //optional\n);", "returns": "The output is a structure of databases or void:\nperc_analysis_s : newtype struct of {\nnetlist_db : perc_netlist_database;\nresults_db : perc_results_database;\nviolations : violation_table_h;\n};\nnetlist_db\nThe netlist saved in the function_expression  Python remote block function\nby the utility function ndb_save_netlist(). This netlist can be used in any\nfunction that takes a perc_netlist_database  as input, such as another\nperc_analyze_netlist()  function.\nresults_db\nThe database that holds netlist objects (nets or devices) saved in the\nfunction_expression  Python remote block function. This database is\nused in the PERC create layer functions, (perc_create_device_layer(),\nperc_create_device_list_layer(), and perc_create_net_layer()) to\ngenerate the shapes associated with the saved netlist objects, and is also used\nin the perc_extract_resistance()  function to perform circuit analysis.\nviolations\nReturns a hash of rule names to violation objects. You specify the rule names in\nthe violation_definitions  argument. For more information about violations,\nsee the \u201cViolation Block\u201d and \u201cViolation Variables\u201d sections in the IC Validator\nUser Guide.", "arguments": {"module_file": "Required. Specifies the file name of the Python module that holds the definition\nof the Python remote function. If the Python module file is not in the current\nperc_analyze_netlist()\nworking directory, you can use the python_validate()  function to resolve any\nsearch paths specified on the IC Validator command line.\nThe path to the specified Python module is automatically included in the\nPython search path. As a result, you can use relative imports without additional\nconfiguration. For example, if you have two scripts, a.py  and b.py, in the same\npath, you can call the perc_analyze_netlist()  function with a.py  and import\nb.py  using the import b  statement.", "function_expression": "Required. Specifies the Python function to be executed by\nperc_analyze_netlist(). This string should include the Python syntax for\ncalling the Python remote function, including any arguments that should be\npassed to it.", "input_netlist_db": "Optional. Specifies the netlist to be passed to the Python remote function for\nprocessing. This netlist is returned by the perc_setup()  function or a previous\nperc_analyze_netlist()  function.", "input_paths_db": "Optional. Specifies the paths database to be passed to the Python\nremote function for processing. This database is returned by the\nperc_extract_resistance()  function.", "violation_definitions": "Optional. Specifies additional rules in a string-to-string hash of individual rule\nnames to their corresponding comments.\nA perc_analyze_netlist()  function can check multiple rules in a single\nPython remote function. If the perc_analyze_netlist()  function is enclosed in\nan IC Validator error structure, this structure defines the default rule checked in\nthe Python remote function. The rule names specified by this argument should\nbe used inside the Python remote function when issuing errors.", "execution_dependencies": "Optional. Specifies any previous perc_analyze_netlist()  functions that\nshould complete before this function is executed. Use this argument when\nthe IC Validator tool is running in distributed processing mode if the Python\nremote function must perform file I/O after previous perc_analyze_netlist()\nfunctions.\nThis option is not necessary if the Python remote function does not perform any\nfile I/O.\nperc_analyze_netlist()", "disable_pruning": "Optional. Controls whether this perc_analyze_netlist()  function should be\nautomatically removed from the IC Validator execution tree if all of its rules have\nbeen turned off by IC Validator selectable rules command-line options. The\ndefault is true.\nThe IC Validator tool can determine when a particular function in the runset\ncan be pruned from the execution tree by checking its dependencies.\nHowever, the tool cannot determine if a Python remote function is doing any\nfile I/O that should be executed even if all of the rules associated with this\nperc_analyze_netlist()  function have been turned off.\nSetting this option to true  protects this perc_analyze_netlist()  function\nfrom being removed. If no critical file I/O is performed in the remote block, then\nsetting this option to false  allows the IC Validator run to be more efficient.", "info_rule_definitions": "Optional. Similar to violation_definitions, specifies additional rules in a\nstring-to-string hash of individual rule names to their corresponding comments.\nDifferent from violation_definitions, the rules specified with\ninfo_rule_definitions are \"information-only\" violations used to provide additional\ninsight of the design for the user. The violations reported in this category\ndo not affect the CLEAN or ERROR status, and they do not show up in the\nLAYOUT_ERRORS file."}, "summary": "The perc_analyze_netlist()  function executes a Programmable Electrical Rule\nChecking (PERC) Python remote function for netlist processing.", "function_name": "perc_analyze_netlist()"}
{"description": "The perc_create_device_layer()  function returns the body shapes for all of the\ndevices in the results database returned by a perc_analyze_netlist()  function. This\nincludes all of the devices that you saved in the results database by using the save\nargument in the ndb_find_device()  or ndb_save_top_cell_device()  utility function.\nWhen you save the devices by using a ndb_find_device()  utility function, the\nbody shapes appear in the hierarchy. When you save the devices by using a\nndb_save_top_cell_device()  utility function, the body shapes are flat in the top cell.", "syntax": "perc_create_device_layer(\ndevice_db  = device_database,\nreport_db  = perc_results_database\n);", "returns": "polygon layer or error result", "arguments": {"report_db": "Required. Specifies the results database returned by a\nperc_analyze_netlist()  function. This database is an element in the data\nstructure returned by the perc_analyze_netlist()  function.", "device_db": "Required. Specifies the device database returned by the\nextract_devices()\nfunction."}, "summary": "The perc_create_device_layer()  function returns the body shapes for all of the\ndevices in the results database returned by a perc_analyze_netlist()  function.", "function_name": "perc_create_device_layer()"}
{"description": "The perc_create_device_list_layer()  function returns either the body\nshapes or extents of each group of devices in the results database returned by the\nperc_analyze_netlist()  function. This includes all of the devices that you saved in the\nresults database by using the ndb_save_top_cell_device_list()  utility function.\nEach call to ndb_save_top_cell_device_list()  adds a group of devices to the results\ndatabase. The perc_create_device_list_layer()  function returns the device body\nshapes or extent shapes for all of these groups. Shapes for devices that you save by using\nthe ndb_find_device()  hierarchical search function are not returned.\nThe body shapes or extent shapes are flat in the top cell. If you request extent shapes,\neach shape represents the minimum enclosing rectangle of the device body shapes for\nthe devices included in a single ndb_save_top_cell_device_list()  function call. Each\ncall of this function executed in a Python remote block by the perc_analyze_netlist()\nfunction produces a single extents shape.\nIf a group of devices in the results database is identical to another group, only unique body\nshapes are returned. However, the IC Validator tool stops executing if extent shapes of two\ngroups overlap each other exactly.", "syntax": "perc_create_device_list_layer(\nreport_db    = perc_results_database,\ndevice_db    = device_database,\noutput_type  = BODY_POLYGONS  | BODY_EXTENTS                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"report_db": "Required. Specifies the results database returned by the\nperc_analyze_netlist()  function. This database is an element in the data\nstructure returned by the perc_analyze_netlist()  function.", "device_db": "Required. Specifies the device database returned by the\nextract_devices()\nfunction.\nperc_create_device_list_layer()", "output_type": "Optional. Specifies the data that you want to write to the output layer. The\ndefault is BODY_POLYGONS.\n\u2022 BODY_POLYGONS. Writes the body shapes to the output layer.\n\u2022 BODY_EXTENTS. Writes the minimum enclosing rectangle for each device\ngroup to the output layer."}, "summary": "The perc_create_device_list_layer()  function returns either the body\nshapes or extents of each group of devices in the results database returned by the\nperc_analyze_netlist()  function.", "function_name": "perc_create_device_list_layer()"}
{"description": "The perc_create_net_layer()  function returns the shapes from the specified list of\nlayers for all of the nets in the results database returned by the perc_analyze_netlist()\nfunction. This includes all of the nets that you saved in the results database by using the\nsave  argument in the ndb_find_net()  or ndb_save_top_cell_net()  utility function.\nNote:\nThe list of layers that you specify to create shapes must be contained in the\nconnect database.\nWhen you save the nets by using an ndb_find_net()  utility function, the shapes appear\nin the hierarchy. When you save the nets by using an ndb_save_top_cell_net()  utility\nfunction, the shapes are flat in the top cell.", "syntax": "perc_create_net_layer(\nreport_db           = perc_results_database,\ndevice_db           = device_database,\noutput_from_layers  = {polygon_layer, ...}                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"report_db": "Required. Specifies the results database in the data structure returned by the\nperc_analyze_netlist()  function.", "device_db": "Required. Specifies the device database returned by the\nextract_devices()\nfunction.", "output_from_layers": "Optional. Specifies the list of layers from which shapes should be drawn for\nthe nets contained in the results database. If you do not specify any layers, the\nshapes of all the layers in the connect database are drawn for the nets in the\nresults database."}, "summary": "The perc_create_net_layer()  function returns the shapes from the specified list of\nlayers for all of the nets in the results database returned by the perc_analyze_netlist()\nfunction.", "function_name": "perc_create_net_layer()"}
{"description": "The perc_extract_resistance()  function sets up a StarRC parasitic extraction run for\nthe current paths that were\n\u2022 Defined using ndb_add_current_path().\n\u2022 Saved to a path database from a previous call to perc_analyze_netlist().\nP2P and node voltage values are computed in a simulation. These values can be used by\nndb_* functions in other perc_anazlyze_netlist()  calls.", "syntax": "perc_extract_resistance(\ncurrent_paths    = {perc_results_database, ...},\nstarrc_mapping_directives  = {\nrouting_layers = {\n{\nlayer = \"string\",\ndirectives = {\n{\nsetting = \"string\",\nvalue   = \"string\",\nuse     = RUNSET | OVERRIDE\n}, ...\n}\n}, ...\n},\nvia_layers = {\n{\nlayer = \"string\",\ndirectives = {\n{\nsetting = \"string\",\nvalue = \"string\",\nuse = RUNSET | OVERRIDE\n}, ...\n}\n}, ...\n}\n}\n);", "returns": "perc_paths_database\nperc_extract_resistance()", "arguments": {"current_paths": "Required. Specifies a list of PERC results databases returned by a previous call\nto perc_analyze_netlist().", "starrc_mapping_directives": "Optional. Retrieves directives from the PEX-generated StarRC command file\nand passes this file to the StarRC command file generator in PERC.\n\u2022 routing_layers. Specifies a list of structure that provides a layer name and\nsheet resistance value.\n\u25e6 layer. Specifies the routing layer.\n\u25e6 directives. Specifies the directives from the PEX mapping file.\n\u25aa setting. Specifies the setting of the value in the\nperc_extract_resistance()  function.\n\u25aa value. Specifies the value of the directive from the PEX mapping file.\n\u25aa use. Uses a value specified by the perc_extract_resistance()\nfunction.\n\u25aa RUNSET. Uses the value of the directive from the PEX mapping file.\n\u25aa OVERRIDE. Uses the value specified in the\nperc_extract_resistance()  function.\n\u2022 via_layers. Specifies a list of structures that provides a via layer name, via\nresistance, and via area value.\n\u25e6 layer. Specifies the via layer.\n\u25e6 directives. Specifies the directives from the PEX mapping file.\n\u25aa setting. Specifies the setting of the value in the\nperc_extract_resistance()  function.\n\u25aa value. Specifies the value of the directive from the PEX mapping file.\n\u25aa use. Uses a value specified by the perc_extract_resistance()\nfunction.\n\u25aa RUNSET. Uses the value of the directive from the PEX mapping file.\n\u25aa OVERRIDE. Uses the value specified in the\nperc_extract_resistance()  function.\nperc_extract_resistance()"}, "summary": "The perc_extract_resistance()  function sets up a StarRC parasitic extraction run for\nthe current paths that were\n\u2022 Defined using ndb_add_current_path().", "function_name": "perc_extract_resistance()"}
{"description": "The perc_import_net_properties_from_file()  function reads a file from disk. The\nfile contains a list of net names, with one name on each line. Each column in the file\nrepresents the name or value of a double property that should be assigned to a net.\nThe first line in the file is a header. This header must be the first line in the file. Comment\nlines are not allowed before the header line.\n\u2022 The first column in the header should contain the keyword NetPath.\n\u2022 Each subsequent column should contain the name of a property.\nAll remaining noncomment lines contain a net name and the properties associated with the\nnet.\n\u2022 The first column contains the net name, with reference to the top cell. The name can be\nhierarchical.\n\u2022 All of the other columns represent a double value; one for each property name.\n\u2022 If a property value is missing on a line, each subsequent property gets the last provided\nvalue.\n\u2022 Use double slashes (//) to indicate a comment on a single line.\nThe following example shows the format of a net double property file:\nNetPath volt control\nIO 3.3 1\nDVDD 1.8 2\nDVSS 0.0\nAVDD 3.3\nAVSS 0.0 3\nX1/X24/A 0.8 4\nIn this example, each net gets the following properties:\n\u2022 IO -> volt=3.3, control=1\n\u2022 DVDD -> volt=1.8, control=2\n\u2022 DVSS -> volt=0.0, control=0.0\n\u2022 AVDD -> volt=3.3, control=3.3\n\u2022 AVSS -> volt=0.0, control=3\n\u2022 X1/X24/A -> volt=0.8, control=4\nperc_import_net_properties_from_file()\nThe file can also be cell based, where the first column is the cell name, the second column\nis the net name with relation to the cell listed in the CellName column, and the remaining\ncolumns give the property values. When cell-based names are used, the header line must\nuse the keyword CellName  in the first column.\nAll of the nets listed in relation to the cell receive the property for all placements of that\ncell:\nCellName NetPath volt control\nlowCell IO 3.3 1\ntopCell DVDD 1.8 2\ntopCell DVSS 0.0 2\notherCell AVDD 3.3 3\notherCell AVSS 0.0 3\nlowCell X1/X24/A 0.8 4\nYou should specify the net names with respect to the input netlist. However, if the input\nnetlist is extracted from the layout as part of an LVS run and the design compares cleanly,\nyou can specify schematic net names if you provide a cross-reference database.\nThe net names do not have to be top-of-net names (the names of the nets at their highest\npoint in the hierarchy). The property values are applied to the entire net throughout its\nhierarchy. If a single hierarchical net has conflicting property values (multiple lines that\nare present for a single net, each one using a name at a different hierarchical level), the\nIC Validator tool uses the value associated with the net at the highest hierarchical level.", "syntax": "perc_import_net_properties_from_file(\nnetlist_db     = perc_netlist_database,\nproperty_file  = \"string\",\nxref_db        = xref_database_handle                         //optional\n);", "returns": "perc_netlist_database", "arguments": {"netlist_db": "Required. Specifies the input netlist. This must come from a perc_setup()\nfunction or a perc_analyze_netlist()  function.", "property_file": "Required. Specifies the name of the file that contains the net double property\ndefinitions. The net names in this file should correspond with net names in the\ninput netlist or should cross-reference names in the input netlist.\nperc_import_net_properties_from_file()", "xref_db": "Optional. Specifies the cross-reference database produced by an IC Validator\nLVS run. The compare must be clean to provide a complete cross-reference\ndatabase."}, "summary": "The perc_import_net_properties_from_file()  function reads a file from disk.", "function_name": "perc_import_net_properties_from_file()"}
{"description": "The perc_merge_netlist_db()  function merges tags, net properties, and netlist\nattributes from input netlist db to output netlist db.\nFor netlist attributes, the function merges the values under same attribute name from all\nthe merge netlist_db.\nThe netlist_db_list  must include either all hierarchical netlists or all cached netlists. If\nyou use cached netlists, the following restrictions apply:\n\u2022 If you call short_equivalent_nodes()  on the input netlists, the same net shorting\nmust occur in each netlist. For example, if net1 and net2 are shorted in one input\nnetlist, they must also be shorted in the other netlists, provided those nets exist. If IC\nValidator detects inconsistent net shorting, it reports an error and stops the run.\n\u2022 The ndb_merge_device()  function is not supported. If you call ndb_merge_device()\non any input netlist, IC Validator reports an error and stops the run.", "syntax": "perc_merge_netlist_db(\nnetlist_db_list   = {perc_netlist_database,...},\n);", "returns": "perc_netlist_database", "arguments": {"netlist_db_list": "Required. Specifies the list of input netlist. This must come from a\nperc_analyze_netlist()  function."}, "summary": "The perc_merge_netlist_db()  function merges tags, net properties, and netlist\nattributes from input netlist db to output netlist db.", "function_name": "perc_write_vue_debug_database()"}
{"description": "The perc_property_to_net()  function returns a connect database\nwith net properties that were found and saved in the results database\nreturned by the perc_analyze_netlist()  function. This includes all of the\nproperties saved to the netlist in the results database by using either the\nndb_import_net_property()  function or by setting net properties using the\nndb_set_top_cell_net_property()  function and exporting those properties to the\nnetlist with the ndb_import_net_properties_from_cache_netlist()  function and\nsaving the netlist with ndb_save_netlist(). The output from this function can be used\nwith IC Validator functions that access connect database net properties, such as the\nannotate_by_property()  or drc_features()  functions.", "syntax": "perc_property_to_net(\ndevice_db       = device_database,\nnetlist_db      = perc_netlist_database,\nnet_properties = {\n{\"string\", double},\n...},\ntag_check      = {\nany_of      = {\"string\", ...},\nall_of      = {\"string\", ...},\nnone_of     = {\"string\", ...}\n}                                       //optional\n);", "returns": "connect database", "arguments": {"device_db": "Required. Specifies the device database returned by the\nextract_devices()\nfunction.", "netlist_db": "Required. Specifies the input netlist.", "net_properties": "Required. Specifies the names and values of the properties to be written, with\nthe net, to the output file. A property is written only for the nets that do not have\nthe property assigned to them.\nperc_property_to_net()", "tag_check": "Optional. Specifies a tag constraint used to designate which nets are written to\nthe output file. When this option is used, only nets that meet the tag specification\nare written to the output file."}, "summary": "The perc_property_to_net()  function returns a connect database\nwith net properties that were found and saved in the results database\nreturned by the perc_analyze_netlist()  function.", "function_name": "perc_property_to_net()"}
{"description": "The perc_read_results_database()  function reads a results database from the disk\nwith a specified file name. The specified file must be created first with a previous call to the\nperc_write_results_database()  function.", "syntax": "perc_read_results_database(\nfile_name  = \"string\"\n);", "returns": "perc_results_database", "arguments": {"file_name": "Required. Specifies the file name to which a results database is saved by a\nprevious call to the perc_write_results_database()  function."}, "summary": "The perc_read_results_database()  function reads a results database from the disk\nwith a specified file name.", "function_name": "perc_read_results_database()"}
{"description": "The perc_setup()  function reads a netlist from disk, or from a layout extraction, and\nprepares it for use in a Programmable Electrical Rule Checking (PERC) remote block\nthrough the perc_analyze_netlist()  function. The perc_setup()  function can be\ncalled only one time in a runset. The IC Validator tool uses this function to define the\nreference netlist that the IC Validator VUE tool uses to report and debug netlist errors.\nThe perc_setup()  function provides two arguments for specifying the input netlist file\nhandle, schematic_netlist  and layout_netlist. Only one of these netlist file handles\ncan be specified. Use the argument for the type of netlist (schematic or layout) that you\nspecify with the netlist_source  argument.\nThe schematic_netlist  argument allows the IC Validator VUE tool to connect to a\nschematic-capture tool for cross-probing. If you need to use this cross-probing capability,\nyou must set the netlist_source  argument to SCHEMATIC. This setting allows the\nIC Validator tool to map the instance names in the netlist to the names used in the\nschematic-capture tool. For more information about using this flow, contact your Synopsys\nrepresentative.\nNote:\nFor a netlist domain check that does not include any layout input or require\nschematic-tool cross-probing capabilities, the input netlist file handle\nthat is passed to the perc_setup()  function is returned using either the\nread_layout_netlist()  or the schematic()  function.\nUsing either function does not affect the netlist processing capabilities in a\nremote Python block called by the perc_analyze_netlist()  function.\nSPICE/CDL type netlists do not contain implant type information for devices like MOS and\nbipolar transistors. Using this implant information is often helpful in netlist processing. For\nexample, if no further information is provided when a SPICE/CDL type netlist is read into\nPERC for processing, all MOS transistor devices have the general MOSFET type. If you\nwant to know which of these devices are NMOS and which devices are PMOS, you must\nprovide this information for PERC.\nYou can use either of the following methods to pass implant information to PERC:\n\u2022 Pass the compare matrix to the perc_setup()  function. PERC can determine the\nimplant types for all devices from information contained in the matrix. Use this method\nwhen netlist processing is part of an LVS runset.\n\u2022 Use the device_type_setting  argument to define implant types explicitly for the\nMOS, bipolar, or diode devices.\nperc_setup()\nIn addition to the implant types, a SPICE/CDL type netlist often represents devices by\nusing empty subcircuits. In this case, PERC does not recognize the instances as devices.\nBoth the compare-state method and explicit definition through the device_type_setting\nargument can resolve this. Most runsets require one of these methods to be used.\nHowever, if the netlist processing that you define does not need any information about\nthe implant types for empty subcircuit devices, you do not need to use either of these\nmethods.", "syntax": "perc_setup(\nnetlist_source       = SCHEMATIC | LAYOUT,\nschematic_netlist    = schematic_netlist_file_handle,  //optional\nlayout_netlist       = layout_netlist_file_handle,  //optional\ncompare_state        = compare_state,           //optional\ndevice_type_setting  = {\nmos    = {nmos                   = {\"string\", ...},\npmos                   = {\"string\", ...},\nundefined_implant_type = ALLOW  | ABORT\n},\nbjt    = {npn                    = {\"string\", ...},\npnp                    = {\"string\", ...},\nundefined_implant_type =\nALLOW  | ABORT\n},\ndiode  = {np                     = {\"string\", ...},\npn                     = {\"string\", ...},\nundefined_implant_type =\nALLOW  | ABORT\n},\nsubckt = {\nsubckt_device_type  = {\n{model_names = {\"string\", ...},\ndevice_type = NMOS | PMOS | NPN | PNP | PN |\nNP | RESISTOR | CAPACITOR |\nINDUCTOR | GENERIC | MOSFET |\nJUNCTION_DIODE | BIPOLAR_TRANSISTOR},\n...},\nempty_subckt        = EMPTY_CELL | ABORT |\nGENERIC_DEVICE}\n},                                             //optional\ntop_cell          = \"string\",                   //optional\npower_nets        = {\"string\", ...},            //optional\nground_nets       = {\"string\", ...},            //optional\nxref_db           = xref_database_handle,       //optional\nstarrc_options     =\nnxtgrd_file            = \"string\",\npex_runset_report_file = pex_runset_report_file_handle,\nsettings               = {\"string\", \"string\", ...},\nadditional_non_nxtgrd_layers = {\nconductors = {layers     = {\"string\", ...},\nrho        = double,\nthickness  = double},\nvias       = {layer      = \"string\",\nperc_setup()\nfrom_layer = \"string\",\nto_layer   = \"string\",\nrho        = double,\nthickness  = double},\nmarkers    =  {\"string\", ...},\n},\n}                                       //optional\n);", "returns": "PERC netlist database", "arguments": {"netlist_source": "Required. Specifies whether the input netlist is from a schematic or a layout\nextraction. If you need to cross-probe the results in a schematic-capture tool, set\nthis option to SCHEMATIC.", "schematic_netlist": "Optional. Specifies the schematic netlist file handle returned by the\nschematic()  function. Use this argument when you set the netlist_source\nargument to SCHEMATIC. You must use either this argument or the\nlayout_netlist  argument.", "layout_netlist": "Optional. Specifies the layout netlist file handle returned by the\nread_layout_netlist()  or netlist()  function. Use this argument when\nyou set the netlist_source  argument to LAYOUT. You must use either this\nargument or the schematic_netlist  argument.", "compare_state": "Optional. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the init_compare_matrix()  function.\nThis argument is used to pass device information from the LVS runset into\nPERC, such as the implant types of MOS devices and the device types of any\ndevices that are included as empty subcircuits in the netlist.", "device_type_setting": "Optional. Specifies the implant types of MOS, bipolar, and diode devices and the\ndevice types of any devices that are included as empty subcircuits in the netlist.\nif you do not specify this argument or the compare_state  argument, all MOS\ndevices have the MOSFET type with no implant specification (NMOS or PMOS),\nall bipolar devices have the BIPOLAR_TRANSISTOR type with no implant\nperc_setup()\nspecification (NPN or PNP), and all diode devices have the JUNCTION_DIODE\ntype with no implant specification (NP or PN).\n\u2022 mos. Optional. Specifies the MOSFET devices to be assigned the NMOS or\nPMOS implant type.\n\u25e6 nmos. Specifies a list of strings that represent the model names of the\nMOS devices to be assigned the NMOS implant type. All MOSFET device\ninstances that have one of these model names are assigned an NMOS\ndevice type.\n\u25e6 pmos. Specifies a list of strings that represent the model names of the\nMOS devices to be assigned the PMOS implant type. All MOSFET device\ninstances that have one of these model names are assigned a PMOS\ndevice type.\n\u25e6 undefined_implant_type. Specifies how the IC Validator tool treats\nMOSFET devices that are not assigned an implant type. The default\nis ALLOW, which means the tool assigns the MOSFET  device type to the\ndevice. If you specify ABORT, tool execution stops.\n\u2022 bjt. Optional. Specifies the bipolar devices to be assigned the NPN or PNP\nimplant type.\n\u25e6 npn. Specifies a list of strings that represent the model names of the\nbipolar devices to be assigned the NPN implant type. All bipolar device\ninstances that have one of these model names are assigned an NPN\ndevice type.\n\u25e6 pnp. Specifies a list of strings that represent the model names of the\nbipolar devices to be assigned the PNP implant type. All bipolar device\ninstances that have one of these model names are assigned a PNP\ndevice type.\n\u25e6 undefined_implant_type. Specifies how the IC Validator tool treats\nbipolar devices that are not assigned an implant type. The default is\nALLOW, which means the tool assigns the BIPOLAR_TRANSISTOR\ndevice type to the device. If you specify ABORT, tool execution stops.\n\u2022 diode. Optional. Specifies the diode devices to be assigned th NP or PN\nimplant type.\n\u25e6 np. Specifies a list of strings that represent the model names of the diode\ndevices to be assigned the NP implant type. All diode device instances\nthat have one of these model names are assigned an NP device type.\n\u25e6 pn. Specifies a list of strings that represent the model names of the diode\ndevices to be assigned the PN implant type. All diode device instances\nthat have one of these model names are assigned a PN device type.\nperc_setup()\n\u25e6 undefined_implant_type. Specifies how the IC Validator tool treats a\ndiode devices that are not assigned an implant type. The default is ALLOW,\nwhich means the tool assigns the JUNCTION_DIODE device type to the\ndevice. If you specify ABORT, tool execution stops.\n\u2022 subckt. Optional. Assigns device types to devices that are netlisted as\nsubcircuits.\n\u25e6 subckt_device_type. Specifies the list of subcircuits and the device type\nto which they are mapped.\n- model_names. Specifies a list of strings that represent the subcircuit\nnames.\n- device_type. Specifies the device type to be assigned to the\nsubcircuits named in the model_names  list.\n\u25e6 empty_subckt. Specifies how the IC Validator tool treats empty\nsubcircuit devices that are not assigned a device type. The default is\nGENERIC_DEVICE, which means the tool maps the empty subcircuit to the\nGENERIC  device type. If you specify EMPTY_CELL, the tool does not assign\na device type to an empty subcircuit device. If you specify ABORT, tool\nexecution stops.", "top_cell": "Optional. Specifies the name of the top cell to be read from the input netlist.", "power_nets": "Optional. Specifies the possible power net names. You can include wildcards.\nThe perc_setup()  function finds any nets in the top block with names that\nmatch a string in this list, and makes them available to the Python remote block\nthrough the ndb_get_power_net_names()  utility function.", "ground_nets": "Optional. Specifies the possible ground net names. you can include wildcards.\nThe perc_setup()  function finds any nets in the top block with names that\nmatch a string in this list, and makes them available to the Python remote block\nthrough the ndb_get_ground_net_names()  utility function.", "xref_db": "Optional. Specifies the handle of the database from which all of the cell names\nand net names in the color file are interpreted as schematic names. If an\nxref_db  is not provided, all of the names are interpreted as layout names. The\nhandle must be previously defined by the compare()  function.\nperc_setup()", "starrc_options": "Optional. Provides an interface for adding or changing option values for the\nPERC StarRC run.\n\u2022 nxtgrd_file. Specifies a path to a StarRC nxtgrd file.\n\u2022 pex_report_file. Specifies the file handle for the PEX runset report file\n(returned by pex_runset_report_file()).\n\u2022 settings. A list of strings that are equivalent to StarRC command file\noptions to be inserted into the StarRC command file.\n\u2022 additional_non_nxtgrd_layers. Defines customized layers, which are not\ndefined in nxtgrd and itf files. The defined layers are passed to the StarRC\ntool.\n\u25e6 conductors. Specifies a list of conducting layers, which are passed to the\nStarRC tool. You must provide the rho  and thickness  settings of each\nlayer.\n\u25e6 vias. Specifies a list of via layers, which are passed to the StarRC tool.\nYou must provide the from_layer, to_layer, rho, and thickness  of\neach layer.\n\u25e6 markers. Specifies a list of layer names of marker layers to be passed to\nthe StarRC tool."}, "summary": "The perc_setup()  function reads a netlist from disk, or from a layout extraction, and\nprepares it for use in a Programmable Electrical Rule Checking (PERC) remote block\nthrough the perc_analyze_netlist()  function.", "function_name": "perc_setup()"}
{"description": "The perc_waiver_options()  function specifies the PERC waiver file list as well as any\nother options which pertain to the PERC waivers.", "syntax": "perc_waiver_options(\nwaiver_files  = {\n{waiver file         = {\"string\"},\nmissing_waiver file = ABORT  | IGNORE,\n...}},                    //optional\nrule_name_match_delimiter  = {search_string = \"string\"},\n//optional\nreport_waiver_details      = true | false,          //optional\n);", "returns": "void", "arguments": {"waiver_files": "Optional. Specifies the list of waiver files that the IC Validator tool uses to apply\nwaivers. Specifying waiver files in this list enables the new waiver flow, which\nsupersedes error_options(match_errors).\n\u2022 waiver_file. Required. Specifies the file path to the waiver file created by\nthe pydb_export  utility. The waiver file can be in cPYDB or OASIS formats.\n\u2022 missing_waiver_file. The default is ABORT.\n\u25e6 ABORT. Specifies that the run stops when the waiver file is not found.\n\u25e6 IGNORE. Continues the IC Validator run if the tool cannot find the waiver\nfile.", "rule_name_match_delimiter": "Optional. Specifies a delimiter that is used to match runset violation comments\nto waiver violation comments. If the delimiter is specified, the waivers are\napplied to violations of a particular rule if the runset violation comment matches\nthe waiver violation comment up to the first occurrence of the delimiter.\n\u2022 search_string. Specifies the delimiter. The search string must be a GNU\nextended regular expression. The default is\n\"[[:space:]]+:|[[:space:]]*:[[:space:]]\"\nperc_waiver_options()\nThat is, the default is one of the following:\n\u25e6 One or more white space characters followed by a colon.\n\u25e6 Zero or more white space characters followed by a colon followed by one\nwhite space character.\n\u2022 ignore_case. Specifies if the character case in the violation comment is\nconsidered when matching the delimiter. The default is false.\n\u25e6 true. The search is case-sensitive.\n\u25e6 false. The search is not case-sensitive.", "report_waiver_details": "Optional. Specifies whether to include details of all waived errors in the\nblock.WAIVER_REPORT file. A report, which includes the details can be\ngenerated by the icv_pydb utility regardless of this argument setting. The default\nis false."}, "summary": "The perc_waiver_options()  function specifies the PERC waiver file list as well as any\nother options which pertain to the PERC waivers.", "function_name": "schematic()"}
{"description": "The perc_write_net_missing_property_file()  function writes an output file\ncontaining the instance-based net names of the nets that did not have properties\npropagated to them. The IC Validator tool writes a default value, set in this function, for the\nnet properties and prints it along with the net.\nFor example, if a net is floating and a property is never propagated to it, this option prints\nthe floating net and a default value for the property to the output file. The output file is\nsimilar to the file produced by the perc_write_net_property_file()  function.", "syntax": "perc_write_net_missing_property_file(\nnetlist_db  = perc_netlist_database,\nfile_name  = \"string\",\nnet_properties  = {\n{\"string\", double},\n...},\ntag_check  = {\nany_of = {\"string\", ...},\nall_of = {\"string\", ...},\nnone_of = {\"string\", ...}\n}                                        //optional\n);", "returns": "void", "arguments": {"netlist_db": "Required. Specifies the input netlist.", "file_name": "Required. Specifies the name of the output file to be produced. This file\ncontain the instance-based net names and the properties specified in the\nnet_properties  argument.", "net_properties": "Required. Specifies the names and values of the properties to be written, with\nthe net, to the output file. A property is written only for the nets that do not have\nthe property assigned to them.\nperc_write_net_missing_property_file()", "tag_check": "Optional. Specifies a tag constraint used to designate which nets are written to\nthe output file. When this option is used, only nets that meet the tag specification\nare written to the output file."}, "summary": "The perc_write_net_missing_property_file()  function writes an output file\ncontaining the instance-based net names of the nets that did not have properties\npropagated to them.", "function_name": "perc_write_net_missing_property_file()"}
{"description": "The perc_write_net_property_file()  function writes an output file of instance-based\nnet names and associated propagated properties in the same format as the file used\nfor the perc_import_net_properties_from_file()  function. However, the output file\nwritten by the perc_write_net_property_file()  function references every net from the\ntop block.\nThe xref_to_double_property()  function can use this file later in an IC Validator\ngeometry-based flow.", "syntax": "perc_write_net_property_file(\nnetlist_db      = perc_netlist_database,\nfile_name       = \"string\",\nnet_properties  = {\"string\", ...},\ntag_check       = {\nany_of = {\"string\", ...},\nall_of = {\"string\", ...},\nnone_of = {\"string\", ...}\n}                                                  //optional\n);", "returns": "void", "arguments": {"netlist_db": "Required. Specifies the input netlist.", "file_name": "Required. Specifies the name of the output file to be produced. This file\ncontains the instance-based net names and the properties specified in the\nnet_properties  argument.", "net_properties": "Required. Specifies the list of property names that the function outputs for each\nnet in the output file.", "tag_check": "Optional. Specifies the tag conditions used to designate which nets the function\nwrites to the output file. When this option is used, only nets that meet the tag\nspecification are written to the output file.\nperc_write_net_property_file()"}, "summary": "The perc_write_net_property_file()  function writes an output file of instance-based\nnet names and associated propagated properties in the same format as the file used\nfor the perc_import_net_properties_from_file()  function.", "function_name": "perc_write_net_property_file()"}
{"description": "The perc_write_results_database()  function writes a results database and its data to\ndisk with a specified file name. This file can be restored to a results database with another\ncall to the\nperc_read_results_database()  function.", "syntax": "perc_write_results_database(\nfile_name   = \"string\",\nresults_db  = perc_results_database\n);", "returns": "void", "arguments": {"file_name": "Required. Specifies the file name to which the results database is saved. The\nfile name cannot contain a parent folder.", "results_db": "Required. Specifies the results database to be saved to disk. This database is\nreturned by previous calls to the perc_analyze_netlist()  function."}, "summary": "The perc_write_results_database()  function writes a results database and its data to\ndisk with a specified file name.", "function_name": "perc_write_results_database()"}
{"description": "The pex_cell_extents_file()  function defines a cell extents file. The\nfile handle generated by this function is used as an input argument to the\npex_generate_database()  function.", "syntax": "pex_cell_extents_file(\nfile  = \"string\"\n);", "returns": "pex_cell_extents_file_handle", "arguments": {"file": "Required. Specifies the cell extents file name."}, "summary": "The pex_cell_extents_file()  function defines a cell extents file.", "function_name": "pex_cell_extents_file()"}
{"description": "The pex_cell_port_file()  function defines a cell port file. The file handle generated by\nthis function is used as an input argument to the\npex_generate_database()  function.", "syntax": "pex_cell_port_file(\nfile  = \"string\"\n);", "returns": "pex_cell_port_file_handle", "arguments": {"file": "Required. Specifies the cell port file name."}, "summary": "The pex_cell_port_file()  function defines a cell port file.", "function_name": "pex_cell_port_file()"}
{"description": "The pex_color_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction color layer parameters. You must call this\nfunction for the color layers you want to map to a StarRC COLOR process layer. The layer\nmapping is written to the color_layers section of the StarRC MAPPING_FILE. Mapping\ninformation is also optionally written to the StarRC OA_LAYER_MAPPING_FILE.", "syntax": "pex_color_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = layer,\nprocess_layer  = \"string\",\nlpp_layer     = {lpp_polygon_layer   = \"string\",\nlpp_polygon_purpose = \"string\",\nlpp_port_layer      = \"string\",\nlpp_port_purpose    = \"string\",\nlpp_subnode_layer   = \"string\",\nlpp_subnode_purpose = \"string\"},           //optional\ntagname       = \"string\",                                   //optional\nappend_string = \"string\"                                    //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.", "process_layer": "Required. Specifies the COLOR layer from the StarRC TCAD_GRD_FILE.\npex_color_layer_map()", "lpp_layer": "Optional. Stores OpenAccess (OA) or Cadence\u00ae CDBA layer purpose pairs\n(LPPs) to generate the StarRC OA_LAYER_MAPPING_FILE.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u2022 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nRestrictions for the tag name are:\n\u2022 Square brackets ([]) are not allowed.\n\u2022 Each specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_color_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction color layer parameters.", "function_name": "pex_color_layer_map()"}
{"description": "The pex_conducting_layer_map()  function stores, in the PEX layer matrix, mapping\nbetween PXL layer objects and parasitic extraction conducting layer parameters\nparasitic extractionconducting layer parameters\n. You must\ncall this function for every PXL layer variable you want to map to a StarRC CONDUCTOR\nprocess layer. The layer mapping is written to the conducting_layers section of the\nStarRC MAPPING_FILE. Mapping information is also optionally written to the StarRC\nOA_LAYER_MAPPING_FILE.", "syntax": "pex_conducting_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = layer,\nprocess_layer  = \"string\",\nlpp_layer     = {lpp_polygon_layer   = \"string\",\nlpp_polygon_purpose = \"string\",\nlpp_port_layer      = \"string\",\nlpp_port_purpose    = \"string\",\nlpp_subnode_layer   = \"string\",\nlpp_subnode_purpose = \"string\"},  //optional\ntagname       = \"string\",\ndevice_layer  = true | false,                      //optional\nmodel_name    = \"string\",                          //optional\nrpsq          = double,                            //optional\nprecedence    = integer,                           //optional\ntable_name    = \"string\",                          //optional\nappend_string = \"string\"                           //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.\npex_conducting_layer_map()", "process_layer": "Required. Specifies the CONDUCTOR layer from the StarRC\nTCAD_GRD_FILE.", "lpp_layer": "Optional. Stores OpenAccess (OA) or Cadence CDBA layer purpose pairs\n(LPPs) to generate the StarRC OA_LAYER_MAPPING_FILE.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u2022 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nRestrictions for the tag name are:\n\u2022 Square brackets ([]) are not allowed.\n\u2022 Each specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "device_layer": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation. The default is false.", "model_name": "Optional. Corresponds to the StarRC MAPPING_FILE option MODEL. See the\nStarRC User Guide and Command Reference  manual for more information.", "rpsq": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.", "precedence": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.\npex_conducting_layer_map()", "table_name": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_conducting_layer_map()  function stores, in the PEX layer matrix, mapping\nbetween PXL layer objects and parasitic extraction conducting layer parameters\nparasitic extractionconducting layer parameters\n.", "function_name": "pex_conducting_layer_map()"}
{"description": "The pex_connected_layer_map()  function writes connected layers to the output parasitic\nextraction layout database for the StarRC tool and to the corresponding section in the\nStarRC MAPPING_FILE. You can control the mapping section in which the layer is written\nby specifying the mapping layer section, including ideal layers.", "syntax": "pex_connected_layer_map(\nmatrix     = pex_layer_matrix,\nlayer1     = layer,\nlayer_type  = layertype,\ntagname  = \"string\",\nappend_string = \"string\"        //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Lists the polygon, edge, and text layers that are written to the output\nparasitic extraction layout database for the StarRC tool.", "layer_type": "Required. Specifies the mapping file section which the layer is written in\nthe StarRC MAPPING_FILE. The only available mapping file section is\nIDEAL_LAYERS.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\npex_connected_layer_map()\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\nRestrictions for the tag name are:\n\u2022 Square brackets ([]) are not allowed.\n\u2022 Each specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_connected_layer_map()  function writes connected layers to the output parasitic\nextraction layout database for the StarRC tool and to the corresponding section in the\nStarRC MAPPING_FILE.", "function_name": "pex_viewonly_layer_map()"}
{"description": "The pex_generate_database()  function generates the following outputs needed by the\nStarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database. Connected layout polygon and device database in\nGDSII or SPICE format.\n\u2022 Parasitic extraction mapping file. Parasitic extraction process layer mapping file\ncorresponding to the StarRC MAPPING_FILE command option.\n\u2022 Parasitic extraction runset report file. Parasitic extraction runset report file\ncorresponding to the StarRC ICV_RUNSET_REPORT_FILE command option.\n\u2022 Parasitic extraction LPP mapping file. Parasitic extraction LPP mapping file\ncorresponding to the StarRC OA_LAYER_MAPPING_FILE command option.\nNote:\nUse the pex_generate_database()  function with GDSII and SPICE formats.\nUse the\npex_generate_results()  function with Milkyway databases.\nNote:\nThe IC Validator parasitic extraction layout database generated for annotated\nGDS (AGDS) and SPICE flows cannot be used with the XREF:COMPLETE  option\nof the StarRC tool.", "syntax": "pex_generate_database(\npex_matrix             = pex_layer_matrix,\npex_library            = gds_library_handle,\npex_library_layer_map  = pex_layout_library_layer_map_handle,\npex_netlist_file       = spice_netlist_file_handle,\npex_cell_extents_file   = pex_cell_extents_file_handle,\npex_cell_port_file      = pex_cell_port_file_handle,\npex_process_map_file   = pex_process_map_file_handle,\npex_runset_report_file = pex_runset_report_file_handle,\npex_lpp_map_file       = pex_lpp_map_file_handle,           //optional\nprecision              = integer,                           //optional\nresolution             = double,                            //optional\ncompress               = true | false                       //optional\nwrite_floating_net      = true  | false                       //optional\n);", "returns": "void\npex_generate_database()", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_*_layer_map()  functions.", "pex_library": "Required. Specifies the handle for the annotated GDSII layout database. The\nhandle is defined using the\ngds_library()  function.", "pex_library_layer_map": "Required. Specifies the handle for the layer mapping file. The file handle is\ndefined using the\npex_library_layer_map_file()  function.", "pex_netlist_file": "Required. Specifies the handle for the SPICE netlist file. The file handle is\ndefined using the\nspice_netlist_file()  function.", "pex_cell_extents_file": "Required. Specifies the handle for the cell extents file. The file handle is defined\nusing the\npex_cell_extents_file()  function.", "pex_cell_port_file": "Required. Specifies the handle for the cell port file. The file handle is defined\nusing the\npex_cell_port_file()  function.", "pex_process_map_file": "Required. Specifies the handle for the parasitic extraction process mapping file.\nThe file handle is defined using the\npex_process_map_file()  function. This file\ncorresponds to the StarRC MAPPING_FILE option.", "pex_runset_report_file": "Required. Specifies the handle for the parasitic extraction runset report file. The\nfile handle is defined using the\npex_runset_report_file()  function. This file\ncorresponds to the StarRC ICV_RUNSET_REPORT_FILE option.", "pex_lpp_map_file": "Optional. Specifies the handle for the LPP mapping file. The file handle is\ndefined using the\npex_lpp_map_file()  function. This file corresponds to the\nStarRC OA_LAYER_MAPPING_FILE option.", "precision": "Optional. Specifies the maximum number of significant figures reported in\nthe GDSII library or SPICE format for extracted device properties from the\npex_generate_database()\nextract_devices()  function. The value can be from 1 through 15. The default\nis 6.", "resolution": "Optional. Snaps the output data to the specified resolution before it is written to\nthe extraction layout database. The default is the IC Validator engine resolution.", "compress": "Optional. Specifies whether to compress the annotate GDSII file and SPICE\nnetlist file. The default is false.", "write_floating_net": "Optional. Specifies whether to output floating net to pex_agds.sp. The default is\ntrue."}, "summary": "The pex_generate_database()  function generates the following outputs needed by the\nStarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database.", "function_name": "pex_generate_database()"}
{"description": "The pex_generate_lpp_map()  function generates the parasitic extraction LPP\nmapping file. The parasitic extraction LPP mapping file corresponds to the StarRC\nOA_LAYER_MAPPING_FILE command option.\nTypically, when multiple PEX layer matrixes exist, you use the pex_generate_lpp_map()\nfunction to generate an LPP mapping file from a different PEX layer matrix than the one\nused by the\npex_generate_database()  and pex_generate_results()  functions.", "syntax": "pex_generate_lpp_map(\npex_matrix       = pex_layer_matrix,\npex_lpp_map_file = pex_lpp_map_file_handle\n);", "returns": "void", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_*_layer_map()  functions.", "pex_lpp_map_file": "Required. Specifies the handle for the LPP mapping file. The file handle is\ndefined using the\npex_lpp_map_file()  function. This file corresponds to the\nStarRC OA_LAYER_MAPPING_FILE option."}, "summary": "The pex_generate_lpp_map()  function generates the parasitic extraction LPP\nmapping file.", "function_name": "pex_generate_lpp_map()"}
{"description": "The pex_generate_process_map()  function generates the parasitic extraction layer\nmapping file. The parasitic extraction layer mapping file corresponds to the StarRC\nMAPPING_FILE command option.\nA common scenario for using the pex_generate_process_map()  function is when\nmultiple PEX layer matrixes are used to store data for multiple parasitic extraction\nprocess corners. In this scenario, you can use the\npex_generate_database()  or\npex_generate_results()  function to generate all parasitic extraction files for the\nnominal process corner, and use the pex_generate_process_map()  function to generate\nadditional layer mapping files for other process corners.", "syntax": "pex_generate_process_map(\npex_matrix           = pex_layer_matrix,\npex_process_map_file = pex_process_map_file_handle\n);", "returns": "void", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_*_layer_map()  functions.", "pex_process_map_file": "Required. Specifies the handle for the process mapping file. The file handle is\ndefined using the\npex_process_map_file()  function. This file corresponds to\nthe StarRC MAPPING_FILE option."}, "summary": "The pex_generate_process_map()  function generates the parasitic extraction layer\nmapping file.", "function_name": "pex_generate_process_map()"}
{"description": "The pex_generate_results()  function generates the following outputs needed by the\nStarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database. Connected layout polygon and device database in\nMilkyway format.\n\u2022 Parasitic extraction mapping file. Parasitic extraction process layer mapping file\ncorresponding to the StarRC MAPPING_FILE command option.\n\u2022 Parasitic extraction runset report file. Parasitic extraction runset report file\ncorresponding to the StarRC ICV_RUNSET_REPORT_FILE command option.\n\u2022 Parasitic extraction LPP mapping file. Parasitic extraction LPP mapping file\ncorresponding to the StarRC OA_LAYER_MAPPING_FILE command option.\nNote:\nUse the pex_generate_results()  function with Milkyway databases. Use the\npex_generate_database()  function with GDSII and SPICE formats.\nStarting with IC Validator version X-2025.06 on the ARM platform, the\nXTRVIEW output format (Milkyway databases) for the PEX flow is disabled. The\noutput automatically switches to the AGDS format (GDSII + SPICE) because\nthe Milkyway library is not supported on ARM.", "syntax": "pex_generate_results(\npex_matrix             = pex_layer_matrix,\nlayout_database        = milkyway_library_handle,\npex_process_map_file   = pex_process_map_file_handle,\npex_runset_report_file = pex_runset_report_file_handle,\npex_lpp_map_file       = pex_lpp_map_file_handle,           //optional\nprecision              = integer,                           //optional\nresolution             = double                             //optional\n);", "returns": "void\npex_generate_results()", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_*_layer_map()  functions.", "layout_database": "Required. Specifies the library handle for the parasitic extraction layout\ndatabase (Milkyway). The handle is defined using the\nmilkyway_library()\nfunction.", "pex_process_map_file": "Required. Specifies the handle for the parasitic extraction process mapping file.\nThe file handle is defined using the\npex_process_map_file()  function. This file\ncorresponds to the StarRC MAPPING_FILE option.", "pex_runset_report_file": "Required. Specifies the handle for the parasitic extraction runset report file. The\nfile handle is defined using the\npex_runset_report_file()  function. This file\ncorresponds to the StarRC ICV_RUNSET_REPORT_FILE option.", "pex_lpp_map_file": "Optional. Specifies the handle for the LPP mapping file. The file handle is\ndefined using the\npex_lpp_map_file()  function. This file corresponds to the\nStarRC OA_LAYER_MAPPING_FILE option.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\nMilkyway library for extracted device properties from the\nextract_devices()\nfunction. The value can be from 1 through 15. The default is 6.", "resolution": "Optional. Snaps the output data to the specified resolution before it is written to\nthe extraction layout database. The default is the IC Validator engine resolution."}, "summary": "The pex_generate_results()  function generates the following outputs needed by the\nStarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database.", "function_name": "pex_generate_results()"}
{"description": "The pex_generate_simple_database()  function generates the following outputs needed\nby the StarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database. Connected layout polygon and device database in\nGDSII or SPICE format.\n\u2022 Parasitic extraction runset report file. Parasitic extraction runset report file\ncorresponding to the StarRC ICV_RUNSET_REPORT_FILE command option.\nNote:\nUse the pex_generate_simple_database()  function with GDSII and SPICE\nformats. Use the\npex_generate_simple_results()  function with Milkyway\ndatabases. An empty layer is not written to the generated GDSII database.\nNote:\nThe generated tag name might be unexpected or inconsistent with the layer\nname when user-coded functions are involved in the related layer creation. In\nthis case, you should explicitly specify the tag names for the layers.\nNote:\nThe IC Validator parasitic extraction layout database generated for annotated\nGDS (AGDS) and SPICE flows cannot be used with the XREF:COMPLETE  option\nof the StarRC tool.", "syntax": "pex_generate_simple_database(\npex_matrix             = pex_layer_matrix,\npex_library            = gds_library_handle,\npex_library_layer_map  = pex_layout_library_layer_map_handle,\npex_netlist_file       = spice_netlist_file_handle,\npex_runset_report_file = pex_runset_report_file_handle,\npex_cell_extents_file   = pex_cell_extents_file_handle,\npex_cell_port_file      = pex_cell_port_file_handle,         //optional\nprecision              = integer,                           //optional\nresolution             = double,                            //optional\ncompress               = true | false                       //optional\nwrite_floating_net      = true  | false                       //optional\n);", "returns": "void\npex_generate_simple_database()", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_simple_layer_maps()  function.", "pex_library": "Required. Specifies the handle for the annotated GDSII layout database. The\nhandle is defined using the\ngds_library()  function.", "pex_library_layer_map": "Required. Specifies the handle for the layer mapping file. The file handle is\ndefined using the\npex_library_layer_map_file()  function.", "pex_netlist_file": "Required. Specifies the handle for the SPICE netlist file. The file handle is\ndefined using the\nspice_netlist_file()  function.", "pex_runset_report_file": "Required. Specifies the handle for the parasitic extraction runset report file. The\nfile handle is defined using the\npex_runset_report_file()  function. This file\ncorresponds to the StarRC ICV_RUNSET_REPORT_FILE option.", "pex_cell_extents_file": "Required. Specifies the handle for the cell extents file. The file handle is defined\nusing the\npex_cell_extents_file()  function.", "pex_cell_port_file": "Optional. Specifies the handle for the cell port file. The file handle is defined\nusing the\npex_cell_port_file()  function. If the StarRC marker layers are a\npart of the generated annotated GDS (AGDS), this cell port file not needed and\ncan be omitted.", "precision": "Optional. Specifies the maximum number of significant figures reported in\nthe GDSII library or SPICE format for extracted device properties from the\nextract_devices()  function. The value can be from 1 through 15. The default\nis 6.", "resolution": "Optional. Snaps the output data to the specified resolution before it is written to\nthe extraction layout database. The default is the IC Validator engine resolution.\npex_generate_simple_database()", "compress": "Optional. Specifies whether to compress the annotate GDSII file and SPICE\nnetlist file. The default is false.", "write_floating_net": "Optional. Specifies whether to output floating net to pex_agds.sp. The default is\ntrue."}, "summary": "The pex_generate_simple_database()  function generates the following outputs needed\nby the StarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database.", "function_name": "pex_generate_simple_database()"}
{"description": "The pex_generate_simple_results()  function generates the following outputs needed\nby the StarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database. Connected layout polygon and device database in\nMilkyway format.\n\u2022 Parasitic extraction runset report file. Parasitic extraction runset report file\ncorresponding to the StarRC ICV_RUNSET_REPORT_FILE command option.\nNote:\nUse the pex_generate_simple_results()  function with Milkyway databases.\nUse the\npex_generate_simple_database()  function with GDSII and SPICE\nformats. An empty layer is not written to the generated Milkyway database.\nNote:\nThe generated tag name might be unexpected or inconsistent with the layer\nname when user-coded functions are involved in the related layer creation. In\nthis case, you should explicitly specify the tag names for the layers.", "syntax": "pex_generate_simple_results(\npex_matrix             = pex_layer_matrix,\nlayout_database        = milkyway_library_handle,\npex_runset_report_file = pex_runset_report_file_handle,\nprecision              = integer,                           //optional\nresolution             = double                             //optional\n);", "returns": "void", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping\nsettings are stored. The matrix is defined by the matrix  argument of the\npex_simple_layer_maps()  function.", "layout_database": "Required. Specifies the library handle for the parasitic extraction layout\ndatabase (Milkyway). The handle is defined using the\nmilkyway_library()\nfunction.\npex_generate_simple_results()", "pex_runset_report_file": "Required. Specifies the handle for the parasitic extraction runset report file. The\nfile handle is defined using the\npex_runset_report_file()  function. This file\ncorresponds to the StarRC ICV_RUNSET_REPORT_FILE option.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\nMilkyway library for extracted device properties from the\nextract_devices()\nfunction. The value can be from 1 through 15. The default is 6.", "resolution": "Optional. Snaps the output data to the specified resolution before it is written to\nthe extraction layout database. The default is the IC Validator engine resolution."}, "summary": "The pex_generate_simple_results()  function generates the following outputs needed\nby the StarRC tool to perform parasitic extraction:\n\u2022 Parasitic extraction layout database.", "function_name": "pex_generate_simple_results()"}
{"description": "The pex_ignore_cap_layer_map()  function creates entries in the\nIGNORE_CAP_LAYERS section of the parasitic extraction process mapping file\nbased on PXL layer objects. This file is created by the\npex_generate_results()  or\npex_generate_process_map()  function.\nA PXL layer should not be specified in the pex_ignore_cap_layer_map()  function unless\nthat layer has previously been mapped by a call to the pex_conducting_layer_map(),\npex_via_layer_map(), pex_unconnected_layer_map(layer_type =\nCONDUCTING_LAYER_TYPE  or VIA_LAYER_TYPE)  functions. Layers mapped by calls to the\nfollowing functions cannot be listed in the pex_ignore_cap_layer_map()  function:\n\u2022 pex_marker_layer_map()\n\u2022 pex_remove_layer_map()\n\u2022 pex_viewonly_layer_map()", "syntax": "pex_ignore_cap_layer_map(\nmatrix                = pex_layer_matrix,\nignore_cap_layer_list  = {polygon_layer, ...},\nignore_to_substrate    = true | false,          //optional\nl                     = double,                //optional\nappend_string         = \"string\"               //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "ignore_cap_layer_list": "Required. Specifies the polygon, edge, or text layers written to the output\nparasitic extraction layout database for the StarRC tool.\npex_ignore_cap_layer_map()", "ignore_to_substrate": "Optional. Adds the keyword SUBSTRATE to the list of layers written to the\nIGNORE_CAP_LAYERS section of the parasitic extraction process mapping file.\nThe default is false.\n\u2022 true. Writes the keyword SUBSTRATE at the end of the list of tag names\ncorresponding to layers specified in the ignore_cap_layer_list  argument.\n\u2022 false. Writes only the tag names corresponding to layers specified in the\nignore_cap_layer_list  argument.", "l": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_ignore_cap_layer_map()  function creates entries in the\nIGNORE_CAP_LAYERS section of the parasitic extraction process mapping file\nbased on PXL layer objects.", "function_name": "pex_ignore_cap_layer_map()"}
{"description": "The pex_library_layer_map_file()  function defines a layout library map file.\nThe file handle generated by this function is used as an input argument to the\npex_generate_database()  function.", "syntax": "pex_library_layer_map_file(\nfile  = \"string\"\n);", "returns": "pex_layout_library_layer_map_handle\npex_layout_library_map_file_handle", "arguments": {"file": "Required. Specifies the layout library map file name."}, "summary": "The pex_library_layer_map_file()  function defines a layout library map file.", "function_name": "pex_library_layer_map_file()"}
{"description": "The pex_lpp_map_file()  function generates a file handle for the output of the\nparasitic extraction StarRC OA_LAYER_MAPPING_FILE. The file handle generated\nby this function is used as an input argument to the\npex_generate_database(),\npex_generate_lpp_map(), and pex_generate_results()  functions.", "syntax": "pex_lpp_map_file(\nfile  = \"string\"\n);", "returns": "pex_lpp_map_file_handle\npex_lpp_map_file_handle", "arguments": {"file": "Required. Specifies the output file name for the StarRC\nOA_LAYER_MAPPING_FILE."}, "summary": "The pex_lpp_map_file()  function generates a file handle for the output of the\nparasitic extraction StarRC OA_LAYER_MAPPING_FILE.", "function_name": "pex_lpp_map_file()"}
{"description": "The pex_marker_layer_map()  function stores, in the PEX layer matrix, mapping\nbetween PXL layer objects and parasitic extraction marker layers parameters. You must\ncall this function for every layer you want to output to the marker_layers section of the\nStarRC MAPPING_FILE. Mapping information is also optionally written to the StarRC\nOA_LAYER_MAPPING_FILE.", "syntax": "pex_marker_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = layer,\nlpp_layer     = {lpp_polygon_layer   = \"string\",\nlpp_polygon_purpose = \"string\",\nlpp_port_layer      = \"string\",\nlpp_port_purpose    = \"string\",\nlpp_subnode_layer   = \"string\",\nlpp_subnode_purpose = \"string\"},  //optional\ntagname       = \"string\",\nappend_string = \"string\"                           //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.", "lpp_layer": "Optional. Stores OpenAccess (OA) or Cadence CDBA layer purpose pairs\n(LPPs) to generate the StarRC OA_LAYER_MAPPING_FILE.\npex_marker_layer_map()", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file, StarRC MAPPING_FILE\n\u2022 Parasitic extraction LPP mapping file, StarRC\nOA_LAYER_MAPPING_FILEOutput parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nEach specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_marker_layer_map()  function stores, in the PEX layer matrix, mapping\nbetween PXL layer objects and parasitic extraction marker layers parameters.", "function_name": "pex_marker_layer_map()"}
{"description": "The pex_perc_apply_terminal_substitution()  function extracts the terminal\nsubstitution devices that are defined in the terminal substitution matrix. This function\nshould only be called one time and before the\npex_perc_merge_substitute_terminal()\nfunction.", "syntax": "pex_perc_apply_terminal_substitution(\nmatrix = in_out pex_perc_substitute_terminal_matrix\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the terminal substitution matrix in which terminal substitution\ndetails are stored."}, "summary": "The pex_perc_apply_terminal_substitution()  function extracts the terminal\nsubstitution devices that are defined in the terminal substitution matrix.", "function_name": "pex_perc_apply_terminal_substitution()"}
{"description": "The pex_perc_merge_substitute_terminal()  function updates the terminal substitution\ndevices information in the PEX layer matrix. This function should only be called one time\nand before the\npex_generate_database()  function.", "syntax": "pex_perc_merge_substitute_terminal(\npex_layer_matrix            = pex_layer_matrix,\nsubstitute_terminal_matrix  = pex_perc_substitute_terminal_matrix\n);", "returns": "void", "arguments": {"pex_layer_matrix": "Required. Specifies the PEX layer matrix where PEX layer mapping settings are\nstored.", "substitute_terminal_matrix": "Required. Specifies the terminal substitution matrix in which terminal substitution\ndetails are stored."}, "summary": "The pex_perc_merge_substitute_terminal()  function updates the terminal substitution\ndevices information in the PEX layer matrix.", "function_name": "pex_perc_merge_substitute_terminal()"}
{"description": "The pex_perc_point_to_point_database()  function stores, in the PEX layer\nmatrix, PERC-related information from the current paths that were defined using\nthe ndb_add_current_path()  function and saved in a previous call to the\nperc_analyze_netlist()  function to a path database, and also from arguments\nspecified by the runset writer directory. This information is used during PEX generation\nto trim the resulting data so that it represents only what is needed for the point-to-point\nresistance or current density flows.", "syntax": "pex_perc_point_to_point_database(\nmatrix          = pex_layer_matrix,\ncurrent_paths   = {perc_results_database, ...},\nupper_layers    = {layer, ...},                 //optional\nignored_devices = {{device_type  = NMOS | PMOS | NPN | PNP |\nPN | NP | RESISTOR |\nCAPACITOR | INDUCTOR | GENERIC,}\ndevice_names = {\"string\", ...},\n...},                         //optional\nremoved_layers  = {layer, ...},                 //optional\npreserve_cells  = {\"string\", ...},               //optional\nbase_metal_interface_layer  = layer               //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix. The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "current_paths": "Required. Specifies a list of PERC results databases returned by a previous call\nto the\nperc_analyze_netlist()  function.\npex_perc_point_to_point_database()", "upper_layers": "Optional. Identifies cells with ESD devices as holding cells. All of the descendant\ncells of the level-1 ancestor cell of each holding cell is identified as an ESD\ncell. Top cells are also considered ESD cells. All other cells are non-ESD cells.\nLower layers with thin metal and via shapes of non-ESD cells are removed for\nperformance, while upper layers with thick metal and via shapes are kept.", "ignored_devices": "Optional. Devices specified in the ndb_add_current_path()  function control\nwhich data can be trimmed during PEX generation. The ignored_devices\nargument specifies devices that were included in ndb_add_current_path()\nfunction, but which should not be used to control PEX data trimming.\n\u2022 device_type. Specifies the device type.\n\u2022 device_names. Specifies the layout devices. Each device must match a\ndevice specified in a device_name  argument of a device configuration\nfunction.", "removed_layers": "Optional. The specified layers are not included in the output layout during PEX\ngeneration, regardless of whether they are associated with nets included in the\nndb_add_current_path()  functions.", "preserve_cells": "Optional. Specifies that for certain non-ESD cells, no layers can be removed.", "base_metal_interface_layer": "Optional. Specifies the interface between base or device layer and metal layer."}, "summary": "The pex_perc_point_to_point_database()  function stores, in the PEX layer\nmatrix, PERC-related information from the current paths that were defined using\nthe ndb_add_current_path()  function and saved in a previous call to the\nperc_analyze_netlist()  function to a path database, and also from arguments\nspecified by the runset writer directory.", "function_name": "pex_perc_point_to_point_database()"}
{"description": "The pex_perc_substitute_terminal()  function indicates terminal substitution of\nspecific devices in the PEX flow. When terminal substitution is applied to a device, all of\nthe related information of that device in the PEX output is modified. The devices in the LVS\nflow are not affected.", "syntax": "pex_perc_substitute_terminal(\nmatrix     = pex_perc_substitute_terminal_matrix,\ndevice_type    =  NMOS | PMOS | NPN | PNP | NP | PN |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names   = {\"string\", ...},\noriginal_layer =  polygon_layer\nnew_layers     = {{layer1 = polygon_layer,\nrange = double                //optional\n);\nNote:\nThe pex_perc_substitute_terminals()  function must be called before the\npex_perc_apply_terminal_substitution()  function.", "returns": "void", "arguments": {"matrix": "Required. Specifies the terminal substitution matrix in which terminal substitution\ndetails are stored.", "device_type": "Required. Specifies the device type.", "device_names": "Required. Specifies a list of the device models in which the terminal substitution\nis applied. No wildcard use is permitted.", "original_layer": "Required. Specifies the terminal layer that is substituted.", "new_layers": "Required. Specifies a list of pair of polygon layers and range for terminal\nsubstitution. There should be at most one element in the list.\npex_perc_substitute_terminal()\n\u2022 layer1. Required. Specifies the connect layer to substitute the\noriginal_layer.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection."}, "summary": "The pex_perc_substitute_terminal()  function indicates terminal substitution of\nspecific devices in the PEX flow.", "function_name": "pex_perc_substitute_terminal()"}
{"description": "The pex_process_map_file()  function generates a file handle for the output\nof the StarRC parasitic extraction MAPPING_FILE. The file handle generated by\nthis function is used as an input argument to the\npex_generate_database(),\npex_generate_process_map(), and pex_generate_results()  functions.", "syntax": "pex_process_map_file(\nfile  = \"string\"\n);", "returns": "pex_process_map_file_handle\npex_process_map_file_handle", "arguments": {"file": "Required. Specifies the output file name for StarRC MAPPING_FILE."}, "summary": "The pex_process_map_file()  function generates a file handle for the output\nof the StarRC parasitic extraction MAPPING_FILE.", "function_name": "pex_process_map_file()"}
{"description": "The pex_qtf_layers()  function specifies which layers from Quickcap Technology File\n(QTF) are used during StarRC\u2013QTF extraction flow. For example, if TCAD_GRD file has\naccurately modeled layers M1 and above, then only layers below M1 need to be specified\nin the qtf_layers  argument.\nThe TCAD_GRD file contains conductor sheet resistances and models for 3-D parasitic\ncapacitance calculation. For information about creating the TCAD_GRD file, see the\nStarRC User Guide and Command Reference.", "syntax": "pex_qtf_layers(\nmatrix     = pex_layer_matrix,\nqtf_layers = {\"string\", ...}\n);", "returns": "void\npex_process_map_file_handle", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction\ndetails are stored for use by the\npex_generate_lpp_map()  and\npex_generate_process_map()  parasitic extraction functions. The matrix must\nbe previously defined by the init_pex_layer_matrix()  function.", "qtf_layers": "Required. Specifies the CONDUCTOR layers from the QTF file."}, "summary": "The pex_qtf_layers()  function specifies which layers from Quickcap Technology File\n(QTF) are used during StarRC\u2013QTF extraction flow.", "function_name": "pex_qtf_layers()"}
{"description": "The pex_qtf_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction QTF layer parameters. You must call this\nfunction for every PXL layer variable you want to map to a StarRC CONDUCTOR process\nlayer from the QTF. The layer mapping is written to the conducting_layers section of the\nStarRC MAPPING_FILE. Mapping information is also optionally written to the StarRC\nOA_LAYER_MAPPING_FILE.\nThe QTF layer should be defined in the qft_layers  argument of the\npex_qtf_layers()\nfunction; otherwise, any layer mapped to the QTF layer is ignored. If a layer is defined\nin both the\npex_conducting_layer_map()  and pex_qtf_layer_map()  functions, the\nStarRC tool considers the QTF layer to have higher precedence. For information about\ncreating a mapping file, see the StarRC User Guide and Command Reference.\nNote:\nUse this function for device region capacitance extraction of finFET devices.", "syntax": "pex_qtf_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = layer,\nqtf_layer     = \"string\",\ntagname       = \"string\",\nappend_string = \"string\"             //optional\n);", "returns": "void\npex_process_map_file_handle", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction\ndetails are stored for use by the\npex_generate_lpp_map()  and\npex_generate_process_map()  parasitic extraction functions. The matrix must\nbe previously defined by the init_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.\npex_qtf_layer_map()", "qtf_layer": "Required. Specifies the CONDUCTOR layer from the QTF.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity.\nEach specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd comments to the mapping file entries."}, "summary": "The pex_qtf_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction QTF layer parameters.", "function_name": "pex_qtf_layer_map()"}
{"description": "The pex_remove_layer_map()  function stores in the PEX layer matrix a PXL layer object\nas a parasitic extraction remove layer. You must call this function for every layer you want\nto output to the remove_layer section of the StarRC parasitic extraction MAPPING_FILE.", "syntax": "pex_remove_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = layer,\ntagname       = \"string\",\nappend_string = \"string\"             //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u2022 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\npex_remove_layer_map()\nEach specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_remove_layer_map()  function stores in the PEX layer matrix a PXL layer object\nas a parasitic extraction remove layer.", "function_name": "pex_remove_layer_map()"}
{"description": "The pex_runset_report_file()  function generates a handle for the output of the\nparasitic extraction runset report file. The file handle generated by this function is used\nas an input argument to the\npex_generate_database()  and pex_generate_results()\nfunction.", "syntax": "pex_runset_report_file(\nfile  = \"string\"\n);", "returns": "pex_runset_report_file_handle\npex_runset_report_file_handle", "arguments": {"file": "Required. Specifies the output file name for the StarRC\nICV_RUNSET_REPORT_FILE."}, "summary": "The pex_runset_report_file()  function generates a handle for the output of the\nparasitic extraction runset report file.", "function_name": "pex_runset_report_file()"}
{"description": "The pex_simple_layer_maps()  function explicitly specifies the tag name for a layer. You\ncan omit the use of this function and allow the simplified flow to automatically generate the\ntag names for the layers.\nThe generated tag name might be unexpected or inconsistent with the layer name when\nuser-coded functions are involved in the related layer creation. In this case, you should\nexplicitly specify the tag names for the layers.\nThe pex_simple_layer_maps()  function is designed for the simplified flow and should\nnot be used in combination with any other pex_*_layer_map()  functions in the same PEX\nlayer matrix.", "syntax": "pex_simple_layer_maps(\npex_matrix        = pex_layer_matrix,\nlayer_maps        = {layer1        = layer,\ntagname       = \"string\"}\n);", "returns": "void", "arguments": {"pex_matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction\ndetails are stored for use by the\npex_generate_simple_database(), and\npex_generate_simple_results()  parasitic extraction functions. The matrix\nmust be previously defined by the init_pex_layer_matrix()  function.", "layer_maps": "Required. Lists the polygon, edge, and text layers that are written to the output\nparasitic extraction layout database for the StarRC tool.\n\u2022 layer1. Required. Lists the polygon, edge, and text layers that are written to\nthe output parasitic extraction layout database for the StarRC tool.\n\u2022 tagname. Required. Associates a user-defined name with a PXL layer. This\ntag name is used to represent the layer in all files requiring a layer identity,\nincluding the\npex_simple_layer_maps()\n\u25e6 Parasitic extraction runset report file\n\u25e6 Parasitic extraction cell port file\n\u25e6 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u25e6 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nRestrictions for the tag name are:\n\u25e6 Square brackets ([]) are not allowed.\n\u25e6 Each specified tag name must be unique and cannot be reused in other\npex_simple_layer_maps()  function calls."}, "summary": "The pex_simple_layer_maps()  function explicitly specifies the tag name for a layer.", "function_name": "pex_simple_layer_maps()"}
{"description": "The pex_unconnected_layer_map()  function writes unconnected layers to the output\nparasitic extraction layout database for the StarRC tool and to the corresponding section\nin the StarRC MAPPING_FILE. You can control the mapping section in which the\nlayer is written by specifying the layer type, including conductor, via, remove, marker,\nignore, color, or viewonly. Mapping information is also optionally written to the StarRC\nOA_LAYER_MAPPING_FILE.", "syntax": "pex_unconnected_layer_map(\nmatrix        = pex_layer_matrix,\nlayer1        = {layer, ...},\nlayer_type    = layertype,\nprocess_layer  = \"string\",                                   //optional\nlpp_layer     = {lpp_polygon_layer   = \"string\",\nlpp_polygon_purpose = \"string\",\nlpp_port_layer      = \"string\",\nlpp_port_purpose    = \"string\",\nlpp_subnode_layer   = \"string\",\nlpp_subnode_purpose = \"string\"},           //optional\ntagname                   = \"string\",                       //optional\nqtf_layer                 = \"string\",\nappend_string             = \"string\",                       //optional\nmapping_file_section_name = \"string\"                        //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Lists the polygon, edge, and text layers that are written to the output\nparasitic extraction layout database for the StarRC tool.\npex_unconnected_layer_map()", "layer_type": "Required. Specifies the layer-type section in which the layer is written in the\nStarRC MAPPING_FILE. The layers must all be unconnected unless the\nlayer_type  is IGNORE_CAP_LAYER_TYPE  or USER_DEFINED_LAYER_TYPE. If\nthe layer_type  is IGNORE_CAP_LAYER_TYPE, some or all of the layers must be\nunconnected.\nNote:\nIf all of the layers are connected, use the\npex_ignore_cap_layer_map()  function instead of the\npex_unconnected_layer_map()  function.\nIf layer_type  is USER_DEFINED_LAYER_TYPE, one or more layers are specified\nin layer1, and the process_layer, lpp_layer, and qtf_layer  arguments are\nignored. All of the other layers in layer1, except the first layer, are declared in\nany of the following mapping functions:\npex_conducting_layer_map()\npex_via_layer_map()\npex_marker_layer_map()\npex_remove_layer_map()\npex_viewonly_layer_map()\npex_color_layer_map()\npex_unconnected_layer_map()\nIn this case, layer_type  is merely applied to the first layer in layer1, and it\ncauses the first layer to be written to the StarRC tool. You must declare the\nmappings of the other layers in layer1.\nTable 65  shows the layer types that can be written into the StarRC\nMAPPING_FILE.\nTable 65 StarRC MAPPING_FILE Layer Types\nCOLOR_LAYER_TYPE CONDUCTING_LAYER_TYPE IGNORE_CAP_LAYER_TYPE\nMARKER_LAYER_TYPE QTF_LAYER_TYPE REMOVE_LAYER_TYPE\nVIA_LAYER_TYPE VIEWONLY_LAYER_TYPE USER_DEFINED_LAYER_TYPE", "process_layer": "Required. Specifies the corresponding layer from the StarRC TCAD_GRD_FILE.\nThis argument must be defined if the layer_type  argument is\nCONDUCTING_LAYER_TYPE, VIA_LAYER_TYPE, or COLOR_LAYER_TYPE.\npex_unconnected_layer_map()", "lpp_layer": "Optional. Stores OpenAccess (OA) or Cadence\u00ae CDBA layer purpose pairs\n(LPPs) to generate the StarRC OA_LAYER_MAPPING_FILE.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u2022 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nRestrictions for the tag name are:\n\u2022 Square brackets ([]) are not allowed.\n\u2022 Each specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "qtf_layer": "Required. Specifies the CONDUCTOR layer from the QTF. This argument is\nrequired if the layer_type  argument is QTF_LAYER_TYPE.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command.", "mapping_file_section_name": "Optional. Specifies a mapping file section name and the layers to be\nwritten in an entry. This argument is referenced only when layer_type  is\nUSER_DEFINED_LAYER_TYPE.\nIn this case, layer_type  must not be empty. The following layer types are not\nallowed:", "conducting_layers": "", "via_layers": "", "marker_layers": "", "remove_layers": "", "viewonly_layers": "", "color_layers": "", "ignore_cap_layers": "pex_unconnected_layer_map()", "qtf_layers": "", "map_qtf_layers": ""}, "summary": "The pex_unconnected_layer_map()  function writes unconnected layers to the output\nparasitic extraction layout database for the StarRC tool and to the corresponding section\nin the StarRC MAPPING_FILE.", "function_name": "pex_unconnected_layer_map()"}
{"description": "The pex_via_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction via layer parameters.\nparasitic extractionvia layer parameter mapping\nYou must call this function\nfor every layer you want to map to a StarRC layer via process layer. The layer mapping\nis written to the via_layers section of the StarRC parasitic extraction MAPPING_FILE.\nMapping information is also optionally written to the StarRC OA_LAYER_MAPPING_FILE.", "syntax": "pex_via_layer_map(\nmatrix                = pex_layer_matrix,\nlayer1                = layer,\nprocess_layer          = \"string\",\nlpp_layer             = {lpp_polygon_layer   = \"string\",\nlpp_polygon_purpose = \"string\",\nlpp_port_layer      = \"string\",\nlpp_port_purpose    = \"string\",\nlpp_subnode_layer   = \"string\",\nlpp_subnode_purpose = \"string\"},   //optional\ntagname               = \"string\",\ndevice_layer          = true | false,                       //optional\nmodel_name            = \"string\",                           //optional\nvia_resistance        = {rpv = double, area = double},      //optional\nmax_via_array_length  = double,                             //optional\nmax_via_array_spacing = double,                             //optional\nappend_string         = \"string\"                            //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the PEX layer matrix in which parasitic extraction details are\nstored for use by the\npex_generate_database(), pex_generate_lpp_map(),\npex_generate_process_map(), and pex_generate_results()  parasitic\nextraction functions. (The pex_layer_matrix  argument in these functions\nselects the PEX layer matrix.) The matrix must be previously defined by the\ninit_pex_layer_matrix()  function.", "layer1": "Required. Specifies the polygon, edge, or text layer that is written to the output\nparasitic extraction layout database for the StarRC tool.\npex_via_layer_map()", "process_layer": "Required. Specifies the via layer from the StarRC TCAD_GRD_FILE.", "lpp_layer": "Optional. Stores OpenAccess (OA) or Cadence CDBA layer purpose pairs\n(LPPs) to generate the StarRC OA_LAYER_MAPPING_FILE.", "tagname": "Required. Associates a user-defined name with a PXL layer. This tag name is\nused to represent the layer in all files requiring a layer identity, including the\n\u2022 Parasitic extraction runset report file\n\u2022 Parasitic extraction cell port file\n\u2022 Parasitic extraction process mapping file (StarRC MAPPING_FILE)\n\u2022 Parasitic extraction LPP mapping file (StarRC\nOA_LAYER_MAPPING_FILE)Output parasitic extraction layout database\n(Milkyway) read by the StarRC tool\nEach specified tag name must be unique and cannot be reused in other\npex_*_layer_map()  function calls.", "device_layer": "Optional. Corresponds to the MAPPING_FILE option of the same name. See the\nStarRC User Guide and Command Reference  manual for more information. The\ndefault is false.", "model_name": "Optional. Corresponds to the StarRC MAPPING_FILE option MODEL. See the\nStarRC User Guide and Command Reference  manual for more information.", "via_resistance": "Optional. Stores resistance per via (rpv) and area as an ordered pair.\nCorresponds to the StarRC MAPPING_FILE options rpv and area. See the\nStarRC User Guide and Command Reference  manual for more information.", "max_via_array_length": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.\npex_via_layer_map()", "max_via_array_spacing": "Optional. Corresponds to the StarRC MAPPING_FILE option of the same\nname. See the StarRC User Guide and Command Reference  manual for more\ninformation.", "append_string": "Optional. Specifies a string to be appended to the end of the corresponding\nmapping entry within the StarRC MAPPING_FILE. That is, the string is used to\nadd information to the end of a StarRC mapping file command."}, "summary": "The pex_via_layer_map()  function stores, in the PEX layer matrix, mapping between\nPXL layer objects and parasitic extraction via layer parameters.", "function_name": "pex_via_layer_map()"}
{"description": "The pitch_properties()  function finds related parameters for a group of signal patterns.", "syntax": "pitch_properties(\nlayer1  = polygon_layer,\nlayer2  = polygon_layer,\nsave_properties  = {width = \"string\",\nspace = \"string\",\npitch = \"string\"}},\n...},\n//optional\nmin_width  = double,                  //optional\nmin_space  = double,                  //optional\ndirection  = HORIZONTAL  | VERTICAL            //optional\n);", "returns": "polygon layer\npitch_properties()", "arguments": {"layer1": "Required. Specifies the group layer that chooses the polygons to calculate\npattern information.", "layer2": "Required. Specifies the polygon layer that might form patterns.", "save_properties": "Optional. Specifies the property names of related parameters.\n\u2022 width. Specifies the property name that stores the width information of the\npatterns.\n\u2022 space. Specifies the property name that stores the space information of the\npatterns.\n\u2022 pitch. Specifies the property name that stores the pitch information of the\npatterns.", "min_width": "Optional. Filters outs the polygons that are smaller than the minimum width. The\ndefault is 0.0.", "min_space": "Optional. Filters outs the space value that is smaller than the minimum space.\nThe default is 0.0.", "direction": "Optional. Specifies the direction of the polygon. The default is HORIZONTAL.\n\u2022 HORIZONTAL. Specifies that the direction of the pattern is horizontal.\n\u2022 VERTICAL. Specifies that the direction of the pattern is vertical."}, "summary": "The pitch_properties()  function finds related parameters for a group of signal patterns.", "function_name": "pitch_properties()"}
{"description": "The point_touching_edge()  function selects entire layer1  edges that have any point\ntouching with layer2  edges. Selection includes inside and outside edge point touching.\nThe complement of this function is the not_point_touching_edge()  function.\nSee the description section of the inside_point_touching_edge()  function for more\ninformation.", "syntax": "point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\npoint_touching_edge() and not_point_touching_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The point_touching_edge()  function selects entire layer1  edges that have any point\ntouching with layer2  edges.", "function_name": "not_point_touching_edge()"}
{"description": "The point_touching_edge()  function selects entire layer1  edges that have any point\ntouching with layer2  edges. Selection includes inside and outside edge point touching.\nThe complement of this function is the not_point_touching_edge()  function.\nSee the description section of the inside_point_touching_edge()  function for more\ninformation.", "syntax": "point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_point_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\npoint_touching_edge() and not_point_touching_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The point_touching_edge()  function selects entire layer1  edges that have any point\ntouching with layer2  edges.", "function_name": "point_touching_edge()"}
{"description": "The polygon_centers()  function creates a square at the center of the extents of each\npolygon in the input layer.", "syntax": "polygon_centers(\nlayer1          = polygon_layer,\nshape_size      = double,                     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "shape_size": "Optional. Specifies the size of the squares. The value must be positive. It is\nrounded to the nearest even multiple of the internal resolution, with a minimum\nvalue of twice the internal resolution. The internal_resolution  argument of", "the": "resolution_options()  function sets the internal resolution. The default is\nDRC_ERROR_BOX, which has a default of 0.1.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\npolygon_centers()"}, "summary": "The polygon_centers()  function creates a square at the center of the extents of each\npolygon in the input layer.", "function_name": "polygon_centers()"}
{"description": "The polygon_extents()  function creates rectangles from the extents of each layer1\npolygon.", "syntax": "polygon_extents(\nlayer1          = polygon_layer,\nrotate          = NONE | FORTY_FIVE,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ninside_layer     = polygon_layer                //optional\noutput_shape     = RECTANGLE  | SQUARE          //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "rotate": "Optional. Specifies the orientation of the extents rectangle. The default is NONE.\n\u2022 NONE. Specifies that the extents rectangle consists of horizontal and vertical\nedges.\n\u2022 FORTY_FIVE. Specifies that the extents rectangle is the smallest rectangle\nconsisting of 45-degree edges that contains the polygon.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\npolygon_extents()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "inside_layer": "Optional. Creates rectangles that are the total extents of all the layer1  polygons\ninside each inside_layer  polygon.\nNote:\nIf you use this argument, the rotate  argument is set to NONE.\nFor example,\npolygon_extents(\nlayer1 = layerA,\ninside_polygon = layerB\n);\nThe created rectangles are shown in\nFigure 535.\nFigure 535 inside_layer Argument Example", "output_shape": "Optional. Specifies the shape used to represent the polygon extents. The default\nis RECTANGLE.\n\u2022 RECTANGLE. Specifies that the output shape is the extents of the polygon.\n\u2022 SQUARE. Specifies that polygon extents are expanded into a squares as\nneeded by extending the shorter sides equally in both directions. With this\nsetting, inside_layer  must not be specified, and rotate  must be NONE."}, "summary": "The polygon_extents()  function creates rectangles from the extents of each layer1\npolygon.", "function_name": "polygon_extents()"}
{"description": "The polygon_features()  function creates user-defined geometries based on\ncharacteristics of the input polygons. The polygons are defined as a list of xy coordinates\nwith each vertex listed one time. The points are ordered clockwise around the outside of\nthe polygon. Donuts are defined by boundaries that abut themselves.\nThis function calls a remote function for each polygon in the input layer. The remote\nfunction calls various utility functions that operate on the current polygon to create new\npolygons and to write these polygons to the output layer. The polygons created by this\nfunction are merged on output.", "syntax": "polygon_features(\nlayer1           = polygon_layer,\npolygon_function = function,\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nfiles             = {ascii_file_handle, ...},   //optional\nname             = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "polygon_function": "Required. Specifies the remote function. See\nPolygon Features Utility Functions\non page 2980 for more information about the utility functions you can use to\ndefine a remote function.", "processing_mode": "Optional. Specifies how the polygons are processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Polygons are defined only within the context of each individual\ncell.\n\u2022 HIERARCHICAL. Polygons are defined within the context of the lowest cell that\ncontains the complete hierarchical polygon.\npolygon_features()", "files": "Optional. Specifies the files that can be written to using the pf_fnote()\nfunction. The files are defined using the fopen()  function. The order of the files\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The polygon_features()  function creates user-defined geometries based on\ncharacteristics of the input polygons.", "function_name": "polygon_features()"}
{"description": "The polygons()  function creates polygons in the top cell using specified coordinates. The\nfunction can generate multiple polygons. Intersecting polygons are merged in the result.", "syntax": "polygons(\ncoordinates = {{{x = double, y = double}, ...}, ...},\nname        = \"layer_label\"                            //optional\n);", "returns": "polygon layer or error result", "arguments": {"coordinates": "Required. Lists the xy coordinate pairs for each created polygon. These\ncoordinates are scaled by the magnification_factor  argument of the\nlibrary()  function. The coordinates can be either\n\u2022 Two coordinates, which are interpreted as the opposing corners of a\nrectangle.\n\u2022 Three or more coordinates, which define the outer boundary of a closed\npolygon. You do not need to repeat the first coordinate at the end of the list.\nThe coordinates can be ordered in either direction around the polygon.\nNote:\nPolygons, or portions of polygons with no area, are ignored. Areas of\nself-intersection are left empty and a warning is given.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The polygons()  function creates polygons in the top cell using specified coordinates.", "function_name": "polygons()"}
{"description": "The property_annotation_file()  function defines an annotation file name. This file is\nspecified in the output_file  argument of\nwrite_annotation_file().", "syntax": "property_annotation_file(\nfile  = \"string\"         //optional\n);", "returns": "property_annotation_file_handle\nproperty_annotation_file_handle", "arguments": {"file": "Optional. Specifies the annotation file name. The file must be gzipped and have\nthe extension .gz. The default is \"anno.gz\"."}, "summary": "The property_annotation_file()  function defines an annotation file name.", "function_name": "property_annotation_file()"}
{"description": "The property_by_net()  function selects polygons from the primary_layer  and assigns\nuser-defined properties to the output polygons. A remote function provides procedural\naccess to individual geometries on multiple layers that are clustered by a net. A cluster is\nformed by a given primary_layer  polygon and all of the secondary_layers  data that are\non the same net. A library of utility functions is provided to query geometric characteristics\nand properties, and select polygons for output, including associated properties. See\nGeneric Utility Functions  for more information.", "syntax": "property_by_net(\nprimary_layer  = polygon_layer,\nsecondary_layers  = {\"string\" => data_layer, ...},\nconnect_sequence = connect_database,\nremote_function   = function,\nshared_secondary_data = ALL_CLUSTERS  | ONE_CLUSTER, //optional\nfiles             = {ascii_file_handle, ...},        //optional\nname             = \"layer_label\"                    //optional\n);", "returns": "polygon_layer or error result", "arguments": {"primary_layer": "Required. Specifies a polygon layer from which data is selected. The clusters\nare formed based on the connectivity of individual polygons of this layer.", "secondary_layers": "Required. Specifies a hash to data layer. The strings of the hash are used to\naccess the particular layers in the remote function. The data in these layers\nare clustered with a given primary layer object. Polygon and edge layers are\nsupported.", "connect_sequence": "Required. Specifies the connect database. The primary_layer  and all of the\nsecondary_layers  must be present in the specified connect database.", "remote_function": "Required. A required function with no arguments, and no return value. This\nspecifies the user-defined remote execution function that provides procedural\naccess to the data of each cluster. Utility functions are used to query geometric\nproperty_by_net()\ncharacteristics and properties, and select polygons for output, including\nassociated properties. See\nUtility Functions.", "shared_secondary_data": "Optional. Specifies processing of secondary data that is shared between\nclusters. The default is ALL_CLUSTERS.\n\u2022 ALL_CLUSTERS. Specifies that data is seen in all clusters in which it is shared.\n\u2022 ONE_CLUSTER. Specifies that data is seen in only one, arbitrary cluster.", "files": "Optional. Specifies a list of ascii file handles. This specifies the ASCII files that\nthe prp_fnote()  function can write to. The files are defined using the\nfopen()\nfunction. The order of the files determines the index for accessing the files in the\nremote functions; the first file listed has an index of 0 (zero).", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The property_by_net()  function selects polygons from the primary_layer  and assigns\nuser-defined properties to the output polygons.", "function_name": "property_by_net()"}
{"description": "The property_by_net_edge()  function selects edges from the primary_layer\nand assigns user-defined properties to the output edges. A remote function provides\nprocedural access to individual geometries on multiple layers that are clustered by a net.\nA cluster is formed by a given primary_layer  edge and all of the secondary_layers\ndata that are on the same net. A library of utility functions is provided to query geometric\ncharacteristics and properties, and select polygons for output, including associated\nproperties. See\nGeneric Utility Functions  for more information.", "syntax": "property_by_net_edge(\nprimary_layer  = edge_layer,\nsecondary_layers  = {\"string\" => data_layer, ...},\nconnect_sequence = connect_database,\nremote_function   = function,\nshared_secondary_data = ALL_CLUSTERS  | ONE_CLUSTER,  //optional\nfiles             = {ascii_file_handle, ...},         //optional\nname            = \"layer_label\"                      //optional\n);", "returns": "edge_layer or error result", "arguments": {"primary_layer": "Required. Specifies an edge layer from which data is selected. The clusters are\nformed based on the connectivity of individual edges of this layer.", "secondary_layers": "Required. Specifies a hash to data layer. The strings of the hash are used to\naccess the particular layers in the remote function. The data in these layers\nare clustered with a given primary layer object. Polygon and edge layers are\nsupported.", "connect_sequence": "Required. Specifies the connect database. The primary_layer  and all of the\nsecondary_layers  must be present in the specified connect database.", "remote_function": "Required. A required function with no arguments, and no return value. This\nspecifies the user-defined remote execution function that provides procedural\naccess to the data of each cluster. Utility functions are used to query geometric\nproperty_by_net_edge()\ncharacteristics and properties, and select polygons for output, including\nassociated properties. See\nUtility Functions.", "shared_secondary_data": "Optional. Specifies processing of secondary data that is shared between\nclusters. The default is ALL_CLUSTERS.\n\u2022 ALL_CLUSTERS. Specifies that data is seen in all clusters in which it is shared.\n\u2022 ONE_CLUSTER. Specifies that data is seen in only one, arbitrary cluster.", "files": "Optional. Specifies a list of ascii file handles. This specifies the ASCII files that\nthe prp_fnote()  function can write to. The files are defined using the\nfopen()\nfunction. The order of the files determines the index for accessing the files in the\nremote functions; the first file listed has an index of 0 (zero).", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The property_by_net_edge()  function selects edges from the primary_layer\nand assigns user-defined properties to the output edges.", "function_name": "property_by_net_edge()"}
{"description": "The property_global()  function provides access to composite properties on multiple\nlayers of all types in the context of the entire chip. A remote function is used to specify\narithmetic conditions in terms of geometric characteristics and properties to choose if\nthe output is empty or non-empty. This is a cluster-based operation, meaning the remote\nfunction is executed one time per cluster; there is only one cluster in this function, formed\nby all of the input layers.\nThe remote function can also access composite net properties from a connect database in\nthe context of the entire database.\nThe output is a global property layer which contains no geometries, but can contain\na virtual polygon, which can also contain user-defined properties. A global property\nlayer is generally considered empty because of the lack of geometry. However, layers\nproduced by property_global()  can be used as secondary layers for subsequent\nclustering operations like\ndrc_features(). The global properties are clustered with\nevery primary layer geometry in the clustering operation. Property values from the global\nproperty layer are available in every cluster and every cell, regardless of where the\ncluster is being processed. Measurements of the property layer are not applicable. The\ncount()  or exist()  functions are applicable and are based on the execution of the\nprp_save_data()  utility function.", "syntax": "property_global(\nremote_function   = function,\nlayers            = {\"string\" => geometry_layer, ...},  //optional\nconnect_sequence  = connect_database,                   //optional\nfiles             = {ascii_file_handle, ...},           //optional\nname              = \"layer_label\"                       //optional\n);", "returns": "polygon layer", "arguments": {"remote_function": "Required. Specifies processing of the input layers and properties. This function\nis executed one time. A library of utility functions is provided to query geometric\ncharacteristics and properties, and select polygons for output, including\nassociated properties. See\nGeneric Utility Functions  for more information.\nproperty_global()", "layers": "Optional. Specifies the hash of string to geometry_layer. The strings are used\nby the remote function to access characteristics of the given layer. Notice that\nalthough this argument is optional, the function requires a non-empty layer list\nand a valid connect_sequence.", "connect_sequence": "Optional. Specifies the connect database for the net-based utility functions.\nNotice that although this argument is optional, the function requires a non-empty\nlayer list and a valid connect_sequence.", "files": "Optional. Specifies the ASCII files that the\nprp_fnote()  utility function can\nwrite to. The files are defined using the fopen()  function. The order of the files\ndetermines the index for accessing the files in the remote functions; the first file\nlisted has an index of 0 (zero).", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The property_global()  function provides access to composite properties on multiple\nlayers of all types in the context of the entire chip.", "function_name": "property_global()"}
{"description": "The property_layer_convert()  function copies a version of the polygon layer from\nthe original property layer. This polygon layer inherits the layer1  properties that were\noriginally saved using the\nnps_read_property()  utility function.\nFor DRC and device property computations, the property on the output\npolygon layer can be read using the\ndf_get_net_pair_property()  and\ndev_get_polygon_double_property()  utility functions, respectively.", "syntax": "property_layer_convert(\nlayer1 = property_layer\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the property layer."}, "summary": "The property_layer_convert()  function copies a version of the polygon layer from\nthe original property layer.", "function_name": "property_layer_convert()"}
{"description": "The property_merge()  function creates a polygon_layer from a derived unmerged\npolygon layer. The processing of the user-defined properties is specified in a remote\nfunction.", "syntax": "property_merge(\nprimary_layer          = polygon_layer | unmerged_polygon_layer,\nsecondary_layers       = {\"string\" =>\npolygon_layer | unmerged_polygon_layer, ...},\nremote_function        = function,\ncluster_mode           = OVERLAP  | OVERLAP_TOUCH | EXACT,   //optional\nshared_secondary_data  = ALL_CLUSTERS  | ONE_CLUSTER,        //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nfiles                  = {ascii_file_handle, ...},          //optional\nname                   = \"layer_label\"                      //optional\n);", "returns": "polygon layer", "arguments": {"primary_layer": "Required. Specifies the layer that defines the clustering of the remote function.\nIt can be a merged or unmerged polygon layer. In the utility functions in the\nremote_function, the null string (\u201c\u201d), is used to specify the primary layer.\nIf unmerged, a temporary polygon layer is formed by merging the primary layer\nto remove overlap and abutment. This merged layer is used to cluster with all\nthe input layers, including the original primary layer. This implies the primary\nlayer might have more then one polygon in a given cluster. The output polygons\nare selected from the temporary merged layer, along with the requested\nproperties.\nIf merged:\n-The primary layer is used for clustering, and output is selected from the primary\nlayer.\n-At least one unmerged layer is required in secondary_layers.\nproperty_merge()", "secondary_layers": "Required. Specifies the hash of string to polygon layers which can be merged or\nunmerged. The strings are used by the remote function to access characteristics\nof the given secondary layer.", "remote_function": "Required. A required function with no arguments, and no return value. This\nspecifies the user-defined remote execution function that provides procedural\naccess to the data of each cluster. Utility functions are used to query geometric\ncharacteristics and properties, and select polygons for output, including\nassociated properties. See\nGeneric Utility Functions.", "cluster_mode": "Specifies how clusters are formed. The default is OVERLAP.\n\u2022 OVERLAP. Polygons that share active area with the primary shape are\nclustered.\n\u2022 OVERLAP_TOUCH. Polygons that overlap or edge touch the primary shape are\nclustered.\n\u2022 EXACT. Polygons that are an exact duplicate of the primary shape are\nclustered.", "shared_secondary_data": "Optional. Specifies processing of secondary data that is shared between\nclusters. The default is ALL_CLUSTERS.\n\u2022 ALL_CLUSTERS. Specifies that data is seen in all clusters in which it is shared.\n\u2022 ONE_CLUSTER. Specifies that data is seen in only one, arbitrary cluster.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "files": "Specifies the ASCII files that the prp_fnote()  function can write to. The files\nare defined using the fopen()  function. The order of the files determines the\nindex for accessing the files in the remote functions; the first file listed has an\nindex of 0 (zero).\nproperty_merge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The property_merge()  function creates a polygon_layer from a derived unmerged\npolygon layer.", "function_name": "property_merge()"}
{"description": "The property_to_net()  function attaches properties to nets. A remote function is\nexecuted one time for each net in the connect database. Utility routines are provided in the\nremote function to aid in generating the required net property value.\nThis function is typically used in conjunction with the annotate_by_property(),\nexternal*(), and drc_features*()  functions in delta voltage applications.\nNote:\nIf the connect()  or incremental_connect()  function processes the connect\ndatabase generated by property_to_net(), the attached net properties are\nremoved. To add layers to the connect database and retain the net properties,\nuse the stamp()  function.", "syntax": "property_to_net(\nconnect_sequence      = connect_database,\nnet_property_function = function,\nlayer_groups          = {\"string\" => {polygon_layer, ...}, //optional\n...},\nsync_name         = \"string\",                          //optional\nnet_pair_property = {pairs = {{\nconnected_layer = polygon_layer,\nproperty_layer  = polygon_layer,\npriority = integer},\n... },\n},\nproperty_name = \"string\",\nproperty_merge_method =\nMAX  | MIN,\n},                              //optional\nsave_text_source_group  = ASSIGNED  | ALL,                   //optional\nproperty_name_prefixes  = {\"string\", ...},                  //optional\nconnected_to_all        = {\"data_layer\", ...},              //optional\nnot_connected_to_all    = {\"data_layer\", ...},              //optional\nconnected_to_any        = {\"data_layer\", ...},              //optional\nnot_connected_to_any    = {\"data_layer\", ...},              //optional\nsync_nets               = {connected_layer = polygon_layer,\nsync_layer = polygon_layer},     //optional\ndata_layer_groups       = {\"data_layer_groups\", ...}        //optional\n);", "returns": "connect database\nproperty_to_net()", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "net_property_function": "Required. Specifies the remote function containing the conditions that extract\nthe layer-based properties and various net-based geometric characteristics\nneeded to generate the required net property.\nThe remote function is called one time for every net in the input connect\ndatabase. It extracts properties from polygons on layers specified by the\nlayer_groups  argument that are on the net being processed.\nSee\nProperty to Net Utility Functions  for more information about the utility\nfunctions you can use to define this remote function.", "layer_groups": "Optional. Specifies the hash of string to polygon layers. The strings are used by\nthe remote function to access layer-based properties and net-based geometric\ncharacteristics on a given net. The default is an empty hash.", "sync_name": "Optional. Specifies the property name to be used to store the synchronous ID\nproperty value. Note that synchronous net properties are created only for nets\nthat are synchronous with other nets. Nets that are synchronous have the same\nsynchronous ID property value.\nThe synchronous net property is generated automatically; therefore, remote\nblock runset code is not needed. You can use this property name later in the\nannotate_by_property()  function to obtain the synchronous ID property\nvalues stored by property_to_net().", "net_pair_property": "Optional. Specifies how to extract an additional property between two nets. This\nproperty is usually used to override delta voltage in\nvoltage_filter  argument\nof the external1_error()  and external2_error()  functions. The default is\nempty.\n\u2022 pairs. List of items that specifies what layers are connected by another layer\nwhich carries the additional property.\n\u25e6 connected_layer. Specifies a layer that is in the connect database.\n\u25e6 property_layer. Specifies a layer that connects the connected_layer.\nThe polygons in the property_layer  carry property. One\nproperty_layer  can connect one connected_layer  in a pair. The same\nproperty_to_net()\nproperty_layer  can connect to multiple connect_layers  in multiple\npairs.\n\u25e6 priority. Specifies the priority of the pair. A larger value indicates a\nhigher priority. For example, if a pair of nets touches property polygons\nfrom a different pair, the property_to_net()  function chooses the pair\nwith the higher priority.\n\u2022 property_name. Specifies the property name the property_to_net()\nfunction extracts from the property_layer  polygons. If its value is an\nempty string, the property_to_net()  function does not generate a net-pair\nproperty.\n\u2022 property_merge_method. Specifies that when the same pair of nets touches\nmultiple property polygons with equal priority, the property_to_net()\nfunction chooses which property to use. The default is MAX.\n\u25e6 MAX. Specifies the maximum number of net-pair properties.\n\u25e6 MIN. Specifies the minimum number of net-pair properties.\n\u25e6 ALL. Specifies that the connect database records all property values\nbetween each pair of nets. This behavior affects:\n\u25aa external1_error()/external_2_error(voltage_filter\n= override_by_net_pair_property = true,\noverride_net_pair_property_criteria = LESS_THAN_EQUAL)\nWhen override_by_net_pair_property_criteria =\nLESS_THAN_EQUAL, IC Validator first calculates the delta voltage\nbetween two nets, and uses this value to select the largest property\nvalue, which is NOT greater than the original delta voltage. For\nexample:\nvoltage_filter = {>=3.0, HIGH_LOW_MAX, \"high\", \"low\",\ntrue,\noverride_by_net_pair_property_criteria = LESS_THAN_EQUAL\nproperty_to_net()\n\u25aa df_get_net_pair_property(dv_max). When dv_max  is NOT\nNULL_DOUBLE, this function returns the largest property value which is\nNOT greater than dv_max.\nSee DRC Features Utility Functions  for more information about the utility\nfunctions you can use to define this remote function.", "save_text_source_group": "Required. Specifies the save type of the layer group name used by text voltage\nsources. This argument affects the dv_error_voltage_source()  function by\nshowing the text voltage sources in VUE. The default is ASSIGNED.\nproperty_to_net()\n\u2022 ASSIGNED. Saves only the layer group name of the text layer that\nassigns the final voltage of a net (the layer group name is specified by\nptn_save_double_property(..., source_group_name, ...)). With this\nsetting, dv_error_voltage_source()  shows only the text voltage sources\nthat assign the final voltages of nets in VUE.\n\u2022 ALL. Saves the all-layer group name used by the\nptn_get_max_double_property()  and ptn_get_min_double_property()\nfunctions, which are typically used in the remote function to assign the\nvoltage of a net. With this setting, dv_error_voltage_source()  shows all of\nthe text voltage sources in a net even if they are not used to assign the final\nvoltage in VUE.", "property_name_prefixes": "Optional. Processes a net in a net property function only when it has any\nproperties whose prefix is specified by property_name_prefixes.\nFor example, if there are three nets a, b and c, and properties ap1, bp1 and cp1,\nnet a has property ap1, net b has property bp1, and net c has property cp1.\nproperty_name_prefixes = {ap, bp} \u00e8 we only process net a & net b", "connected_to_all": "Optional. Specifies the layers. To be processed in a net property function, all\nof these layers must be on the net. By default, the IC Validator tool does not\nrequire any specific layers.", "not_connected_to_all": "Optional. Specifies the layers. If all of the layers are on the net, the net is not\nprocessed in a net property function. By default, the IC Validator tool does not\nexclude any layers.", "connected_to_any": "Optional. Specifies the layers. To be processed in a net property function, at\nleast one of these layers must be on the net. By default, the IC Validator tool\ndoes not require any specific layers.", "not_connected_to_any": "Optional. Specifies the layers. If any one of the layers is on the net, the net is not\nprocessed in a net property function. By default, the IC Validator tool does not\nexclude any layers.", "sync_nets": "Defines the nets whose signals are synchronized. When calculating their delta\nvoltage, use MAX(|high1-high2|, |low1-low2|)  instead of MAX(|high1-\nproperty_to_net()\nlow2|, |high2-low1|). See voltage_filter( delta_method = SYNC_NET)\nin the external1_error()  and external2_error()  functions.\n\u2022 connected_layer. Specifies a layer in the connect database.\n\u2022 sync_layer. Specifies the layer whose polygon touches the connected layer\npolygons with different nets whose signals are synchronized, that is both nets\nturn to high or low at the same time.\n\u2022", "data_layer_groups": "Optional. Specifies the hash of string to polygon or edge layers. The strings\nare used by the remote function to access the layer-based parameters on a\ngiven net. The default is an empty hash. Notice that IC Validator combines the\nsettings of layer_groups  and data_layer_groups  and sends them to the\nproperty_to_net()  function. Therefore, you cannot create layer groups with\nthe same key in both layer_groups  and data_layer_groups."}, "summary": "The property_to_net()  function attaches properties to nets.", "function_name": "property_to_net()"}
{"description": "The prototype_options()  function defines the criteria for the creation of\nprototype cells, creation\nprototype\ncells during hierarchical preprocessing. (The creation of prototype cells is a hierarchical\noptimization.) If this function is not in the runset, it is automatically invoked with the\ndefaults. This function can be called only one time in a runset.\n\u2022 Cells placed at a rotation that is not a multiple of 90 degrees are replaced with\nprototype cells.\n\u2022 Cells that are placed with a magnification other than 0 are replaced with prototype\ncells.\n\u2022 Relatively large cells that are rotated can be replaced with prototype cells to facilitate\ndata management.\nWhen new prototype cells are generated, the new cell names contain a suffix indicating\nthe rotation and reflection of the original cell that is represented by the new prototype cell.\nCommon angles are abbreviated by the quadrant where they are located. Unusual angles\nhave longer, more descriptive suffixes.\nTable 66  shows common cell-naming conventions.\nTable 66 Common Cell-Naming Conventions\nNew cell name Degree of rotation Reflection\nINV 0 no reflection\nINV_2Q 90 no reflection\nINV_3Q 180 no reflection\nINV_4Q 270 no reflection\nINV_1R 0 reflected\nINV_2R 90 reflected\nINV_3R 180 reflected\nINV_4R 270 reflected\nINV_45_0000D_0R 45 no reflection\nINV_135_7500D_1R 135.75 reflected\nprototype_options()\nIn addition, a new cell named with the suffix _0x is generated to contain all polygon\ncontent of the original cell that is unaffected by directional operations in the runset. This\n_0x cell is instantiated by each generated prototype cell from\nTable 66.\nIn runsets that have extensive use of directional operations, creation of prototype cells\ncan provide improved performance. Examples of\ndirectional operation\ndirectional operations are shrink(),\ngrow(), and move(), and the use of the direction  argument in spacing checks, such\nas external1(). The prototype cells provide a hierarchical location for the results of\ndirectional operations. Otherwise, storing the directional results can cause considerable\nflattening of data.\nNote:\nThe creation of prototype cells can cause a significant increase in the number\nof cells. This increase causes overhead for the entire runset. Because most\napplications have few directional operations, do not use prototype cells unless a\nspecific performance problem with a directional operation is detected.\nIf prototype cells are required, set symmetry  to AUTOMATIC. The prototype cells are\ncreated in accordance with directional operations that appear in the runset.\nNote:\nOther settings of symmetry  are for debugging or advanced applications only\nand should be used with caution.", "syntax": "prototype_options(\nlarge_cells = true  | false,                                 //optional\nsymmetry    = FULL | HORIZONTAL_AXIS | VERTICAL_AXIS |\nDUAL | ROTATIONAL | ASYMMETRIC | AUTOMATIC    //optional\n);", "returns": "void", "arguments": {"large_cells": "Optional. Specifies whether relatively large cells that are rotated can be replaced\nwith prototype cells. This argument affects only large cells, and it is independent\nof the symmetry  argument. The default is true.\n\u2022 true. Prototypes large cells to facilitate data management.\n\u2022 false. Disables optimization.\nprototype_options()", "symmetry": "Optional. Describes the symmetry of the directional inputs in the runset. This\nargument affects all cells regardless of cell size, and it is independent of the\nlarge_cells  argument. The default is FULL.\n\u2022 FULL. Does not create additional prototype cells. Use this option when there\nare no directional operations in the runset, or there is complete symmetry of\ndirectional specifications.\n\u2022 AUTOMATIC. Automatically chooses one of the other symmetry settings.\nWhen not set to FULL,\n\u2022 Cells are prototyped in accordance with the specified axes of symmetry to\nresolve the instance specificity of directional operations.\nNote:\nThe remaining settings of the symmetry  argument are only for\ndebugging or advanced applications. Use these settings with caution.\n\u2022 HORIZONTAL_AXIS. Prototypes cells to facilitate directional inputs that have a\nhorizontal axis of symmetry.\n\u2022 VERTICAL_AXIS. Prototypes cells to facilitate directional inputs that have a\nvertical axis of symmetry.\n\u2022 DUAL. Processes hierarchy to improve performance of directional commands\nfor cell placements with 90 or 270 angle.\n\u2022 ROTATIONAL. Prototypes cells to facilitate directional inputs that have\nrotational symmetry, such as for using with the extend_edge()  function.\n\u2022 ASYMMETRIC. Replaces all cells that are rotated or reflected with prototype\ncells. This results in a hierarchy without any rotation or reflection. Use this\noption when there is no symmetry in directional operations."}, "summary": "The prototype_options()  function defines the criteria for the creation of\nprototype cells, creation\nprototype\ncells during hierarchical preprocessing.", "function_name": "prototype_options()"}
{"description": "The prune_nets()  function prunes instance connections of the nets that no longer\nconnect to any layers produced by new antenna checks in two ways:\n\u2022 marker_layer = NULL_POLYGON_LAYER. In this case, the nets that connect to the\nconnected layer are not pruned when prune=NOT_CONNECTED_TO.\n\u2022 marker_layer  is specified. Selects polygons from the connected_layer. The\nnets that connect to those selected polygons are not pruned when prune =\nNOT_CONNECTED_TO.", "syntax": "prune_nets(\nconnect_sequence = connect_database,\nprune_specs      = {{prune = NOT_CONNECTED_TO,\nconnected_layer = polygon_layer,\nmarker_layer    = polygon_layer},\n...}\n//optional\n);", "returns": "connect database", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "prune_specs": "Required. Lists the prune specifications.\n\u2022 prune. Specifies the relationship between pruned nets and the connected\nlayers. The default is NOT_CONNECTED_TO.\n\u2022 connected_layer. Specifies a layer in the connect database.\n\u2022 marker_layer. Optional. Specifies the polygon layer, which selects polygons\nfrom the connected_layer  where nets are not pruned. The default is\nNULL_POLYGON_LAYER."}, "summary": "The prune_nets()  function prunes instance connections of the nets that no longer\nconnect to any layers produced by new antenna checks in two ways:\n\u2022 marker_layer = NULL_POLYGON_LAYER.", "function_name": "prune_nets()"}
{"description": "The pull_down()  function creates a copy of the layer1  layer by moving data down to the\nlowest possible hierarchical level. The intersection of the data overlapping all placement\nextents of a given cell is cut out and moved into the cell. Pulled data is removed from its\noriginal position. The extents are determined by all layers that appear in assign functions.\nIn this context,\n\u2022 Data refers to any active area.\n\u2022 Moved down refers to being translated from ancestors into descendants.\n\u2022 Depth is measured from bottom up, so lowest or deepest refers to how close the cell is\nto the leaf cells, not how far it is from the top cell.", "syntax": "pull_down(\nlayer1    = polygon_layer,\nduplicate  = ALL,            //optional\nname      = \"layer_label\"   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is copied.", "duplicate": "Optional. Specifies which descendants can have copies of the data moved into\nthem. In cases where sibling cells overlap geographically, data moves down\nmultiple branches of a given subtree. The default is ALL.\npull_down()\n\u2022 ALL. Duplicates data in any branch of the subtree, even when the destination\nis not at the lowest level to which data is moving.\nIn the hierarchical tree example shown in\nFigure 539, data in cell T that can\nbe moved down into both cell A and cell B appears in both.\nFigure 539 Example Hierarchical Tree", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The pull_down()  function creates a copy of the layer1  layer by moving data down to the\nlowest possible hierarchical level.", "function_name": "pull_down()"}
{"description": "The pull_down_edge()  function creates a copy of the layer1  layer by moving data\ndown to the lowest possible hierarchical level. The intersection of the data overlapping\nall placement extents of a given cell is cut out and moved into the cell. The pulled data is\nremoved from its original position. The extents are determined by all layers that appear in\nassign functions. In this context,\n\u2022 Data refers to edges or edge segments.\n\u2022 Moved down refers to being translated from ancestors into descendants.\n\u2022 Depth is measured from bottom up, so lowest or deepest refers to how close the cell is\nto the leaf cells, not how far it is from the top cell.", "syntax": "pull_down_edge(\nlayer1    = edge_layer,\nduplicate  = ALL,           //optional\nname      = \"layer_label\"  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer that is copied.", "duplicate": "Optional. Specifies which descendants can have copies of the data moved into\nthem. In cases where sibling cells overlap geographically, data moves down\nmultiple branches of a given subtree. The default is ALL.\nSee the hierarchical tree example shown in\nFigure 539  in the pull_down()\nfunction description for more information.\n\u2022 ALL. Duplicates data in any branch of the subtree, even when the destination\nis not at the lowest level to which data is moving.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\npull_down_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The pull_down_edge()  function creates a copy of the layer1  layer by moving data\ndown to the lowest possible hierarchical level.", "function_name": "pull_down_edge()"}
{"description": "The pull_down_to()  function creates a copy of the layer1  polygon layer by moving data\ndown to the lowest possible hierarchical level of cells containing layer2. The intersection\nof the data overlapping all placement extents of a given cell is cut out and moved into the\ncell. The pulled data is removed from its original position. The extents are determined by\nall layers that appear in assign functions. In this context,\n\u2022 Data refers to any active area.\n\u2022 Moved down refers to being translated from ancestors into descendants.\n\u2022 Depth is measured from bottom up, so lowest or deepest refers to how close the cell is\nto the leaf cells, not how far it is from the top cell.", "syntax": "pull_down_to(\nlayer1                 = polygon_layer,\nlayer2                  = data_layer,\nduplicate              = ALL,                  //optional\nname                   = \"layer_label\",        //optional\ninteraction_check      = {NONE, INTERACTING}   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is copied.", "layer2": "Required. Specifies the layer to which data is pulled.", "duplicate": "Optional. Specifies which descendants can have copies of the data moved into\nthem. In cases where sibling cells overlap geographically, data moves down\nmultiple branches of a given subtree. The default is ALL.\nSee the hierarchical tree example shown in\nFigure 539  in the pull_down()\nfunction description for more information.\n\u2022 ALL. Duplicates data in any branch of the subtree, even when the destination\nis not at the lowest level to which data is moving.\npull_down_to()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "interaction_check": "Optional. Specifies what, if any, interaction check is executed on the pulled data\nrelative to layer2. The default is NONE.\n\u2022 NONE. Does not check the real polygon interaction between the pulled data\nand layer2. Only checks whether the pulled data interacts with the layer\nextent of layer2.\n\u2022 INTERACTING. Specifies that pulled data must interact with layer2."}, "summary": "The pull_down_to()  function creates a copy of the layer1  polygon layer by moving data\ndown to the lowest possible hierarchical level of cells containing layer2.", "function_name": "pull_down_to()"}
{"description": "The pull_down_to_edge()  function creates a copy of the layer1  edge layer by moving\ndata down to the lowest possible hierarchical level of cells containing layer2. The\nintersection of the data overlapping all placement extents of a given cell is cut out and\nmoved into the cell. The pulled data is removed from its original position. The extents are\ndetermined by all layers that appear in assign functions. In this context,\n\u2022 Data refers to edges or edge segments.\n\u2022 Moved down refers to being translated from ancestors into descendants.\n\u2022 Depth is measured from bottom up, so lowest or deepest refers to how close the cell is\nto the leaf cells, not how far it is from the top cell.", "syntax": "pull_down_to_edge(\nlayer1    = edge_layer,\nlayer2     = data_layer,\nduplicate  = ALL,           //optional\nname      = \"layer_label\"  //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer that is copied.", "layer2": "Required. Specifies the layer to which data is pulled.", "duplicate": "Optional. Specifies which descendants can have copies of the data moved into\nthem. In cases where sibling cells overlap geographically, data moves down\nmultiple branches of a given subtree. The default is ALL.\nSee the hierarchical tree example shown in\nFigure 539  in the pull_down()\nfunction description for more information.\n\u2022 ALL. Duplicates data in any branch of the subtree, even when the destination\nis not at the lowest level to which data is moving.\npull_down_to_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The pull_down_to_edge()  function creates a copy of the layer1  edge layer by moving\ndata down to the lowest possible hierarchical level of cells containing layer2.", "function_name": "pull_down_to_edge()"}
{"description": "The python_validate()  function resolves the directory location of the specified Python\nmodule file, by using the IC Validator -I  command-line option, and checks the file for\nPython parse errors. You can specify the returned, fully-qualified directory path to the\nPython module file with the module_file  argument in the perc_analyze_netlist()\nfunction. You can also use the python_validate()  function just to check for Python parse\nerrors in user-defined Python modules.", "syntax": "python_validate(\nfilename  = \"string\"\n);", "returns": "string or void", "arguments": {"filename": "Required. Specifies the name of the Python module file to be located or checked\nfor Python parse errors."}, "summary": "The python_validate()  function resolves the directory location of the specified Python\nmodule file, by using the IC Validator -I  command-line option, and checks the file for\nPython parse errors.", "function_name": "python_validate()"}
{"description": "The read_group()  function imports layers written by the\nwrite_group()  function in a\nprevious IC Validator run to a specified library. The read_group()  function matches cells\nby name and matches cell placements by xy position, rotation, and reflection. For the\nreturned polygon layer, the read_group()  function flattens cells from the input layer that\ndo not match a placement in the current run. Flattening occurs for\n\u2022 Cell placements that moved slightly or were deleted\n\u2022 Cells that are in the delete or explode lists\n\u2022 Cells whose names have changed\nBefore using the read_group()  function, the input library must have been defined\nusing the\ngroup_library()  function and written using the write_group()  function in a\nprevious run.\nNote:\nMultiple read_group(),\nread_group_edge(), and read_group_text()\nfunctions can use the same handle within a run; however, they cannot have the\nsame handle as a\nwrite_group()  function within that run.", "syntax": "read_group(\ninput_library = group_library_handle,\nlabel         = \"string\",\nname          = \"layer_label\"          //optional\n);", "returns": "polygon layer", "arguments": {"input_library": "Required. Specifies the group library handle. The handle is defined using the\ngroup_library()  function.", "label": "Required. Specifies a string defined by the write_group()  function that used to\nreference the saved layer.\nread_group()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The read_group()  function imports layers written by the\nwrite_group()  function in a\nprevious IC Validator run to a specified library.", "function_name": "read_group()"}
{"description": "The read_group_edge()  function imports layers written by the\nwrite_group()  function\nin a previous IC Validator run to a specified library. The read_group_edge()  function\nmatches cells by name and matches cell placements by xy position, rotation, and\nreflection. For the returned edge layer, the read_group_edge()  function flattens cells from\nthe input layer that do not match a placement in the current run. Flattening occurs for\n\u2022 Cell placements that moved slightly or were deleted,\n\u2022 Cells that are in the delete or explode lists,\n\u2022 Cells whose names have changed,\nBefore using the read_group_edge()  function, the input library must have been defined\nusing the\ngroup_library()  function and written using the write_group()  function in a\nprevious run.\nNote:\nMultiple\nread_group(), read_group_edge(), and read_group_text()\nfunctions can use the same handle within a run; however, they cannot have the\nsame handle as a\nwrite_group()  function within that run.", "syntax": "read_group_edge(\ninput_library = group_library_handle,\nlabel         = \"string\",\nname          = \"layer_label\"          //optional\n);", "returns": "edge layer", "arguments": {"input_library": "Required. Specifies the group library handle. The handle is defined using the\ngroup_library()  function.", "label": "Required. Specifies a string defined by a write_group()  function that is used to\nreference the saved layer.\nread_group_edge()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The read_group_edge()  function imports layers written by the\nwrite_group()  function\nin a previous IC Validator run to a specified library.", "function_name": "read_group_edge()"}
{"description": "The read_group_text()  function imports layers written by the\nwrite_group()  function\nin a previous IC Validator run to a specified library. The read_group_text()  function\nmatches cells by name and discards mismatched cells from the input layer.\nBefore using the read_group_text()  function, the input library must have been defined\nusing the\ngroup_library()  function and written using the write_group()  function in a\nprevious run.\nNote:\nMultiple\nread_group(), read_group_edge(), and read_group_text()\nfunctions can use the same handle within a run; however, they cannot have the\nsame handle as a write_group()  function within that run.", "syntax": "read_group_text(\ninput_library = group_library_handle,\nlabel         = \"string\",\nname          = \"layer_label\"          //optional\n);", "returns": "text layer", "arguments": {"input_library": "Required. Specifies the group library handle. The handle is defined using the\ngroup_library()  function.", "label": "Required. Specifies a string defined by a write_group()  function that is used to\nreference the saved layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The read_group_text()  function imports layers written by the\nwrite_group()  function\nin a previous IC Validator run to a specified library.", "function_name": "write_group()"}
{"description": "The read_layout_netlist()  function reads one of the two netlists compared in the\nnetlist-versus-netlist flow and translates it to IC Validator netlist format, if the netlist is\nnot already in that format and uncompressed. In a netlist-versus-netlist flow, the netlist\nimported by the read_layout_netlist()  function is designated as the layout netlist,\neven though this netlist can be generic and can originate from any source.\nNote:\nIn a SPICE flow (that is, when the lvs_netlist_flow  argument of the\nrun_options()  function is SPICE), the schematic file, which is in SPICE format,\nis not translated. For a SPICE flow, the -sf  command-line option can only be\nset to SPICE.\nThe result of this function is used by the\ncompare()  function. The\nNetTrantranslation\nNetTran utility does the\ntranslation.\nNote:\nWhen you set the -lnf  command-line option to ICV, the\nread_layout_netlist()  function does not run NetTran. In this situation, the\nIC Validator tool uses the netlist specified by the -ln  option for LVS compare.\nNote:\nThe split netlists are in the include_netlists_lay folder.", "syntax": "read_layout_netlist(\nlayout_file                    = {{filename = \"string\",\nformat   = SPICE | VERILOG | ICV},\n...},\nglobal_nets                   = {\"string\", ...},            //optional\nexpand_multiple_devices       = true | false,               //optional\nuppercase                     = true | false,               //optional\ncell                          = \"string\",                   //optional\nadd_cell_ports                 = {\"string\", ...},            //optional\noutput_netlist_file           = \"string\",                   //optional\nremove_devices                 = {\"string\", ...},            //optional\nremove_device_instances       = {\"string\", ...},            //optional\nspice_settings    = {short_out_devices       = {\"string\", ...},\nshort_voltage_threshold = double,\nremove_instance_prefix  = true | false,\nremove_device_prefix    = true | false,\ndevice_map_file         = \"string\",\nignore_cdl_resi         = true  | false,\ncheck_ldd               = true | false,\nread_layout_netlist()\nresolve_duplicate_instances = true | false,\nduplicate_port          = ABORT | WARNING,\nscale                   = double},      //optional\nduplicate_property      = FIRST |\nLAST  | ABORT,\nignore_cdl_scale        = true | false,\nsubckt_slash_mode       = UNSET  | SPACE,\nshort_voltage_nets      = true | false,\nauto_detect_busdelimiter = NONE  | FIRST,\nmax_mos_pins            = SEVEN|FOUR,\nbus_port_order          = DESCENDING  | SPICE,\nserial_multiplier_names = {name, ...},\nconcatenate_all_files   = true | false,\nundefined_parameter     = WARNING  | ABORT\n| ABORT_ON_MULTIPLIER\n},                                       //optional\nverilog_settings  = {global_ground       = \"string\",\nglobal_power        = \"string\",\nbus_start_bit       = HIGH  | LOW,\nglobal_net_map_file = \"string\",\nretain_backslash    = true | false,     //optional\nprefer_module_supply   = true | false,  //optional\nlocalize_module_supply = true | false,  //optional\nlocalize_global_supply = true | false}, //optional\nfloating_pins     = ABORT | ALLOW,                           //optional\nduplicate_cell   = ABORT | USE_MULTIPLE  | USE_ONE,          //optional\nuse_composite_for_shorted_nets             = true  | false,  //optional\nerror_limit       = integer,                       //optional\nforce_globals_on = true | false               //optional\n);", "returns": "layout_netlist_file_handle\nlayout_netlist_file_handle", "arguments": {"layout_file": "Required. Specifies a list of layout files, including the optional path, and their\nformat. The formats are SPICE, VERILOG, and ICV. The default is ICV.\nThe file name can be overwritten with the -ln  command-line option, and the\nformat can be overwritten with the -lnf  command-line option. See IC Validator\nCommand-Line Options  in the \u201cIC Validator Basics\u201d chapter of the IC Validator\nUser Guide  for more information.", "global_nets": "Optional. Specifies the IC Validator global nets. The default is an empty list.", "expand_multiple_devices": "Optional. Specifies if devices are netlisted multiple times. The default is false.\nread_layout_netlist()\n\u2022 true. Lists devices in the netlist multiple times.\n\u2022 false. Does not netlist the device multiple times.", "uppercase": "Optional. Specifies if input is converted to uppercase characters. The default is\nfalse.\n\u2022 true. Converts input to uppercase characters.\n\u2022 false. Does not convert input to uppercase characters.", "cell": "Optional.\ntop cellspecifying\nSpecifies the top cell for the output netlist. The top cell is also the\ncell to which ports are added using the add_cell_ports  argument. Only cells\ncontained in the hierarchy of this top cell are output. The default is an empty\nstring (\"\"), meaning that all cells in the input netlist are translated into the output\nnetlist.", "add_cell_ports": "Optional. Specifies the ports to add to the cell specified by the cell  argument.\nBy default, the IC Validator tool does not add ports to any cells.", "output_netlist_file": "Optional. Specifies the output netlist file. If the file already exists, the content of\nthe file is overwritten. The default name is \"cell.lay_out\".\nNote:\nIf the input netlist is a single IC Validator uncompressed netlist, there\nis no output netlist and this option is ignored.", "remove_devices": "Optional. Filters out the devices that have specific model names, or cell\ninstances that have specific cell names.", "remove_device_instances": "Optional. Filters out the devices or cell instances that have specific instance\nnames. You can use the \"*\" metacharacter.", "spice_settings": "Optional. Specifies settings related to SPICE translations.\nSPICE translations\nFor Boolean\narguments set to false, the described behavior is not enabled.\nread_layout_netlist()\n\u2022 short_out_devices. Specifies the resistors, capacitors, and inductors that\nare filtered out. After the devices are removed, the two pins are shorted.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-fshort  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 short_voltage_threshold. Specifies the voltage source threshold value for\nshorts. By default, the IC Validator tool replaces all voltage sources in SPICE\ndesigns with an open. Use this setting to override the open with a short. All\nsources with a DC voltage of less than or equal to the threshold are replaced\nby a short.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-voltThresh  command-line option. See Command-Line Syntax\nfor NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User\nGuide  for more information.\n\u2022 remove_instance_prefix. Specifies if the leading X prefix in SPICE\ninstance names is stripped. The default is false.\n\u25e6 true. Strips the leading X prefix in SPICE instance names.\n\u25e6 false. Does not strip the prefix.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-chopXPrefix  command-line option. See Command-Line\nSyntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS\nUser Guide  for more information.\n\u2022 remove_device_prefix. Specifies if the leading R, L, C, Q, D, and M\nprefixes in SPICE instance names are stripped. The default is false.\n\u25e6 true. Strips the leading R, L, C, Q, D, and M prefixes in SPICE instance\nnames during netlist read-in and before any netlist processing, such as\nflattening.\n\u25e6 false. Does not strip the prefixes.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-chopDevPrefix  command-line option. See Command-Line\nSyntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS\nUser Guide  for more information.\n\u2022 device_map_file. Specifies a map of device model names to new names.\nSee the CDL Map File  section in the \u201cNetlist Formats\u201d chapter of the\nIC Validator LVS User Guide  for an example of the mapping file format.\nread_layout_netlist()\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-devMap  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 ignore_cdl_resi. Specifies that the *.RESI statements in the netlist are\nignored. The default is true.\n\u25e6 true. Does not short the resistors specified in the *.RESI statements.\n\u25e6 false. Shorts the resistors specified in the *.RESI statements.\nWhen the IC Validator tool runs NetTran, this argument corresponds to the\nNetTran -sp-checkResi  command-line option. See Command-Line Syntax\nfor NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User\nGuide  for more information.\n\u2022 check_ldd. Specifies if NetTran checks the *.LDD statements in the netlist.\nThe default is false.\n\u25e6 true. Recognizes $LDD[model]  as the model name only when *.LDD  is\nset in the netlist.\n\u25e6 false. Ignores *.LDD  statements in the netlist and always recognizes\n$LDD[model]  as the model name.\ncheck_ldd=true check_ldd=false\nSet *.LDD Recognize $LDD[model] Recognize $LDD[model]\nNo *.LDD Ignore $LDD[model] Recognize $LDD[model]\nWhen the IC Validator tool runs NetTran, this argument corresponds to the\nNetTran -sp-checkLdd  command-line option. See Command-Line Syntax\nfor NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User\nGuide  for more information.\n\u2022 resolve_duplicate_instances. If duplicate instance names are found\nwithin the same cell, you can rename these instance names by adding a\nsuffix to the following format: DUP#index. The new names do not cause any\nnaming collisions. The default is false.\nWhen the IC Validator tool runs NetTran, this argument corresponds to the\nNetTran -sp-resolveDupInstances  command-line option. See Command-\nLine Syntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator\nLVS User Guide  for more information.\nread_layout_netlist()\n\u2022 duplicate_port. Controls the duplicate ports in the SPICE cell port list\n(implicitly defined). For a $PINS statement, duplicate pins are not allowed.\nThe default is WARNING.\nNote:\nThe -sp-dupPort  NetTran command-line option provides the\nsame functionality.\n\u25e6 ABORT. Reports an error and aborts the run at the cell definition.\n\u25e6 WARNING. Shorts the duplicate ports and gives a warning message.\n\u2022 scale. Overwrites the scaling factor (*.SCALE  and .OPTION SCALE) for\nall input netlists in the SPICE format. If this argument is not specified, the\nscaling factor follows the existing scaling syntax of the input SPICE netlist.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -sp-scale  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 duplicate_property. Optional. Specifies whether NetTran handles the first\nor last of the duplicate properties. The default is LAST.\n\u25e6 FIRST. Specifies that NetTran uses the first of the duplicate properties.\n\u25e6 LAST. Specifies that NetTran uses the last of the duplicate properties.\n\u25e6 ABORT. Reports an error and aborts the run if duplicate properties are\nfound.\n\u2022 ignore_cdl_scale. Optional. Ignores *.SCALE METER | MICRON\nstatements in the input SPICE netlist. The default is false. See the -sp-\nignoreCdlScale  command-line option for more information.\n\u2022 subckt_slash_mode. Optional. Specifies whether the front-slash character\nshould be treated as white space within subcircuit definitions and calls. The\ndefault is UNSET.\n\u25e6 UNSET. When applicable, uses the IC Validator default behavior of treating\nthe front-slash character as white space.\n\u25e6 SPACE. Treats front-slashes (/) as spaces within subcircuit definitions and\ncalls. It does not apply to subcircuit names in subcircuit definitions and\ninstance names in subcircuit calls.\n\u2022 short_voltage_nets. Optional. Specifies the voltage source to be a short.\nBy default, the IC Validator tool replaces all voltage sources in SPICE\ndesigns with an open. Use this setting to override the open with a short. This\nread_layout_netlist()\nsetting forces to replace all voltage sources with a short without checking the\nthreshold. The default is false. See the -sp-shortVoltNets  command-line\noption for more information.\n\u2022 auto_detect_busdelimiter  Optional. Detects busdelimiters in the input\nSPICE netlist. The default is NONE. See the -sp-autoDetectBus  command-\nline option for more information.\n\u2022 max_mos_pins. Controls the behavior how Nettran handles mosfet Spice\nsyntax. This affects how Nettran determines the mosfet model name. Default\nis SEVEN.\n\u25e6 SEVEN. Nettran can accept at most 7 pins (4 optional bulks).\n\u25e6 FOUR. Nettran can accept at most 4 pins (1 optional bulks).\n\u2022 bus_port_order. Controls the behavior how Nettran handles SPICE bus\nports to match Verilog pins. Default is DESCENDING.\n\u25e6 DESCENDING. No matter how the ports are ordered, Nettran always treat\nthem as DESCENDING.\n\u25e6 SPICE.The order is determined depending on how input spice ports are\nordered. a[0] a[1] a[2]  means ASCENDING, a[2] a[1] a[0]  means\nDESCENDING. For other random orderings, it is treated as DESCENDING.\n\u2022 concatenate_all_files. Specifies Nettran to concatenate all input SPICE\nnetlists in a single netlist. The default is false.\n\u2022 undefined_parameter. Controls the behavior of Nettran to handle undefined\nparameters. Default is WARNING.\n\u25e6 WARNING. Nettran writes a warning message in the log file and keeps\nrunning.\n\u25e6 ABORT. Nettran writes an error message in the log file and the run stops.\n\u25e6 ABORT_ON_MULTIPLIER. When there exists undefined parameters in\nmultiplier assign syntax, Nettran writes an error message in the log file\nand the run stops. When there exists undefined parameters in other\nplaces, Nettran writes a warning message in the log file and keeps\nrunning.", "verilog_settings": "Optional. Specifies settings related to Verilog translations. For Boolean\narguments set to false, the described behavior is not enabled.\nread_layout_netlist()\n\u2022 global_ground. Specifies the Verilog global ground net.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-b0  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 global_power. Specifies the Verilog global power net.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-b1  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 bus_start_bit. Specifies if Verilog buses start with the most or least\nsignificant bit first in the bus range. The default is HIGH.\n\u25e6 HIGH. Starts the buses with the most significant bit, for example, Y[7:0].\n\u25e6 LOW. Starts the buses with the least significant bit, for example, Y[0:7].\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-busLSB  command-line option. See Command-Line\nSyntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS\nUser Guide  for more information.\n\u2022 global_net_map_file. Specifies the Verilog global net mapping file.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-voltmap  command-line option. See Command-Line\nSyntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS\nUser Guide  for more information.\n\u2022 retain_backslash. Specifies if the backslash (\\) is retained on Verilog net\nnames. The default is false.\n\u25e6 true. Retains the backslash (\\) on Verilog net names.\n\u25e6 false. Does not retain the backslash (\\) on Verilog net names.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-R  command-line option. See Command-Line Syntax for\nNetTran  in the \u201cNetlist Formats\u201d chapter of the IC Validator LVS User Guide\nfor more information.\n\u2022 prefer_module_supply. Changes the precedence of 1) user-specified\nglobal supply nets, 2) local supply nets, and 3) default global supply nets,\nVDD and VSS. The default is false.\nread_layout_netlist()\n\u25e6 true. Supply net precedence is 2) > 1) > 3).\n\u25e6 false. Supply net precedence is 1) > 2) > 3).\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-preferModuleSupply  command-line option. See\nCommand-Line Syntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the\nIC Validator LVS User Guide  for more information.\n\u2022 localize_module_supply. Changes the precedence of 1) user-specified\nglobal supply nets, 2) local supply nets, and 3) default global supply nets,\nVDD and VSS. Global net generation for local supply nets can be disabled\nas well. The default is false.\n\u25e6 true. Supply net precedence is 2) > 1) > 3). Global net generation for\nlocal supply nets is disabled.\n\u25e6 false. Supply net precedence is 1) > 2) > 3).\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-localizeModuleSupply  command-line option. See\nCommand-Line Syntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the\nIC Validator LVS User Guide  for more information.\n\u2022 localize_global_supply. Disables global net generation of user-specified\nglobal supply nets and default global supply nets, VDD and VSS. The default\nis false.\n\u25e6 true. Global net generation for global supply nets is disabled.\n\u25e6 false. Global net generation for global supply nets is not disabled.\nWhen the IC Validator tool runs NetTran, this value corresponds to the\nNetTran -verilog-localizeGlobalSupply  command-line option. See\nCommand-Line Syntax for NetTran  in the \u201cNetlist Formats\u201d chapter of the\nIC Validator LVS User Guide  for more information.", "floating_pins": "Optional. Reports if floating pins are detected. If you use the duplicate_cell\nargument with the floating_pins  argument, the NetTran utility tries to select\nduplicate cell definitions that are not floating pins. The default is ALLOW.\nSee the -noFloatingPins  command-line option in the Command-Line\nSyntax for NetTran  section in the \u201cNetlist Formats\u201d chapter of the IC\nValidator LVS User Guide  for more information.\nread_layout_netlist()\n\u2022 ALLOW. Allows floating pins. When the NetTran utility detects a floating pin, it\nreports a warning message. For the port that does not have a corresponding\npin connection, a placeholder net, with the name icv_floatnet_xx, is added.\nSee Translating Standard Netlists to IC Validator Format  in the \u201cNetlist\nFormats\u201d chapter of the IC Validator LVS User Guide  for more information.\n\u2022 ABORT. Does not allow floating pins. When the NetTran utility detects a\nfloating pin, it reports an error message.", "duplicate_cell": "Optional. Specifies how to handle multiple cell definitions having the same\nname. The default is USE_MULTIPLE.\n\u2022 ABORT. Reports an error and aborts the run if more than one cell contains\nthe same cell name. The -dupCell ABORT  NetTran command-line option\nprovides the same functionality.\n\u2022 USE_MULTIPLE. Specifies the cell definition by using the following rules:\n\u25e6 Each instance (placement) selects a cell definition with the same netlist\ntype, if it exists.\n\u25e6 Each instance (placement) selects a cell definition in the same file, if it\nexists.\n\u25e6 If there is no cell definition with the same netlist type or in the same file,\nNetTran selects a random cell definition.\nThe -dupCell USE_MULTIPLE  NetTran command-line option provides the\nsame functionality.\n\u2022 USE_ONE. Selects the first-read definition as the master definition for all\ninstances. If both empty and non-empty duplicate .subckt cells exist in the\ninput netlists, NetTran selects the first read non-empty definition. If there\nexists different port count of non-empty definition, NetTran selects the one\nwith the same instance pin count. If there are multiple netlist type definitions\nto select the master definition regardless of input order, NetTran follows this\npriority: SPICE -> VERILOG -> ICV.\nThe -dupCell USE_ONE  NetTran command-line option provides the same\nfunctionality.\nNote:\nThe read_layout_netlist()  function does not support the\n-dupCell RESOLVE_PORTS  NetTran command-line option.\nread_layout_netlist()", "use_composite_for_shorted_nets": "Optional. Specifies if shorted nets are merged into a composite net. The default\nis true.\n\u2022 true. Specifies if shorted nets are merged into a composite net.\n\u2022 false. Specifies if the shorted nets are replaced by one representative net.", "error_limit": "Specifies the maximum number of times a warning and error category are\nprinted in the log file. The default is 1000.", "force_globals_on": "Optional. Ensures that pins connected to global nets are renamed to match the\nglobal net name. The default is false.\n\u2022 true. Specifies -forceGlobalsOn  when invoking Nettran.\n\u2022 false. Does not specify -forceGlobalsOn  when invoking Nettran."}, "summary": "The read_layout_netlist()  function reads one of the two netlists compared in the\nnetlist-versus-netlist flow and translates it to IC Validator netlist format, if the netlist is\nnot already in that format and uncompressed.", "function_name": "read_layout_netlist()"}
{"description": "The recalculate_property()  function creates or modifies device properties before\nmerging and comparison in an LVS flow. The result of the recalculate_property()\nfunction can be used by compare functionality that reads device properties to affect the\nnetlist comparison. Some examples are:\n\u2022 The exclude_tolerances  and property_functions  arguments of the\nmerge_parallel()  and merge_series()  functions\n\u2022 The property_tolerances  argument of the check_property()  function\n\u2022 The lvs_get_double_property()  compare utility function.", "syntax": "recalculate_property(\nstate             = compare_state,\ndevice_type       = NMOS | PMOS | NPN | PNP | NP | PN |\nRESISTOR | CAPACITOR | INDUCTOR | GENERIC,\ndevice_names      = {\"string\", ...},                        //optional\nproperty_function = \"string\",                               //optional\nequiv_cells       = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                   //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the recalculate_property()  function is added.", "device_type": "Required. Specifies the device type.", "device_names": "Optional. Specifies the layout devices. Each device must match a device\nspecified in a device_name  argument of a device configuration function.\nrecalculate_property()\nNote:\nWhen device names are specified but not declared by a device or\nmap_*  function, IC Validator automatically creates equates for these\ndevices when possible. Exceptions where device names do not\nautomatically create equates are when merge_series()  is used with\ngendev_series_pins  and filter()  is used with short_pins.", "property_function": "Optional. Specifies the remote function that recalculates properties. See\nCompare Utility Functions  for more information about the utility functions you\ncan use to define a remote function.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which the\nrecalculate_property()  function applies. You must specify the equiv_cells\npairs in the equiv_options()  function before calling the merge_series()\nfunction. If only one cell name in the pair is specified, the names are assumed to\nbe the same.\nNote:\nThe recalculate_property()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell pair\nis exploded into the parent equivalence cell pair while comparing the\nparent, the recalculate_property()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The recalculate_property()  function creates or modifies device properties before\nmerging and comparison in an LVS flow.", "function_name": "recalculate_property()"}
{"description": "The recognize_gate()  function tells the IC Validator tool to analyze transistor-\nlevel circuitry by looking for logic gates. When found, these gates are represented as\ncomposite devices, similar to the merging process. The IC Validator tool then performs the\ncomparison based on the recognized gates and the remaining devices. The recognized\ngates are described in the Examples section.\nThe devices that form a gate are swappable. That is, you are allowed to swap the\norder of the devices that are members of a gate. As shown in\nFigure 544, without the\nrecognize_gate  function, the two circuits do not match; with the recognize_gate\nfunction, both circuits form _SP_NMOS_2_1_1 half gates and the two circuits match.\nFigure 544 Swappable Gates Example\nNote:\nA device can be merged by the merge_series()  function or recognized by the\nrecognize_gate()  function, but not both in the same runset.\nDo not use the recognize_gate()  function when a remote function is specified\nby the property_function  argument of the check_property()  function.\nThis function must be called before the compare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "recognize_gate(\nstate              = compare_state,\ntype               = ALL  | SIMPLE,                          //optional\nrecognize_gate()\nexclude_tolerances = {{device_type = NMOS | PMOS,}\ndevice_names = {\"string\", ...},\ntolerances = {\n{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type =\nRELATIVE  | ABSOLUTE},\n...}},                             //optional\nequiv_cells        = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                  //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the recognize_gate()  function is added.", "type": "Optional. Specifies the types of gates that are recognized. The gate type name\nis reported in the summary file and displayed in the VUE Netlist Visualizer. See\nthe Examples section for information about the types. The default is ALL.\n\u2022 ALL. Specifies that all types of gates are recognized, including\n_INV\n_NANDn\n_NORn\n_AOI_n1_n2_...nm\n_OAI_n1_n2_...nm\n_S_NMOSn\n_S_PMOSn\n_SP_NMOS_n1_n2_..._nm\n_SP_PMOS_n1_n2_..._nm\n_SP_PMOS(expression)\n_SP_NMOS(expression)\nrecognize_gate()\n\u2022 SIMPLE. Specifies that only simple gates are recognized:\n_INV\n_NANDn\n_NORn\n_S_NMOSn\n_S_PMOSn\n_SP_NMOS_n1_n2_..._nm\n_SP_PMOS_n1_n2_..._nm", "exclude_tolerances": "Optional. Lists the tolerance settings composed of device type, list of device\nnames, and list of property tolerance settings. This is a more general exclude\ntolerances setting than that of the merge_series()  function.\nNote:\nThe recognize_gate()  function does not support swappable\nproperties in the exclude_tolerances  argument.\nUse this parameter to constrain gate recognition based on property comparison.\n\u2022 device_type. Required. Specifies the device type. Only NMOS and PMOS\ndevice types are available.\n\u2022 device_names. Optional. Specifies the layout devices. Each device\nmust match a device specified in a device_name  argument of a device\nconfiguration function.\nNote:\nWhen device names are specified but not declared by a device\nor map_*  function, IC Validator automatically creates equates for\nthese devices when possible. Exceptions where device names\ndo not automatically create equates are when merge_series()\nis used with gendev_series_pins  and filter()  is used with\nshort_pins.\n\u2022 tolerances. Optional. Lists the tolerance settings that exclude candidate\ndevices from being merged based on the device property values.\nrecognize_gate()\n\u25e6 property. Required. Specifies the property used to check the tolerance\nrange.\n\u25e6 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies either that\nthe tolerance is a percentage (default) or an absolute value. The default is\n[-10,+10].\n\u25e6 tolerance_type. Optional. Checks property tolerances based on a\nrelative or absolute property difference. The default is RELATIVE.\n- RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n- ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the lvs_user_unit  argument of", "the": "run_options()  function.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which information\nspecified in the recognize_gate()  function applies. You must specify the\nequiv_cells  pairs in the equiv_options()  function before calling the\nrecognize_gate()  function. If only one cell name in the pair is specified, the\nnames are assumed to be the same.\nNote:\nThe recognize_gate()  instruction is observed only when comparing\neach listed equivalence cell pair. If an equivalence cell pair is\nexploded into the parent equivalence cell pair while comparing\nthe parent, the recognize_gate()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The recognize_gate()  function tells the IC Validator tool to analyze transistor-\nlevel circuitry by looking for logic gates.", "function_name": "recognize_gate()"}
{"description": "The recognize_gate_off()  function disables gate recognition for specified devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "recognize_gate_off(\nstate              = compare_state,\nequiv_cells        = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...}                                  //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function.", "equiv_cells": "Optional. Lists the schematic and layout cell name pairs for which information\nspecified in the recognize_gate_off()  function applies. You must specify\nthe equiv_cells  pairs in the equiv_options()  function before calling the\nrecognize_gate_off()  function. If only one cell name in the pair is specified,\nthe names are assumed to be the same.\nNote:\nThe recognize_gate_off()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell\npair is exploded into the parent equivalence cell pair while comparing\nthe parent, the recognize_gate()  instruction is discarded for the\ncontent of the exploded cell."}, "summary": "The recognize_gate_off()  function disables gate recognition for specified devices.", "function_name": "recognize_gate_off()"}
{"description": "The rectangle_overlap()  function oversizes orthogonal rectangles from the input layer\nthat meet the specified dimensions, and then creates polygons that represent the area\nwhere the oversized rectangles overlap.\nNote:\nNonrectangular and nonorthogonal data is ignored.\nEach edge of a rectangle must fit one of the length specifications for the\nrectangle to be oversized.", "syntax": "rectangle_overlap(\nlayer1  = polygon_layer,\nlength1 = doubleconstraint,\nlength2 = doubleconstraint,\nsize1    = double,\nsize2    = double,\nname    = \"layer_label\"      //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "length1": "Required. Specifies the length for one side of the rectangles. See\nConstraints  on\npage 3344 for more information. The default is >0.", "length2": "Required. Specifies the length for one side of the rectangles. See Constraints  on\npage 3344 for more information. The default is >0.\nNote:\nIf both edges fit both length specifications, the shortest edge gets the\nsmallest oversize. For a square, the largest oversize is used for the\ntop and bottom expansions, while the smallest oversize is used for\nthe left and right expansions.\nrectangle_overlap()\nIf only one edge fits both length specifications, the other edge\nis oversized for the length it fits. The edge that fits both length\nspecifications is oversized for the other length.", "size1": "Required. Specifies the oversize distance for edges that fit the length1\nargument value. A value of 0 or less means the edge is not oversized.\nNote:\nIf both size arguments are 0 or less, the output is empty.", "size2": "Required. Specifies the oversize distance for edges that fit the length2\nargument value. A value of 0 or less means the edge is not oversized.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The rectangle_overlap()  function oversizes orthogonal rectangles from the input layer\nthat meet the specified dimensions, and then creates polygons that represent the area\nwhere the oversized rectangles overlap.", "function_name": "rectangle_overlap()"}
{"description": "The rectangle_spacing1()  function selects rectangles that fit the specified count and\ndistance constraints. The not_rectangle_spacing1()  function selects rectangles that do\nnot fit the specified count and distance constraints.", "syntax": "rectangle_spacing1(\nlayer1                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer,           //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);\nnot_rectangle_spacing1(\nlayer1                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer,           //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.\nrectangle_spacing1() and not_rectangle_spacing1()", "count": "Required. Specifies the number of rectangles that must be in violation.", "distance": "Required. Specifies the distance constraint of orthogonal rectangles for potential\nselection. The distance definition is dependent on the corner_extension\nargument.\n\u2022 When the corner_extension  argument is SQUARE, the distance of a\nrectangle is checked by oversizing.\nFor example, the distance between rectangles A and B must be less than\n\"a\". To determine distance, rectangle A is oversized by the value \"a\". If\nrectangle A then intersects rectangle B, rectangles A and B are selected\nbecause B is in the checking zone  of rectangle A.\n\u2022 When the corner_extension  argument is RADIAL, the distance is a\nEuclidean distance.", "corner_extension": "Optional. Specifies the shape of the checking zone.", "measure": "Optional. Specifies how the checking zone is measured. The default is\nEDGE_TO_EDGE.\n\u2022 EDGE_TO_EDGE. Measures the distance between the borders of the\nrectangles. That is, a rectangle is counted if its check zone interacts with\nanother rectangle.\n\u2022 CENTER_TO_CENTER. Measures the distance between the centers of the\nrectangles. That is, a rectangle is counted if its check zone interacts with the\ncenter of another rectangle.\nFigure 555  shows how the corner_extension  and measure  arguments effect\nthe selection of rectangles.\nrectangle_spacing1() and not_rectangle_spacing1()\nFigure 555 Spacing of Rectangles: Distance Between the Two Polygons Is < a", "center_to_center_direction": "Optional. Specifies the alignment of the neighboring rectangles. The default is\nALL.\nNote:\nThis argument is used only when the measure  argument is\nCENTER_TO_CENTER.\n\u2022 ALL. Counts all rectangles regardless of the alignment.\n\u2022 ORTHOGONAL. Counts a rectangle if the centerline is aligned on a multiple of\n90 degrees; that is in either the x- or y-direction.\n\u2022 OCTAGONAL. Counts a rectangle if the centerline is aligned at 45 degrees.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nrectangle_spacing1() and not_rectangle_spacing1()", "inside_layer": "Optional. Selects only layer1  rectangles that are inside the polygons of this\nlayer. These rectangles must fit the specified count and distance constraints.\nThe counting is restricted to layer1  rectangles that are inside the same\ninside_layer  polygon.\nNote:\nThe not_rectangle_spacing1()  function selects only layer1\nrectangles that are inside the inside_layer  polygons but do not fit\nthe specified count and distance constraints.\nIn the following examples, shown in\nFigure 556  and Figure 557, assume that the\ndistance constraint between the polygons is met.\nFigure 556  shows an example with a layer1  layer that has four polygons and\nan inside_layer  layer that has two polygons.\nWith the following command, which uses the inside_layer  argument, the\nresult is a layer that only has polygon R because polygons B, C, and D, which\nare also inside polygon P1, meet the constraints. Polygon A does not meet\nthe count constraint because it is the only layer1  polygon that is inside the\ninside_layer  polygon P2.\nresult = rectangle_spacing1(layer1 = LayerA, distance <= d,\ncount = 3, inside_layer = layerC);\nWith the following command, which does not use the inside_layer  argument,\nthe result is a layer that only has polygon R because the layer1  polygons A, B,\nC, and D, meet the constraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d, count =\n4);\nFigure 556 inside_layer Argument With Two Polygons Example\nrectangle_spacing1() and not_rectangle_spacing1()\nFigure 557  shows an example with a layer1  layer that has four polygons and\nan inside_layer  layer that has one polygon.\nWith the following command, which uses the inside_layer  argument, the\nresult is a layer that only has polygon R because polygons A, B, C, and D, which\nare inside polygon P3, meet the constraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d,\ncount = 4, inside_layer=layerC);\nWith the following command, which does not use the inside_layer  argument,\nthe result is the same as above where the inside_layer  argument is used\n\u2014a layer that only has polygon R because polygons A, B, C, and D meet the\nconstraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d, count =\n4);\nFigure 557 inside_layer Argument With One Polygon Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.\nNote:\nIf inside_layer  is specified, connectivity  must be ALL.\nSee Figure 560  in the rectangle_spacing2()  function for the effect of the\nconnectivity  argument settings.\nrectangle_spacing1() and not_rectangle_spacing1()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET."}, "summary": "The rectangle_spacing1()  function selects rectangles that fit the specified count and\ndistance constraints.", "function_name": "rectangle_spacing1()"}
{"description": "The rectangle_spacing1()  function selects rectangles that fit the specified count and\ndistance constraints. The not_rectangle_spacing1()  function selects rectangles that do\nnot fit the specified count and distance constraints.", "syntax": "rectangle_spacing1(\nlayer1                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer,           //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);\nnot_rectangle_spacing1(\nlayer1                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer,           //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.\nrectangle_spacing1() and not_rectangle_spacing1()", "count": "Required. Specifies the number of rectangles that must be in violation.", "distance": "Required. Specifies the distance constraint of orthogonal rectangles for potential\nselection. The distance definition is dependent on the corner_extension\nargument.\n\u2022 When the corner_extension  argument is SQUARE, the distance of a\nrectangle is checked by oversizing.\nFor example, the distance between rectangles A and B must be less than\n\"a\". To determine distance, rectangle A is oversized by the value \"a\". If\nrectangle A then intersects rectangle B, rectangles A and B are selected\nbecause B is in the checking zone  of rectangle A.\n\u2022 When the corner_extension  argument is RADIAL, the distance is a\nEuclidean distance.", "corner_extension": "Optional. Specifies the shape of the checking zone.", "measure": "Optional. Specifies how the checking zone is measured. The default is\nEDGE_TO_EDGE.\n\u2022 EDGE_TO_EDGE. Measures the distance between the borders of the\nrectangles. That is, a rectangle is counted if its check zone interacts with\nanother rectangle.\n\u2022 CENTER_TO_CENTER. Measures the distance between the centers of the\nrectangles. That is, a rectangle is counted if its check zone interacts with the\ncenter of another rectangle.\nFigure 555  shows how the corner_extension  and measure  arguments effect\nthe selection of rectangles.\nrectangle_spacing1() and not_rectangle_spacing1()\nFigure 555 Spacing of Rectangles: Distance Between the Two Polygons Is < a", "center_to_center_direction": "Optional. Specifies the alignment of the neighboring rectangles. The default is\nALL.\nNote:\nThis argument is used only when the measure  argument is\nCENTER_TO_CENTER.\n\u2022 ALL. Counts all rectangles regardless of the alignment.\n\u2022 ORTHOGONAL. Counts a rectangle if the centerline is aligned on a multiple of\n90 degrees; that is in either the x- or y-direction.\n\u2022 OCTAGONAL. Counts a rectangle if the centerline is aligned at 45 degrees.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nrectangle_spacing1() and not_rectangle_spacing1()", "inside_layer": "Optional. Selects only layer1  rectangles that are inside the polygons of this\nlayer. These rectangles must fit the specified count and distance constraints.\nThe counting is restricted to layer1  rectangles that are inside the same\ninside_layer  polygon.\nNote:\nThe not_rectangle_spacing1()  function selects only layer1\nrectangles that are inside the inside_layer  polygons but do not fit\nthe specified count and distance constraints.\nIn the following examples, shown in\nFigure 556  and Figure 557, assume that the\ndistance constraint between the polygons is met.\nFigure 556  shows an example with a layer1  layer that has four polygons and\nan inside_layer  layer that has two polygons.\nWith the following command, which uses the inside_layer  argument, the\nresult is a layer that only has polygon R because polygons B, C, and D, which\nare also inside polygon P1, meet the constraints. Polygon A does not meet\nthe count constraint because it is the only layer1  polygon that is inside the\ninside_layer  polygon P2.\nresult = rectangle_spacing1(layer1 = LayerA, distance <= d,\ncount = 3, inside_layer = layerC);\nWith the following command, which does not use the inside_layer  argument,\nthe result is a layer that only has polygon R because the layer1  polygons A, B,\nC, and D, meet the constraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d, count =\n4);\nFigure 556 inside_layer Argument With Two Polygons Example\nrectangle_spacing1() and not_rectangle_spacing1()\nFigure 557  shows an example with a layer1  layer that has four polygons and\nan inside_layer  layer that has one polygon.\nWith the following command, which uses the inside_layer  argument, the\nresult is a layer that only has polygon R because polygons A, B, C, and D, which\nare inside polygon P3, meet the constraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d,\ncount = 4, inside_layer=layerC);\nWith the following command, which does not use the inside_layer  argument,\nthe result is the same as above where the inside_layer  argument is used\n\u2014a layer that only has polygon R because polygons A, B, C, and D meet the\nconstraints.\nR = rectangle_spacing1(layer1 = LayerA, distance <= d, count =\n4);\nFigure 557 inside_layer Argument With One Polygon Example", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\n\u2022 ALL. Checks all rectangles regardless of connectivity.\nNote:\nIf inside_layer  is specified, connectivity  must be ALL.\nSee Figure 560  in the rectangle_spacing2()  function for the effect of the\nconnectivity  argument settings.\nrectangle_spacing1() and not_rectangle_spacing1()", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET."}, "summary": "The rectangle_spacing1()  function selects rectangles that fit the specified count and\ndistance constraints.", "function_name": "not_rectangle_spacing1()"}
{"description": "The rectangle_spacing2()  function selects layer1  rectangles that fit the\nspecified count and distance constraints for interaction with layer2  rectangles. The\nnot_rectangle_spacing2()  function selects layer1  rectangles that do not fit the\nspecified count and distance constraints for interaction with layer2  rectangles.", "syntax": "rectangle_spacing2(\nlayer1                     = polygon_layer,\nlayer2                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer            //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);\nnot_rectangle_spacing2(\nlayer1                     = polygon_layer,\nlayer2                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,          //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,         //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,                //optional\nname                       = \"layer_label\",            //optional\ninside_layer               = polygon_layer,            //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,      //optional\nconnect_sequence            = connect_database           //optional\n);", "returns": "polygon layer or error result\nrectangle_spacing2() and not_rectangle_spacing2()", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "count": "Required. Specifies the number of layer2  orthogonal rectangles that must be in\nviolation.", "distance": "Required. Specifies the distance constraint of layer1  orthogonal rectangles\nfor potential selection. The distance definition is dependent on the\ncorner_extension  argument.\n\u2022 When the corner_extension  argument is SQUARE, the distance of a\nrectangle is checked by oversizing.\nFor example, the distance between rectangle A on the layer1  polygon\nlayer and rectangle B on the layer2  polygon layer must be less than \"a\". To\ndetermine distance, rectangle A is oversized by the value \"a\". If rectangle\nA then intersects rectangle B, rectangles A and B are selected because\nrectangle B is in the checking zone  of rectangle A.\n\u2022 When the corner_extension  argument is RADIAL, the distance is a\nEuclidean distance.", "corner_extension": "Optional. Specifies the shape of the checking zone.", "measure": "Optional. Specifies how the checking zone is measured. The default is\nEDGE_TO_EDGE.\n\u2022 EDGE_TO_EDGE. Measures the distance between the borders of the\nrectangles. That is, a rectangle is counted if its check zone interacts with\nanother rectangle.\n\u2022 CENTER_TO_CENTER. Measures the distance between the centers of the\nrectangles. That is, a rectangle is counted if its check zone interacts with the\ncenter of another rectangle.\nFigure 555  shows how the corner_extension  and measure  arguments effect\nthe selection of rectangles.\nrectangle_spacing2() and not_rectangle_spacing2()", "center_to_center_direction": "Optional. Specifies the alignment of the neighboring rectangles. The default is\nALL.\nNote:\nThis argument is used only when the measure  argument is\nCENTER_TO_CENTER.\n\u2022 ALL. Counts all rectangles regardless of the alignment.\n\u2022 ORTHOGONAL. Counts a rectangle if the centerline is aligned on a multiple of\n90 degrees; that is in either the x- or y-direction.\n\u2022 OCTAGONAL. Counts a rectangle if the centerline is aligned at 45 degrees.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "inside_layer": "Optional. Selects only layer1  rectangles that are inside the polygons of this\nlayer. These rectangles must fit the specified count and distance constraints\nfor interaction with layer2  rectangles. The counting is restricted to layer1  and\nlayer2  rectangles that are inside the same inside_layer  polygon.\nNote:\nThe not_rectangle_spacing2()  function selects only layer1\nrectangles that are inside the inside_layer  polygons but do not\nfit the specified count and distance constraints for interaction with\nlayer2  rectangles.\nSee the examples in the definition of the inside_layer  argument of the\nrectangle_spacing1() and not_rectangle_spacing1()  functions.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\nrectangle_spacing2() and not_rectangle_spacing2()\n\u2022 ALL. Checks all rectangles regardless of connectivity.\nNote:\nIf inside_layer  is specified, connectivity  must be ALL.\nFigure 560  shows the effect of the connectivity  argument settings.\n// connectivity = ALL: output both 2 green rectangles.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER);\n// connectivity = SAME_NET: output only the left green rectangle\nthat has the same net as the red rectangle.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER,\nconnectivity = SAME_NET, connect_sequence = cdb);\n// connectivity = DIFFERENT_NET: output only the right green\nrectangle that has different net to the red rectangle.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER,\nconnectivity = DIFFERENT_NET, connect_sequence = cdb);\nFigure 560 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET."}, "summary": "The rectangle_spacing2()  function selects layer1  rectangles that fit the\nspecified count and distance constraints for interaction with layer2  rectangles.", "function_name": "rectangle_spacing2()"}
{"description": "The rectangle_spacing2()  function selects layer1  rectangles that fit the\nspecified count and distance constraints for interaction with layer2  rectangles. The\nnot_rectangle_spacing2()  function selects layer1  rectangles that do not fit the\nspecified count and distance constraints for interaction with layer2  rectangles.", "syntax": "rectangle_spacing2(\nlayer1                     = polygon_layer,\nlayer2                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,         //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,        //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,               //optional\nname                       = \"layer_label\",           //optional\ninside_layer               = polygon_layer            //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,     //optional\nconnect_sequence            = connect_database          //optional\n);\nnot_rectangle_spacing2(\nlayer1                     = polygon_layer,\nlayer2                     = polygon_layer,\ncount                      = integerconstraint,\ndistance                   = doubleconstraint,\ncorner_extension            = RADIAL  | SQUARE,          //optional\nmeasure                    = EDGE_TO_EDGE  |\nCENTER_TO_CENTER,         //optional\ncenter_to_center_direction  = ALL  | ORTHOGONAL |\nOCTAGONAL,                //optional\nname                       = \"layer_label\",            //optional\ninside_layer               = polygon_layer,            //optional\nconnectivity                = SAME_NET |\nDIFFERENT_NET | ALL,      //optional\nconnect_sequence            = connect_database           //optional\n);", "returns": "polygon layer or error result\nrectangle_spacing2() and not_rectangle_spacing2()", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "count": "Required. Specifies the number of layer2  orthogonal rectangles that must be in\nviolation.", "distance": "Required. Specifies the distance constraint of layer1  orthogonal rectangles\nfor potential selection. The distance definition is dependent on the\ncorner_extension  argument.\n\u2022 When the corner_extension  argument is SQUARE, the distance of a\nrectangle is checked by oversizing.\nFor example, the distance between rectangle A on the layer1  polygon\nlayer and rectangle B on the layer2  polygon layer must be less than \"a\". To\ndetermine distance, rectangle A is oversized by the value \"a\". If rectangle\nA then intersects rectangle B, rectangles A and B are selected because\nrectangle B is in the checking zone  of rectangle A.\n\u2022 When the corner_extension  argument is RADIAL, the distance is a\nEuclidean distance.", "corner_extension": "Optional. Specifies the shape of the checking zone.", "measure": "Optional. Specifies how the checking zone is measured. The default is\nEDGE_TO_EDGE.\n\u2022 EDGE_TO_EDGE. Measures the distance between the borders of the\nrectangles. That is, a rectangle is counted if its check zone interacts with\nanother rectangle.\n\u2022 CENTER_TO_CENTER. Measures the distance between the centers of the\nrectangles. That is, a rectangle is counted if its check zone interacts with the\ncenter of another rectangle.\nFigure 555  shows how the corner_extension  and measure  arguments effect\nthe selection of rectangles.\nrectangle_spacing2() and not_rectangle_spacing2()", "center_to_center_direction": "Optional. Specifies the alignment of the neighboring rectangles. The default is\nALL.\nNote:\nThis argument is used only when the measure  argument is\nCENTER_TO_CENTER.\n\u2022 ALL. Counts all rectangles regardless of the alignment.\n\u2022 ORTHOGONAL. Counts a rectangle if the centerline is aligned on a multiple of\n90 degrees; that is in either the x- or y-direction.\n\u2022 OCTAGONAL. Counts a rectangle if the centerline is aligned at 45 degrees.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "inside_layer": "Optional. Selects only layer1  rectangles that are inside the polygons of this\nlayer. These rectangles must fit the specified count and distance constraints\nfor interaction with layer2  rectangles. The counting is restricted to layer1  and\nlayer2  rectangles that are inside the same inside_layer  polygon.\nNote:\nThe not_rectangle_spacing2()  function selects only layer1\nrectangles that are inside the inside_layer  polygons but do not\nfit the specified count and distance constraints for interaction with\nlayer2  rectangles.\nSee the examples in the definition of the inside_layer  argument of the\nrectangle_spacing1() and not_rectangle_spacing1()  functions.", "connectivity": "Optional. Specifies how to consider connectivity. The default is ALL.\n\u2022 SAME_NET. Checks the rectangles that are on the same net.\n\u2022 DIFFERENT_NET. Checks the rectangles that are on different nets.\nrectangle_spacing2() and not_rectangle_spacing2()\n\u2022 ALL. Checks all rectangles regardless of connectivity.\nNote:\nIf inside_layer  is specified, connectivity  must be ALL.\nFigure 560  shows the effect of the connectivity  argument settings.\n// connectivity = ALL: output both 2 green rectangles.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER);\n// connectivity = SAME_NET: output only the left green rectangle\nthat has the same net as the red rectangle.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER,\nconnectivity = SAME_NET, connect_sequence = cdb);\n// connectivity = DIFFERENT_NET: output only the right green\nrectangle that has different net to the red rectangle.\nrectangle_spacing2(green, red, count = 1, distance < d, measure =\nCENTER_TO_CENTER,\nconnectivity = DIFFERENT_NET, connect_sequence = cdb);\nFigure 560 connectivity Argument Example", "connect_sequence": "Optional. Specifies the connect database for spacing based on connectivity. This\ndatabase must be a valid connect database when the connectivity  argument\nis SAME_NET  or DIFFERENT_NET."}, "summary": "The rectangle_spacing2()  function selects layer1  rectangles that fit the\nspecified count and distance constraints for interaction with layer2  rectangles.", "function_name": "not_rectangle_spacing2()"}
{"description": "The rectangles()  function selects rectangles in the specified layer that fit the specified\ndimensions. The not_rectangles()  function selects polygons that are not rectangles and\nalso those rectangles that do not meet the specified dimensions.", "syntax": "rectangles(\nlayer1          = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},  //optional\norientation     = ORTHOGONAL | ALL,              //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\",                 //optional\ndirection        = X_BY_Y| ALL                     //optional\n);\nnot_rectangles(\nlayer1          = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},  //optional\norientation     = ORTHOGONAL | ALL,              //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\",                 //optional\ndirection        = X_BY_Y| ALL                     //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\nvalue is optional, with a default of >0. See\nConstraints  on page 3344 for more\ninformation.", "orientation": "Optional. Specifies the orientation of rectangles selected. The default is ALL.\nrectangles() and not_rectangles()\n\u2022 ORTHOGONAL. Selects only orthogonal rectangles.\n\u2022 ALL. Selects rectangles regardless of orientation.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "direction": "Optional. Specifies how the constraints in the sides  argument apply to\nrectangles. The default is ALL.\n\u2022 X_BY_Y. Specifies that length1  in the sides  argument applies in the x-\ndirection, and length2  applies in the y-direction. The argument is available\nonly when orientation = ORTHOGONAL.\n\u2022 ALL. Specifies that the lengths of the sides  argument apply to the sides of\nthe rectangle, one per side without fixed directions.\nrectangles() and not_rectangles()\nFigure 564 Rectangle() Function Examples"}, "summary": "The rectangles()  function selects rectangles in the specified layer that fit the specified\ndimensions.", "function_name": "rectangles()"}
{"description": "The rectangles()  function selects rectangles in the specified layer that fit the specified\ndimensions. The not_rectangles()  function selects polygons that are not rectangles and\nalso those rectangles that do not meet the specified dimensions.", "syntax": "rectangles(\nlayer1          = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},  //optional\norientation     = ORTHOGONAL | ALL,              //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\",                 //optional\ndirection        = X_BY_Y| ALL                     //optional\n);\nnot_rectangles(\nlayer1          = polygon_layer,\nsides           = {length1 = doubleconstraint,\nlength2 = doubleconstraint},  //optional\norientation     = ORTHOGONAL | ALL,              //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,     //optional\nname            = \"layer_label\",                 //optional\ndirection        = X_BY_Y| ALL                     //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "sides": "Optional. Specifies the dimensions of the rectangles that are selected using two\nlengths, one per side. The dimensions must be greater than 0. The length2\nvalue is optional, with a default of >0. See\nConstraints  on page 3344 for more\ninformation.", "orientation": "Optional. Specifies the orientation of rectangles selected. The default is ALL.\nrectangles() and not_rectangles()\n\u2022 ORTHOGONAL. Selects only orthogonal rectangles.\n\u2022 ALL. Selects rectangles regardless of orientation.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "direction": "Optional. Specifies how the constraints in the sides  argument apply to\nrectangles. The default is ALL.\n\u2022 X_BY_Y. Specifies that length1  in the sides  argument applies in the x-\ndirection, and length2  applies in the y-direction. The argument is available\nonly when orientation = ORTHOGONAL.\n\u2022 ALL. Specifies that the lengths of the sides  argument apply to the sides of\nthe rectangle, one per side without fixed directions.\nrectangles() and not_rectangles()\nFigure 564 Rectangle() Function Examples"}, "summary": "The rectangles()  function selects rectangles in the specified layer that fit the specified\ndimensions.", "function_name": "not_rectangles()"}
{"description": "The rectangles_interacting()  function oversizes orthogonal rectangles from the input\nlayer that meet the specified dimensions. The function then selects rectangles based on\nthe interaction of the oversized rectangles.\nNote:\nNonrectangular and nonorthogonal data is ignored.\nEach edge of a rectangle must fit one of the length specifications for the\nrectangle to be oversized.\nThe complement of this function is the not_rectangles_interacting()  function. It\nselects all nonrectangular and nonorthogonal data without measurement.", "syntax": "rectangles_interacting(\nlayer1           = polygon_layer,\nlength1          = doubleconstraint,\nlength2          = doubleconstraint,\nsize1             = double,\nsize2             = double,\ncount             = integerconstraint,       //optional\ncorner_extension = CLIP  | RADIAL | SQUARE,  //optional\ninclude_touch    = NONE | ALL,              //optional\nname             = \"layer_label\"            //optional\n);\nnot_rectangles_interacting(\nlayer1           = polygon_layer,\nlength1          = doubleconstraint,\nlength2          = doubleconstraint,\nsize1             = double,\nsize2             = double,\ncount             = integerconstraint,       //optional\ncorner_extension = CLIP  | RADIAL | SQUARE,  //optional\ninclude_touch    = NONE | ALL,              //optional\nname             = \"layer_label\"            //optional\n);", "returns": "polygon layer or error result\nrectangles_interacting() and not_rectangles_interacting()", "arguments": {"layer1": "Required. Specifies the polygon layer.", "length1": "Required. Specifies the length for one side of the rectangles. See\nConstraints  on\npage 3344 for more information.", "length2": "Required. Specifies the length for one side of the rectangles. See Constraints  on\npage 3344 for more information.\nNote:\nIf both edges fit both length specifications, the shortest edge gets the\nsmallest oversize. For a square, the largest oversize is used for the\ntop and bottom expansions, while the smallest oversize is used for\nthe left and right expansions.\nIf only one edge fits both length specifications, the other edge\nis oversized for the length it fits. The edge that fits both length\nspecifications is oversized for the other length.", "size1": "Required. Specifies the oversize distance for edges that fit the length1  value. A\nvalue of 0 or less means the edge is not oversized.\nNote:\nIf both size arguments are 0 or less, the output is empty.", "size2": "Required. Specifies the oversize distance for edges that fit the length2  value. A\nvalue of 0 or less means the edge is not oversized.", "count": "Optional. Specifies the number of interactions that must be met by the oversize\nof the rectangle for it to be selected. The default is >0.", "corner_extension": "Optional. Specifies how corners are processed in the sizing operation. The\nlayer1  rectangle edges that meet the dimensions specified by the length1  and\nlength2  arguments are oversized based on the dimensions specified by the\nsize1  and size2  arguments, respectively. The result of all oversizing operations\nforms the check region. The default is CLIP.\nrectangles_interacting() and not_rectangles_interacting()\n\u2022 CLIP. Clips corners by connecting the endpoints of oversized adjacent\nedges. Figure 565  shows oversizing corners by clipping.\nFigure 565 Clipped Corners\n\u2022 RADIAL. Oversizes corners into radial arcs that connect the endpoints of\noversized adjacent edges. This setting requires that the size1  and size2\narguments have the same value. Figure 566  shows oversizing corners into\nradial arcs.\nFigure 566 Corners Oversized Into Radial Arcs\nrectangles_interacting() and not_rectangles_interacting()\n\u2022 SQUARE. Oversizes corners to form squares. This setting requires that the\nsize1  and size2  arguments have the same value. Figure 567  shows\noversizing corners to form squares.\nFigure 567 Corners Oversized to Form Squares", "include_touch": "Optional. Specifies the outside touches that cause a layer1  polygon to be\nselected.\n\u2022 NONE. Specifies that neither point touches nor edge touches cause a polygon\nto be selected.\n\u2022 ALL. Specifies that both edge touches and point touches cause a polygon to\nbe selected.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The rectangles_interacting()  function oversizes orthogonal rectangles from the input\nlayer that meet the specified dimensions.", "function_name": "rectangles_interacting()"}
{"description": "The rectangles_interacting()  function oversizes orthogonal rectangles from the input\nlayer that meet the specified dimensions. The function then selects rectangles based on\nthe interaction of the oversized rectangles.\nNote:\nNonrectangular and nonorthogonal data is ignored.\nEach edge of a rectangle must fit one of the length specifications for the\nrectangle to be oversized.\nThe complement of this function is the not_rectangles_interacting()  function. It\nselects all nonrectangular and nonorthogonal data without measurement.", "syntax": "rectangles_interacting(\nlayer1           = polygon_layer,\nlength1          = doubleconstraint,\nlength2          = doubleconstraint,\nsize1             = double,\nsize2             = double,\ncount             = integerconstraint,       //optional\ncorner_extension = CLIP  | RADIAL | SQUARE,  //optional\ninclude_touch    = NONE | ALL,              //optional\nname             = \"layer_label\"            //optional\n);\nnot_rectangles_interacting(\nlayer1           = polygon_layer,\nlength1          = doubleconstraint,\nlength2          = doubleconstraint,\nsize1             = double,\nsize2             = double,\ncount             = integerconstraint,       //optional\ncorner_extension = CLIP  | RADIAL | SQUARE,  //optional\ninclude_touch    = NONE | ALL,              //optional\nname             = \"layer_label\"            //optional\n);", "returns": "polygon layer or error result\nrectangles_interacting() and not_rectangles_interacting()", "arguments": {"layer1": "Required. Specifies the polygon layer.", "length1": "Required. Specifies the length for one side of the rectangles. See\nConstraints  on\npage 3344 for more information.", "length2": "Required. Specifies the length for one side of the rectangles. See Constraints  on\npage 3344 for more information.\nNote:\nIf both edges fit both length specifications, the shortest edge gets the\nsmallest oversize. For a square, the largest oversize is used for the\ntop and bottom expansions, while the smallest oversize is used for\nthe left and right expansions.\nIf only one edge fits both length specifications, the other edge\nis oversized for the length it fits. The edge that fits both length\nspecifications is oversized for the other length.", "size1": "Required. Specifies the oversize distance for edges that fit the length1  value. A\nvalue of 0 or less means the edge is not oversized.\nNote:\nIf both size arguments are 0 or less, the output is empty.", "size2": "Required. Specifies the oversize distance for edges that fit the length2  value. A\nvalue of 0 or less means the edge is not oversized.", "count": "Optional. Specifies the number of interactions that must be met by the oversize\nof the rectangle for it to be selected. The default is >0.", "corner_extension": "Optional. Specifies how corners are processed in the sizing operation. The\nlayer1  rectangle edges that meet the dimensions specified by the length1  and\nlength2  arguments are oversized based on the dimensions specified by the\nsize1  and size2  arguments, respectively. The result of all oversizing operations\nforms the check region. The default is CLIP.\nrectangles_interacting() and not_rectangles_interacting()\n\u2022 CLIP. Clips corners by connecting the endpoints of oversized adjacent\nedges. Figure 565  shows oversizing corners by clipping.\nFigure 565 Clipped Corners\n\u2022 RADIAL. Oversizes corners into radial arcs that connect the endpoints of\noversized adjacent edges. This setting requires that the size1  and size2\narguments have the same value. Figure 566  shows oversizing corners into\nradial arcs.\nFigure 566 Corners Oversized Into Radial Arcs\nrectangles_interacting() and not_rectangles_interacting()\n\u2022 SQUARE. Oversizes corners to form squares. This setting requires that the\nsize1  and size2  arguments have the same value. Figure 567  shows\noversizing corners to form squares.\nFigure 567 Corners Oversized to Form Squares", "include_touch": "Optional. Specifies the outside touches that cause a layer1  polygon to be\nselected.\n\u2022 NONE. Specifies that neither point touches nor edge touches cause a polygon\nto be selected.\n\u2022 ALL. Specifies that both edge touches and point touches cause a polygon to\nbe selected.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The rectangles_interacting()  function oversizes orthogonal rectangles from the input\nlayer that meet the specified dimensions.", "function_name": "not_rectangles_interacting()"}
{"description": "The reduce_four_color_graph()  function is used in quadruple-patterning flows to\noutput a smaller layout after graph reduction. Optional node precoloring is also input to the\nfunction. Precolored nodes are not deleted during graph reduction.", "syntax": "Note: The definitions for the arguments are after the Returns section.\nreduce_four_color_graph(\nnodes             = polygon_layer,\nlinks             = geometry_layer,\npre_color1        = polygon_layer,    //optional\npre_color2        = polygon_layer,    //optional\npre_color3        = polygon_layer,    //optional\npre_color4        = polygon_layer,    //optional\niterative        = true | false,     //optional\npre_color_reduce = true | false      //optional\n);", "returns": "The output is a structure of polygons:\nreduce_four_color_graph_result_s : newtype struct of {\nhigh_degree_nodes                    : polygon_layer;\ncomponent_nodes                      : polygon_layer;\ncomponent_links                      : polygon_layer;\nsubgraphs                            : polygon_layer;\n};\nhigh_degree_nodes\nThe output contains the nodes  polygons that remain after low-degree <4 node\ndeletion. When iterative reduction is enabled (the iterative  option is set to\ntrue), the output layer is empty.\ncomponent_nodes\nThe output contains the nodes that designate the components of the graph from\ncut vertices. When iterative reduction is disabled (the iterative  argument is\nfalse), and pre_color_reduce  is enabled (the pre_color_reduce  argument\nis true), the output layer is empty. When iterative reduction is enabled (the\niterative  option is true), the output contains only the component nodes that\nare part of the subgraphs.\nFor an example of cut vertices, see\nFigure 571.\nreduce_four_color_graph()\ncomponent_links\nThe output contains the links that designate the components of the graph from\ntwo-edge cuts. When iterative reduction is enabled (the iterative  option is set\nto true), the output layer is empty.\nFor an example of two-edge cuts, see\nFigure 572.\nsubgraphs\nThe output contains the nodes and links found as subgraphs when iterative\nreduction is enabled. Otherwise, the output layer is empty.", "arguments": {"nodes": "Required. Specifies the polygon layer that contains the polygons targeted for\ncoloring.", "links": "Required. Specifies the input geometry layer that contains polygons that connect\nnodes  polygons to complete the graph description. Each polygon in the links\ngeometry layer interacts, either by edge touch or polygon overlap, with the\nnodes  polygons.\nThe links  geometry layer is commonly generated using dimensional\ncommands on the nodes  polygon layer. For example, the links  geometry layer\ncan be generated by using an external spacing check on the nodes  polygon\nlayer that captures multiple-patterning critical spacing relationships.\nNote:\nedge_layer  is no longer a valid input of links. It is recommended to\nuse error layer as an input.", "pre_color1": "Optional. Specifies the marker layers representing color 1 precoloring of the\npolygons. All the polygons must be included in the nodes  layer. The precolors\nare markers on the nodes. If a precolor marker does not intersect with any node,\nthe marker is ignored.", "pre_color2": "Optional. Specifies the marker layers representing color 2 precoloring of the\npolygons. See\npre_color1  for more information.", "pre_color3": "Optional. Specifies the marker layers representing color 3 precoloring of the\npolygons. See\npre_color1  for more information.\nreduce_four_color_graph()", "pre_color4": "Optional. Specifies the marker layers representing color 4 precoloring of the\npolygons. See\npre_color1  for more information.", "iterative": "Optional. Specifies whether the reduce_four_color_graph()  function\nperforms iterative reduction on the input graph, which is constructed from the\nnodes and links of the layout. The default is false.\n\u2022 true. Processes the input graph to apply reductions and find components\niteratively. A component is a part of the input graph obtained after certain\nreduction operations. When no further reduction is applicable, the component\nbecomes a subgraph.\n\u2022 false. Does not perform iterative reduction on the input graph.", "pre_color_reduce": "Optional. Specifies whether the reduce_four_color_graph()  function\nperforms filtering on the precolored data before graph reduction. The default is\nfalse.\n\u2022 true. Enables filtering of precolored data.\n\u2022 false. Disables filtering of precolored data.\nPrecolor filtering filters both links that interact only with precolored nodes and\nprecolored polygons that do not interact with uncolored polygons through a\nlink. See\nFigure 573, in the reduce_three_color_graph()  function for more\ninformation on precolor reduction."}, "summary": "The reduce_four_color_graph()  function is used in quadruple-patterning flows to\noutput a smaller layout after graph reduction.", "function_name": "reduce_four_color_graph()"}
{"description": "The reduce_three_color_graph()  function is used in triple-patterning flows to output a\nsmaller layout after graph reduction. Optional node precoloring is also input to the function.\nPrecolored nodes are not deleted during graph reduction.", "syntax": "Note: The definitions for the arguments are after the Returns section.\nreduce_three_color_graph(\nnodes             = polygon_layer,\nlinks             = geometry_layer,\npre_color1        = polygon_layer,    //optional\npre_color2        = polygon_layer,    //optional\npre_color3        = polygon_layer,    //optional\niterative        = true | false,     //optional\npre_color_reduce = true | false      //optional\n);", "returns": "The output is a structure of polygons:\nreduce_three_color_graph_result_s : newtype struct of {\nhigh_degree_nodes                    : polygon_layer;\ncomponent_nodes                      : polygon_layer;\ncomponent_links                      : polygon_layer;\nsubgraphs                            : polygon_layer;\n};\nhigh_degree_nodes\nThe output contains the nodes  polygons that remain after low-degree <3 node\ndeletion. When iterative reduction is enabled (the iterative  option is set to\ntrue), the output layer is empty.\ncomponent_nodes\nThe output contains the nodes that designate the components of the graph from\ncut vertices. Otherwise, the output layer is empty. When iterative reduction is\nenabled (the iterative  option is set to true), the output contains only the\ncomponent nodes that are part of the subgraphs.\nIn the graph shown in\nFigure 571, node A is a cut node. Removing this node\nbreaks the graph into two components.\nreduce_three_color_graph()\nFigure 571 Example of Cut Vertices\ncomponent_links\nThe output contains the links that designate the components of the graph from\ntwo-edge cuts. When iterative reduction is enabled (the iterative  option is set\nto true), the output layer is empty.\nNote:\nWhen iterative=false, the output of the component_links\nargument might be different when setting the pre_color_reduce\noption to true  or false.\nIn the example shown in\nFigure 572, edges P and Q form a two-edge cut, the\nremoval of these edges breaks the graph into two components.\nFigure 572 Example of Two-Edge Cuts\nsubgraphs\nThe output contains the nodes and links found as subgraphs when iterative\nreduction is enabled. Otherwise, the output layer is empty.", "arguments": {"nodes": "Required. Specifies the polygon layer that contains the polygons targeted for\ncoloring.", "links": "Required. Specifies the input geometry layer that contains polygons that connect\nnodes  polygons to complete the graph description. Each polygon in the links\nreduce_three_color_graph()\ngeometry layer interacts, either by edge touch or polygon overlap, with nodes\npolygons.\nThe links  geometry layer is commonly generated using dimensional\ncommands on the nodes  polygon layer. For example, the links  geometry layer\ncan be generated by using an external spacing check on the nodes  polygon\nlayer that captures triple-patterning critical spacing relationships.\nNote:\nedge_layer  is no longer a valid input of links. It is recommended to\nuse error layer as an input.", "pre_color1": "Optional. Specifies the marker layers representing color 1 precoloring of the\npolygons. All the polygons must be included in the nodes  layer. The precolors\nare markers on the nodes. If a precolor marker does not intersect with any node,\nthe marker is ignored.", "pre_color2": "Optional. Specifies the marker layers representing color 2 precoloring of the\npolygons. See\npre_color1  for more information.", "pre_color3": "Optional. Specifies the marker layers representing color 3 precoloring of the\npolygons. See\npre_color1  for more information.", "iterative": "Optional. Specifies whether the reduce_three_color_graph()  function\nperforms iterative reduction on the input graph, which is constructed from the\nnodes and links of the layout. The default is false.\n\u2022 true. Processes the input graph to apply reductions and find components\niteratively. A component is a part of the input graph obtained after certain\nreduction operations. When no further reduction is applicable, the component\nbecomes a subgraph.\n\u2022 false. Does not perform iterative reduction on the input graph.", "pre_color_reduce": "Optional. Specifies whether the reduce_three_color_graph()  function\nperforms filtering on the precolored data before graph reduction. The default is\nfalse.\n\u2022 true. Enables filtering of precolored data.\n\u2022 false. Disables filtering of precolored data.\nreduce_three_color_graph()\nPrecolor filtering filters both links that interact only with precolored nodes and\nprecolored polygons that do not interact with uncolored polygons through a link.\nIn\nFigure 573, shapes A, B, C, and D are precolored. E is uncolored. After\nprecolor reduction, shapes A and C are filtered out and links 1, 2, 3, and 4 are\nalso filtered out.\nFigure 573 Precolor Reduction"}, "summary": "The reduce_three_color_graph()  function is used in triple-patterning flows to output a\nsmaller layout after graph reduction.", "function_name": "reduce_three_color_graph()"}
{"description": "The redundant_vias()  function identifies redundant via polygons and saves properties\nto each output redundant via polygon. The redundant via polygon is defined as a polygon\nthat can be removed without affecting the connectivity of the input layers. Any via polygon\nthat interacts with zero or one layer is not checked or output.", "syntax": "redundant_vias(\nlayers = {{layer            = polygon_layer,\noutput_layer_key = \"string\",\noutput_type      = REDUNDANT  | NON_REDUNDANT,    //optional\nsave_properties  = {group_id       = \"string\",\nvia_count      = \"string\",\nall_vias_count = \"string\"}},\n...},                        //optional\nconnect_items         = {{layer1   = polygon_layer,\nby_layer =  polygon_layer,\nlayer2   =  polygon_layer},\n...},\nflatten                = true | false,                       //optional\nmin_via_overlap_ratio = double,                             //optional\nname                  = \"layer_label\",                      //optional\nsubdivide_groups      = true | false                        //optional\n);", "returns": "The output is a hash of string to polygon layer.", "arguments": {"layers": "Required. Specifies the output. Each item in the layers  argument corresponds\nto the output_layer_key  -> polygon_layer  in the output hash.\n\u2022 layer\nRequired. Specifies the input polygon layer. This layer must be specified as a\nby_layer  in the connect_items  argument.\n\u2022 output_layer_key\nRequired. Identifies the output layer in the output hash.\n\u2022 output_type\nOptional. Specifies the type of output generated. The default is REDUNDANT.\nredundant_vias()\n\u25e6 REDUNDANT. Returns all redundant via polygons.\n\u25e6 NON_REDUNDANT. Returns non-redundant via polygons. Any via that does\nnot meet the criteria of a redundant via polygon is considered as a non-\nredundant via, except those malfunctioning vias that interact with zero or\none layer.\n\u2022 save_properties\nOptional. Specifies the properties to attach to the output shapes. This option\nworks only when output_type=REDUNDANT. The properties are collected\nwithin the same redundant via group. A redundant via group is defined\nas the largest set of redundant vias that are connected together when all\nnon-redundant vias are removed. The default is an empty string (\"\"). Any\nproperty with an empty string specified is not saved.\n\u25e6 group_id. Specifies a user-defined property that contains a unique\nnumeric value for each redundant via group. This value might vary\nbetween runs.\n\u25e6 via_count. Specifies the number of shapes from the layer  within the\nsame redundant via group.\n\u25e6 all_vias_count. Specifies the number of shapes from the by_layer  in\nthe connect_items  argument within the same redundant via group.", "connect_items": "Required. Lists the connection specifications.\n\u2022 layer1. Required. Specifies the layer1  polygons.\n\u2022 by_layer. Optional. Specifies the via layer by which layer1  and layer2  are\nconnected.\n\u2022 layer2. Required. Specifies the layer2  polygons.", "flatten": "Optional. Specifies whether the operation runs in hierarchical or flatten mode.\nThe default is false.\n\u2022 true. Specifies that output polygons are saved in the top cell.\n\u2022 false. Specifies that the operation runs in hierarchical mode. In this mode,\noutput polygons are saved in the lower cell, if possible.", "min_via_overlap_ratio": "Optional. Specifies the minimum overlap area of a via within Mi/Mi+1 transition.\nAny via polygon with a ratio of via overlap area within Mi/Mi+1 transition to total\nredundant_vias()\nvia area, greater than or equal to this value, is a valid via polygon to check. The\nvalue must be between 0.5  and 1. The default is 0.5.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "subdivide_groups": "Optional. Specifies if redundant groups are to be subdivided into smaller\ngroups. The subdivide_groups  argument applies only when output_type  is\nREDUNDANT, and affects only the behavior of the save_properties  argument.\nThe default is false.\n\u2022 true. Subdivides each redundant group as follows:\nAll vias between a given pair of Mx/Mx+1 polygons are replaced with a single\npseudo-via. The pseudo-vias are segregated between non-redundant and\nredundant, (with non-redundant being those that change connectivity if\nremoved). Groups are formed by redundant pseudo-vias that are connected\nwhen non-redundant pseudo-vias are removed. Additionally, each non-\nredundant pseudo-via forms a separate group.\n\u2022 false. Connects redundant group vias when non-redundant vias are\nremoved."}, "summary": "The redundant_vias()  function identifies redundant via polygons and saves properties\nto each output redundant via polygon.", "function_name": "redundant_vias()"}
{"description": "The remove_fill()  function removes rectangles that share active area with a blocking\nlayer. Rectangles from AREFs (array references) are reformed as AREFs or SREFs\n(structured references) as much as possible. As a result, new cells and new placements\nmight be created in the output layer.\nTo keep the remaining rectangles as AREFs or SREFs, the layer1  polygon layer must\ncontain only AREFs of rectangles; that is, an output layer created when the output_aref\nargument of the fill_pattern()  function is true. If the constraints on the layer1\npolygon layer are not met, the function behaves as the outside()  function and explodes\nthe remaining rectangles in AREFs that have some rectangles removed.\nRectangles that are outside the blocking layer, including point and line touches, are kept in\nthe output layer.", "syntax": "remove_fill(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\ncell_prefix      = \"string\",            //optional\ngroup_by_cell   = true | false,        //optional\nremove           = OVERLAP  | OUTSIDE,   //optional\nname            = \"layer_label\"        //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "layer2": "Required. Specifies the blocking polygon layer.", "cell_prefix": "Optional. Specifies the prefix for all cell names created when fill is removed and\nreformed. The default is \"$RF\". For example, if the cell_prefix  argument\nis not set, then the generated cell name is of this form: \u201c$RF_1x1s_1\u201d. If the\ncell_prefix  argument is \u201cpre\u201d, then the generated cell name is of this form:\n\u201cpre_1x1s_1\u201d.\nremove_fill()", "group_by_cell": "Optional. Specifies whether to remove additional polygons. The default is false.\n\u2022 true. In addition to removing the polygons identified by layer2, also\nremoves any other polygons that belong to the same AREF cell instance as\nthe polygons identified by layer2.\n\u2022 false. Does not remove additional polygons.", "remove": "Optional. Specifies whether to delete polygons that interact with layer2\npolygons. The default is OVERLAP.\n\u2022 OVERLAP. Deletes polygons that interact with layer2  polygons.\n\u2022 OUTSIDE. Deletes polygons that are outside of layer2  polygons.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The remove_fill()  function removes rectangles that share active area with a blocking\nlayer.", "function_name": "remove_fill()"}
{"description": "The remove_fill_to_target()  function removes cell and stack fill patterns to meet the\nrequired density, based on the input polygon and other arguments.", "syntax": "remove_fill_to_target(\nwindow_layer       = polygon_layer,\ndesign_layer       = polygon_layer,\nfill_layer         = polygon_layer,\nframe_layer        = polygon_layer,\ncell_stack_pattern = {width = double, height = double,\nspace_x = double, space_y = double,\nstagger_x = double, stagger_y = double},\nmax_target_density = double,\nstack_density      = double,                                //optional\ndelta_window       = double,                                //optional\ndelta_step         = double,                                //optional\noutput_aref        = {output_aref = true | false,\ncell_prefix = \"string\"},              //optional\nname               = \"layer_label\",                         //optional\nboundary           = CLIP  | ALIGN | IGNORE | REPLICATE_WINDOW\n//optional\ngradient            = {range  = doubleconstraint,\ncomparison   = ABSOLUTE  | RELATIVE,\ncheck_corner = true | false},\n//optional\ngradient_delta_window  = {width = double, height = double},  //optional\ngradient_delta_x       = double,                             //optional\ngradient_delta_y       = double                             //optional\n);", "returns": "polygon layer", "arguments": {"window_layer": "Required. Specifies the polygon layer containing one or more polygons that\ndefine the areas where layers are processed for density calculations and fill\nremoval.", "design_layer": "Required. Specifies the non-fill polygon layer to be used for density calculations.\nremove_fill_to_target()", "fill_layer": "Required. Specifies the polygon layer to be used for density calculations and is\nthe input for fill removal.", "frame_layer": "Required. Specifies the polygon layer that defines the boundaries of individual\nfill cells/stack and is the input for fill removal.", "cell_stack_pattern": "Required. Specifies the fill cell-chain description.\n\u2022 width. Required. Specifies the width of the fill cell chain.\n\u2022 height. Required. Specifies the height of the fill cell chain.\n\u2022 space_x. Required. Specifies the distance between the fill cell chain in the x-\ndirection.\n\u2022 space_y. Required. Specifies the distance between the fill cell chain in the y-\ndirection.\n\u2022 stagger_x. Optional. Specifies the stagger distance between the fill cell\nchain in the x-direction. The default is 0.\n\u2022 stagger_y. Optional. Specifies the stagger distance between the fill cell\nchain in the y-direction. The default is 0.", "max_target_density": "Required. Specifies the maximum target density to be achieved as the result of\nfill removal.", "stack_density": "Optional. Specifies the density introduced by fill polygons of one individual cell\nchain. The IC Validator tool calculates the value when it is not specified.", "delta_window": "Optional. Specifies a square subwindow stepped across each window layer\npolygon. The density is evaluated within each subwindow. The default is 10.", "delta_step": "Optional. Specifies the delta_window  subwindow step distance in the x- and y-\ndirection. The default is 10.", "output_aref": "Optional. Specifies whether to keep fill as AREFs (array references) during fill\nremoval.\nremove_fill_to_target()\n\u2022 output_aref. The default is false.\n\u25e6 true. Outputs polygons in AREFs.\n\u25e6 false. Outputs individual polygons.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cell names created when\nfill is removed and reformed. The default is \"$RT\".", "name": "Optional. Specifies the label used by the IC Validator tool for the output files.\nThis name is displayed in various output report files. It is used only for log files;\nrunset variables are not changed. If the name is not specified, default output file\nnames are created.", "boundary": "Optional. Specifies how to process a delta_window  subwindow that overlaps\nthe boundary of the extents of a window layer polygon. The default is CLIP.\n\u2022 CLIP. Truncates the subwindow at the limits of the window layer.\nif the x_edge_process_amount  or y_edge_process_amount  argument is not\nequal to -1 when the boundary  argument is CLIP, then\n\u25e6 If the overhang is less than the x_edge_process_amount  or\ny_edge_process_amount  value, a clip is performed.\n\u25e6 If the overhang is equal to or greater than the x_edge_process_amount\nor y_edge_process_amount  value, an align is performed.\n\u25e6 If the overhang in the horizontal direction is less than the\nx_edge_process_amount  value, then clip the subwindow along the\nwindow layer.\n\u25e6 If the overhang in the horizontal direction is equal to or greater than\nthe x_edge_process_amount  value, then align the subwindow with the\nwindow layer\n\u25e6 If the overhang in the vertical direction is less than\ny_edge_process_amount  value, then clip the u along the window layer\n\u25e6 If the overhang in the vertical direction is equal or more than\ny_edge_process_amount  value, then align the subwindow with the\nwindow layer\nremove_fill_to_target()\nFigure 583  shows how a subwindow is clipped.\nFigure 583 boundary = CLIP Example\n\u2022 ALIGN. If a subwindow overlaps the right side or top edge of the window\nlayer, shifts the window left or down until it no longer overlaps the window\nlayer. The density calculation is performed after the window is shifted.\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is ALIGN.\nFigure 584  shows how a subwindow is aligned.\nFigure 584 boundary = ALIGN Example\nremove_fill_to_target()\n\u2022 IGNORE. If a subwindow overlaps the right or top edges of the window\nlayer boundary, ignores the subwindow and does not output data for that\nsubwindow location.\nNote:\nBoth x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is IGNORE.\nFigure 585  shows when the subwindow is ignored.\nFigure 585 boundary = IGNORE Example\n\u2022 REPLICATE_WINDOW. To simulate density measurements on a die, replicates\nthe input layers to properly measure density at the boundary of the chip. If\na window overlaps the right or top edges of the window layer polygons, the\nwindow layer extent and its data is duplicated and added to the right or top\nside of the original bounding box. The density measurement on the boundary\nsubwindow is calculated considering the original data and the duplicated\ndata.\nremove_fill_to_target()\nNote:\nBoth the x_edge_process_amount  and y_edge_process_amount\narguments must be -1 when the boundary  argument is\nREPLICATE_WINDOW.\nFigure 586  shows a replicated subwindow.\nFigure 586 boundary = REPLICATED Example", "gradient": "Defines the gradient window criteria. The values for comparison are obtained\nfrom the default equation or window function. To turn off the gradient check\nfeature, specify a 0 for the width or height of the gradient delta window.\n\u2022 range. Specifies the range of acceptable values. The default is <=0.05\n\u2022 comparison. Checks the gradient value based on a relative or absolute\ndifference. The default is ABSOLUTE.\nremove_fill_to_target()\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference.\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n\u2022 check_corner. Specifies if a corner-to-corner check is required. The default\nis false.", "gradient_delta_window": "Optional. Specifies the subwindow specific to gradient calculations stepped\nacross each window layer polygon. The criteria equations are evaluated within\neach subwindow. The default is one quarter of the delta_window  values.", "gradient_delta_x": "Optional. Specifies the gradient_delta_window  subwindow step distance in\nthe x-direction. This is specific to gradient calculations. The default is the width\noption of the delta_window  argument.", "gradient_delta_y": "Optional. Specifies the gradient_delta_window  subwindow step distance in\nthe y-direction. This is specific to gradient calculations. The default is the height\noption of the delta_window  argument."}, "summary": "The remove_fill_to_target()  function removes cell and stack fill patterns to meet the\nrequired density, based on the input polygon and other arguments.", "function_name": "remove_fill_to_target()"}
{"description": "The remove_jogs()  function creates a simple polygon to pass to other processing and\ndata creation steps.", "syntax": "remove_jogs(\nlayer1    = polygon_layer,\nx_length  = double,         //optional\ny_length  = double,         //optional\nadjacent  = true | false,   //optional\nname      = \"layer_label    //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "x_length": "Optional. Specifies jog lengths to be removed in the x-direction.", "y_length": "Optional. Specifies jog lengths to be removed in the y-direction.", "adjacent": "Optional. Specifies jogs that are adjacent to the x- and y-directions to be\nremoved. The default is false.", "name": "Optional. Specifies the label used by the IC Validator tool for the output files.\nThis name is displayed in various output report files. It is used only for log files;\nrunset variables are not changed. If the name is not specified, default output file\nnames are created."}, "summary": "The remove_jogs()  function creates a simple polygon to pass to other processing and\ndata creation steps.", "function_name": "remove_jogs()"}
{"description": "The remove_layout_devices()  function takes a layout netlist handle and returns a\nmodified layout netlist database. The primary reason for using this function instead of the\nfilter()  function is when the filtered device pins are shorted, and the resulting shorts\nmust be propagated hierarchically, therefore shorting ports across the cells.", "syntax": "remove_layout_devices(\nlayout         = layout_netlist_file_handle,\nremove_devices = {\n{device_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR |\nGENERIC,\ndevice_names = {\"string\", ...},           //optional\nshort_pins   = {\"string\", ...},           //optional\nproperties   = {name  = \"string\",\nvalue = doubleconstraint,},\n},                         //optional\n}\n);", "returns": "layout_netlist_file_handle", "arguments": {"layout": "Required. Specifies the layout netlist database handle.", "remove_devices": "Required. Specifies devices to be removed. <device_type, device_name>  pair\ncannot be duplicated, or the tool issues an error message.\n\u2022 device_type. Required. Specifies the device type.\n\u2022 device_names. Optional. Specifies the device name to be filtered. Each\ndevice must match a device specified in a device_name  argument of a\ndevice configuration function. No wildcard use is permitted. By default, all\ndevices of the type specified in this argument are filtered.\n\u2022 short_pins. Optional. Specifies the pin names used to short the pin nets\ntogether. If no pins are listed as short pins, all pins remain open or floating\nafter the devices are removed. When pins are listed for short pins, only those\nremove_layout_devices()\npins listed are shorted to each other. Any remaining pins not specified as\nshort pins remain open or floating after the devices are removed.\nNote:\nAll pin nets specified in the short pins are shorted together. You\ncannot short pins by group.\nFor example,\nshort_pins = {\"A\", \"B\", \"C\", \"D\"}\nThe pin nets on pin \"A\", \"B\", \"C\", \"D\" are shorted together. There is no rule\nfor shorting \"A\" only to \"B\" and \"C\" only to \"D\". If a pin name listed in the\nshort_pins  does not exist in a corresponding device, an error message is\nissued.\n\u2022 properties. Optional. Specifies the property constraints used to removes\ndevices depending on the value of the properties on the device. If there are\nmultiple constraints, a device must first meet all the constraint criteria to be\nfiltered.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value.\nIf property w=5, l=3,or r  does not exist, and the following property\nconstraint is listed:\nproperties = {\n{name=\"w\", value=<5},\n{name=\"l\", value=<5},\n{name=\"r\", value=>5},\n}\nA warning message is issued because the property constraint is specified but\nthe device does not have that property."}, "summary": "The remove_layout_devices()  function takes a layout netlist handle and returns a\nmodified layout netlist database.", "function_name": "remove_layout_devices()"}
{"description": "The remove_schematic_devices()  function takes a schematic netlist handle and returns\na modified schematic netlist database. The primary reason for using this function instead\nof the filter()  function is when the filtered device pins are shorted, and the resulting\nshorts must be propagated hierarchically, therefore shorting ports across the cells.", "syntax": "remove_schematic_devices(\nschematic      = schematic_netlist_file_handle,\nremove_devices = {\n{device_type  = NMOS | PMOS | NPN | PNP | PN | NP |\nRESISTOR | CAPACITOR | INDUCTOR |\nGENERIC,\ndevice_names = {\"string\", ...},           //optional\nshort_pins   = {\"string\", ...},           //optional\nproperties   = {name  = \"string\",\nvalue = doubleconstraint,},\nshort_pins_groups =\n{\"string\", ...}           //optional\n},                         //optional\n}\n);", "returns": "schematic_netlist_file_handle", "arguments": {"schematic": "Required. Specifies the input netlist database and requires this netlist to process\nfiltering. The input netlist database is not modified after filtering. A new filtered\nnetlist database is returned.", "remove_devices": "Required. Specifies devices to be removed. A <device_type, device_name>\npair cannot be duplicated, or the tool issues an error message.\n\u2022 device_type. Required. Specifies the device type.\n\u2022 device_names. Optional. Specifies the device name to be filtered. Each\ndevice must match a device specified in a device_name  argument of a\ndevice configuration function. No wildcard use is permitted. By default, all\ndevices of the type specified in this argument are filtered.\nremove_schematic_devices()\n\u2022 short_pins. Optional. Specifies the pin names used to short the pin nets\ntogether. If no pins are listed as short pins, all pins remain open or floating\nafter the devices are removed. When pins are listed for short pins, only\nthose pins listed are shorted to each other. Any remaining pins not specified\nas short pins remain open or floating after the devices are removed. For\nexample:\nsch_db = remove_schematic_devices(\nschematic = sch_db,\nremove_devices = {\n{RESISTOR, device_names = {\"SH\"},\nshort_pins = {\"A\", \"B\"}}\n}\n)\nSee\nTable 67  for IC Validator default pin names, as well as the example for\nthe short_pins  argument in the remove_layout_devices()function.\nNote:\nAll pin nets specified in the short pins are shorted together. You\ncannot short pins by group.\n\u2022 properties. Optional. Specifies the property constraints used to removes\ndevices depending on the value of the properties on the device. If there\nare multiple constraints, a device must first meet all of the constraint\ncriteria to be filtered. See the example for the properties  argument in the\nremove_layout_devices()function.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value.\n\u2022 short_pins_groups. Optional. Specifies the group of the pin names used\nto short the pin nets together. Any remaining pins not specified as short pins\nremain open or floating after the devices are removed."}, "summary": "The remove_schematic_devices()  function takes a schematic netlist handle and returns\na modified schematic netlist database.", "function_name": "remove_schematic_devices()"}
{"description": "The remove_vias()  function removes via polygons to separate the connected metal/via\npolygons in nets whose property, that is, accumulated area, would otherwise exceed the\ngiven antenna constraint. The property of each resulting net built with the output via layers\nmeets the specified criteria.", "syntax": "remove_vias(\ncriteria    = {max_area = double},\nvia_layers  = {\n{layer      = polygon_layer,\nlayer_type = VIA_REMOVABLE | VIA_UNREMOVABLE,\noutput_layer_key = \"string\"}, ...},\nconnect_sequence   = connect_database\n);", "returns": "layer_list_h. A hash of string to polygon layer. The polygon layer is derived from the layer\nof type VIA_REMOVABLE with the corresponding hash key.", "arguments": {"criteria": "Required. Specifies the following criteria for the nets built with the via polygons\nin the output layers, to meet.\n\u2022 max_area. The area each net can have at most.", "via_layers": "Required. Lists the structures that define the via layers. The layers specified in\nthe list must be in the connect_sequence. This argument assumes that a via\npolygon connects only one pair of metal polygons in the input layers. If there are\nmultiple metal polygons overlapping with a via polygon on one side, only one\nof them is considered connected to the via polygon according to the traversal\norder of the underlying algorithm. To avoid unexpected results, ensure that a via\nconnects only one pair of metal polygons before calling this function.\n\u2022 layer. Required. Specifies the input polygon layer representing a via layer.\n\u2022 layer_type. Required. Specifies the type of the via layer.\n\u25e6 VIA_REMOVABLE. Indicates that the vias in this layer can be removed.\n\u25e6 VIA_UNREMOABLE. Indicates that the vias in this layer cannot be removed.\nremove_vias()\n\u2022 output_layer_key. Optional. Specified the string to identify the output layer\nin the output hash. This is required for VIA_REMOVABLE  layers and ignored for\nVIA_UNREMOVABLE  layers.\nNote:\nIf the accumulated property of the metal polygons and the\nconnecting unremovable vias exceeds the constraint, the\nconnecting unremovable vias are not removed. In this case, the\nresulting nets violate the specified criteria.", "connect_sequence": "Required. Specifies the connect database for the input layers. The layers\nspecified in via_layers  must be in the connect_sequence. The command\nexpects the nets in the connect database to be built with include_touch=NONE.\nThus, a connect database with nets built with include_touch=EDGE  is rejected."}, "summary": "The remove_vias()  function removes via polygons to separate the connected metal/via\npolygons in nets whose property, that is, accumulated area, would otherwise exceed the\ngiven antenna constraint.", "function_name": "remove_vias()"}
{"description": "The replace_angled_edges()  function takes a polygon input layer and outputs a polygon\nlayer whose boundary is a combination of orthogonal and 45-degree edges. The output is\nan approximate replacement of the polygon input.", "syntax": "replace_angled_edges(\nlayer1                = polygon_layer,\nmax_deviation         = double,\nreplace_edges         = SKEW | NON_ORTHOGONAL,         //optional\noutput_edges          = OCTILINEAR | ORTHOGONAL,       //optional\nname                  = \"layer_label\"                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "max_deviation": "Required. Specifies the maximum perpendicular distance from the original\nangled edge to any point on the new orthogonal or 45-degree edge.", "replace_edges": "Optional. Specifies the edges that need to be replaced. The default is SKEW.\n\u2022 SKEW. Specifies that only skew edges, that is, non-45 degree angled edges\nmust be replaced.\n\u2022 NON_ORTHOGANAL. Specifies that all nonorthogonal edges must be replaced.", "output_edges": "Optional. Specifies the output data that the input edges are replaced with. The\ndefault is OCTILINEAR.\n\u2022 OCTILINEAR. Specifies that the input data is replaced by either only\northogonal edges or orthogonal edges and 45-degree edges based on the\ndegree of the angle.\n\u2022 ORTHOGONAL. Specifies that the output edges are a combination of only\northogonal data.\nreplace_angled_edges()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The replace_angled_edges()  function takes a polygon input layer and outputs a polygon\nlayer whose boundary is a combination of orthogonal and 45-degree edges.", "function_name": "replace_angled_edges()"}
{"description": "The replace_text()  function creates a text layer from a text layer by replacing the\nspecified text strings. Any text not matching the replacement specification is unchanged.", "syntax": "replace_text(\nlayer1  = text_layer,\nreplace = {{search_strings = {\"string\", ...},\nreplace_string = \"string\"},\n...},\nname    = \"layer_label\"                        //optional\n);", "returns": "text layer", "arguments": {"layer1": "Required. Specifies the text layer.", "replace": "Required. Specifies the text strings replaced with another text string. The\nreplacements are processed in order, so that the first matching criteria has\nprecedence. When a string is matched, it is replaced and output to the output\ntext layer. The matched string is not considered for the remaining search strings.\n\u2022 search_strings. Specifies the text strings replaced. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation. Text strings must be a complete match; there is no partial text\nstring replacement.\n\u2022 replace_string. Specifies the string that replaces any text strings matching\nthe search criteria. An empty string (\"\") results in the removal of the\nspecified search string.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nreplace_text()"}, "summary": "The replace_text()  function creates a text layer from a text layer by replacing the\nspecified text strings.", "function_name": "replace_text()"}
{"description": "The required_layer()  function restricts the pruning\npruning of layerslayerspruning of\nof any layer in the runset. The\nspecified layer is not pruned during IC Validator execution, such as pruning for run-only\nexecution (-ro  command-line option), selectable rules processing (-svn, -svc, -sfn,\n-uvn, -uvc, and -ufn  command-line options), and incremental layers processing (-il  and\n-iln  command-line options).", "syntax": "required_layer(\ninput  = layer\n);", "returns": "void", "arguments": {"input": "Required. Specifies a layer that is required. It is not pruned by IC Validator."}, "summary": "The required_layer()  function restricts the pruning\npruning of layerslayerspruning of\nof any layer in the runset.", "function_name": "required_layer()"}
{"description": "The resistor()  function collects extraction configuration information about designed\nresistors that have a device layer, two terminal layers, and one or more optional layers. NP\nor PN diodes can also be extracted for diffusion resistors. The configuration information,\nwhich contains device body and terminal layers, property extraction information, schematic\ndevice mappings, and pin handling instructions, is stored in the device matrix that is\npassed to the\nextract_devices()  function.\nThe device body layer polygons must interact with exactly one polygon from each terminal\nlayer. Also, if an optional pin layer with its pin type set to BULK  is specified, the required\nrelationship between the pin layer polygon and the device body layer polygon is defined\nby the bulk_relationship  argument. If an optional pin layer with its pin type set to\nTERMINAL  is specified, the optional pin layer polygon must interact with the device body\nlayer polygon but is not required to enclose the device body layer polygon. The device\nbody layer is usually generated by an and()  function call between a resistor recognition\nlayer and the resistor material. Then, the device layer is used to cut the resistor material\nusing a not()  function call to form the resistor terminals.\nNote:\nSee\nDevice Names  on page 3350 for the device_name  argument restrictions.", "syntax": "resistor(\nmatrix                 = device_matrix,\ndevice_name            = \"string\",\ndevice_body            = polygon_layer,\nterminal_a             = polygon_layer,\nterminal_b             = polygon_layer,\noptional_pins          = {{device_layer = polygon_layer,\npin_name     = \"string\",\npin_type     = TERMINAL | BULK\npin_compared = true  | false},\n...},                             //optional\nrecognition_layer      = polygon_layer,                     //optional\nreference_layer        = polygon_layer,                     //optional\nprocessing_layer_hash  = {\"string\" => {layer1 = polygon_layer,\nrange  = double},\n...},                             //optional\nproperties             = {{name  = \"string\",\ntype  = DOUBLE | DOUBLE_LIST |\nINTEGER | INTEGER_LIST | STRING,\nscale = FEMTO | PICO | NANO | MICRO |\nMILLI | KILO | MEGA |\nNONE},\n...},                             //optional\nwrite_property_to =\nresistor()\nNETLIST_XTR_SPICE | NETLIST_PEX_SPICE |\nSPICE | ANNOTATION_FILE |\nNETLIST_ANNOTATION_FILE_SPICE |\nNETLIST | NETLIST_SPICE |\nAUTO  |\nNETLIST_SKIP_PCELL,\nscale_mode        =\nMULTIPLY  | UNIT,\npex_string_property_double_quotes = true  |\nfalse},\n},                                 //optional\nproperty_function      = function,                          //optional\nmerge_parallel         = true | false,                      //optional\nbulk_relationship      = ENCLOSE | INTERACT,                //optional\nswappable_pins         = {{\"string\", ...}, ...},            //optional\nschematic_devices      = {{device_name   = \"string\",\nterminal_a    = \"string\",\nterminal_b    = \"string\",\noptional_pins = {\"string\", ...},\nignore_pins   = {\"string\", ...}},\n...},                             //optional\nx_card                 = true | false,                      //optional\nspice_netlist_function = \"string\",                          //optional\nresistor_value         = double,                            //optional\nparasitic_diodes       = {diode_name = \"string\",\ndiode_type = NP | PN | NONE},     //optional\nextract_shorted_device = true | false,                      //optional\nprocessing_mode        = CELL_LEVEL | HIERARCHICAL,         //optional\nunique_identifier      = \"string\",                          //optional\nswappable_properties   = {{pin_name      = \"string\",\nproperty_list = {\"string\", ...}},\n...},                             //optional\nsimulation_model_name   = \"string\",                          //optional\ndlink_libraries         = {dev_dlink_library_handle, ...},   //optional\ntop_simulation_properties     = true | false                //optional\n);", "returns": "void", "arguments": {"matrix": "Required. Specifies the device matrix used by the extraction functions. The\nmatrix must be defined by the\ninit_device_matrix()  function. Configuration\ndetails for device extraction are stored in the matrix data object for use by the\nextract_devices()  function.", "device_name": "Required. Specifies the resistor. A device name can be reused across multiple\ncalls of the resistor()  function if all calls have\nresistor()\n\u2022 Equivalent numbers of optional pins with equivalent values for the pin_name\nand pin_compared  options.\n\u2022 Equivalent settings for the swappable_pins  argument.\n\u2022 Equivalent settings for the schematic_devices  argument.\n\u2022 Equivalent settings for x_card  argument.", "device_body": "Required. Specifies the body layer of the resistor.", "terminal_a": "Required. Specifies the device layer that contains the first terminal of the\nresistor. The pin name generated by the IC Validator tool is \u201cA\u201d.", "terminal_b": "Required. Specifies the device layer that contains the second terminal of the\nresistor. The pin name generated by the IC Validator tool is \u201cB\u201d.", "optional_pins": "Optional. Lists additional bulk or terminal layers. You can specify up to 20 pins.\n\u2022 device_layer. Required. Specifies the device layer.\n\u2022 pin_name. Optional. Specifies the pin name. The default is \"BULK\".\nNote:\nIf more than one optional pin is specified, use the pin_name  option\nto avoid having more than one pin named \u201cBULK\u201d.\n\u2022 pin_type. Optional. Specifies whether the layer is a terminal or bulk. The\ndefault is BULK.\n\u2022 pin_compared. Optional. Specifies whether the pin connectivity is compared\nbetween the schematic and layout netlists. The default is true.\n\u25e6 true. The pin connectivity is compared between the schematic and\nlayout netlists.\n\u25e6 false. The pin is discarded for schematic to layout comparison. This\nsetting is useful when a layout netlist instance has a bulk pin but the\ncorresponding schematic instance does not.", "recognition_layer": "Optional. Specifies the layer used to recognize a device when the device\nbody layer does not interact with all terminal layers and processing layers. All\nprocessing layers must interact with this specified recognition layer. This layer is\nresistor()\nalso used to identify device instances that are merged during layout extraction\nwhen multiple individual devices occur within a single recognition layer polygon.\nSee the\nmerge_parallel  argument for more information.", "reference_layer": "Optional. Specifies the intended location in the hierarchy for the extracted\ndevice. The layer is usually an assign layer.", "processing_layer_hash": "Optional. Specifies a hash of string to a processing layer and range pair. In the\nremote property function, each layer is retrieved as a polygon set by passing the\nhash key to the dev_processing_layer()  function.\n\u2022 layer1. Required. Specifies the processing layer, which is a non-terminal\nlayer used for calculating properties.\n\u2022 range. Optional. Specifies the maximum distance value from a device body\npolygon. This value defines a window around the device body for data\ncollection.\nA nonnegative range value collects processing polygons that are within the\nspecified range of the body polygon which might or might not interact with\nthe body polygon. The default is -1.\n\u25e6 When the range  value is -1, only processing_layer_hash  polygons\ninteracting with the body layer polygon are selected for the polygon set.\n\u25e6 When the range  value is >0, a window is created by oversizing the body\nlayer polygon by the range value. All processing_layer_hash  polygons\ninteracting with this window, either by overlap or by an externally touching\nedge, are selected for the polygon set.\nSee the description of the processing_layer_hash  argument of the\nnmos()\nand pmos()  functions for diagrams that illustrate the application of the range\nvalue.", "properties": "Optional. Lists the property values that define the device.\ndevice properties, defaultresistor\nThe default is\nproperties = {{\"l\", DOUBLE, MICRO},\n{\"w\", DOUBLE, MICRO},\n{\"r\"}\n},\nNote:\nFor a normal, two-terminal device, the device width is calculated\nusing the average of the widths where each terminal touches the\nresistor()\nbody. For a single-terminal device, the width is equivalent only to the\nvalue of the single-terminal touching body.\n\u2022 name. Specifies the property name. See \u201cPredefined Name Matches\u201d in\nChapter 7, \u201cCompare Functions Basics\u201d of the IC Validator LVS User Guide\nfor the names and associated matches that are predefined during LVS\ncompare.\nNote:\nMore than one property sharing the same name is prohibited.\nFurthermore, the property name is case-insensitive.\n\u2022 type. Specifies the data type of the property. The default is DOUBLE.\nNote:\nThe compare()  function does not support the DOUBLE_LIST\nproperty. When running dual-hierarchy extraction, the list of\ndouble properties is always written to the annotation file unless the\nwrite_property_to  argument is explicitly specified.\n\u2022 scale. Optional. Specifies the scale factor applied to property values output\nby the\nwrite_spice(), write_xref_spice(), pex_generate_results(),\nand write_annotation_file()  functions. The default is NONE, which\nmeans no scaling.\nYou can use this scale  option to convert dimensional property values from\nthe IC Validator native base unit of microns into the base unit of meters for\nSPICE simulation.\n\u2022 write_property_to. Optional. Specifies to which file the property is written.\nThe default is AUTO.\n\u25e6 NETLIST_XTR_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\nresistor()\n\u25e6 NETLIST_PEX_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the\npex_generate_results()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()function.\n\u25e6 SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the write_spice()function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n- The annotation file by the\nwrite_annotation_file()  function.\n\u25e6 ANNOTATION_FILE. Writes the corresponding property to\n- The annotation file by the write_annotation_file()  function.\nThe property is not written to\n- The output netlist (cell.net) by the\nnetlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_ANNOTATION_FILE_SPICE. Writes the corresponding property to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output netlist (cell.net) by the netlist()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\nresistor()\nThe property is not written to\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST. Writes the corresponding property to\n- The output netlist (cell.net) by the\nnetlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The output SPICE netlist (cell.sp) by the write_spice()  function.\n- The property lists of cell instances matching the extracted device inside\nthe parasitic extraction layout database generated by the IC Validator\ntool.\n\u25e6 NETLIST_SPICE. Writes the corresponding property to\n- The output SPICE netlist (cell.sp) by the\nwrite_spice()  function.\n- The output netlist (cell.net) by the netlist()  function.\nThe property is not written to\n- The annotation file by the\nwrite_annotation_file()  function.\n- The SPICE netlist for the interface between the IC Validator and StarRC\ntools generated by the pex_generate_database()  function.\n\u25e6 AUTO.\n- IC Validator determines automatically whether to write the property to a\nnetlist or - an annotation file based on the compare section of the runset.\nThe property is written to either the output netlist (.net) or the annotation\nfile depending on whether the property is a compare property.\n- If the property is a compare property, it is written to the output netlist\n(.net) by the\nnetlist()  function.\n- If the property is not a compare property, it is written to the annotation\nfile by the\nwrite_annotation_file()  function.\n\u25e6 NETLIST_SKIP_PCELL. Writes the corresponding property to\n- The properties file (cell_pcell.gz).\nresistor()\n- When dual_hierarchy_extraction = true, the\nNETLIST_SKIP_PCELL  option is equivalent to the ANNOTATION_FILE\noption.\nThe NETLIST_SKIP_PCELL  option is required when the property being\ncalculated requires the terminal or processing layers of the device to level\nout of a skip cell.\n\u2022 scale_mode. Optional. Specifies how scale is used to control property value\nrepresentation. The default is MULTIPLY.\n\u25e6 MULTIPLY. Multiplies the property value by the scale.\n\u25e6 UNIT. Appends a unit character of the scale to the value.\nSee the\nnmos() and pmos()  functions for an example.\n\u2022 pex_string_property_double_quotes. Optional. Specifies that If the\nproperty is a string type, this option controls whether the property is\nsurrounded by double quotation marks in the PEX netlist file. This option is\nignored if the property is not a string type. This option does not affect the LVS\nflow. The default is true.\n\u25e6 true. Specifies that if the property is a string type, the property is\nsurrounded by double quotation marks in the PEX netlist file.\n\u25e6 false. Specifies that if the property is not a string type, the property is not\nsurrounded by double quotation marks in the PEX netlist file.", "property_function": "Optional. Specifies the remote function that calculates the geometric properties\nfor each extracted resistor. The default calculations are for the length of the\nresistor between the terminals, width of the resistor, and resistance. The default\ncalc_resistor_properties()  function is defined in the device_public.rh\nheader file.\nIf you use a remote function, you must specify the device properties in the\nproperties  argument. See\nUtility Functions  for more information about the\nutility functions you can use to define a remote function.", "merge_parallel": "Optional. Specifies whether parallel devices enclosed by the same recognition\nlayer polygon are merged. The default is false.\nresistor()\n\u2022 true. Merges parallel devices enclosed by the same recognition layer\npolygon. Multiple banks of parallel-merged devices can occur within a single\nrecognition layer polygon.\n\u2022 false. Does not merge parallel devices enclosed by the same recognition\nlayer polygon.", "bulk_relationship": "Optional. Specifies the required relationship between the bulk polygon and the\ndevice polygon.\n\u2022 ENCLOSE. Specifies that the bulk polygon must enclose the device polygon.\n\u2022 INTERACT. Specifies that the bulk polygon must interact with the device\npolygon by one of these methods: enclosing, cutting, or outside edge\ntouching.", "swappable_pins": "Optional. Lists the pins that can be swapped for a successful comparison with\nthe schematic device. By default, pins \u201cA\u201d and \u201cB\u201d can be swapped. Use an\nempty list to disable swapping of all pins:\nswappable_pins = {}\nIn the following example, \u201cA\u201d and \u201cB\u201d can be swapped, and \u201cC\u201d and \u201cD\u201d can be\nswapped. However, \u201cA\u201d and \u201cC\u201d cannot be swapped.\nswappable_pins = {{\"A\",\"B\"}, {\"C\",\"D\"}}", "schematic_devices": "Optional. Lists the corresponding schematic devices and terminals for\ncomparison. By default, the comparison is based on matching names in the\nlayout.\nNote:\nYou need this argument if either of these statements are true:\n- The schematic device name does not match the device_name\nargument of the device configuration function.\n- The schematic pin names do not match the standard \u201cA\u201d, \u201cB\u201d, and\n\u201cBULK\u201d pin names, in addition to optional pin names provided in the\noptional_pins  list of structures argument of the device configuration\nfunction.\nresistor()\n\u2022 device_name. Required. Specifies the schematic device.\n\u2022 terminal_a. Optional. Specifies the first terminal of the device. The default\nis \"A\".\n\u2022 terminal_b. Optional. Specifies the second terminal of the device. The\ndefault is \"B\".\n\u2022 optional_pins. Optional. Specifies the schematic pins that correspond to\nthe pin name in the optional_pins  argument.\n\u2022 ignore_pins. Optional. Ignores the specified schematic pins during pin\nconnectivity comparison between the layout and schematic. If a pin name\nis listed that matches a pin name defined by the optional_pins  argument,\nthat pin is ignored both in the layout and schematic. This behavior is\nsimilar to the pin_compared  option of the optional_pins  argument of the\nresistor()  function.\nIf the schematic device has an optional pin that does not correspond to\nany pin in the resistor()  function, that pin can be specified with the\nignore_pins. Otherwise, this optional pin produces an error during the\ncompare operation.", "x_card": "Optional. Specifies if the instance name prefix is replaced. The default is false.\n\u2022 true. Replaces the default instance name prefix for the layout extracted\ndevice with an X-card. This option facilitates the use of SPICE SUBCKT\nmodels to represent devices in simulation.\n\u2022 false. The default instance name prefix for the layout extracted device is not\nreplaced.", "spice_netlist_function": "Optional. Specifies the function used to format instances of the device in netlists\ngenerated by the\nwrite_spice()  and write_xref_spice()  functions. See\nFlexible Netlisting Utility Functions  for more information.", "resistor_value": "Optional. Specifies the calculated value of sheet resistance per square unit.", "parasitic_diodes": "Optional. Specifies the device name for the newly created diodes generated in\nthe netlist.\nresistor()\nNote:\nWhen using the parasitic_diodes  argument, a bulk layer must\nbe specified using the optional_pins  argument with the pin_type\noption set to BULK.\n\u2022 diode_name. Specifies the name for the newly created parasitic diodes.\n\u2022 diode_type. Specifies the device type. When you specify a diode name, set\nthe diode type to PN  or NP.", "extract_shorted_device": "Optional. Specifies whether shorted resistors, that is, resistors with only one\nterminal, are extracted. The default is true.\n\u2022 true. Extracts shorted resistors if there are at least two touching edges\nbetween the terminal and device body layers.\n\u2022 false. Reports shorted resistors as error devices.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "unique_identifier": "Specifies the user-derived string used by the remote property function. The\nunique_identifier  argument value is retrieved from the remote property\nfunction with the dev_unique_identifier()  utility function. See the Examples\nsection of the\ncapacitor()  function for more information. You must ensure that\nthe strings are valid and unique. (The IC Validator tool does not check values to\nensure that they are unique.) The default is an empty string (\"\").\nThis functionality is used to access data objects created outside of a remote\nproperty function but passed in as global variables. Use this functionality\nwhen access to these global variables must be synchronized to a specific\ndevice configuration function call. For example, you can create a global\nhash object containing property extraction parameters for several device\nconfiguration functions. The hash key is a unique identifier string that matches\nthe unique_identifier  argument value. Then, you can clear the hash key by\ninvoking the dev_unique_identifier()  function that is in the property function.\nThe dev_unique_identifier()  function retrieves the unique_identifier\nargument value to the corresponding device configuration function call.\nresistor()", "swappable_properties": "Optional. Lists the pins and pin-specific device properties that can be swapped.\nThe IC Validator tool considers the connectivity of the corresponding swapped\npins for property-based merge exclusion, device merging composite property\ncalculations, and property comparisons. Pins that have properties with identical\nproperty_list  indexes are swapped. By default, the IC Validator tool does not\nmap swappable pins to properties.\n\u2022 pin_name. Allows the specified pin to be swapped. The pin must be listed in\nthe swappable_pins  argument.\n\u2022 property_list. Specifies the ordered list of pin-specific device properties\nfor property-based merge exclusion, device merging composite property\ncalculations, and property comparisons.\nSee the swappable_properties  argument of the\ncapacitor()  function for an\nexample.", "simulation_model_name": "Optional. Specifies the simulation netlist model name. As needed, define this\nmodel name for each device configuration function. This name is output to the\nrunset report file. The device name is not changed.", "dlink_libraries": "Optional. Specifies the libraries that can be used to pass measurement\ndata to external libraries. See the Dynamic-Link Library Support  chapter in\nthe IC Validator User Guide  and\nDynamic Linking Utility Functions  for more\ninformation.", "top_simulation_properties": "Optional. Controls whether properties identified as simulation properties are\nextracted hierarchically or in the top cell. The default is false.\n\u2022 true. Extracts simulation properties in the top cell.\n\u2022 false. Extracts simulation properties hierarchically.\nSee\nTable 40  for more information about the behavior of the\ntop_simulation_properties  argument."}, "summary": "The resistor()  function collects extraction configuration information about designed\nresistors that have a device layer, two terminal layers, and one or more optional layers.", "function_name": "resistor()"}
{"description": "The resolution_options()  function specifies resolution and snapping values.", "syntax": "resolution_options(\ninternal_resolution       = double  |\nINTERNAL_RESOLUTION_AUTO,   //optional\nsnap_resolution           = double,                      //optional\nsnap_instance_resolution  = double,                      //optional\nsnap_preference           = OVERSIZE | UNDERSIZE |\nRETAIN_45 | CLOSEST,         //optional\nworking_resolution_factor = ONE_X | TWO_X  | AUTO,        //optional\nspacing_tolerance         = double,                      //optional\nlayout_resolution_check   = {resolution = double,\naction     = ABORT | WARN |\nIGNORE}, ...   //optional\ndrc_length_precision          = double,                  //optional\ndrc_angle_precision           = double,                  //optional\ndrc_distance_precision         = double,                  //optional\ninternal_resolution_factor     = ONE_X | TWO_X |\nTEN_X\n//optional\n);", "returns": "void", "arguments": {"internal_resolution": "Optional.\ninternal resolutionresolutioninternal\nEnables the IC Validator tool to use a resolution for processing other\nthan the input\nlibrary resolution\nlibrary resolution. The default is the input library resolution.\n\u2022 Use a finer value to provide more grid points for storing data, a finer\nprecision for all dimensional values specified, and a finer precision for all\nbuilt-in tolerances.\n\u2022 Use a coarser value to provide a larger coordinate space. A coarser value\ncauses a loss of precision and it might cause snapping.\n\u2022 Use the internal_resolution  argument to ensure that a\nmagnification factor", "magnification": "factor results in all coordinates falling on grid. The magnification factor is\nspecified in the\nlibrary()  function.\nresolution_options()\n\u2022 INTERNAL_RESOLUTION_AUTO: Finds the finest internal_resolution  value\namong all import layouts.\nNote:\nThe resolution calculation is based on both inlib resolution and\nmagnification factor values.", "snap_resolution": "Optional.\nsnap resolutionresolutionsnap\nSnaps input data and instances to this resolution. The default is 0.", "snap_instance_resolution": "Optional.\nsnap instance resolutionresolutionsnap instances\nSnaps instances to this resolution. This value overrides the\nsnap_resolution  argument for instances. The default is 0.", "snap_preference": "Optional.\nsnap preferencespreferences, snap\nSpecifies the preferences when snapping. The default is RETAIN_45.\n\u2022 OVERSIZE. Snaps a polygon so that all vertices are snapped to grid points on\nor outside the original polygon boundary.\n\u2022 UNDERSIZE. Snaps a polygon so that all vertices are snapped to grid points\non or inside the original polygon boundary.\n\u2022 RETAIN_45. Attempts to maintain 45-degree edges in the original polygon\nwhen snapping.\n\u2022 CLOSEST. Snaps the polygon vertices to the nearest grid point.", "working_resolution_factor": "Optional.\nworking resolution factorresolutionworking\nEnables the IC Validator tool to use a finer working resolution than\nthe internal resolution for the storage of geometric data. The working resolution\nfactor provides more grid points to solve merging and snapping issues for 45-\ndegree and all-angle data. Set the working_resolution_factor  argument to\nONE_X  to solve problems with integer overflow for coordinates of large chips. The\ndefault is TWO_X.\n\u2022 ONE_X. Specifies that the working resolution is the same as the internal\nresolution.\n\u2022 TWO_X. Specifies that the working resolution is twice the internal resolution,\nwhich means there are twice as many grid points for storing data than the\ninternal resolution.\n\u2022 AUTO. Specifies that the optimum working resolution factor is based on\nthe input library resolution and the internal resolution. If the input library\nresolution is an even multiple of the internal resolution, the working resolution\nfactor is ONE_X, otherwise it is TWO_X.\nresolution_options()", "spacing_tolerance": "Optional.\nspacing tolerancetolerance for distance of dimensional spacing check\nSpecifies the tolerance for the distance of the dimensional spacing\ncheck on nonorthogonal data. The default is unspecified to have default\ntolerances.\nThe specified spacing_tolerance  value is used throughout the runset. It is\napplied to all external*(), internal*(), and enclose*()  functions except\nthe corner-to-corner measurements functions, such as external_corner*(),\ninternal_corner*()  and enclose_corner*().\nThe spacing_tolerance  value is applied only to measurements where either\nof the edges is nonorthogonal. The effect of the spacing_tolerance  option is\nto decrease the maximum distance value (<  or <=) specified in the dimensional\nfunctions. For orthogonal data measurements, the spacing_tolerance  option\ndoes not affect the maximum distance value.\nExample:\nThe default for spacing_tolerance  is unspecified.\ngreen = external1(red, distance < 0.1, extension = RADIAL);\nresolution_options()\nWhen spacing_tolerance  is specified,\nresolution_options(spacing_tolerance = 0.004);\ngreen = external1(red, distance < 0.1, extension = RADIAL);\nThe check distance for angled data is < 0.096, for orthogonal data is < 0.1.", "layout_resolution_check": "Checks the input library resolution against the specified resolution\nvalue.\nresolution_options()\n\u2022 resolution. Specifies the resolution value to compare against the input\nlibrary resolution. The default is 0.001.\n\u2022 action. Specifies the IC Validator action if the input library resolution does\nnot match the specified resolution value. The default is IGNORE.\n\u25e6 ABORT. Aborts the run if the input library resolution does not match the\nspecified resolution value.\n\u25e6 WARN. Issues a warning if the input library resolution does not match the\nspecified resolution value.\n\u25e6 IGNORE. Does not compare the input library resolution against the\nspecified resolution value and continues the run.", "drc_length_precision": "Optional. Specifies the precision to be used for measuring the length of non-\nrectilinear edges. The default is internal_resolution/2.\nThe specified length_precision  value is a nonnegative double in microns. A\nsmaller value provides more accuracy. The smallest value used is 1e-10. The\nvalue is applied to all occurrences of these arguments in the runset:\n\u2022 adjacent_edge(length, adjacent_length1, adjacent_length2)\n\u2022 projection_length  in the spacing checks\n\u2022 length_edge(distance)\n\u2022 rectangles (sides)", "drc_angle_precision": "Optional. Specifies the precision to be used for measuring the angle of skew\nedges. The default varies for the different functions.\nNote:\nBy setting drc_angle_precision  to 0, you can use hard tolerance\nfor measuring right angle of rectangles.\nThe specified angle_precision  value is a nonnegative double in degrees. A\nsmaller value provides more accuracy. The smallest value used is 1e-10. The\nvalue is applied to all occurrences of these arguments in the runset:\n\u2022 angle_edge(angles)\n\u2022 adjacent_edge(angle1, angle2)\n\u2022 intersections*(angles)\n\u2022 vertex*(angles)\nresolution_options()\n\u2022 orientation  in the spacing checks\n\u2022 intersecting  in the spacing checks\n\u2022 intersection_angle  in the spacing checks\n\u2022 Rectangle corners in rectangles()/not_rectangles()\n\u2022 Rectangle corners in center_to_center1()/center_to_center2()\n\u2022 Rectangle corners in enclosed_by()/not_enclosed_by()\n\u2022 Rectangle corners in contained_by()/not_contained_by()\n\u2022 Rectangle corners in covered_by()/not_covered_by()", "drc_distance_precision": "Optional. Specifies the precision to be used for measuring the distance of\nspacing checks.\nThe specified distance_precision  value is a nonnegative double in microns.\nA smaller value provides more accuracy. The default is unspecified for backward\ncompatibility. The value is applied to all occurrences of these arguments in the\nrunset:\n\u2022 distance in spacing checks\n\u2022 distance in spacing corner checks\n\u2022 distance in center_to_center", "internal_resolution_factor": "Optional. Divides the internal_resolution  value by 1/2/10, which gives a\nfiner internal_resolution  value."}, "summary": "The resolution_options()  function specifies resolution and snapping values.", "function_name": "resolution_options()"}
{"description": "The resolve_path()  function resolves the specified path to its absolute path.", "syntax": "resolve_path(\npath = \"string\"\n);", "returns": "string", "arguments": {"path": "Required. Specifies the unresolved file path."}, "summary": "The resolve_path()  function resolves the specified path to its absolute path.", "function_name": "resolve_path()"}
{"description": "The reverse_edge()  function reverses the edge direction for an edge layer.", "syntax": "reverse_edge(\nlayer1 = edge_layer,\nname    = \"layer_label\"      //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the edge layer that is reversed.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The reverse_edge()  function reverses the edge direction for an edge layer.", "function_name": "reverse_edge()"}
{"description": "The route_directives()  function gives you better control over\nADR flow, automatic DRC repairautomatic DRC repair, ADR\nautomatic DRC repair.\n(The ADR flow uses the signoff_autofix_drc  command within the IC Compiler tool and\nthe signoff_fix_drc  command within the IC Compiler II tool.) The bounding boxes are\noutput to the LAYOUT_ERRORS file, and VUE displays the specified display markers,\nerror layers, and all of the directive layers in this function. The directive layers include\ncombinations of add shapes, subtract shapes, and move vias; the error layers include\nmultiple error markers. Both the directive and error layers are passed directly to the\nIC Compiler and IC Compiler II tools in the ADR flow.\nThe following restrictions apply to the route_directives()  function:\n\u2022 All shapes altered by the route_directives  and route_directive_sets  arguments\nmust be on the minimum manufacturing grid. (The manufacturing grid is specified in the\ntechnology file.)\n\u2022 An add_layer  directive must not create a short, even if a subtract_layer  directive\nwould resolve it.\n\u2022 The result of a route directive must not be an open or floating shape.\n\u2022 A layer specified by a subtract_layer  argument must not interact with any via\nenclosure.\n\u2022 Any route_directives  or route_directive_sets  layer must not overlap with power\nand ground straps, shapes that have a route type of fixed or user enter, and pins.\n\u2022 A subtract layer can interact only with shapes having a route type of SIGNAL_DETAIL.", "syntax": "route_directives(\ndisplay_marker        = polygon_layer,\ngroup_marker          = polygon_layer,\nerror_layers          = {layername = polygon_layer, ...},    //optional\nroute_directives     = {{add_layer      = polygon_layer,\nsubtract_layer = polygon_layer,\nmove_layer     = edge_layer,\nlayer_name     = \"string\"},\n}, ...},                            //optional\nroute_directive_sets  = {{{add_layer      = polygon_layer,\nsubtract_layer = polygon_layer,\nmove_layer     = edge_layer,\nlayer_name     = \"string\"}, ...\n}, ...}                             //optional\n);\nroute_directives()", "returns": "void", "arguments": {"display_marker": "Required. Specifies the layer that contains the shapes used to display the\nerrors.", "group_marker": "Required. Specifies the layer with the shapes that enclose the shapes\ndefined by the display_marker, error_layers, route_directives, and\nroute_directive_sets  arguments.", "error_layers": "Optional. Specifies the layers that are used to specify the errors. These\nlayers are interpreted by the signoff_autofix_drc  and signoff_fix_drc\ncommands as alternative representations. Each of these layers is used in an\nindependent fixing attempt in the ADR flow.", "route_directives": "Optional. Specifies the layers that contain shapes which identify surgical fixes\nfor the router. For a given set of add_layer  and subtract_layer  shapes\ncontained by a single group_marker  layer, the shapes are implemented by the\nrouter if they are allowed actions.\n\u2022 add_layer. The shapes on this layer are added, as if by an OR operator, to\nthe database by the router, inheriting properties and connectivity based on\nthe shapes they are touching.\n\u2022 subtract_layer. The shapes on this layer are subtracted, as if by a NOT\noperator, from the database by the router, possibly leaving behind partial\nshapes in the database.\n\u2022 move_layer. The directed edges on this layer instruct the Zroute router\nto move vias in the database from the beginning point of the edge to the\nendpoint of the edge.\n\u2022 layer_name. Specifies the mask name of the layer to which the route\ndirectives in this set apply. This must match the mask name of the layer in\nthe technology file.", "route_directive_sets": "Optional. Specifies the sets of layers that contain shapes which identify surgical\nfixes for the router. Each set of directives is grouped together to represent a\nsingle fix guidance.\nroute_directives()\n\u2022 add_layer. The shapes on this layer are added, as if by an OR operator, to\nthe database by the router, inheriting properties and connectivity based on\nthe shapes they are touching.\n\u2022 subtract_layer. The shapes on this layer are subtracted, as if by a NOT\noperator, from the database by the router, possibly leaving behind partial\nshapes in the database.\n\u2022 move_layer. The directed edges on this layer instruct the router to move\nvias in the database from the beginning point of the edge to the endpoint of\nthe edge.\nNote:\nFor a via array, only one edge must represent the original and new\nlocation for the movement. The router skips the moving action for\na via array if more than one edge is provided.\n\u2022 layer_name. Specifies the mask name of the layer to which the route\ndirectives in this set apply. This must match the mask name of the layer in\nthe technology file.\nExample:\nroute_directives(\ndisplay_marker             = pattern_extent,\ngroup_marker               = pattern_extent,\nerror_layers               = {{error_markers}},\nroute_directive_sets = {\n{ // First possible fix guidance\n{add_layer = M3_add_fix1,         layer_name =\n\"metal3\"},\n{subtract_layer = M2_remove_fix1, layer_name =\n\"metal2\"},\n{move_layer = V2_move_fix1,       layer_name = \"via2\"}\n},\n{ // Second possible fix guidance\n{add_layer = M2_add_fix2,         layer_name =\n\"metal2\"},\n{subtract_layer = M3_remove_fix2, layer_name =\n\"metal3\"},\n{move_layer = V2_move_fix2,       layer_name = \"via2\"}\n}\n}\n);"}, "summary": "The route_directives()  function gives you better control over\nADR flow, automatic DRC repairautomatic DRC repair, ADR\nautomatic DRC repair.", "function_name": "route_directives()"}
{"description": "The run_options()  function specifies directories, files, and run variations.", "syntax": "run_options(\ngroup_path                    = \"string\",                   //optional\nprint_precision               = integer,                    //optional\nprint_preprocess_files        = {TREE, VCELL, TECH},        //optional\ntree_files                    = ALL | FIRST_LAST,           //optional\nflat_polygon_count            = true | false,               //optional\nuppercase                     = true | false,               //optional\ninstance_prefix                = \"string\",                   //optional\noptimize_floating_fills        = true  | false,               //optional\nlvs_netlist_flow               = ICV  | SPICE,                //optional\nlvs_user_unit                  = MICRON  | METER,             //optional\nverbose_results_file           = {ERRORS, PRE_WAIVED_ERRORS\nFLAT_VIOLATION_COUNT,\nTOTAL_VIOLATION_COUNT,\nASSIGNS},\n//optional\nassign_layer_out_of_range     = ABORT | WARN,               //optional\ncompress_netlist              = true  | false,               //optional\nreport_streamfile_information = {GDS_LAST_MODIFIED,\nGDS_LAST_ACCESSED,\nMD5SUM, FORMAT, PATH,\nCOMMAND},                  //optional\ninter_die_error_report         = true | false,               //optional\ncompress_tree_files            = true  | false,               //optional\nprogress_script               = \"string\"\n//optional\n);", "returns": "void", "arguments": {"group_path": "Optional. Specifies the directory that contains layer group files and other files\nused during a run. Because these files can be quite large, avoid reading and\nwriting over a network. The group directory should exist on a local disk of the\nhost executing the run. The default is the group directory in the run_details\ndirectory.\nrun_options()\nNote:\nThe IC Validator tool does not allow you to set this path to the current\nworking directory (.).\nThe path can be changed with the -g  command-line option. See the IC Validator\nCommand-Line Options  section in the \u201cIC Validator Basics\u201d chapter of the\nIC Validator User Guide  for more information.", "print_precision": "Optional. Specifies the\nprint precisionprecision, print\nnumber of decimal places for the floating point values\nreported in output files, including the LAYOUT_ERRORS file and the window\nstatistics files for the density family of functions. The default is 4.", "print_preprocess_files": "Optional.\npreprocess files, writingtree file, stopping creation\nSpecifies the preprocess files to generate. More than one value can\nbe listed. These files are useful when debugging runs. The default is {TREE,\nVCELL, TECH}.", "tree_files": "Optional. If the print_preprocess_files  argument includes the TREE  value,\nthe tree_files  argument is used to determine the amount of tree files printed\nand saved on disk. The default is FIRST_LAST.\n\u2022 ALL. Prints tree files for all of the preprocessing phases.\n\u2022 FIRST_LAST. Prints tree files for the first and last preprocessing phases.\nThe first phase (tree0) represents the read-in hierarchy before hierarchy\noptimizations; the last phase (tree999) represents the optimized hierarchy\nafter all of the preprocessing steps.", "flat_polygon_count": "Optional. Specifies if functions that derive layers include the flat polygon count\nalong with the cell level polygon count in the cell.sum file. When set to true, the\npolygon count is included in the file. The default is false.\nNote:\nUse the flat_polygon_count  argument as a debug option. Do not\nuse it in production runsets because there are performance and\nmemory costs for calculating the flat polygon count.", "uppercase": "Optional. Specifies if layout text is converted to uppercase characters for DRC,\nERC, extraction, and netlist functions. The default is false.\nrun_options()\n\u2022 true. Converts the layout text to uppercase characters for these functions.\nThis conversion affects all functions that process text.\n\u2022 false. Does not convert the layout text to uppercase characters.\nSee the FULL_NAME_CASE_INSENSITIVE  setting in the generate_user_equivs\nargument of the lvs_options()  function for more information.", "instance_prefix": "Optional. Serves as a mechanism to make the cell instances different from\nthe X-card netlisted device instances in the SPICE netlist. To create a valid\nSPICE netlist when you are using the x_card  option of the device configuration\nfunctions, such as nmos(), you must also set instance_prefix  to a non-null\nstring value.\nFor the SPICE flow, that is when the lvs_netlist_flow  argument\nis SPICE, the tool adds the prefix X to cell instances. The X is added\nautomatically preceding the specified instance prefix. For example, specifying\ninstance_prefix=\"MyCell\"  and setting lvs_netlist_flow=SPICE, the cell\ninstance of layout has the prefix XMyCell.\nNote:\nThe prefix X might conflict with the exploded_text_options\nargument of the text_options()  function. If the\nhierarchical_delimiter  option is prefixed with X in a SPICE flow,\nThe tool cannot differentiate where the X come from and an error\noccurs.", "optimize_floating_fills": "Optional. Specifies if the floating fill is optimized in the connect database. When\nset to true, the fill is optimized in the connect database. The default is true.\nNote:\nAll functions that check floating fill do so as usual and do the same\nwork as without this optimization.", "lvs_netlist_flow": "Optional. Specifies the netlist format for the LVS flow. The default is ICV.\nrun_options()\n\u2022 ICV.\n\u2022 SPICE. The format specified in the schematic()  and\nread_layout_netlist()  functions must be SPICE.\nNote:\nThe verilog_settings  argument of the\nread_layout_netlist()  and schematic()  functions is ignored.", "lvs_user_unit": "Optional. Specifies the unit of measure for the LVS flow, including device\nextraction and comparison. The units are for length, width, area, and perimeter.\nThe coordinates are always in microns. The default is MICRON.\nThis argument does not support\n\u2022 Unit conversion to the input IC Validator netlist.\n\u2022 Micron-to-meter translation.\nFor example,\nIf the input SPICE input is only in meters, the lvs_user_unit  argument can\nbe set to MICRON  or METER. But, if part of the SPICE input is in microns, the\nlvs_user_unit  argument can only be set to MICRON; setting it to METER  causes\nan error.\nIf the input IC Validator netlist is in METER, the lvs_user_unit  argument\ncan only be set to METER. If the input IC Validator netlist is in MICRON, the\nlvs_user_unit  argument can only be set to MICRON. Otherwise the IC Validator\ntool issues an error message.\nThe tolerance-related functions that can be affected by the lvs_user_unit\nargument are:\nRunset Functions:\ncheck_property()\nmerge_parallel()\nmerge_series()\nrecognize_gate()\nshort_equivalent_nodes_off()\nrun_options()\nCompare Utility Functions:\nlvs_get_compare_tolerance()\nlvs_get_exclude_tolerance()\n\u2022 MICRON. Ensures consistency in micron units cross the LVS flow:\n\u25e6 All schematic properties of netlists are converted to microns.\n\u25e6 The geometry utility functions used in device extraction are also in\nmicrons. See the Glossary for a list of the geometry functions.\n\u25e6 The extracted netlist has geometry properties in microns.\n\u25e6 Compare has no additional conversion of properties.\n\u2022 METER. Ensures consistency in meters units cross the LVS flow:\n\u25e6 All schematic properties are in meters. No conversion is required because\nthe SPICE netlist is in meters by default.\n\u25e6 The scale  option of the properties  argument of the device\nconfiguration functions is ignored.\n\u25e6 The geometry utility functions in device extraction are also in meters.\n\u25e6 The extracted netlist has geometry properties in meters.\n\u25e6 Compare has no additional conversion of properties.", "verbose_results_file": "Optional. Specifies if error violation details and assign layer details are reported\nin the cell.RESULTS file. The default is ERRORS.\n\u2022 ERRORS. Reports each rule name and the total number of violations for that\nrule.\nNote:\nWhen using error classification, the number of waived violations is\nexcluded from the number of violations found in the cell.RESULTS\nfile. For example, the tool detects 100 violations, but 60 of them\nare waived. Therefore, the number of violations reported is 40.\n\u2022 PRE_WAIVED_ERRORS. Specifies the reporting of pre-waiver violation counts in\na separate table following the current (post-waiver) violation counts table.\n\u2022 FLAT_VIOLATION_COUNT. Reports the flat violation count for each rule in the\nerror details section and the total flat violation count in the error summary\nsection.\nrun_options()\n\u2022 TOTAL_VIOLATION_COUNT. Reports the total number of hierarchical and flat\nviolation counts at the top of the rules table in the error details section.\n\u2022 ASSIGNS. Reports each assign layer name, hierarchical and flat polygon\ncounts for the layer (or \u201cPruned\u201d if the layer was pruned), and additional\nassignment information for the layer from the assign functions in the runset.", "assign_layer_out_of_range": "Optional. Specifies the behavior of the IC Validator tool when an assign function\ncontains layer or datatype numbers that are greater than the maximum allowed\nrange of the input library format. The default is WARN.\n\u2022 ABORT. Aborts the run with an error when an assign function contains an out\nof range layer.\n\u2022 WARN. Issues a warning and continues the run when an assign function\ncontains an out of range layer.\nSee\nLayout Layer and Datatype Ranges  for information about the limits of the\nvalues in the assign functions.", "compress_netlist": "Optional. Compresses the output layout netlist generated using the netlist()\nfunction. The output file name is cell.net.gz. A file called cell.net is a soft link to\nthe compressed file, and it enables certain flows to continue to operate normally.\nThe default is true.", "report_streamfile_information": "Optional. Generates a report in the cell.RESULTS file for the GDSII and OASIS\ninput libraries, md5sum, GDSII last modified, last accessed data and time\nstamps, format, path to the input library, and function specifying the input library,\ndepending on the settings. The default is no reporting.\n\u2022 GDS_LAST_MODIFIED. Reports the date and time when GDSII was last\nmodified and extracted from the GDSII library. If this information is\nunavailable, then \u201cNOT AVAILABLE\u201d is reported. This occurs when the date\nfields in GDSII are all \u201c0\u201d or invalid characters.\n\u2022 GDS_LAST_ACCESSED. Reports the date and time when GDSII was last\naccessed and extracted from the GDSII library. If this information is\nunavailable, then \u201cNOT AVAILABLE\u201d is reported. This occurs when the date\nfields in GDSII are all \u201c0\u201d or invalid characters.\n\u2022 MD5SUM. Reports md5sum of the input library computed on the entire file\nusing the UNIX command, md5sum -b file. For compressed GDSII,\nthe md5sum is computed on the compressed file. If this information is\nrun_options()\nunavailable, then \u201cNOT AVAILABLE\u201d is reported. This occurs when md5sum\nis not in the user $path.\n\u2022 FORMAT. Reports the GDSII or OASIS input library formats.\n\u2022 PATH. Reports the absolute path to input library file.\n\u2022 COMMAND. Reports the function name, runset, and the line number where the\nlibrary was specified in the runset.", "progress_script": "Specified script is run every time the percent complete line is updated in the\nicv.log file.", "compress_tree_files": "Optional. Specifies if the print_preprocess_files  argument includes the\nTREE  option, the compress_tree_files  argument is used to determine if the\ntree files are compressed when written to disk. The default is true.\n\u2022 true. Compresses the tree files in .gz format.\n\u2022 false. Writes the tree files without compression.", "inter_die_error_report": "Optional. Specifies that the -inter_die  command-line option must be used if\ninter_die_error_report=true. The default is false.\n\u2022 true. Replaces standard IC Validator output files,\ntop_cell.LAYOUT_ERRORS and top_cell.LVS_ERRORS with\ntop_cell.INTERDIE_ERRORS file. This option must only be used for 2.5-D\nand 3-D designs.\n\u2022 false. Outputs the standard IC Validator output\nfiles,top_cell.LAYOUT_ERRORS and top_cell.LVS_ERRORS."}, "summary": "The run_options()  function specifies directories, files, and run variations.", "function_name": "run_options()"}
{"description": "The sconnect()  function selects the layer1  polygons that intersect the layer2\npolygons which belong to the net with the highest layer1  polygon count. The result is\nnondeterministic because different nets can have the same polygon count.", "syntax": "sconnect(\nconnect_sequence = connect_database,\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\nmode             = GLOBAL | LOCAL,    //optional\ninclude_touch     = NONE  | EDGE,       //optional\nname              = \"layer_label\"      //optional\n);", "returns": "polygon layer", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "layer1": "Required. Selects polygons from the specified polygon layer, which must be in\nthe connect database.", "layer2": "Required. Specifies the second polygon layer. It must not be in the connect\ndatabase.", "mode": "Optional. Specifies the context in which the net with the highest layer1  polygon\ncount is determined. The default is LOCAL.\n\u2022 GLOBAL. Specifies that the context is the entire layer. All layer1  polygons\nthat intersect layer2  polygons are included in determining the net with the\nhighest polygon count.\n\u2022 LOCAL. Specifies that the context is within a layer2  polygon. Only the\nlayer1  polygon intersecting the layer2  polygon is included in determining\nthe highest polygon count.\nsconnect()", "include_touch": "Optional. Specifies the types of touches that provide an electrical connection.\nThe default is NONE.\n\u2022 NONE. Specifies that no touches form an electrical connection.\n\u2022 EDGE. Specifies that outside edge touches form an electrical connection.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The sconnect()  function selects the layer1  polygons that intersect the layer2\npolygons which belong to the net with the highest layer1  polygon count.", "function_name": "sconnect()"}
{"description": "The select_by_double_property()  function sorts the polygons of the input layer into a\npolygon layer based on the specified property name and value pair. Each polygon that fits\nthe pair is in the output layer. Other polygons are ignored.", "syntax": "select_by_double_property(\nlayer1         = polygon_layer,\nproperty_name  = \"string\",\nproperty_value = doubleconstraint,\nname            = \"layer_label\"\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer that is sorted.", "property_name": "Required. Specifies the user-defined name of the property.", "property_value": "Required. Specifies the constraint that must be satisfied.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The select_by_double_property()  function sorts the polygons of the input layer into a\npolygon layer based on the specified property name and value pair.", "function_name": "select_by_double_property()"}
{"description": "The select_marker_by_double_property()  function retrieves the pattern markers\nbased on the specified property name and double value pair. Each polygon that fits the\npair is in the output layer.", "syntax": "select_marker_by_double_property(\nlayer1         = marker_layer,\nproperty_name  = \"string\",\nproperty_value = doubleconstraint,\nname           = \"layer_label\"\n);", "returns": "marker_layer", "arguments": {"layer1": "Required. Specifies the pattern markers.", "property_name": "Required. Specifies the user-defined name of the property.", "property_value": "Required. Specifies the property value, which is a constraint of double.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The select_marker_by_double_property()  function retrieves the pattern markers\nbased on the specified property name and double value pair.", "function_name": "select_marker_by_double_property()"}
{"description": "The select_marker_by_string_property()  function retrieves the pattern markers\nbased on the specified property name and string value pair. Each polygon that fits the pair\nis in the output layer.", "syntax": "select_marker_by_string_property(\nlayer1          = marker_layer,\nproperty_name   = \"string\",\nproperty_value   = \"string\",\nname             = \"layer_label\",\nkeep_properties  = ALL  | NONE | INTERNAL,  //optional\nremove_duplicate_output  = true | false     //optional\n);", "returns": "marker_layer", "arguments": {"layer1": "Required. Specifies the pattern markers.", "property_name": "Required. Specifies the user-defined name of the property.", "property_value": "Required. Specifies the property value, which is a string.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "keep_properties": "Optional. Controls which properties are propagated to the output layer.\n\u2022 ALL. Specifies that all properties are propagated to the output layer.\n\u2022 NONE. Specifies that the output layer has no properties.\nselect_marker_by_string_property()\n\u2022 INTERNAL. Specifies that only the IC Validator internal properties are\npropagated to the output layer. The internal properties are PATTERN_NAME,\nPATTERN_ORIENTATION, and PATTERN_XOR_AREA. The user-defined\nproperties are dropped.\nNote:\nNote: When keep_properties = INTERNAL, the input marker\nlayer must be the output of a partial match, otherwise a runtime\nfatal error occurs.", "remove_duplicate_output": "Optional. Controls how duplicate markers are output. Duplicate markers have\nthe same bounding box. The default is false.\n\u2022 false. Specifies that all markers are output.\n\u2022 true. Specifies that the behavior depends on the setting of\nkeep_properties:\n\u25e6 INTERNAL. Duplicate markers are removed. A representative marker is\nchosen based on the internal property values, in this order:\n\u25aa minimum PATTERN_XOR_AREA\n\u25aa minimum PATTERN_NAME  \u2013 minimum is defined by ASCII order.\n\u25aa minimum PATTERN_ORIENTATION  \u2013 minimum is defined by this order,\nascending:\n\u25aa 0 rotation, no reflection\n\u25aa 90 rotation, no reflection\n\u25aa 180 rotation, no reflection\n\u25aa 270 rotation, no reflection\n\u25aa 0 rotation, reflected on x-axis\n\u25aa 90 rotation, reflected on y-axis\n\u25aa 0 rotation, reflected on y-axis\n\u25aa 90 rotation, reflected on x-axis"}, "summary": "The select_marker_by_string_property()  function retrieves the pattern markers\nbased on the specified property name and string value pair.", "function_name": "select_marker_by_string_property()"}
{"description": "The set_bias_by_rule_edge()  function attaches the specific bias value property on the\nedge segment by using the bias-rules list.", "syntax": "set_bias_by_rule_edge(\nlayer1      = data_layer,\nmain_layer  = polygon_layer,\nbias_rules  = {space  = doubleconstraint,\nwidth  = doubleconstraint,\nlength = doubleconstraint,\nmain_edge_length = doubleconstraint,\nbias   = double,\ntarget_space_after_bias  = double,\nspace_extension  = NONE  |\nNONE_INCLUSIVE |\nRADIAL | EDGE,\nspace_extension_distance = double,\nspace_projecting_length  = doubleconstraint,\nwidth_extension  =\nNONE  | NONE_INCLUSIVE |\nRADIAL | EDGE,\nwidth_extension_distance = double,\nwidth_projecting_length  = doubleconstraint,\nlook_through             =\nNONE  | NOT_ADJACENT,\n},\n//optional\nmain_space_layer  = polygon_layer,         //optional\nvalid_bias_range  = doubleconstraint        //optional\n);", "returns": "edge_layer", "arguments": {"layer1": "Required. Specifies the edge layer or polygon layer. The bias value property is\nattached on the segments of the edge layer or the edges of polygon layer.\nIf layer1  is an edge layer, the segments on layer1  are edges of main_layer  or\npart of the edges of main_layer. The segments on layer1  must be coincident\nwith the edge of main layer. If layer1  is a polygon layer, the polygons on\nlayer1  are required to be a subset of the polygons on the main_layer.\nIf layer1  has bias value, the attached bias value accumulates. For example, the\ninput layer1  has one segment, which the initial bias value property is equal to\nset_bias_by_rule_edge()\n0.01, and this function's internal calculation gets the bias value equal to 0.02.\nThe output bias value property 0.03.", "main_layer": "Required. Specifies the polygon layer. The space checking is done between\nlayer1  and main_layer( if there is no main_space_layer). The width\nchecking is done between layer1  and main_layer. The edge on main_layer,\nwhich is coincident with the segment on layer1, is used to calculate the length\nas the main_edge_length.", "bias_rules": "Required. Specifies the input rules table. The default is an empty list.\n\u2022 space. Specifies the space range of the rule. The space means the minimum\ndistance from the segment on layer1  to the polygons on the main_layer  (or\nmain_space_layer).\n\u2022 width. Specifies the width range of the rule. The width means the minimum\ndistance from the segment on layer1  to the polygons on the main_layer  by\nlooking through inside coincident.\n\u2022 length. Specifies the length range of the rule. The length means the length\nof the layer1  segment.\n\u2022 main_edge_length. Specifies the main edge length range of the rule. The\nmain_edge_length  represents the length of the edge on the main_layer,\nwhich is coincident with the segment on layer1.\n\u2022 bias. Specifies the bias value of the rule. The following example shows\nbias:\nrule : bias_rule_l = {{space = (0.2, 0.3), bias = 0.05},\n{space = [0.3, 0.4), bias = 0.10}};\nset_dis_result = set_bias_by_rule_edge(layer1, main_layer,\nrule);\nresult = apply_bias(set_dis_result, main_layer);\nset_bias_by_rule_edge()\n\u2022 target_space_after_bias. Specifies the target\nspace value after biasing. The bias value is (space -\nrule_constraint_s.target_space_after_bias) / 2\nIf the target_space_after_bias  option exist is set by a positive value, the\nspace constraint cannot be >, >=, or !=. The following example is in violation:\n{space = > 0.03, target_space_after_bias = 0.1},\nExample 1:\nrule : bias_rule_l = {{space = (0.1, 0.3),\ntarget_space_after_bias = 0.05},\n{space = [0.3, 0.4),\ntarget_space_after_bias = 0.10}};\nset_dis_result = set_bias_by_rule_edge(layer1, main_layer,\nrule);\nresult = apply_bias(set_dis_result, main_layer);\nset_bias_by_rule_edge()\nThe bias values for the red marked segments are calculated here:\nSeg1: bias = (space - target_space_after_bias)/2 = (0.25 - 0.05)/2 = 0.10\nSeg2: bias = (space - target_space_after_bias)/2 = (0.25 - 0.05)/2 = 0.10\nSeg3: bias = (space - target_space_after_bias)/2 = (0.35 - 0.10)/2 =\n0.125\nExample 2:\nrule : bias_rule_l = {{space = (0.10, 0.15),\ntarget_space_after_bias = 0.05},\n{space = [0.15, 0.30),\ntarget_space_after_bias = 0.15},\n{space = [0.30, 0.50),\ntarget_space_after_bias = 0.20};\nset_dis_result = set_bias_by_rule_edge(layer1, main_layer,\nrule);\nresult = apply_bias(set_dis_result, main_layer);\nset_bias_by_rule_edge()\nThe bias values for the red marked segments are calculated below,\nSeg1: bias = (space - target_space_after_bias)/2 = (0.134 - 0.05)/2 =\n0.42\nSeg2: bias = (space - target_space_after_bias)/2 = (0.134 - 0.05)/2 =\n0.42\nSeg3: bias = (space - target_space_after_bias)/2 = (0.280 - 0.15)/2 =\n0.065\nSeg4: bias = (space - target_space_after_bias)/2 = (0.134 - 0.05)/2 =\n0.42\n\u2022 space_extension. Optional. Specifies the space extension type of the\ninput rule. The default type is NONE. If space_extension_distance  is set\nto 0 (zero) and space_extension  is set to EDGE, space_extension  is\nautomatically changed to NONE.\n\u25e6 NONE. Does not extend the check region. It is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check\nregion is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.space  value.\n\u25e6 NONE_INCLUSIVE. Does not extend the check region; it is formed\nwith right-angle boundaries at the edge endpoints. The right-angle\nboundaries of the check region are inclusive. The far boundary of the\ncheck region is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.space  value.\n\u25e6 RADIAL. Extends the check region past the endpoints of the edges using\nthe table_constraint_s.space  value with a radial curve. The boundary\nof the check region is inclusive or exclusive depending on the constraint\nof the table_constraint_s.space  value.\nset_bias_by_rule_edge()\nThe RADIAL  example is:\ntable : bias_table_l = {{space = (0.0, 0.10], width = >0.0,\nbias = 0.01},\n{space = (0.1, 0.15), width =\n>0.0, bias = 0.03}};\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, space_extension = RADIAL);\nresult = apply_bias(set_dis_result, main_layer);\n\u25e6 EDGE. Forms the check region by extending the edges using\nspace_extension_distance  and creating right-angle boundaries at\nthe extended endpoints based on the table_constraint_s.space\nconstraint. The right-angle boundaries of the check region are exclusive.\nThe far boundary of the check region is inclusive or exclusive depending\non the constraint of the table_constraint_s.space  value.\nThe EDGE  example is:\ntable : bias_table_l = {{space = (0.0, 0.10], width = >0.0,\nbias = 0.01},\n{space = (0.1, 0.15), width =\n>0.0, bias = 0.03}};\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, space_extension = EDGE,\nset_bias_by_rule_edge()\nspace_extension_distance = 0.05);\nresult = apply_bias(set_dis_result, main_layer);\n\u2022 space_extension_distance. Optional. Specifies the space extension\ndistance of the input rule. The default distance is 0 (zero). If the\nspace_extension_distance  is set to a nonzero positive value, the\nspace_extension  is automatically changed to EDGE.\nThe EDGE  example is:\n\u2022 space_projecting_length. Optional. Reports spacing violations\nif the projection length meets the specification. The default is >0,\nwhich means the projection length is ignored. The restriction is\nrule_constraint_s.space_extension  must be NONE.\nThe projection length is the length of the projecting edge, where the\nprojecting edge is the violation edge that created the projection region. For\nnonparallel violations, the projecting edge is the edge that is perpendicular to\nthe violation.\n\u2022 width_extension. Optional. Specifies the width extension type of the\ninput rule. The default type is NONE. If width_extension_distance  is set\nto 0 (zero) and width_extension  is set to EDGE, width_extension  is\nautomatically changed to NONE.\n\u25e6 NONE. Does not extend the check region. It is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries\nof the check region are exclusive. The far boundary of the check\nregion is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.width  value.\n\u25e6 NONE_INCLUSIVE. Does not extend the check region; it is formed\nwith right-angle boundaries at the edge endpoints. The right-angle\nboundaries of the check region are inclusive. The far boundary of the\nset_bias_by_rule_edge()\ncheck region is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.width  value.\n\u25e6 RADIAL. Extends the check region past the endpoints of the edges using\nthe table_constraint_s.width  value with a radial curve. The boundary\nof the check region is inclusive or exclusive depending on the constraint\nof the table_constraint_s.width  value.\n\u25e6 EDGE. Forms the check region by extending the edges using\nwidth_extension_distance  and creating right-angle boundaries at\nthe extended endpoints based on the table_constraint_s.width\nconstraint. The right-angle boundaries of the check region are exclusive.\nThe far boundary of the check region is inclusive or exclusive depending\non the constraint of the table_constraint_s.width  value.\n\u2022 width_extension_distance. Optional. Specifies the width extension\ndistance of the input rules. The default distance is 0 (zero). If the\nwidth_extension_distance  is set to nonzero positive value, the\nwidth_extension  is automatically changed to EDGE.\n\u2022 width_projecting_length. Optional. Specifies the constraint of the\nprojecting_length  range of the rule. The default is to ignore this\nconstraint.\n\u2022 look_thru. Optional. Optional. Specifies the edges that the spacing check\nlooks through when measuring. The default is NONE.\nNote:\nThis setting is used only for spacing checks. The width looks\nthrough inside coincident edges all of the time.\n\u25e6 NONE. Looks through inside coincident edges from layer1  to\nmain_layer.\n\u25e6 NOT_ADJACENT. Looks through all edges, except for this special case:\nwhen two checked edges do not project onto each other, an adjacent\nedge of the extension past the endpoint of one checked edge can block\nthe extension check. If the adjacent edge fully blocks the shape of the\nextension violation, the extension violation is not reported. The extension\nis not measured.\nset_bias_by_rule_edge()\nThe example for look_through  is:", "main_space_layer": "Optional. Specifies main_space_layer  instead of main_layer  to do\nspacing checks against which the space is calculated. The default is\nNULL_POLYGON_LAYER. For example:\nrule : bias_rule_l = {{space = (0.1, 0.2), bias = 0.02},\n{space = [0.2, 0.3), bias = 0.4},\n{space = >=0.3,      bias = 0.06} };\nset_dis_result = set_bias_by_rule_edge(layer1, main_layer, rule,\nmain_space_layer);\nresult = apply_bias(set_dis_result, main_layer);", "valid_bias_range": "Optional. Specifies the valid bias range. If the bias value is out of\nvalid_bias_range, the upper or lower boundary value replaces the original\nbias value. The default range is [-100.0, 100.0].\nset_bias_by_rule_edge()\ntable : bias_table_l = {{space = (0.3, 0.5), width = >0.0, bias =\n0.15}};\nvalid_bias_range = [-0.1, 0.1];\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, valid_bias_range);\nresult = apply_bias(set_dis_result, main_layer,\nvalid_bias_range);\nset_bias_by_table_edge()\nset_bias_by_table_edge()"}, "summary": "The set_bias_by_rule_edge()  function attaches the specific bias value property on the\nedge segment by using the bias-rules list.", "function_name": "set_bias_by_rule_edge()"}
{"description": "The set_bias_by_table_edge()  function attaches the specific bias value property on the\nedge segment by using the bias-rules tables.", "syntax": "set_bias_by_table_edge(\nlayer1        = data_layer,\nmain_layer    = polygon_layer,\nbias_tables   = {space = doubleconstraint,\nwidth = doubleconstraint,\nbias  = double,\n},\nvalid_bias_range          = doubleconstraint,  //optional\nspace_extension           = NONE  | NONE_INCLUSIVE |\nRADIAL | EDGE,\n//optional\nspace_extension_distance  = double,            //optional\nwidth_extension           = NONE  | NONE_INCLUSIVE |\nRADIAL | EDGE,\n//optional\nwidth_extension_distance  = double,            //optional\nlook_through              = NOT_ADJACENT  | NONE | ALL  //optional\n);", "returns": "edge_layer", "arguments": {"layer1": "Required. Specifies the edge layer or polygon layer. The bias value property is\nattached on the segments of the edge layer or the edges of polygon layer.\nIf layer1  is an edge layer, the segments on layer1  are edges of main_layer  or\npart of the edges of main_layer. The segments on layer1  must be coincident\nwith the edge of main_layer. If layer1  is a polygon layer, the polygons on\nlayer1  are required to be a subset of the polygons on the main_layer.\nIf the segment in layer1  is already attached with bias value, the new bias value\nis accumulated. For example, for a segment in layer1, is attached with a bias\nvalue of 0.01 before calling this function, and this function prepares a new bias\nvalue of 0.02 according to the input table/rule. Finally, the output bias value\nproperty 0.03.\nset_bias_by_table_edge()", "main_layer": "Required. Specifies the polygon layer. The space and width checking is done\nbetween layer1and main_layer.", "bias_tables": "Required. Specifies the input rules table. The default is an empty list.\n\u2022 space. Specifies the space range of the rule. The space means the minimum\ndistance from the segment on layer1  to the polygons on the main_layer.\n\u2022 width. Specifies the width range of the rule. The width means the minimum\ndistance from the segment on layer1  to the polygons on the main_layer  by\nlooking through inside coincident.\n\u2022 bias. Specifies the bias value of the rule.\nThe following example shows the bias_by_table_edge():\ntable : bias_table_l = {{space = (0.2, 0.3), width = >0.0, bias =\n0.05},\n{space = [0.3, 0.4), width = >0.0,\nbias = 0.10}};\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable);\nresult = apply_bias(set_dis_result, main_layer);", "valid_bias_range": "Optional. Specifies the valid bias range. If the bias value is out of\nvalid_bias_range, the upper or lower boundary value replaces the original\nbias value. The default range is [-100.0, 100.0].\ntable : bias_table_l = {{space = (0.3, 0.5), width = >0.0, bias =\n0.15}};\nvalid_bias_range = [-0.1, 0.1];\nset_bias_by_table_edge()\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, valid_bias_range);\nresult = apply_bias(set_dis_result, main_layer,\nvalid_bias_range);", "space_extension": "Optional. Specifies the space extension type of the input rule. The default type is\nNONE. If space_extension_distance  is set to 0 (zero) and space_extension  is\nset to EDGE, space_extension  is automatically changed to NONE.\n\u2022 NONE. Does not extend the check region. It is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the table_constraint_s.space\nvalue.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the table_constraint_s.space\nvalue.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe table_constraint_s.space  value with a radial curve. The boundary of\nthe check region is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.space  value.\nThe RADIAL  example is:\ntable : bias_table_l = {{space = (0.0, 0.10], width = >0.0,\nbias = 0.01},\nset_bias_by_table_edge()\n{space = (0.1, 0.15), width =\n>0.0, bias = 0.03}};\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, space_extension = RADIAL);\nresult = apply_bias(set_dis_result, main_layer);\n\u2022 EDGE. Forms the check region by extending the edges using\nspace_extension_distance  and creating right-angle boundaries at the\nextended endpoints based on the table_constraint_s.space  constraint.\nThe right-angle boundaries of the check region are exclusive. The far\nboundary of the check region is inclusive or exclusive depending on the\nconstraint of the table_constraint_s.space  value.\nThe EDGE  example is:\ntable : bias_table_l = {{space = (0.0, 0.10], width = >0.0,\nbias = 0.01},\n{space = (0.1, 0.15), width =\n>0.0, bias = 0.03}};\nset_dis_result = set_bias_by_table_edge(layer1, main_layer,\ntable, space_extension = EDGE,\nset_bias_by_table_edge()\nspace_extension_distance = 0.05);\nresult = apply_bias(set_dis_result, main_layer);", "space_extension_distance": "Optional. Specifies the space extension distance of the input rule. The default\ndistance is 0 (zero). If the space_extension_distance  is set to a nonzero\npositive value, the space_extension  is automatically changed to EDGE.\nThe EDGE  example is:", "width_extension": "Optional. Specifies the width extension type of the input rule. The default type is\nNONE. If width_extension_distance  is set to 0 (zero) and width_extension  is\nset to EDGE, width_extension  is automatically changed to NONE.\n\u2022 NONE. Does not extend the check region. It is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the check\nregion are exclusive. The far boundary of the check region is inclusive or\nexclusive depending on the constraint of the table_constraint_s.width\nvalue.\n\u2022 NONE_INCLUSIVE. Does not extend the check region; it is formed with right-\nangle boundaries at the edge endpoints. The right-angle boundaries of the\ncheck region are inclusive. The far boundary of the check region is inclusive\nor exclusive depending on the constraint of the table_constraint_s.width\nvalue.\n\u2022 RADIAL. Extends the check region past the endpoints of the edges using\nthe table_constraint_s.width  value with a radial curve. The boundary of\nthe check region is inclusive or exclusive depending on the constraint of the\ntable_constraint_s.width  value.\n\u2022 EDGE. Forms the check region by extending the edges using\nwidth_extension_distance  and creating right-angle boundaries at the\nset_bias_by_table_edge()\nextended endpoints based on the table_constraint_s.width  constraint.\nThe right-angle boundaries of the check region are exclusive. The far\nboundary of the check region is inclusive or exclusive depending on the\nconstraint of the table_constraint_s.width  value.", "width_extension_distance": "Optional. Specifies the width extension distance of the input rules. The default\ndistance is 0 (zero). If the width_extension_distance  is set to nonzero\npositive value, the width_extension  is automatically changed to EDGE.", "look_through": "Optional. Specifies the edges that the spacing check looks through when\nmeasuring. The default is NONE.\nNote:\nThis setting is used only for spacing checks. The width looks through\ninside coincident edges all of the time.\n\u2022 NONE. Looks through inside coincident edges from layer1  to main_layer.\n\u2022 NOT_ADJACENT. Looks through all edges, except for this special case: when\ntwo checked edges do not project onto each other, an adjacent edge of the\nextension past the endpoint of one checked edge can block the extension\ncheck. If the adjacent edge fully blocks the shape of the extension violation,\nthe extension violation is not reported. The extension is not measured.\nThe example for look_through  is:"}, "summary": "The set_bias_by_table_edge()  function attaches the specific bias value property on the\nedge segment by using the bias-rules tables.", "function_name": "set_bias_by_table_edge()"}
{"description": "The shift_edge()  function creates edges by shifting all edges on the input layer by the\nspecified offsets. Each edge is independently shifted.", "syntax": "shift_edge(\nlayer1     = edge_layer,\ndistance   = double,\nname       = \"layer_label\"                              //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer that is the target layer.", "distance": "Required. Specifies a distance that the edge is shifted.\n\u2022 A positive value shifts the edges toward the outside direction.\n\u2022 A negative value shifts the edges toward the inside direction.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The shift_edge()  function creates edges by shifting all edges on the input layer by the\nspecified offsets.", "function_name": "shift_edge()"}
{"description": "The shift_symmetry()  function checks the symmetry of the target layer polygons\nagainst the created, mirrored polygons. This function uses a bounding layer to identify\nsymmetry units within a given context layer bounding box. All of the original polygons\n(layer1) that interact with the bounding layer within the context layer are considered to\nform one symmetry unit. This unit is checked for symmetry as per the given criteria with\nthe remaining symmetry units. The function\n\u2022 Selects a marker shape from the bounding layer for each polygon in the context layer\nand creates mirrored bodies of the original polygons (layer1) within each bounding\nbox of the context layer according to the given symmetry type.\n\u2022 For each bounding box in the context layer, compares the original polygons that\ninteract with the unselected marker shapes of the bounding layer against the created\nmirrored polygons, and reports the existing part in target polygons not in mirrored\npolygons.\n\u2022 Polygons in the context and bounding layers are deposited in the top cell and the\npolygons of the bounding layer must be enclosed in the polygons of the context layer.", "syntax": "shift_symmetry(\nlayer1          = polygon_layer,\ncontext_layer   = polygon_layer,\nbounding_layer  = polygon_layer,\nsymmetry        = HORIZONTAL_AXIS | VERTICAL_AXIS | ROTATE_180 | NONE,\nname            = \"layer_label\"                              //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is the target layer.", "context_layer": "Required. Specifies the polygon layer that is the context layer. Polygons in\nlayer1  that interact with polygons on the context layer are selected.\nshift_symmetry()", "bounding_layer": "Required. Specifies the polygon layer that is the bounding layer. Polygons in the\ncontext_layer  that interact with polygons on the bounding layer are selected.", "symmetry": "Required. Specifies the symmetry type of the pattern. The options are\n\u2022 HORIZONTAL_AXIS.\n\u2022 VERTICAL_AXIS.\n\u2022 ROTATE_180.\n\u2022 NONE.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The shift_symmetry()  function checks the symmetry of the target layer polygons\nagainst the created, mirrored polygons.", "function_name": "shift_symmetry()"}
{"description": "The short_equivalent_nodes()  function creates shorts between electrically equivalent\nnodes. The specified criteria must be met in order for the equivalent nodes to be\nshorted. The default is {\"w\", [-10, +10], RELATIVE, RATIO }, as specified in the\nexclude_tolerances  setting.\nNote:\nThe width_ratio_tolerance  argument takes precedence over the\nexclude_tolerances  argument when used in the same function. To use\nexclude_tolerances, do not set width_ratio_tolerance  simultaneously.\nWhen using width_ratio_tolerance, the tool issues a warning message that\nthis argument will be retired in the future. To be a candidate for equivalent node\nshorting, the bulk potential after shorting must be consistent with the potential\nbefore shorting for every MOSFET in the stack. Port nets cannot be candidates\nfor equivalent node shorting.\nSee the\nstack_type  argument for support of split series-parallel structure.\nAll nets are treated as non static except when they have the same name as the\nopposite side port or when they are explicitly specified in the layout_static_nets  or\nschematic_static_nets  arguments of the equiv_options()  function.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "short_equivalent_nodes(\nstate                 = compare_state,\ndevice_type           = NMOS | PMOS,\ndevice_names          = {\"string\", ...},                    //optional\nshort_nodes           = SAME_DEVICE_NAME_ONLY  | ANY_DEVICE_NAME |\nANY_DEVICE_TYPE,                    //optional\nwidth_ratio_tolerance = {tolerance      = doubleconstraint,\ntolerance_type = RELATIVE  | ABSOLUTE},\n//optional\nequiv_cells           = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"},\n...},                              //optional\nstack_type             = {SERIES_PARALLEL},                  //optional\nexclude_tolerances     = {{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type = RELATIVE  | ABSOLUTE},\ntolerance_calculation_method = CASCADE |\nshort_equivalent_nodes()\nRATIO}}\n//optional\nkeep_dangling_nets     = true | false                        //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the short_equivalent_nodes()  function is added.", "device_type": "Required. Specifies the device type. Only NMOS and PMOS device types are\navailable.", "device_names": "Optional. Specifies the layout devices. Each device must match a device\nspecified in a device_name  argument of a device configuration function.\nNote:\nWhen device names are specified but not declared by a device or\nmap_*  function, IC Validator automatically creates equates for these\ndevices when possible. Exceptions where device names do not\nautomatically create equates are when merge_series()  is used with\ngendev_series_pins  and filter()  is used with short_pins.", "short_nodes": "Optional. Specifies when shorts can be created. The default is\nSAME_DEVICE_NAME_ONLY.\nNote:\nWhen applying short_equivalent_nodes(), all devices in the same\nrow must be the same type and model name by default.\n\u2022 SAME_DEVICE_NAME_ONLY. Creates shorts when devices in the same series\nchain and parallel row have the same device type and same device name.\n\u2022 ANY_DEVICE_NAME. Creates shorts when devices in the same series chain\nand parallel row have the same device type.\n\u2022 ANY_DEVICE_TYPE. Creates shorts when devices in the same series chain\nare any type or name, and the parallel row has the same device type.\nshort_equivalent_nodes()\nThere are four cases of series chains with swappable and non-swappable pin\ndevices for the short_equivalent_nodes()  function:\n\u2022 Case 1. Series chain with the same order of non-swappable pin devices\n\u2022 Case 2. Series chain with a different order of non-swappable pin devices\n\u2022 Case 3. Series chain with swappable pin devices\n\u2022 Case 4. Series chain with swappable and non-swappable pin devices\nCases 1, 3, and 4 are considered valid series chains for the\nshort_equivalent_nodes()  function.\nFigure 599 Series Chain Cases", "width_ratio_tolerance": "Optional. Specifies the tolerance constraints. The difference of width ratio\nof devices at the equivalent nodes must satisfy the tolerance constraints.\nOtherwise, the shorts are not created.\n\u2022 tolerance. Specifies the tolerance for the width ratio. The width ratio is\nchecked based on this tolerance. The tolerance must be specified as a\nrange. The default is undefined and must be given a valid value.\n\u2022 tolerance_type. Optional. Specifies how property tolerances are checked.\nThe default is RELATIVE.\nshort_equivalent_nodes()\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\nproperty difference.\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nproperty value difference. The units are based on the lvs_user_unit\nargument of the run_options()  function.", "equiv_cells": "Optional. Specifies the schematic and layout cell name pairs for which\nthe short_equivalent_nodes()  function applies. You must specify the\nequiv_cells  pairs in the equiv_options()  function before calling the\nshort_equivalent_nodes()  function. If only one cell name in the pair is\nspecified, the names are assumed to be the same.\nNote:\nThe short_equivalent_nodes()  instruction is observed only when\ncomparing each listed equivalence cell pair. If an equivalence cell pair\nis exploded into the parent equivalence cell pair while comparing the\nparent, the short_equivalent_nodes()  instruction is discarded for\nthe content of the exploded cell.", "stack_type": "Optional. Specifies support for split series-parallel structures.\n\u2022 SERIES_PARALLEL. Shorts nets of each series stack of parallel devices as\nshown in\nFigure 600.\nFigure 600 SERIES_PARALLEL Option of the stack_type Argument\nThis option applies to the series-parallel structures of MOS devices where\neach series stack has the same form of parallel structures. Structures more\ncomplex than series-parallel are not supported.\nshort_equivalent_nodes()", "exclude_tolerances": "Optional. Lists the tolerance settings that exclude candidate devices from being\nmerged based on the property values of the devices.\n\u2022 property. Specifies the property name. When none of the merged\ncandidates contain a property, the exclude condition does not apply.\n\u2022 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies if the tolerance is\na percentage (default) or absolute value. The default is {\"w\", [-10,+10],\nRELATIVE, RATIO }.\nThe minimum resolution allowed for tolerance checking is as follows:\n\u25e6 When schematic_property !=0, the minimum resolution value is\nabsolute_value(schematic_property*1e-6).\n\u25e6 When schematic_property ==0, the minimum resolution value is\nabsolute_value(layout_property*1e-6).\nIf the specified tolerance range is less than this minimum value, for example,\n[-0,0], the property  option is checked for violations according to the\nminimum resolution.\n\u2022 tolerance_type. Optional. Checks property tolerances based on a relative\nor absolute property difference. The default is RELATIVE.\n\u25e6 RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n\u25e6 ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the\nlvs_user_unit  argument of\nthe run_options()  function.\n\u2022 tolerance_calculation_method. Optional. Specifies the algorithm by\nwhich tolerances are checked. The default is RATIO.\n\u25e6 CASCADE. Checks each corresponding device pair in two-series chains.\n\u25e6 RATIO. Calculates the series-to-series property ratio for each of the\ncorresponding device pairs. The smallest property ratio serves as the\nbase ratio in which other property ratios are compared.", "keep_dangling_nets": "Optional. Prevents dangling nets from being shorted. The default is false.\nshort_equivalent_nodes()"}, "summary": "The short_equivalent_nodes()  function creates shorts between electrically equivalent\nnodes.", "function_name": "short_equivalent_nodes()"}
{"description": "The short_equivalent_nodes_off()  function prevents equivalent node shorts from\nbeing created on a path that contains one of the specified devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "short_equivalent_nodes_off(\nstate        = compare_state,\ndevice_type  = NMOS | PMOS,\ndevice_names = {\"string\", ...},                    //optional\nequiv_cells  = {{schematic_cell = \"string\",\nlayout_cell    = \"string\"}, ...}  //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\nshort_equivalent_nodes_off()  information is added.", "device_type": "Required. Specifies the device type. Only NMOS and PMOS device types are\navailable.", "device_names": "Optional. Specifies the layout devices. Each device must match a device\nspecified in a device_name  argument of a device configuration function.", "equiv_cells": "Optional. Specifies the schematic and layout cell name pairs for which the\nshort_equivalent_nodes_off()  function applies. You must specify the\nequiv_cells  pairs in the equiv_options()  function before calling the\nshort_equivalent_nodes_off()  function. If only one cell name in the pair is\nspecified, the names are assumed to be the same.\nshort_equivalent_nodes_off()\nNote:\nThe short_equivalent_nodes_off()  instruction is observed only\nwhen comparing each listed equivalence cell pair. If an equivalence\ncell pair is exploded into the parent equivalence cell pair while\ncomparing the parent, the short_equivalent_nodes_off()\ninstruction is discarded for the content of the exploded cell."}, "summary": "The short_equivalent_nodes_off()  function prevents equivalent node shorts from\nbeing created on a path that contains one of the specified devices.", "function_name": "short_equivalent_nodes_off()"}
{"description": "The short_equivalent_stack_nodes()  function creates stacks between electrically\nequivalent stack nodes. This function currently only supports the inverter + pass-\ngate structure. The internal net connects the inverter and the pass-gate. This function\nrecognizes such netlist patterns and shorts the internal nets, as shown in\nFigure 607.\nFigure 607 inverter + pass-gate Structure\nNote:\nPower, ground, and global nets cannot be candidates for equivalent node\nshorting. It does not form an inverter + pass-gate structure if d connects e or f\nconnects g, as shown in\nFigure 608.\nFigure 608 No inverter + pass-gate Structure is Formed\nshort_equivalent_stack_nodes()\nIt is not recommended that you provide the stack as shown in Figure 609. That is,\na connects f and c connects d, or a connects g and c connects e. This might cause\nunexpected results.\nFigure 609 Undesirable Stack\nWhen source/drain are not swappable, the following structures are valid for the inverter\nand pass-gate structures, as shown in\nFigure 610  and Figure 611.\nFigure 610 Valid Inverter Structure When Source/Drain are Not Swappable\nshort_equivalent_stack_nodes()\nFigure 611 Valid Pass-Gate Structure When Source/Drain are Not Swappable\nAll nets are treated as non static except when they have the same name as the\nopposite side port or when they are explicitly specified in the layout_static_nets  or\nschematic_static_nets  arguments of the equiv_options()  function.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "short_equivalent_stack_nodes(\nstate                 = compare_state,\nexclude_tolerances= {{device_type = NMOS | PMOS,}\ndevice_names = {\"string\", ...},\ntolerances = {\n{property       = \"string\",\ntolerance      = doubleconstraint,\ntolerance_type =\nRELATIVE  | ABSOLUTE},\n...}}                        //optional\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the short_equivalent_stack_nodes()  function is added.\nshort_equivalent_stack_nodes()", "exclude_tolerances": "Optional. Lists the tolerance settings composed of device type, list of device\nnames, and list of property tolerance settings. This is a more general exclude\ntolerances setting than that of the merge_series()  function.\nNote:\nThe short_equivalent_stack_nodes()  function does not support\nswappable properties in the exclude_tolerances  argument.\nUse this parameter to constrain gate recognition based on property comparison.\n\u2022 device_type. Required. Specifies the device type. Only NMOS and PMOS\ndevice types are available.\n\u2022 device_names. Optional. Specifies the layout devices. Each device\nmust match a device specified in a device_name  argument of a device\nconfiguration function.\nNote:\nWhen device names are specified but not declared by a device\nor map_*  function, IC Validator automatically creates equates for\nthese devices when possible. Exceptions where device names\ndo not automatically create equates are when merge_series()\nis used with gendev_series_pins  and filter()  is used with\nshort_pins.\n\u2022 tolerances. Optional. Lists the tolerance settings that exclude candidate\ndevices from being merged based on the device property values.\n\u25e6 property. Required. Specifies the property used to check the tolerance\nrange.\n\u25e6 tolerance. Optional. Specifies the tolerance. The property  option is\nchecked for violations based on this tolerance. The tolerance must be\nspecified as a range. The tolerance_type  option specifies either that\nthe tolerance is a percentage (default) or an absolute value. The default is\n[-10,+10].\n\u25e6 tolerance_type. Optional. Checks property tolerances based on a\nrelative or absolute property difference. The default is RELATIVE.\n- RELATIVE. Specifies that tolerances are checked based on a percentage\ndifference.\n- ABSOLUTE. Specifies that tolerances are checked based on an absolute\nvalue difference. The units are based on the lvs_user_unit  argument of", "the": "run_options()  function.\nshort_equivalent_stack_nodes()"}, "summary": "The short_equivalent_stack_nodes()  function creates stacks between electrically\nequivalent stack nodes.", "function_name": "short_equivalent_stack_nodes()"}
{"description": "The short_equivalent_stack_nodes_off()  prevents equivalent node stacks from\nbeing created on a path that contains one of the specified devices.\nThis function must be called before the\ncompare()  function. See Chapter 7, \u201cCompare\nFunctions Basics\u201d in the IC Validator LVS User Guide  for more information about\ncomplementary functions and precedence rules.", "syntax": "short_equivalent_stack_nodes_off(\nstate = compare_state\n);", "returns": "void", "arguments": {"state": "Required. Specifies the structure that contains compare settings. The compare\nmatrix must be defined by the\ninit_compare_matrix()  function. The\ninformation from the short_equivalent_nodes_off()  function is added."}, "summary": "The short_equivalent_stack_nodes_off()  prevents equivalent node stacks from\nbeing created on a path that contains one of the specified devices.", "function_name": "short_equivalent_stack_nodes_off()"}
{"description": "The shrink()  function creates polygons from the input layer that are undersized\nin the specified directions by the specified distances. If the north, south, east,\nand west  arguments are all 0 (zero) then the output is the original layer. See the\nprototype_options()  function for more information about defining the criteria for the\ncreation of prototype cells during hierarchical preprocessing.", "syntax": "shrink(\nlayer1          = polygon_layer,\nnorth           = double,                     //optional\nsouth           = double,                     //optional\neast            = double,                     //optional\nwest            = double,                     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",             //optional\norientation      = ALL  | ORTHOGONAL,          //optional\ncorner_extension  = NONE | INTERSECTION       //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "north": "Optional. Specifies the undersize distance from the northern direction, or the top\nof the polygons. The default is 0.", "south": "Optional. Specifies the undersize distance from the southern direction, or the\nbottom of the polygons. The default is 0.", "east": "Optional. Specifies the undersize distance from the eastern direction, or right of\nthe polygons. The default is 0.", "west": "Optional. Specifies the undersize distance from the western direction, or left of\nthe polygons. The default is 0.\nshrink()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "orientation": "Optional. Specifies the edges to shrink. The default is ALL.\n\u2022 ALL. Shrinks all the edges.\n\u2022 ORTHOGONAL. Shrinks only the orthogonal edges.", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The default is INTERSECTION.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 NONE. Does not extend corners."}, "summary": "The shrink()  function creates polygons from the input layer that are undersized\nin the specified directions by the specified distances.", "function_name": "shrink()"}
{"description": "The size()  function oversizes the polygons on the input layer by the specified value.", "syntax": "size(\nlayer1           = polygon_layer,\ndistance         = double,\ncorner_extension = INTERSECTION | RADIAL_OUTSIDE |\nRADIAL_INSIDE | NONE,                    //optional\nclip_acute       = BISECTOR | ORTHOGONAL | OCTAGONAL | TRUNCATE |\nNONE,                                    //optional\ncorner_steps     = integer,                                 //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,               //optional\nname             = \"layer_label\",                           //optional\nradial_sectors    = integer,                                 //optional\nsnap             = CLOSEST  | OVERSIZE | UNDERSIZE,          //optional\nclip_distance    = double                                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the size distance.\n\u2022 A positive value oversizes the polygons.\n\u2022 A negative value undersizes the polygons.\n\u2022 A value of 0 is a copy.", "corner_extension": "Optional. Specifies how the corners are processed. The default is\nINTERSECTION.\nsize()\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 RADIAL_OUTSIDE. Forms a radial corner using an approximation curve that\nis generated by a regular polygon circumscribed by a circle with the radius\ndistance.\n\u2022 RADIAL_INSIDE. Forms a radial corner using an approximation curve that is\ngenerated by a regular polygon inscribed by a circle with the radius distance.\n\u2022 NONE. Does not extend corners.", "clip_acute": "Optional. When the corner_extension  argument is INTERSECTION, specifies\nthe type of clipping that occurs when an acute interior angle is oversized, or an\nacute exterior angle is undersized. The default is OCTAGONAL.\n\u2022 BISECTOR. Clips acute angles with an edge perpendicular to the angle\nbisector at (sqrt(2) x distance) from the original corner.\n\u2022 ORTHOGONAL. When one edge is orthogonal, clips the angle perpendicular to\nthat edge at the specified distance from the original corner. Otherwise, clips\nthe angle with an edge perpendicular to the angle bisector at the specified\ndistance away from the original corner.\n\u2022 OCTAGONAL. Clips acute angles with two edges at the specified distance from\nthe original corner, perpendicular to each of the edges forming the corner.\n\u2022 TRUNCATE. When one edge is orthogonal, clips the angle perpendicular to\nthat edge. Otherwise, clips the angle with an edge perpendicular to the angle\nbisector. The clipping distance is set by the clip_distance  argument, which\ndefaults to distance/cos(67.5).\n\u2022 NONE. Does not clip acute angles.", "corner_steps": "Optional. When the corner_extension  argument is NONE, this argument\nprovides an approximation of the oversize of orthogonal corners using the\nspecified number of steps. Nonorthogonal corners are approximated with a\nsingle edge. The default is 0.\nIf the specified corner_steps  value is too big, meaning that the corresponding\ncorner step size is smaller than the internal resolution, the specified\ncorner_steps  value has no effect. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. In this case, the\ninternal resolution is used to determine the largest possible number to be used\nas the corner_steps  value.\nsize()", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "radial_sectors": "Optional. Specifies the number of radial sectors used to approximate a quadrant\nat the right corner. The effect of this argument on the sizing depends on the\nvalue of the corner_extension  argument.\nThe minimum value is 0, and the maximum value is 32. The value must be\ngreater than 0 if the corner_extension  argument is RADIAL_INSIDE  or\nRADIAL_OUTSIDE. The default is 0.", "snap": "Optional. Specifies how non-orthogonal edges are snapped. The default is\nCLOSEST.\n\u2022 CLOSEST. Specifies that sized vertices are snapped to the closest internal\nresolution.\n\u2022 OVERSIZE. Specifies that sized vertices are snapped to the closest upper\ninternal resolution.\n\u2022 UNDERSIZE. Specifies that sized vertices are snapped to the closest lower\ninternal resolution.", "clip_distance": "Optional. A double value that specifies the clipping distance when\nclip_acute=TRUNCATE. The default is distance/cos(67.5)."}, "summary": "The size()  function oversizes the polygons on the input layer by the specified value.", "function_name": "size()"}
{"description": "The size_and_grow_inside()  function is a bounded, incremental, oversize operation.\nThe process begins with an AND operation to find the active area shared by the two\nlayers. The layer1  or the bounding  layer polygons that do not share active areas with\nthe other layer are ignored. The size_and_grow_inside()  function is quite similar to the\nsize_inside()  function but you can have a different value in north, south, east, and west\ndirections. The process continues by repeating these two steps:\n1. An oversize using the increment  argument value.\n2. An AND with the bounding  layer.", "syntax": "size_and_grow_inside(\nlayer1      = polygon_layer,\nbounding    = polygon_layer,\ndistance    = double,\nincrement   = double,\ngrow_ambits  = {list of ambit_s},   //optional\ngrow_jump_notch   = true | false,    //optional\nname        = \"layer_label\",          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL, //optional\npredicate    = true  | false      //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is sized.", "bounding": "Required. Specifies the bounding polygon layer.", "distance": "Required. Specifies the total oversize distance. It must be a positive number.", "increment": "Required. Specifies the step size, which must have a value greater than 0.\nsize_and_grow_inside()", "grow_ambits": "Optional. If the list is not specified, the result is aligned to the size_inside()\nfunction. The list contains the ambits of several grow()  function to be processed\nwith the size_inside()  function.", "grow_jump_notch": "Optional. Specifies the result of the grow()  function that can jump over the\nlayer1 polygon. The default is false.\n\u2022 true.The grow()  result can cross over the gap of input polygon layer.\n\u2022 false : The grow()  result needs to be a single polygon and discards the\noutput that jumps over the gap.\nFigure 618  and Figure 619  describes the behavior of the grow_jump_notch\nargument.\nFigure 618 grow_jump_notch Behavior\nsize_and_grow_inside()\nFigure 619 grow_jump_notch Behavior (continued)", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "predicate": "Optional. Specifies a predicate_handle  for empty layer optimization. The\npredicate controls the operation as follows:\n\u2022 true. The function operates as normal.\n\u2022 false. The function produces empty output."}, "summary": "The size_and_grow_inside()  function is a bounded, incremental, oversize operation.", "function_name": "size_outside()"}
{"description": "The size_inside()  function is a bounded, incremental, oversize operation. The process\nbegins with an AND operation to find the active area shared by the two layers. The layer1\nor the bounding  layer polygons that do not share active areas with the other layer are\nignored. The process continues by repeating these two steps:\n1. An oversize using the increment  argument value.\n2. An AND with the bounding  layer.\nEach iteration results in data that increasingly fills the area of the enclosing, bounding\npolygon. These two steps are repeated until the accumulated oversize meets the specified\ndistance. By default, the process is completed by subtracting the sized data from the\nbounding polygon, such that the result is the portion of the bounding polygon that was not\ncovered by the incrementally sized data.", "syntax": "size_inside(\nlayer1           = polygon_layer,\nbounding         = polygon_layer,\ndistance         = double,\nincrement        = double,\noutput_type      = OVERSIZE | REMAINDER,                    //optional\nradial_points    = {ONE, TWO, FOUR, EIGHT, SIXTEEN},        //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,               //optional\nname             = \"layer_label\",                           //optional\nradial_sectors    = integer,                                 //optional\ncorner_extension = INTERSECTION  | RADIAL_OUTSIDE | RADIAL_INSIDE,\n//optional\nstart_with       = AND  | SIZE,                              //optional\nclip_acute       = NONE | TRUNCATE,                         //optional\nclip_distance    = double,                                 //optional\napply_radial_sectors  = ALL_INCREMENTS  | FIRST_INCREMENT     //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer that is sized.", "bounding": "Required. Specifies the bounding polygon layer.\nsize_inside()", "distance": "Required. Specifies the total oversize distance. It must be a positive number.", "increment": "Required. Specifies the step size, which must have a value greater than 0.\nThe objective is to set the increment  argument to the largest legal value so that\nthe size_inside()  function takes the fewest iterations to complete.\nThe limitations are as follows:\n\u2022 Too large of an increment can cause the oversized data to jump into adjacent\ndata.\n\u2022 Too small of an increment causes the operation to run in less than optimal\ntime.", "output_type": "Optional. Specifies the type of output generated.\n\u2022 OVERSIZE. Outputs the incremental, bounded, size.\n\u2022 REMAINDER. Outputs the portion of the bounding polygon that is not covered\nby the oversized data. The remainder does not  include bounding polygons\nthat do not share an active area with layer1.", "radial_points": "Optional. Specifies the number of points used to approximate a radial curve\nwhen oversizing right, interior corners. The default is ONE. The possible values\nare:\n\u2022 ONE  (indicates that no approximation curve is formed)\n\u2022 TWO\n\u2022 FOUR\n\u2022 EIGHT\n\u2022 SIXTEEN\nApproximation Curves\nsize_inside()\nApproximation curves are formed, as follows:\n\u2022 90-degree interior corners are approximated with the number of radial points\nspecified.\n\u2022 The sharper the interior angle, the more points that are used for the\napproximation. The number of points used varies across the continuum of\nangles. That is,\n\u25e6 The oversizing of 135-degree interior corners is approximated with 0.5 as\nmany radial points.\n\u25e6 The oversizing of 45-degree interior corners is approximated with 1.5 as\nmany radial points.\nIf the radial_points  argument is not ONE, set the increment as\nincrement = distance / error ratio\nwhere the error ratios are shown in\nTable 68.\nTable 68 Error Ratios\nradial_points value Error ratio\nTWO 1.09\nFOUR 1.02\nEIGHT 1.005\nSIXTEEN 1.002", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nsize_inside()", "radial_sectors": "Optional. Specifies the number of radial sectors used to approximate a quadrant\nat the right corner. The effect of this argument on the sizing depends on the\nvalue of the corner_extension  argument. The radial_points  argument must\nbe ONE.\nThe minimum value is 0, and the maximum value is 32. If the value is 0, then the\nsize_inside()  function does not form an approximation curve. The default is 0.", "corner_extension": "Optional. Specifies how corners are handled when the function causes the\nadjacent edges to pull apart. This behavior does not apply to corners where the\nfunction causes the edges to collide. The radial_points  argument must be\nONE. The default is INTERSECTION.\n\u2022 INTERSECTION. Forms a new corner at the intersection point of the sized\nadjacent edges.\n\u2022 RADIAL_OUTSIDE. A radial corner is formed by the approximation curve is\ngenerated by a regular polygon circumscribed by a circle with the radius\ndistance.\n\u2022 RADIAL_INSIDE. A radial corner is formed by the approximation curve is\ngenerated by a regular polygon inscribed by a circle with the radius distance.", "start_with": "Optional. Specifies how to start the size_inside  operations of layer1. The\ndefault is AND.\n\u2022 AND. Starts with an AND  operation to find the area shared by layer1  and a\nbounding layer.\nNote:\nThe output of the size_inside()  function is empty for a layer1\nshape that does not share an active area with a bounding layer.\n\u2022 SIZE. Starts with a SIZE  operation. Use this setting when the\nsize_inside()  function needs to size a layer1  shape inside a bounding\nlayer that does not share an active area with a boundary layer.", "clip_acute": "Optional. When the corner_extension  argument is INTERSECTION, specifies\nthe type of clipping that occurs when an acute interior angle is oversized, or an\nacute exterior angle is undersized. The default is NONE.\nsize_inside()\n\u2022 NONE. Does not clip acute angles.\n\u2022 TRUNCATE. When one edge is orthogonal, clips the angle perpendicular to\nthat edge. Otherwise, clips the angle with an edge perpendicular to the angle\nbisector. The clipping distance is set by the clip_distance  argument, which\ndefaults to distance/cos(67.5).", "clip_distance": "Optional. A double value that specifies the clipping distance when\nclip_acute=TRUNCATE. The default is distance/cos(67.5).", "apply_radial_sectors": "Optional. Specifies the corner_extension  to be applied on the\nFIRST_INCREMENT  or ALL_INCREMENTS. The option should be applied with only\nwhen corner_extension  is RADIAL_OUTSIDE  or RADIAL_INSIDE. The default is\nALL_INCREMENTS.\n\u2022 ALL_INCREMENTS. Applies the corner_extension  on the all size operation.\n\u2022 FIRST_INCREMENT. Only applies the corner_extension  on the first size\noperation."}, "summary": "The size_inside()  function is a bounded, incremental, oversize operation.", "function_name": "size_inside()"}
{"description": "The size_overlap()  function oversizes the polygons on the input layer by the specified\nvalue, and then creates polygons that represent the area where the separate, oversized\npolygons overlap.", "syntax": "size_overlap(\nlayer1     = polygon_layer,\ndistance   = double,\nclip_acute = BISECTOR | ORTHOGONAL | OCTAGONAL | NONE,      //optional\nname       = \"layer_label\"                                  //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the oversize distance. It must be positive; a value of 0\nresults in an empty output layer.", "clip_acute": "Optional. When the corner_extension  argument is INTERSECTION, this\nargument specifies the type of clipping that occurs on acute interior angles. The\ndefault is NONE.\n\u2022 BISECTOR. Clips acute angles with an edge perpendicular to the angle\nbisector at (sqrt(2) x distance) from the original corner.\n\u2022 ORTHOGONAL. When one edge is orthogonal, clips the angle perpendicular to\nthat edge at the specified distance from the original corner. Otherwise, clips\nthe angle with an edge perpendicular to the angle bisector at the specified\ndistance away from the original corner.\n\u2022 OCTAGONAL. Clips acute angles with two edges at the specified distance\nfrom the original corner, perpendicular to each of the edges forming the\ncorner.\n\u2022 NONE. Does not clip acute angles.\nsize_overlap()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The size_overlap()  function oversizes the polygons on the input layer by the specified\nvalue, and then creates polygons that represent the area where the separate, oversized\npolygons overlap.", "function_name": "size_overlap()"}
{"description": "The snap()  function creates polygons that represent the input polygons with all vertices\nsnapped to the specified resolution. This function is a cell-level operation.\nNote:\nThe tool does not fill in holes created by a self-intersecting polygons that are\ncreated by the snap()  function.", "syntax": "snap(\nlayer1     = polygon_layer,\nresolution  = double,\npreference = OVERSIZE | UNDERSIZE | RETAIN_45  | CLOSEST,  //optional\nname       = \"layer_label\"                                //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer.", "resolution": "Required. Specifies the resolution value for snapping the polygons. It must be a\npositive value.", "preference": "Optional. Specifies where vertices are snapped. The default is RETAIN_45.\n\u2022 OVERSIZE. Specifies that vertices are snapped to the closest grid point that is\noutside or on the input polygon.\n\u2022 UNDERSIZE. Specifies that vertices are snapped to the closest grid point that\nis inside or on the input polygon.\n\u2022 RETAIN_45. Specifies that vertices are snapped to the closest grid point with\nthe possible exception of 45-degree edges. An attempt is made to maintain\n45-degree edges when snapping.\n\u2022 CLOSEST. Specifies that vertices are snapped to the closest grid point.\nsnap()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The snap()  function creates polygons that represent the input polygons with all vertices\nsnapped to the specified resolution.", "function_name": "snap()"}
{"description": "The snap_edge()  function creates edges that represent the input edges with all endpoints\nsnapped to the specified resolution. This function is a cell-level operation.", "syntax": "snap_edge(\nlayer1     = edge_layer,\nresolution  = double,\npreference = OVERSIZE | UNDERSIZE | RETAIN_45  | CLOSEST,  //optional\nname       = \"layer_label\"                                //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the edge layer.", "resolution": "Required. Specifies the resolution value for snapping the edges. It must be a\npositive value.", "preference": "Optional. Specifies where endpoints are snapped. The default is RETAIN_45.\n\u2022 OVERSIZE. Specifies that endpoints are snapped to the closest grid point that\nis outside or on the input edge.\n\u2022 UNDERSIZE. Specifies that endpoints are snapped to the closest grid point\nthat is inside or on the input edge.\n\u2022 RETAIN_45. Specifies that endpoints are snapped to the closest grid point\nwith the possible exception of 45-degree edges. An attempt is made to\nmaintain 45-degree edges when snapping.\n\u2022 CLOSEST. Specifies that endpoints are snapped to the closest grid point.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nsnap_edge()"}, "summary": "The snap_edge()  function creates edges that represent the input edges with all endpoints\nsnapped to the specified resolution.", "function_name": "snap_edge()"}
{"description": "The snap_to_pattern()  function creates data that represent the input data snapped to\nthe specified grid_pattern. This function is a cell-level operation.", "syntax": "snap_to_pattern(\nlayer1          = polygon_layer,\nbounding_layer  = polygon_layer,\nreference_layer  = polygon_layer,\ngrid_pattern    = list of double,\noffset          = double,\norientation     = VERTICAL | HORIZONTAL,\npreference      = OVERSIZE | UNDERSIZE | CLOSEST_OVERSIZE  |\nCLOSEST_UNDERSIZE,                        //optional\nname            = \"layer_label\",                            //optional\nsnap_side       = ALL  | HIGH | LOW,                         //optional\noutput_type     = ALL  | DELTA                               //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the input layer to be snapped. The snap_to_pattern()\nargument accepts polygon layer and output polygon layer.", "bounding_layer": "Required. Specifies the input polygon layer to limit the edges that could be\nsnapped. Both the data to be snapped and the snapped result should be inside\nor inside_coincident with the bounding layer.", "reference_layer": "Required. Specifies the input polygon layer to use (left, bottom) of its layer\nextents as the reference point to define the grid pattern.", "grid_pattern": "Required. Specifies different distance values to form the repeated pattern.\nsnap_to_pattern()", "offset": "Required. Specifies the distance before the repeated pattern, measured from\nthe reference point, which depends on the orientation  argument:\n\u2022 orientation=VERTICAL. Uses the left of the layer extents of the reference\nlayer.\n\u2022 orientation=HORIZONTAL. Uses the bottom of the layer extents of the\nreference layer.", "orientation": "Required. Specifies the orientation used to snap to the grids.\n\u2022 VERTICAL. Snaps the x-coordinate of vertices from vertical edges.\n\u2022 HORIZONTAL. Snaps the y-coordinate of vertices from horizontal edges.", "preference": "Optional. Specifies how edges are snapped. These edges cannot snap exceed\nthe bounding layer polygon where they are inside or inside_coincident. The\ndefault is CLOSEST_OVERSIZE.\n\u2022 OVERSIZE. Specifies that vertices from candidate edges are snapped to the\nclosest grid that is outside or on the input polygon or edge.\n\u2022 UNDERSIZE. Specifies that vertices from candidate edges are snapped to the\nclosest grid that is inside or on the input polygon or edge.\n\u2022 CLOSEST_OVERSIZE. Specifies that vertices from candidate edges are\nsnapped to the closest grid. If it is in the middle point, choose OVERSIZE.\n\u2022 CLOSEST_UNDERSIZE. Specifies that vertices from candidate edges are\nsnapped to the closest grid. If it is in the middle point, choose UNDERSIZE.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "snap_side": "Optional. Specifies the limit at which the side must be snapped. The default is\nALL.\n\u2022 ALL. Specifies that both the LOW  and HIGH  edges must be snapped.\n\u2022 HIGH. Specifies that if the orientation is HORIZONTAL, the edge on the\ntop side, with a direction from left to right is snapped. If the orientation is\nsnap_to_pattern()\nVERTICAL, the edge on the right side, with a direction from top to bottom, is\nsnapped.\n\u2022 LOW. Specifies that if the orientation is HORIZONTAL, the edge on the bottom\nside, with a direction from right to left is snapped. If the orientation is\nVERTICAL, the edge on the left side, with a direction from bottom to top is\nsnapped.", "output_type": "Optional. Specifies how the post-snapping result is returned. The default is ALL.\n\u2022 ALL. Specifies that the post-snap output is the extension and retraction\nportion along with the polygon that is input to the snapping operation.\n\u2022 DELTA. Specifies that the post-snap output is just the extension and retraction\nportion of the snapping operation."}, "summary": "The snap_to_pattern()  function creates data that represent the input data snapped to\nthe specified grid_pattern.", "function_name": "snap_to_pattern()"}
{"description": "The snap_to_pattern_edge()  function creates data that represent the input data\nsnapped to the specified grid_pattern. This function is a cell-level operation.", "syntax": "snap_to_pattern_edge(\nlayer1          = edge_layer,\nbounding_layer  = polygon_layer,\nreference_layer  = polygon_layer,\ngrid_pattern    = list of double,\noffset          = double,\norientation     = VERTICAL | HORIZONTAL,\npreference      = OVERSIZE | UNDERSIZE | CLOSEST_OVERSIZE  |\nCLOSEST_UNDERSIZE,                        //optional\nname            = \"layer_label\",                            //optional\nsnap_side       = ALL  | HIGH | LOW                          //optional\n);", "returns": "edge layer", "arguments": {"layer1": "Required. Specifies the input layer to be snapped. The\nsnap_to_pattern_edge()  argument accepts edge layer and output edge layer.\nFor edge input, edges are snapped independently per edge.", "bounding_layer": "Required. Specifies the input polygon layer to limit the edges that could be\nsnapped. Both the data to be snapped and the snapped result should be inside\nor inside_coincident with the bounding layer.", "reference_layer": "Required. Specifies the input polygon layer to use (left, bottom) of its layer\nextents as the reference point to define the grid pattern.", "grid_pattern": "Required. Specifies different distance values to form the repeated pattern.\nsnap_to_pattern_edge()", "offset": "Required. Specifies the distance before the repeated pattern, measured from\nthe reference point, which depends on the orientation  argument:\n\u2022 orientation=VERTICAL. Uses the left of the layer extents of the reference\nlayer.\n\u2022 orientation=HORIZONTAL. Uses the bottom of the layer extents of the\nreference layer.", "orientation": "Required. Specifies the orientation used to snap to the grids.\n\u2022 VERTICAL. Snaps the x-coordinate of vertices from vertical edges.\n\u2022 HORIZONTAL. Snaps the y-coordinate of vertices from horizontal edges.", "preference": "Optional. Specifies how edges are snapped. These edges cannot snap exceed\nthe bounding layer polygon where they are inside or inside_coincident. The\ndefault is CLOSEST_OVERSIZE.\n\u2022 OVERSIZE. Specifies that vertices from candidate edges are snapped to the\nclosest grid that is outside or on the input polygon or edge.\n\u2022 UNDERSIZE. Specifies that vertices from candidate edges are snapped to the\nclosest grid that is inside or on the input polygon or edge.\n\u2022 CLOSEST_OVERSIZE. Specifies that vertices from candidate edges are\nsnapped to the closest grid. If it is in the middle point, choose OVERSIZE.\n\u2022 CLOSEST_UNDERSIZE. Specifies that vertices from candidate edges are\nsnapped to the closest grid. If it is in the middle point, choose UNDERSIZE.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "snap_side": "Optional. Specifies the limit at which the side must be snapped. The default is\nALL.\n\u2022 ALL. Specifies that both the LOW  and HIGH  edges must be snapped.\n\u2022 HIGH. Specifies that if the orientation is HORIZONTAL, the edge on the\ntop side, with a direction from left to right is snapped. If the orientation is\nsnap_to_pattern_edge()\nVERTICAL, the edge on the right side, with a direction from top to bottom, is\nsnapped.\n\u2022 LOW. Specifies that if the orientation is HORIZONTAL, the edge on the bottom\nside, with a direction from right to left is snapped. If the orientation is\nVERTICAL, the edge on the left side, with a direction from bottom to top is\nsnapped."}, "summary": "The snap_to_pattern_edge()  function creates data that represent the input data\nsnapped to the specified grid_pattern.", "function_name": "snap_to_pattern_edge()"}
{"description": "The soft_check()  function verifies that all layer1  polygons which intersect a layer2\npolygon belong to the same net. It can be used in polygon mode or error mode. Output\ncan be reported as a polygon layer or error.\nBounding box errors are reported to the LAYOUT_ERRORS file and appear as boxes in\nVUE.\nThe layer1  polygons must be in the connect database while the layer2  polygons must\nnot be in connect database, as this affects the selection of output.", "syntax": "soft_check(\nconnect_sequence  = connect_database,\nlayer1           = polygon_layer,\nlayer2           = polygon_layer,\noutput_layer     = LAYER1 | LAYER2  | ALL,  //optional\nlayer1_output    = ONE  | ALL,              //optional\ninclude_touch     = NONE  | EDGE,            //optional\nname              = \"layer_label\"           //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "layer1": "Required. Specifies a polygon layer. It must be in the connect database.", "layer2": "Required. Specifies a polygon layer. It must not be in the connect database.", "output_layer": "Optional. Specifies the layer used to generate the derived output layer. The\ndefault is LAYER2.\nsoft_check()\n\u2022 LAYER1. Outputs the layer1  polygons that are not connected to the same\nnet.\n\u2022 LAYER2. Outputs the layer2  polygons that intersect the failed layer1\npolygons.\n\u2022 ALL. Outputs all layer1  polygons that interact with layer2  polygons and\nlayer2  polygons.", "layer1_output": "Optional. Specifies the number of layer1  polygons per net reported for a\nlayer2  polygon. This argument affects the generated layer only when the\noutput_layer  argument is LAYER1  or ALL. The default is ONE.\n\u2022 ONE. Outputs one arbitrary layer1  polygon from each net.\n\u2022 ALL. Outputs all layer1  polygons that intersect the layer2  polygon.", "include_touch": "Optional. Specifies the types of touches that provide an electrical connection.\nThe default is NONE.\n\u2022 NONE. Specifies that no touches form an electrical connection.\n\u2022 EDGE. Specifies that outside edge touches form an electrical connection.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The soft_check()  function verifies that all layer1  polygons which intersect a layer2\npolygon belong to the same net.", "function_name": "soft_check()"}
{"description": "The soft_connect()  function creates a connect database that defines electrical\nconnectivity for the specified layers. For each entry within the soft_connect_items\ndefinition, the soft_connect()  function passes connectivity from upper to lower layers\nwhen the lower layer interacts with one or multiple upper-layer nets.\nWhen the lower layer interacts with multiple upper-layer nets, the soft_connect()\nfunction selectively passes connectivity between one upper-layer net and the lower\nlayer. The soft_connect()  function detects when the lower layer interacts with multiple\nupper-layer nets, even when different by layers are used. The connect database created\nby the soft_connect()  function retains text from the input connect database. Lower\nlayers interacting with multiple upper-layer nets can be reported as errors by using the\nsoft_connect_check()  function.", "syntax": "soft_connect(\nconnect_sequence      = connect_database,\nsoft_connect_items   = {{upper_layer    = polygon_layer,\nlower_layers   = {polygon_layer, ...},\nby_layer       = polygon_layer,\ninclude_touch  = NONE  | EDGE},\n...},\nallow_connected_lower_layers            = true | false,     //optional\nconflict_resolution   = POLYGON_COUNT  | TRAPEZOID_COUNT,     //optional\nconflict_output      = REJECTED_NETS  | ALL_NETS,        //optional\nreport_conflict       = true | false                    //optional\n);", "returns": "connect database", "arguments": {"connect_sequence": "Required. Specifies the connect database.", "soft_connect_items": "Required. Lists the connection specifications.\n\u2022 upper_layer\nRequired. Specifies the layer used by the soft_connect()  to pass\nconnectivity to the lower layer. This layer must exist in the input connect\nsoft_connect()\ndatabase or already exist in the soft_connect_items  definition as a lower\nlayer. This is usually a routing layer.\n\u2022 lower_layers\nRequired. Specifies the layer that receives connectivity from the upper layer.\nThis layer cannot exist in the input connect database. This layer is usually\nthe well layer.\n\u2022 by_layer\nOptional. Specifies the polygon layer by which the upper and lower layers\nare connected. These layers are usually contact or tap layers.\n\u2022 include_touch\nOptional. Specifies the types of touches that provide an electrical connection.\nThe default is NONE.\n\u25e6 NONE. Specifies that no outside edge touches form an electrical\nconnection.\n\u25e6 EDGE. Specifies that upper layers that outside edge touch the lower layer\nform an electrical connection.\nNote:\nThe by layer cannot be used when include_touch=EDGE.", "allow_connected_lower_layers": "Optional. Specifies whether connected layers are present in the lower layers.\nThis relaxed condition might indicate that lower-layer polygons are already\nshorted with their given connectivity. This scenario suggests a misuse of the\nargument, but it is still allowed. Therefore, be aware of the potential risk of\nsetting the allow_connected_lower_layers  argument to true. The default is\nfalse.\n\u2022 true. Specifies that any layer in the lower layers can be connected if its\nconnectivity has nothing to do with any of its corresponding upper layers.\nTherefore, it still should not be connected to any of its upper layers, either\ndirectly or indirectly.\n\u2022 false. Specifies that the lower layers cannot be connected.", "conflict_resolution": "Optional. Specifies how a soft connection conflict is resolved. The default is\nPOLYGON_COUNT.\nsoft_connect()\n\u2022 POLYGON_COUNT. Resolves the conflict on the lower-layer polygon by\nselecting the net that has the most contact polygons which interact with this\npolygon.\nNote:\nThis behavior is similar to the sconnect()  function when mode =\nLOCAL.\n\u2022 TRAPEZOID_COUNT. Resolves the conflict on the lower-layer polygon by\nselecting the net that has the most polygon trapezoids among all of the upper\nlayers and by layers.\nNote:\nA layer in the upper layer or by layer is related to the conflict when\nit is specified as the same item as the lower-layer polygon of the\nsoft_connect_items  definition.", "conflict_output": "Optional. Specifies how the subsequent\nsoft_connect_check()  function\nreports an error. The default is REJECTED_NETS.\n\u2022 REJECTED_NETS. For each lower-layer polygon, specifies that only the upper\nlayers or by layers of the rejected nets are reported.\n\u2022 ALL_NETS. For each lower polygon, specifies that all of the interacting upper\nlayers or by layers are reported whether or not they belong to the selected or\nrejected nets.", "report_conflict": "Optional. Specifies to output a SOFT CONNECT WARNING  violation in error\nreport for the soft_connect()  command, if there are any net conflicts. The\ndefault is false."}, "summary": "The soft_connect()  function creates a connect database that defines electrical\nconnectivity for the specified layers.", "function_name": "soft_connect()"}
{"description": "The soft_connect_check()  function processes a connect database generated by\nsoft_connect()  function to verify that the lower layer touches only one upper layer net.\nThe soft_connect_check()  function creates a polygon or error representing the upper,\nlower, and contact layers that do not meet this criteria.", "syntax": "soft_connect_check(\nconnect_sequence  = connect_database,\nlower_layer      = polygon_layer,\noutput_layer     = UPPER | LOWER  | CONTACT | ALL,  //optional\nname              = \"layer_label\"                   //optional\n);", "returns": "polygon layer or error result", "arguments": {"connect_sequence": "Required. Specifies a connect database generated by the soft_connect()\nfunction.", "lower_layer": "Required. Specifies the lower layer needed to verify the number of touching\nupper-layer nets. This lower layer must be used as a lower layer in a previous\nsoft_connect()  function.", "output_layer": "Optional. Specifies the layer used to generate the polygon or error layer\nwhen lower layers interact with multiple upper-level nets. When the\nsoft_connect_check()  function processes UPPER  and CONTACT  polygons,\nonly those polygons that are not connected to the lower layers by the\nsoft_connect()  function are candidates for output. The default is LOWER.\n\u2022 UPPER. Outputs an upper layer used in a previous soft_connect()  function.\n\u2022 LOWER. Outputs a lower layer used in a previous soft_connect()  function.\n\u2022 CONTACT. Outputs a by layer used in a previous soft_connect()  function.\nIf CONTACT  is selected and the by_layer  argument is not defined for all soft\nconnect items containing the lower layer in a previous soft_connect()\nsoft_connect_check()\nfunction, a warning message is reported and the upper_layer  polygons are\nselected instead.\n\u2022 ALL. Outputs all layers.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The soft_connect_check()  function processes a connect database generated by\nsoft_connect()  function to verify that the lower layer touches only one upper layer net.", "function_name": "soft_connect_check()"}
{"description": "The spice_netlist_file()  function defines a SPICE file name. This file is specified\nin the output_file  argument of the write SPICE functions,\nwrite_spice()  and\nwrite_xref_spice().\nNote:\nThe spice_netlist_file()  function cannot be called more than one time\nwith the same file argument. The result, however, can be used in more than\none\nwrite_spice()  or write_xref_spice()  function, in which case the file is\noverwritten.", "syntax": "spice_netlist_file(\nfile = \"string\"\n);", "returns": "spice_netlist_file_handle\nspice_netlist_file_handle", "arguments": {"file": "Required. Names the SPICE netlist output file. See the\nwrite_spice()  and\nwrite_xref_spice()  functions for more information."}, "summary": "The spice_netlist_file()  function defines a SPICE file name.", "function_name": "spice_netlist_file()"}
{"description": "Selects the polygon that can approximate to the stadium shape satisfied with a constraint.", "syntax": "stadiums(\nlayer1              = polygon_layer,\ndiameter            = positive_constraint = >0.0, //optional\nlength              = positive_constraint = >0.0, //optional\ntolerance           = double, //optional\nangle_tolerance_45  = double_constraint  = 0.45, //optional\nprocessing_mode     = CELL_LEVEL | HIERARCHICAL,\nname                = \"layer_label\"\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies a polygon layer.", "diameter": "Optional. Specifies the diameter of two semicircles on the stadium shape.\nNote:\nThe IC Validator engine internally calculates the radius (half of the\ndiameter) to determine semicircle vertices and checks variations\nagainst the specified tolerance to ensure geometric precision.", "length": "Optional. Specifies the maximum length of the stadium parallel to the two\nparallel lines of the shape.\nstadiums()", "tolerance": "Optional. Specifies the expansion values to the original diameter and length.\nOnly valid if the diameter or length is specified.", "angle_tolerance_45": "Optional. Specifies a floating-point number between zero and one, which\nidentifies the number of degrees of variation required such that the 45-degree\nsides might differ and still be considered a 45-degree rectangle. A default\ntolerance of 0.45 degrees is applied if this option is not specified.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Specifies the name used by the IC Validator tool for the output layer. This\nname is displayed in various output log files, such as the summary, tree,and\ndistributed processing log files. It is used only for log files; runset variables are\nnot changed. The default is the name of the layer being created."}, "summary": "Selects the polygon that can approximate to the stadium shape satisfied with a constraint.", "function_name": "stadiums()"}
{"description": "The stamp()  function passes connectivity from one layer to another without modifying the\nconnectivity of the connected layer.\nThe stamp()  function derives a layer by selecting the layer1  polygons that interact with\nthe layer2  polygons from the same net. The output connect database retains text from\nthe input connect database.\nA connectivity database, specified by the out_connect_sequence  argument, is then\ncreated by incrementally connecting the derived layer (from the stamp()  function output)\nby the layer2  polygons. The connectivity is determined within the context of the database\nspecified by the in_connect_sequence  argument.\nThe layer1  polygons are not selected when\n\u2022 The layer1  polygons do not interact with the layer2  polygons.\n\u2022 The layer1  polygons interact with the layer2  polygons on more than one net.\nNote:\nThe layer polygons that interact with one hierarchical net, but with more than\none cell-level net, are exploded to a hierarchical location where they interact\nwith only one cell-level net.", "syntax": "stamp(\nlayer1               = polygon_layer,\nlayer2               = polygon_layer,\nin_connect_sequence  = connect_database,\nout_connect_sequence = out_connect_database,\ninclude_touch         = NONE | EDGE,           //optional\nname                 = \"layer_label\",         //optional\ncheck_connectivity   = true  | false           //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the polygon layer that needs connectivity.\nstamp()", "layer2": "Required. Specifies the polygon layer that is already connected.", "in_connect_sequence": "Required. Specifies the connect database in which the layer2  layer is\nconnected.", "out_connect_sequence": "Required. Specifies the output connect database that contains the derived layer.", "include_touch": "Optional. Specifies the types of touches that provide an electrical connection.\nThe default is EDGE.\n\u2022 NONE. Specifies that no touches form an electrical connection.\n\u2022 EDGE. Specifies that outside edge touches form an electrical connection.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "check_connectivity": "Optional. Specifies whether a connectivity check between two input layers are\nenabled. The default is true.\n\u2022 true. Specifies that a connectivity check is enabled.\n\u2022 false. Specifies that a connectivity check is disabled. All layer1  polygons\nare selected for output regardless of the interaction with layer2  edges."}, "summary": "The stamp()  function passes connectivity from one layer to another without modifying the\nconnectivity of the connected layer.", "function_name": "stamp()"}
{"description": "The stamp_edge()  function passes connectivity from a polygon layer to an edge layer\nwithout modifying the connectivity of the connected layer.\nThe stamp_edge()  function derives an edge layer by selecting the layer1  edges that\ninteract with the layer2  polygons from the same net. The output connect database retains\ntext from the input connect database.\nA connectivity database, specified by the out_connect_sequence  argument, is then\ncreated by incrementally connecting the derived layer (from the stamp()  function output)\nby layer2  polygons. The connectivity is determined within the context of the database\nspecified by the in_connect_sequence  argument.\nThe layer1  edges are not selected when\n\u2022 The layer1  edges do not interact with layer2  polygons.\n\u2022 The layer1  edges interact with layer2  polygons on more than one net.\nNote:\nLayer polygons that interact with one hierarchical net, but more than one cell-\nlevel net, are exploded to a hierarchical location where they interact with only\none cell-level net.\nThe summary file contains\n\u2022 Missing connections are reported if a layer1  edge does not interact with any layer2\npolygon.\n\u2022 Conflicting connections are reported if a layer1  edge interacts with two or more\nlayer2  polygons that have different connectivity.", "syntax": "stamp_edge(\nlayer1               = edge_layer,\nlayer2               = polygon_layer,\nin_connect_sequence  = connect_database,\nout_connect_sequence = out_connect_database,\nname                 = \"layer_label\",         //optional\ncheck_connectivity   = true  | false           //optional\n);", "returns": "edge layer\nstamp_edge()", "arguments": {"layer1": "Required. Specifies the edge layer that needs connectivity.", "layer2": "Required. Specifies the polygon layer that is already connected.", "in_connect_sequence": "Required. Specifies the connect database in which the layer2  layer is\nconnected.", "out_connect_sequence": "Required. Specifies the output connect database that contains the derived layer.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "check_connectivity": "Optional. Specifies whether a connectivity check between two input layers are\nenabled. The default is true.\n\u2022 true. Specifies that a connectivity check is enabled.\n\u2022 false. Specifies that a connectivity check is disabled. All layer1  edges are\nselected for output regardless of the interaction with layer2  edges."}, "summary": "The stamp_edge()  function passes connectivity from a polygon layer to an edge layer\nwithout modifying the connectivity of the connected layer.", "function_name": "stamp_edge()"}
{"description": "The stripes()  function generates rectangles within the polygon extent of a specified\nfillable region.", "syntax": "stripes(\nlayer1     = polygon_layer,\nwidth      = double,\nspacing    = double,\ndirection  = HORIZONTAL  | VERTICAL,\nmode       = {LOWER_LEFT_FIXED,\nLOWER_LEFT_CENTERLINE_ON_BOUNDARY_FIXED,\nCENTER_FIXED, BOUNDARY_FIXED,\nCENTER_ADJUSTABLE, BOUNDARY_ADJUSTABLE,\nBOUNDARY_ADJUSTABLE_SAME_SPACE}\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the input fillable region.", "width": "Required. Specifies the required width of the stripes. Negative values are\nrejected during compile. If the user-specified width is smaller than the library\nresolution, the width becomes the library resolution.", "spacing": "Required. Specifies the required spacing between two stripes. Negative values\nare rejected during compile. If the user-specified spacing is smaller than the\nlibrary resolution, the spacing becomes the library resolution.", "direction": "Required. Specifies the direction of the stripes. The default is HORIZONTAL.\n\u2022 HORIZONTAL. Specifies that the direction of the stripes is horizontal.\n\u2022 VERTICAL. Specifies that the direction of the stripes is vertical.", "mode": "Required. Specifies the distribution mode. The default is LOWER_LEFT_FIXED.\nstripes()\n\u2022 LOWER_LEFT_FIXED. Specifies stripes from the left edge (when direction =\nVERTICAL  or bottom edge (when direction = HORIZONTAL).\n\u2022 LOWER_LEFT_CENTERLINE_ON_BOUNDARY_FIXED. Specifies stripes from one\nhalf of the space outside of the left edge (when direction = VERTICAL) or\nbottom edge (when direction = HORIZONTAL).\n\u2022 CENTER_FIXED. Specifies stripes placed at the center of the fillable region,\nwith extra space distributed as equally as possible at the outer edge.\nstripes()\n\u2022 BOUNDARY_FIXED. Specifies stripes from the left or right edge (when\ndirection = VERTICAL), or the bottom or top edge (when direction =\nHORIZONTAL). If the total number of stripes is odd, place one additional stripe\nin the middle.\n\u2022 CENTER_ADJUSTABLE. Similar to CENTER_FIXED, except that spacing is\nnot fixed. The s  spacing value is greater than or equal to the user-defined\nspacing value. The s  value should be as large as possible, but still maintain\nthe same number of stripes while using the user-defined spacing.\nstripes()\n\u2022 BOUNDARY_ADJUSTABLE. Similar to BOUNDARY_FIXED, except that spacing is\nnot fixed. The s  spacing value is greater than or equal to the user-defined\nspacing value. The s  value should be as large as possible, but still maintain\nthe same number of stripes while using the user-defined spacing.\n\u2022 BOUNDARY_ADJUSTABLE_SAME_SPACE. Similar to BOUNDARY_ADJUSTABLE,\nexcept that spacing between all fills should be uniformly distributed. If the\nstripes()\nspacing cannot be uniformly distributed, the spacing varies at most by 1\nDBU."}, "summary": "The stripes()  function generates rectangles within the polygon extent of a specified\nfillable region.", "function_name": "stripes()"}
{"description": "The system()  function executes any valid UNIX command during an IC Validator run.\nAfter the UNIX command is completed, runset execution resumes at the place it stopped.\nNote:\nWhen you are using distributed processing, any system()  function must be\nincluded in runtime control flow constructs to force it to execute after specific\nfunctions.\nYou cannot use the system()  function in a remote function.", "syntax": "system(\ncommand  = \"string\"\n);", "returns": "void", "arguments": {"command": "Required. Specifies any valid UNIX command."}, "summary": "The system()  function executes any valid UNIX command during an IC Validator run.", "function_name": "system()"}
{"description": "Selects teardrops satisfying the specified constraints. A teardrop is formed by\nconcatenating a circle and a triangle.", "syntax": "teardrops(\nlayer1           = polygon_layer,\nradius           = doubleconstraint, //optional\npeak_length      = doubleconstraint, //optional\ntolerance        = double, //optional\ntangent          = Boolean = true | false,  //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname             = \"layer_label,\ntype             = STANDARD  | CROPPED | ALL,   //optional\"\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies a polygon layer.", "radius": "Optional. Specifies the radius of the circle that encloses the nonpeak points.", "peak_length": "Optional. Specifies the length from the circle center to the peak point.\nteardrops()\nFigure 642 Peak Length", "tolerance": "Optional. Specifies the expansion values to the original radius  and\npeak_length  constraints. Only valid if radius  or peak_length  is specified.", "tangent": "Optional. Selects only the teardrops whose triangle edges are tangential to the\ncircle.\nFigure 643 Tangent", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\nteardrops()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Specifies the name used by the IC Validator tool for the output layer. This\nname is displayed in various output log files, such as the summary, tree, and\ndistributed processing log files. It is used only for log files; runset variables are\nnot changed. The default is the name of the layer being created.", "type": "Optional. Specifies the teardrop variants to select. The default is STANDARD.\n\u2022 STANDARD. Select only intact teardrops.\n\u2022 CROPPED. Select only line cropped teardrops. Note that the two angles of the\ncropped corners should be the same.\n\u2022 ALL. Select both STANDARD  and CROPPED  teardrops.\n\u2022Figure 644 Type"}, "summary": "Selects teardrops satisfying the specified constraints.", "function_name": "teardrops()"}
{"description": "The text_interact()  function selects polygons by text. The complement of this function\nis the not_text_interact()  function.\nNote:\nBy default, text is discarded for a cell that is exploded during preprocessing,\nwhile the text_interact()  and not_text_interact()  functions still use\ndiscarded text to select polygons when use_text = ALL. If any unused text or\ntext shorts exist after the discarded text, the IC Validator tool does not report the\nerror.", "syntax": "text_interact(\nlayer           = polygon_layer,\ntext_layer      = text_layer,\ntext            = {\"string\", ...},\nuse_text        = ALL  | TOP,                      //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,      //optional\nname             = \"layer_label\"                   //optional\n);\nnot_text_interact(\nlayer           = polygon_layer,\ntext_layer      = text_layer,\ntext            = {\"string\", ...},\nuse_text        = ALL  | TOP,                      //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,      //optional\nname             = \"layer_label\"                   //optional", "returns": "polygon layer or error result", "arguments": {"layer": "Required. Specifies the polygon layer from which polygons are selected.", "text_layer": "Required. Specifies the text layer.\ntext_interact() and not_text_interact()", "text": "Required. Specifies the text strings used for selection. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation.", "use_text": "Optional. Specifies the cells in the specified text layer whose text is used. The\ndefault is ALL.\n\u2022 ALL. Uses text from all cells.\n\u2022 TOP. Uses only text from the top cell.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the current cell;\nplacements are considered. When unused text interacts with a polygon in\na lower-level cell that has a port to the cell containing the text, the text is\napplied to the associated net.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The text_interact()  function selects polygons by text.", "function_name": "not_text_interact()"}
{"description": "The text_interact()  function selects polygons by text. The complement of this function\nis the not_text_interact()  function.\nNote:\nBy default, text is discarded for a cell that is exploded during preprocessing,\nwhile the text_interact()  and not_text_interact()  functions still use\ndiscarded text to select polygons when use_text = ALL. If any unused text or\ntext shorts exist after the discarded text, the IC Validator tool does not report the\nerror.", "syntax": "text_interact(\nlayer           = polygon_layer,\ntext_layer      = text_layer,\ntext            = {\"string\", ...},\nuse_text        = ALL  | TOP,                      //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,      //optional\nname             = \"layer_label\"                   //optional\n);\nnot_text_interact(\nlayer           = polygon_layer,\ntext_layer      = text_layer,\ntext            = {\"string\", ...},\nuse_text        = ALL  | TOP,                      //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,      //optional\nname             = \"layer_label\"                   //optional", "returns": "polygon layer or error result", "arguments": {"layer": "Required. Specifies the polygon layer from which polygons are selected.", "text_layer": "Required. Specifies the text layer.\ntext_interact() and not_text_interact()", "text": "Required. Specifies the text strings used for selection. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation.", "use_text": "Optional. Specifies the cells in the specified text layer whose text is used. The\ndefault is ALL.\n\u2022 ALL. Uses text from all cells.\n\u2022 TOP. Uses only text from the top cell.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the current cell;\nplacements are considered. When unused text interacts with a polygon in\na lower-level cell that has a port to the cell containing the text, the text is\napplied to the associated net.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The text_interact()  function selects polygons by text.", "function_name": "text_interact()"}
{"description": "The text_net_global_options()  function overwrites all corresponding settings in the\ntext_net()  function in the runset.", "syntax": "text_net_global_options(\nopens                          = UNSET  | IGNORE | RENAME |\nMERGE_CONNECTED |\nMERGE_CONNECTED_AND_TOP |\nMERGE_ALL |\nMERGE_TOP_THEN_CONNECTED |\nMERGE_TOP_PORTS_THEN_CONNECTED |\nMERGE_TOP,             //optional\nuse_text                       = UNSET  | ALL | TOP |\nEQUIV_CELLS,           //optional\nmerge_open_net_names               = {\"string\", ...},   //optional\nlvs_black_box_merge_open_net_names  = {\"string\", ...},   //optional\nattach_text                     = UNSET  | NONE |\nTOP | ALL,             //optional\nshort_debugging                 = {vue_short_finder = true | false,\nstatic_output =\n{graphics =\nNONE  | OASIS | GDSII,\nascii = true | false,\nerror = true | false,\npath_limit_per_short = 10},\noutput_limit = 200,\noutput_text =\nTOP  | ALL,\noutput_short_graph = FULL  | MIN},\nshort_type     = UNSET  |\nWITHOUT_PORT_CONNECTION_ERROR |\nALL |\nWITH_PORT_CONNECTION_ERROR_ONLY},\n//optional\nmerge_open_net_names_by_cell    = {{cells = {\"string\", ...},\ntext = {\"string\", ...}},\n...},                  //optional\nreport_errors_from    = UNSET  | ALL_CELLS |\nTOP_CELL | EQUIV_CELLS,  //optional\nshorts               = UNSET  | KEEP_ONE |\nDISCARD,                 //optional\nrename_open_nets     = KEEP_ONE | ALL | KEEP_ONE_LARGEST_NET\n| UNSET,  //optional\nrename_prefix        = \"string\",                         //optional\ntext_priority_list   = {\"string\", ...},                  //optional\ncreate_short_finder_nets  = {nets = {\"string\", ...},\nwith_nets = {\"string\", ...}},\ntext_net_global_options()\n...},               //optional\nnet_port_items             = {{nets  = {\"string\",...},\nports = {\"string\",...}},\n//optional\ncheck_power_ground_port_connection     = {override = true | false,\nvalue = true | false},\n//optional\nshorted_violation_comment         = \"string\",            //optional\nunused_violation_comment          = \"string\",            //optional\nmerged_violation_comment          = \"string\",            //optional\nrenamed_violation_comment        = \"string\",            //optional\nreassign_shorted_violation_comment= \"string\",           //optional\nport_connection_violation_comment  = \"string\",            //optional\nerror_classifications     = {{errors  = {UNSET, UNUSED, SHORTED,\nMERGED,\nRENAMED, REASSIGN_SHORTED},\ntext    = {\"string\", ...},\ncells   = {\"string\", ...},\nclassification = \"string\",\ncpydb   = UNSET | USE | DISCARD,\ncomment = \"string\"}, ...}    //optional\n);", "returns": "void", "arguments": {"opens": "Optional. Specifies processing of text opens and overwrites all\ntext_net(opens)  settings in the runset. When set to UNSET, no\ntext_net(opens)  settings are overwritten. The default is UNSET. See the\ntext_net()  function for more information.", "use_text": "Optional. Specifies the cells whose text is used and overwrites all\ntext_net(use_text)  settings in the runset. When set to UNSET, no\ntext_net(use_text)  settings are overwritten. The default is UNSET. See the\ntext_net()  function for more information.", "merge_open_net_names": "Optional. Specifies the list of nets that are processed for opens and overwrites\nall text_net(merge_open_net_names)  settings in the runset. The default is {},\nand the overwriting mechanism is off by default. See the\ntext_net()  function\nfor more information.\ntext_net_global_options()", "lvs_black_box_merge_open_net_names": "Optional. Specifies the list of nets that are processed\nfor opens only for black-box cells, and overwrites all\ntext_net(lvs_black_box_merge_open_net_names)  settings in the runset.\nThe default is{\"__ICV_UNSPECIFIED_STRING_LIST__\"}, which means that\nthe setting is not overwritten. You can use an empty list ({}) to turn off all\ntext_net(lvs_black_box_merge_open_net_names)  settings. See the\ntext_net()  function for more information.", "attach_text": "Optional. Controls the attachment of the unused higher-level text to the lower-\nlevel polygon, and overwrites all text_net(attach_text)  settings in the\nrunset. The overwriting mechanism is off when attach_text=UNSET. The\ndefault is UNSET.", "short_debugging": "Optional. Specifies a way to debug shorts, using either the\nVUE Short Finder, static output from the VUE Short Finder,\nor both, and overwrites all text_net(short_debugging)\nsettings in the runset. The overwriting mechanism is off when\nvue_short_finder=false,static_output{graphics}=NONE,\nstatic_output{ascii}=false, and static_output{error}= false.\n\u2022 short_type. Optional. Specifies the kinds of short nets the Short Finder\nmust use to generate the short database and short path results, and\noverwrites all text_net(short_debugging(short_type))  settings in the\nrunset. The default is UNSET, which means the overwriting mechanism is off.", "merge_open_net_names_by_cell": "Optional. Specifies the list of nets of cell that are processed for opens. By\ndefault, no cell is set.\n\u2022 cells. Optional. Merges open text from the specified cells. By default,\nopen text is merged from all cells. String matching using metacharacters is\nallowed. See\nString Matching  for more information.\n\u2022 text. Optional. Merges the specified open text strings. By default, all open\ntext strings are merged. String matching using metacharacters is allowed.\nSee\nString Matching  for more information.", "report_errors_from": "Optional. Specifies the text errors that are reported, and it overwrites all\ntext_net(report_errors_from)  settings in the runset. The default is UNSET,\nwhich means that the overwriting mechanism is off.\ntext_net_global_options()", "shorts": "Optional. Specifies the action taken when a single net has multiple different\nassigned texts, and it overwrites all text_net(shorts)  settings in the runset.\nThe default is UNSET, which means that the overwriting mechanism is off.", "rename_open_nets": "Optional. Specifies which nets are renamed, and it overwrites all\ntext_net(rename_open_nets)  settings in the runset. The default is UNSET,\nwhich means that the overwriting mechanism is off.", "rename_prefix": "Optional. Specifies the prefix for renamed nets, and it and overwrites\nall text_net(rename_prefix)  settings in the runset. The default is\n__ICV_UNSPECIFIED_STRING__, which means that the overwriting mechanism\nis off.", "text_priority_list": "Optional. Lists the strings that prioritize the selection of the net\nname when the shorts  argument is KEEP_ONE, and it overwrites all\ntext_net(text_priority_list)  settings in the runset. The default is\n{__ICV_UNSPECIFIED_STRING_LIST__}, which means that the overwriting\nmechanism is off.", "create_short_finder_nets": "Optional. Lists the net pairs for which Short Finder data is\ngenerated for the VUE interactive Short Finder, and it overwrites all\ntext_net(create_short_finder_nets)  settings in the runset. The default is\n{{{__ICV_UNSPECIFIED_STRING_LIST__}}}, which means that the overwriting\nmechanism is off.\n\u2022 nets. Specifies the texts to check for shorts against the texts listed in the\nwith_nets  option. The default is \u201c*\u201d, means all texts are selected.\n\u2022 with_nets. Specifies the texts to check for shorts. The default is \u201c*\u201d, which\nmeans all texts are selected.", "net_port_items": "Optional. Specifies which parent nets should connect to which port nets and\noverwrites all text_net(net_port_items)  settings in the runset. The default\nis {{{\"__ICV_UNSPECIFIED_STRING_LIST__\"}}}, which means that the\noverwriting mechanism is turned off.\ntext_net_global_options()", "check_power_ground_port_connection": "Optional. Turns on or off the default port connection checking rule, and\noverwrites all text_net(check_power_ground_port_connection)  settings in\nthe runset. The default is OVERRIDE.\n\u2022 OVERRIDE. Optional. Enables the overwriting mechanism. The default is\nfalse.\n\u2022 VALUE. Optional. Specifies the value to overwrite all\ntext_net(check_power_ground_port_connection)  settings in the runset\nwhen OVERRIDE  is true. The default is false.", "shorted_violation_comment": "Optional. Specifies the violation comment for text short errors. The default is the\ncurrent runset violation comment.", "unused_violation_comment": "Optional. Specifies the violation comment for unused text errors. The default is\nthe current runset violation comment.", "merged_violation_comment": "Optional. Specifies the violation comment for merged text open errors. The\ndefault is the current runset violation comment.", "renamed_violation_comment": "Optional. Specifies the violation comment for renamed text open errors. The\ndefault is the current runset violation comment.", "reassign_shorted_violation_comment": "Optional. Specifies the violation comment for reassigned nets that are shorted.\nThe default is the current runset violation comment.", "port_connection_violation_comment": "Optional. Specifies the violation comment for unused text errors. The default is\nthe current runset violation comment.", "error_classifications": "Optional. Uses -runset_config  to overwrite all\ntext_net(error_classifications)  setting to ignore or waive unwanted nets\nto be checked."}, "summary": "The text_net_global_options()  function overwrites all corresponding settings in the\ntext_net()  function in the runset.", "function_name": "text_net_global_options()"}
{"description": "The text_to_double_property()  function turns text into a polygon property. It creates\na square marker at the location of each text, with the double value of the text attached to\nthe polygon. Text that cannot be represented by a double value causes an error and is\ndropped.\nNote:\nProperties on a polygon layer are only recognized by the drc_features(),\nnet_polygon_by_property(), and select_by_double_property()\nfunctions. All other functions ignore properties on a polygon layer and do not\npropagate the properties to their result.", "syntax": "text_to_double_property(\nlayer1          = text_layer,\nproperty        = \"string\",\nmerge_operator  = MIN | MAX | SUM,\nbox_size       = double,            //optional\nreport_errors   = {NOT_A_DOUBLE},    //optional\nname           = \"layer_label\"      //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the text layer containing text that is changed to properties.", "property": "Required. Specifies the property name.", "merge_operator": "Required. Specifies how to handle text markers that collide.\n\u2022 MIN. Sets the property to the minimum value of all properties of the colliding\nmarkers.\nNote:\nHierarchically interacting markers output by the\ntext_to_double_property()  function are leveled and merged.\ntext_to_double_property()\n\u2022 MAX. Sets the property to the maximum value of all properties of the colliding\nmarkers.\n\u2022 SUM. Sets the property to the sum of all values of all properties of the colliding\nmarkers.", "box_size": "Optional. Specifies the size of the square markers. The default is 0.002.", "report_errors": "Optional. Reports ignored text to the LAYOUT_ERRORS file. The default is\nNOT_A_DOUBLE.\n\u2022 NOT_A_DOUBLE. Reports text that is not all numeric.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The text_to_double_property()  function turns text into a polygon property.", "function_name": "text_to_double_property()"}
{"description": "The text_to_property_unmerged()  function converts text into a polygon property. It\ncreates a square at the location of each text, with the value of the text attached to the\npolygon as a user-defined property.", "syntax": "text_to_property_unmerged(\nlayer1    = text_layer,\nproperty  = \"string\",\ntype      = STRING | NUMERIC| NON_NUMERIC,\nlocation  = TOP_CELL | ALL,\nbox_size  = double,          //optional\nname      = \"layer_label\"    //optional\n);", "returns": "unmerged polygon layer", "arguments": {"layer1": "Required. Specifies the text layer containing text that is used to create\nproperties.", "property": "Required. String that specifies the property name.", "type": "Required. Specifies the type of text / property conversion.\n\u2022 STRING. Specifies that all text is converted to a string property.\n\u2022 NUMERIC. Specifies that numeric text is converted to a double property. Non-\nnumeric text generates a warning.\n\u2022 NON_NUMERIC. Specifies that non-numeric text is converted to a string\nproperty.", "location": "Specifies the hierarchical location of the text to be processed. The default is\nALL.\ntext_to_property_unmerged()\n\u2022 TOP_CELL. Specifies that only text from the top cell is processed.\n\u2022 ALL. Specifies that all text is processed.", "box_size": "Optional. Specifies the size of the square markers. The default is 0.002.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The text_to_property_unmerged()  function converts text into a polygon property.", "function_name": "text_to_property_unmerged()"}
{"description": "The text_to_string_property()  creates a square marker at the location of each text\nwith the string value of the text attached to the polygon.\nNote:\nIf there are multiple texts in the same output merged polygon, they are\nconcatenated as a list of unique strings. Properties on a polygon layer are\nonly recognized by the drc_features(), net_polygon_by_property(), and\nselect_by_double_property()  functions. All other functions ignore properties\non a polygon layer and do not propagate the properties to their result.", "syntax": "text_to_string_property(\nlayer1          = text_layer,\nproperty        = \"string\",\nbox_size       = double,            //optional\nname           = \"layer_label\"      //optional\n);", "returns": "polygon layer", "arguments": {"layer1": "Required. Specifies the text layer containing text that is changed to properties.", "property": "Required. Specifies the property name.", "box_size": "Optional. Specifies the size of the square markers. The default is 0.002.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The text_to_string_property()  creates a square marker at the location of each text\nwith the string value of the text attached to the polygon.", "function_name": "text_to_string_property()"}
{"description": "The texted_with()  function selects polygons from the layer1  layer that are attached\nwith the specified text in the layer2  layer. This function is a cell-level operation; that\nis, all processing is within the context of a given cell and placements are ignored. The\ncomplement of this function is the not_texted_with()  function.\nNote:\nBy default, text is discarded for a cell that is exploded during preprocessing,\nwhile the texted_with()  and not_texted_with()  functions still use discarded\ntext to select polygons when use_text = ALL. If any unused text or text shorts\nexist after the discarded text, the IC Validator tool does not report the error.", "syntax": "texted_with(\nlayer1                    = polygon_layer,\nlayer2                    = text_layer,\ntext                      = {\"string\", ...},\nuse_text                  = ALL  | TOP,\ncolon_text                = EQUATE_NETS | REGULAR_TEXT,     //optional\nshorts                    = KEEP_ONE  | DISCARD,             //optional\nreport_errors             = {SHORTED, UNUSED},              //optional\nshorted_violation_comment  = \"string\",                       //optional\nunused_violation_comment   = \"string\",                       //optional\nname                      = \"layer_label\"                   //optional\n);\nnot_texted_with(\nlayer1                    = polygon_layer,\nlayer2                    = text_layer,\ntext                      = {\"string\", ...},\nuse_text                  = ALL  | TOP,\ncolon_text                = EQUATE_NETS | REGULAR_TEXT,     //optional\nshorts                    = KEEP_ONE  | DISCARD,             //optional\nreport_errors             = {SHORTED, UNUSED},              //optional\nshorted_violation_comment  = \"string\",                       //optional\nunused_violation_comment   = \"string\",                       //optional\nname                      = \"layer_label\"                   //optional\n);", "returns": "polygon layer or error result\ntexted_with() and not_texted_with()", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the text layer.", "text": "Required. Specifies the text strings used for selection. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation.", "use_text": "Optional. Specifies the cells in the specified text layer whose text is used. The\ndefault is ALL.\n\u2022 ALL. Uses text from all cells.\n\u2022 TOP. Uses only text from the top cell. That is, only polygons from the top cell\nare selected.\nNote:\nWith this setting, the not_texted_with()  function is not  the\ncomplement of the texted_with()  function. When the use_text\nargument is TOP, both functions select polygons only from the top\ncell.", "colon_text": "Optional. Specifies how the colon ( : ) is processed. The default is\nREGULAR_TEXT.\n\u2022 EQUATE_NETS. For layer2  text strings, ignores the colon and characters\nfollowing it. For example, \u201ca:\u201d, \u201ca:a\u201d, and \u201ca:xyz\u201d all match the text \u201ca\u201d. This\nsetting applies only when the colon_text  argument is EQUATE_NETS  in the\ntext_options()  function.\n\u2022 REGULAR_TEXT. Retains the colon and does not give the colon special\nprocessing.", "shorts": "Optional. Specifies the action to take when a single polygon contains multiple\ndifferent texts. The default is KEEP_ONE.\ntexted_with() and not_texted_with()\n\u2022 KEEP_ONE. Generally, uses the text closest to the origin. All other text\ninvolved in the short is ignored.\n\u2022 DISCARD. Discards all shorted text.", "report_errors": "Optional. Specifies the error types reported to the LAYOUT_ERRORS file. The\ndefault is {SHORTED, UNUSED}.\nNote:\nIf the output for the texted_with()  function is to a polygon layer or\nan error report, the errors are reported to the LAYOUT_ERRORS\nfile. If the output for the texted_with()  function is to an error report,\nthe output polygons (texted polygons) are only reported to the\nLAYOUT_ERRORS file.\n\u2022 SHORTED. Reports shorted text.\n\u2022 UNUSED. Reports unused text, which is text that is not contained in the\nlayer2  layer.", "shorted_violation_comment": "Optional. Specifies the violation comment for text short errors. The default is the\ncurrent runset violation comment.", "unused_violation_comment": "Optional. Specifies the violation comment for unused text errors. The default is\nthe current runset violation comment.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The texted_with()  function selects polygons from the layer1  layer that are attached\nwith the specified text in the layer2  layer.", "function_name": "texted_with()"}
{"description": "The texted_with()  function selects polygons from the layer1  layer that are attached\nwith the specified text in the layer2  layer. This function is a cell-level operation; that\nis, all processing is within the context of a given cell and placements are ignored. The\ncomplement of this function is the not_texted_with()  function.\nNote:\nBy default, text is discarded for a cell that is exploded during preprocessing,\nwhile the texted_with()  and not_texted_with()  functions still use discarded\ntext to select polygons when use_text = ALL. If any unused text or text shorts\nexist after the discarded text, the IC Validator tool does not report the error.", "syntax": "texted_with(\nlayer1                    = polygon_layer,\nlayer2                    = text_layer,\ntext                      = {\"string\", ...},\nuse_text                  = ALL  | TOP,\ncolon_text                = EQUATE_NETS | REGULAR_TEXT,     //optional\nshorts                    = KEEP_ONE  | DISCARD,             //optional\nreport_errors             = {SHORTED, UNUSED},              //optional\nshorted_violation_comment  = \"string\",                       //optional\nunused_violation_comment   = \"string\",                       //optional\nname                      = \"layer_label\"                   //optional\n);\nnot_texted_with(\nlayer1                    = polygon_layer,\nlayer2                    = text_layer,\ntext                      = {\"string\", ...},\nuse_text                  = ALL  | TOP,\ncolon_text                = EQUATE_NETS | REGULAR_TEXT,     //optional\nshorts                    = KEEP_ONE  | DISCARD,             //optional\nreport_errors             = {SHORTED, UNUSED},              //optional\nshorted_violation_comment  = \"string\",                       //optional\nunused_violation_comment   = \"string\",                       //optional\nname                      = \"layer_label\"                   //optional\n);", "returns": "polygon layer or error result\ntexted_with() and not_texted_with()", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the text layer.", "text": "Required. Specifies the text strings used for selection. String matching using\nmetacharacters is allowed. See\nString Matching  on page 3353 for more\ninformation.", "use_text": "Optional. Specifies the cells in the specified text layer whose text is used. The\ndefault is ALL.\n\u2022 ALL. Uses text from all cells.\n\u2022 TOP. Uses only text from the top cell. That is, only polygons from the top cell\nare selected.\nNote:\nWith this setting, the not_texted_with()  function is not  the\ncomplement of the texted_with()  function. When the use_text\nargument is TOP, both functions select polygons only from the top\ncell.", "colon_text": "Optional. Specifies how the colon ( : ) is processed. The default is\nREGULAR_TEXT.\n\u2022 EQUATE_NETS. For layer2  text strings, ignores the colon and characters\nfollowing it. For example, \u201ca:\u201d, \u201ca:a\u201d, and \u201ca:xyz\u201d all match the text \u201ca\u201d. This\nsetting applies only when the colon_text  argument is EQUATE_NETS  in the\ntext_options()  function.\n\u2022 REGULAR_TEXT. Retains the colon and does not give the colon special\nprocessing.", "shorts": "Optional. Specifies the action to take when a single polygon contains multiple\ndifferent texts. The default is KEEP_ONE.\ntexted_with() and not_texted_with()\n\u2022 KEEP_ONE. Generally, uses the text closest to the origin. All other text\ninvolved in the short is ignored.\n\u2022 DISCARD. Discards all shorted text.", "report_errors": "Optional. Specifies the error types reported to the LAYOUT_ERRORS file. The\ndefault is {SHORTED, UNUSED}.\nNote:\nIf the output for the texted_with()  function is to a polygon layer or\nan error report, the errors are reported to the LAYOUT_ERRORS\nfile. If the output for the texted_with()  function is to an error report,\nthe output polygons (texted polygons) are only reported to the\nLAYOUT_ERRORS file.\n\u2022 SHORTED. Reports shorted text.\n\u2022 UNUSED. Reports unused text, which is text that is not contained in the\nlayer2  layer.", "shorted_violation_comment": "Optional. Specifies the violation comment for text short errors. The default is the\ncurrent runset violation comment.", "unused_violation_comment": "Optional. Specifies the violation comment for unused text errors. The default is\nthe current runset violation comment.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The texted_with()  function selects polygons from the layer1  layer that are attached\nwith the specified text in the layer2  layer.", "function_name": "not_texted_with()"}
{"description": "The touching()  function selects layer1  polygons that have any inside or outside\nedge coincidence with the layer2  edges. There is no restriction on what other types\nof interaction can occur between the touching polygon and any layer2  edges. The\ncomplement of this function is the not_touching()  function.", "syntax": "touching(\nlayer1          = polygon_layer,\nlayer2          = edge_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_touching(\nlayer1          = polygon_layer,\nlayer2          = edge_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer from which polygons are selected.", "layer2": "Required. Specifies the edge layer against which the layer1  layer is checked.", "count": "Optional. Specifies the number of edges that must be touched. See\nConstraints\non page 3344 for more information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ntouching() and not_touching()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The touching()  function selects layer1  polygons that have any inside or outside\nedge coincidence with the layer2  edges.", "function_name": "touching()"}
{"description": "The touching_edge()  function selects entire layer1  edges that have the specified\ncoincidence with layer2  edges. It includes inside and outside coincident. The complement\nof this function is the not_touching_edge()  function.", "syntax": "touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional: Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, polygons are counted. If layer2  is an\nedge layer, individual edges are counted. See\nConstraints  for more information.\nThe default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ntouching_edge() and not_touching_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The touching_edge()  function selects entire layer1  edges that have the specified\ncoincidence with layer2  edges.", "function_name": "touching_edge()"}
{"description": "The touching_edge()  function selects entire layer1  edges that have the specified\ncoincidence with layer2  edges. It includes inside and outside coincident. The complement\nof this function is the not_touching_edge()  function.", "syntax": "touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);\nnot_touching_edge(\nlayer1          = data_layer,\nlayer2          = data_layer,\ncount           = integerconstraint,          //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\ncoincidence     = EDGE | ENDPOINT | ALL       //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "layer2": "Required. Specifies the edge or polygon layer.", "count": "Optional: Specifies the number of touches that must occur for an edge to be\nselected. If layer2  is a polygon layer, polygons are counted. If layer2  is an\nedge layer, individual edges are counted. See\nConstraints  for more information.\nThe default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\ntouching_edge() and not_touching_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "coincidence": "Optional. Specifies the types of coincidence that cause a selection. The default\nis EDGE.\n\u2022 EDGE. Only edge coincidence causes an edge to be selected.\n\u2022 ENDPOINT. Only those edges that have no edge coincidence, but have\ncollinear, endpoint, coincidence are selected.\n\u2022 ALL. All types of coincidence cause an edge to be selected."}, "summary": "The touching_edge()  function selects entire layer1  edges that have the specified\ncoincidence with layer2  edges.", "function_name": "not_touching_edge()"}
{"description": "The two_color()  function is used in double-patterning flows to decompose the input layer\ninto two colors. Optional precoloring assignments are used during graph coloring.", "syntax": "two_color(\nnodes                   = polygon_layer,\nlinks                   = geometry_layer,\nout_color1              = out_polygon_layer,\nout_color2              = out_polygon_layer,\neven_loops              = out_polygon_layer,\npre_color_errors        = out_polygon_layer,\npre_color1              = polygon_layer,                    //optional\npre_color2              = polygon_layer,                    //optional\noutput_even_loops        = true | false,                     //optional\noutput_type             = ODD_LOOP_ONE_LINK  | ODD_LOOP_ALL_LINKS |\nODD_LOOP_ALL_NODES | ODD_LOOP_ALL_LOOP |\nODD_LOOP_INSIDE_RING,             //optional\npre_color_error_mode     = PRE_COLOR_ALL_NODES |\nPRE_COLOR_ENVELOPE_PATH  |\nPRE_COLOR_SHORTSET_PATH,\n//optional\ncolor_preference        = NONE  | BALANCED,                  //optional\ncolor_consistency        = {\nhierarchically_insensitive = true | false, //optional\norphan_nodes_balance_distance = 0.3  //optional\n}, //optional\nwindow_balance          = {\nwindow_layer    = polygon_layer,\nlayer_hash      = {\"string\" => polygon_layer, ...},\nwindow_function = function,\ndelta_window    = {25, 25},\ndelta_x         = 12.5,\ndelta_y         = 12.5,\nboundary        = CLIP |\nALIGN  | IGNORE |\nREPLICATE_WINDOW,\nrebalance_mode  =\nGLOBAL  | LOCAL,\noptional_link_purpose = COLOR  | BALANCE\n//optional\nrebalance_space = 1.0,\nallowed_color1_ratio = doubleconstraint\n},                                                          //optional\nshift_min_length        = double,                           //optional\nshift_ratio             = double,                           //optional\nshift_mode              = {SHORTEST, CENTER, CENTER_ALL_ANGLE,\noptional_links          = {geometry_layer, ...}             //optional\nout_color_type           = ALL  | CONFLICTS | NONE,           //optional\nout_color_pull_down      = true  | false,                     //optional\ntwo_color()\npre_color_reduce        = true | false,                     //optional\n= true | false,                     //optional\ngenerate_fix_guidance   = true | false,                     //optional\nfix_guidance_parameters = {\nodd_loop_limit            = integer,                     //optional\ncolor_spacing_rules       = {\n{rule_type          = SIDE_TO_SIDE | LINE_END_TO_SIDE |\nLINE_END_TO_LINE_END | CORNER_TO_CORNER |\nNOTCH | CENTER_TO_CENTER | USER_DEFINED,\ndistance           = doubleconstraint,\nextension_distance = double,                         //optional\nprojection_length  = doubleconstraint,               //optional\nextension          = EDGE |\nNONE | RADIAL |\nRECTANGLE | SQUARE,             //optional\nlook_thru          =\nNONE  | NOT_ADJACENT | ALL,      //optional\nlook_thru_count    = integerconstraint},             //optional\n...},                                                 //optional\nerror_color_spacing_rules = {\n{error_link = error_layer,\ndistance   = double,\nsized_by   = double,                                 //optional\nmeasure_to =\nORIGINAL_SHAPE  | SIZED_SHAPE},          //optional\n...},\nuser_defined_links        = polygon_layer,               //optional\nline_end_length           = double,                      //optional\nadjacent_length           = double,                      //optional\nline_end_expand           = double,                      //optional\nside_expand               = double,                      //optional\ndirection                 = {\nHORIZONTAL  |\nVERTICAL},     //optionalcolo\npitch                     = double,\nmin_width                 = double,                      //optional\ntrack_layer               = edge_layer                    //optional\n},\noutput_even_loops_mode       = ALL | NEIGHBORING_ODD,       //optional\noutput_irregular_links       = ALL  | NONE | SELF_CONNECT,   //optional\nsame_color_links             = geometry_layer,              //optional\nsame_color_optional_links     = {geometry_layer, ...},       //optional\nerror_link_interaction        = COMPLEX  | SIMPLE,            //optional\noptional_pre_color1           = {polygon_layer, ...}, //optional\noptional_pre_color2           = {polygon_layer, ...}, //optional\nsearch_mode                   = UNSET  | NORMAL | QUICK       //optional\nquick_mode_spec               = {min_conflicts   = 1,\nmin_standard_time        = -1,\nmin_standard_search_time = 3600,\nmax_net_conflicts        = 100,\nmax_group_conflicts      = 1000,\n//optional\nnonplanar_output_preference   = NONE  | ALL_RINGS\nSEPARATE_RINGS,             //optional\noutput_ignored_same_color_links  = true  | false,            //optional\npreference_color1             = polygon_layer,              //optional\npreference_color2             = polygon_layer,              //optional\ntwo_color()\npre_color_include_touch       = NONE  | EDGE,                 //optional\nodd_loop_output_preference  = NONE  | ALL_SMALLEST_RINGS |\nALL_SMALLEST_LOOPS,\n//optional\npre_color_purpose  = COLOR_NODE | PRIORITIZE_LINK\n//optional\n);", "returns": "polygon layer\nThe return value of the function is a conflict marker layer that indicates where legal two-\ncoloring is not possible. For example, in the case where two nodes  polygons on either side\nof a links  polygon have the same output color, the resulting conflict marker layer is the\nconnector polygon between the two polygons associated with the default output_type\nargument for the ODD_LOOP_ONE_LINK  option. Other output arguments enable additional\ninformation in the return layer to capture the nodes that are involved in the coloring\nconflict.", "arguments": {"nodes": "dangling nodes.\nThe color_preference  argument is set to BALANCED  automatically when\ncolor balancing is activated with the window_balance  argument.", "links": "Required. Specifies the input geometry layer that contains polygons that connect\nnodes  polygons to complete the graph description of the coloring problem. Each\npolygon in the links  geometry layer must interact, either by edge touch or\npolygon overlap, with exactly two nodes  polygons to achieve correct coloring.\nThe links  geometry indicates that the two connected nodes  polygons must be\nassigned to different colors.\nThe links  geometry layer is commonly generated using dimensional\ncommands on the nodes  polygon layer. For example, it is generated using\nan external spacing check on the nodes  polygon layer that captures double-\npatterning critical spacing relationships.\nNote:\nedge_layer  is no longer a valid input of links. It is recommended to\nuse error layer as an input.", "out_color1": "Required. Specifies the output polygon layer that contains the subset of nodes\npolygons that are colored with color 1.\ntwo_color()", "out_color2": "Required. Specifies the output polygon layer that contains the subset of nodes\npolygons that are colored with color 2.", "even_loops": "Required. Specifies the output polygon layer that contains all even loops in\nany local graph. That is, the layer is a connected network of nodes  or links\npolygons that contain a coloring conflict. This layer can be used to identify\nnested odd cycles.", "pre_color_errors": "Required. Specifies the output polygon layer that marks coloring conflicts\nbetween nodes  polygons that are marked for precoloring by the pre_color1\nand pre_color2  arguments. When you specify the output_type  argument\nwithout the ODD_LOOP_ONE_LINK  option, the pre_color_errors  argument\noutput contains any color conflict path between any two precolored nodes\nthat are part of minimal cycles, as well as any node marked with two different\nprecolors. For the ODD_LOOP_ONE_LINK  option, the pre_color_errors\nargument output contains only those precolored nodes marked with both the\npre_color1  and pre_color2  arguments.", "pre_color1": "Optional. Specifies the polygon layer that marks a subset of nodes  polygons\nthat must be assigned to the out_color1  argument. The precolor marker must\nhave polygon interaction, that is, shape overlap, with the nodes  polygon to be\nassigned to the out_color1  argument. Portions of the pre_color1  argument\nthat fall outside of the nodes  polygons are ignored.", "pre_color2": "Optional. Specifies the polygon layer that marks a subset of nodes  polygons\nthat must be assigned to the out_color2  argument. The precolor marker must\nhave polygon interaction, that is, shape overlap, with the nodes  polygon to be\nassigned to the out_color2  argument. Portions of the pre_color2  argument\nthat fall outside of nodes  polygons are ignored.", "output_even_loops": "Optional. Specifies if the even_loops  output is generated. The default is false.\n\u2022 true. The output polygon layer contains all even loops that are adjacent to\nodd loops in a conflict graph. .\n\u2022 false. The output even_loops  layer is empty.\ntwo_color()", "output_type": "Optional. Controls the shape returned for coloring conflicts. The default is\nODD_LOOP_ONE_LINK.\n\u2022 ODD_LOOP_ONE_LINK. Returns the links  polygon between the two nodes\npolygons of the same color.\n\u2022 ODD_LOOP_ALL_LINKS. Returns all of the links  polygons in the minimum\nodd-member ring formed by nodes  polygons and linked by links  polygons\nthat include two same-colored nodes  polygons connected by a single links\npolygon.\n\u2022 ODD_LOOP_ALL_NODES. Returns all of the nodes  polygons in the minimum\nodd-member ring formed by nodes  polygons and linked by links  polygons\nthat include two same-colored nodes  polygons connected by a single links\npolygon.\n\u2022 ODD_LOOP_ALL_LOOP. Returns all of the links  polygons as well as the nodes\npolygons in the minimum odd-member ring formed by nodes  polygons and\nlinked by links  polygons that include two same-colored nodes  polygons\nconnected by a single links  polygon.\n\u2022 ODD_LOOP_INSIDE_RING. Returns a ring that is two times the input library\nresolution wide inside the minimum odd-member ring formed by nodes\npolygons. The ring is linked by links  polygons that include two same-\ncolored nodes  polygons connected by a single links  polygon. When\nan odd loop is closely connected to cross links  or look-thru links,\nthe ODD_LOOP_INSIDE_RING  output for this odd loop is the same as the\nODD_LOOP_ALL_LOOP  output.", "pre_color_error_mode": "Optional. Specifies the output information for precolor errors. The default is\nPRE_COLOR_ENVELOPE_PATH.\n\u2022 PRE_COLOR_ALL_NODES. Output contains all conflict pre-colored nodes. If a\nnet has an odd cycle in it, the output contains only the net marked by the\nprecolor marker.\n\u2022 PRE_COLOR_ENVELOPE_PATH. Output contains all conflict pre-colored nodes\nand the envelop path between conflict pre-colored nodes.\n\u2022 PRE_COLOR_SHORTSET_PATH. Output contains the minimum length paths\nbetween conflict pre-colored nodes.", "color_preference": "Optional. Specifies if the IC Validator tool balances the color selections.\nBalancing is based on polygon area. The default is NONE.\ntwo_color()\n\u2022 NONE. Does not balance color selections. Orphan nodes are colored.\n\u2022 BALANCED. Balances color selections. Orphan nodes are colored. The tool\ntries to balance the two colors hierarchically at each cell.\nNote:\nOrphan nodes\norphan nodes\nare those polygons that do not have same color\nspacing links to their neighbors. Orphan nodes are also called", "dangling": "", "color_consistency": "Optional. Specifies non-sensitive hierarchy coloring.\n\u2022 hierarchically_insensitive. Optional. Specifies hierarchy insensitive\ncoloring on or off. Default is false.\n\u2022 orphan_nodes_balance_distance. Optional. Specifies the maximum\ndistance between orphan nodes. For the two nodes <= distance, the two\nnodes are in the same net. The distance is calculated iteratively, which\nmeans that if all nodes are shorter than this distance, they are seen as in the\nsame net. Even if they are in a line. The number should be double. Default is\n0.3.", "window_balance": "Optional. Turns on color balance functionality. In this flow, the tool determines a\ncoloring result, then measures the color balance (density). If a window violates\nthe balance requirement, which is defined in the window_function, then the\ntool explodes any cell that interacts with the violating window polygon without\ncompletely covering it.\n\u2022 window_layer. Required. Specifies the polygon layer containing one or\nmore polygons that define the boundaries where layers are processed for\ndensity calculations.\nThe\nchip_extent()  and layer_extent()  functions can be used to create a\nwindow layer. Call these functions before the density()  function.\n\u25e6 The chip_extent()  function returns a layer containing a single rectangle\nequal to the extents of the chip. Use this function to create a single\nfull-chip check window. See the\nchip_extent()  function for more\ninformation.\ntwo_color()\n\u25e6 The layer_extent()  function returns a layer containing a single\nrectangle equal to the extents of the input layer. Use this function to\ncreate a single-layer check window. See the\nlayer_extent()  function for\nmore information.\nFor more information about density calculations, see the density()  function.\n\u2022 layer_hash. Optional. Specifies a hash of string to polygon layer that is\nprocessed for density calculations. Data in the hash is accessible via the\nhash key within the remote window function. When referencing data in\nhash from within the window function, only the portion of the layer within the\ncurrent delta_window  subwindow or the current window layer polygon is\nseen.\nIf you specify an external layer_hash, this hash definition is merged with\nthe default hash definition into a single hash. The default names cannot\nbe overwritten; default names are nodes, out_color1, out_color2,\neven_loops, and pre_color_errors. Optional layers are needed in an\nexternal layer_hash  only when they are required for the color_balance()\nfunction.\n\u2022 window_function. Optional. Specifies the remote function that calculates\nthe density. See the\nLayout Density Utility Functions  for more information\nabout the utility functions you can use to define a remote function.\n\u2022 delta_window. Optional. Specifies the subwindow stepped across each\nwindow layer polygon. The density equations are evaluated within each\nsubwindow. The default is the extents of each window layer polygon.\n\u2022 delta_x. Optional. Specifies the delta_window  subwindow step distance\nin the x-direction. The default is the width  option of the delta_window\nargument.\n\u2022 delta_y. Optional. Specifies the delta_window  subwindow step distance\nin the y-direction. The default is the height  option of the delta_window\nargument.\n\u2022 boundary. Optional. Specifies how to process a delta_window  subwindow\nthat overlaps the boundary of the extents of a window layer polygon. The\ndefault is ALIGN.\nFor more information about density calculations, see the\ndensity()  function.\n\u2022 rebalance_mode. Optional. Controls how the window_balance  argument\nsolves density balance violation areas. The default is GLOBAL.\ntwo_color()\n\u25e6 GLOBAL. Performs density rebalancing globally for the entire nodes layer.\n\u25e6 LOCAL. Performs density rebalancing locally for each density violation\nmarker.\n\u2022 optional_link_purpose. Optional. Specifies the use of the optional links in\nthis two_color  run. The default is COLOR.\n\u25e6 COLOR. Uses optional links to color.\n\u25e6 BALANCE. Uses optional links for balance, connecting the orphan nodes\nwith their neighboring nets to the same group.\n\u2022 rebalance_space. Optional. Specifies user-defined input space value for the\nexternal distance.\n\u2022 allowed_color1_ratio. Optional. Specifies the constraint used in the\ndensity utility functions.", "shift_min_length": "Optional. Specifies the link shifting threshold. A link is shifted only when its\nlength is equal to or greater than this value. The default is 0  (zero).", "shift_ratio": "Optional. Defines the ratio of the shift segment to the overlap segment. For\nexample, if the overlap segment for an error pair is 100 microns and this value\nis set to 0.1, the shift segment is 10 microns. The shifted link is within this\nsegment. The default is 1.", "shift_mode": "Optional. Specifies the mode used to generate the link, which can be a subset of\nall of the modes. The default is SHORTEST.\n\u2022 SHORTEST. Uses the shortest distance between error pairs to generate a link.\n\u2022 CENTER. Uses center points of the error pair to generate a link. This mode is\napplicable only when the run length is less than or equal to 0 (zero) and the\nlink derived by the default shift mode is orthogonal.\n\u2022 CENTER_ALL_ANGLE. Uses center points of the error pair to generate a link.\nThis mode is applicable only when the error pair run length is less than or\nequal to 0 (zero).\n\u2022 OPPOSITE. Shifts two endpoints of the generated link in opposite directions\nwith respect to the shift ratio. This mode is applicable only when the shift\nrange is positive, which means the run length is greater than 0 (zero), the\nlink length is greater than or equal to the shift threshold, and the shift ratio is\ngreater than 0 (zero).\ntwo_color()\n\u2022 ERROR_CENTER. Uses center points of the error pair to generate a link.\nNote:\nWhen you select the ERROR_CENTER  option to generate a link, all\nof the other modes are disabled.", "optional_links": "Optional. Specifies a list of geometry layers. Each layer is a link layer and has\nan implied weight associated with it. The first layer has weight 1 and has the\nhighest priority after the required link layer. The second layer has weight 2\nand has the next highest priority, and so on. The tool uses these weights in\noptimization, for example, density balancing. You can specify up to seven layers.\nThe default is empty.\nNote:\nAll the link layers, including the required link layer and layers defined\nin the optional_links  argument, must be the same type, that is,\nthey all must be either polygon layers or error layers.\nList of edge_layer  are no longer valid inputs of optional_links.\nColor conflicts that involve only optional links are not output.", "out_color_type": "Optional. Controls how coloring results are generated for the output polygon\nlayers specified by the out_color_1  and out_color_2  arguments. The default\nis ALL.\n\u2022 ALL. Generates all coloring results of out_color_1  and out_color_2.\n\u2022 CONFLICTS. Generates the coloring results only for the conflict graphs of\nout_color_1  and out_color_2.\n\u2022 NONE. Does not generate any coloring results, which means out_color_1\nand out_color_2  are empty.", "out_color_pull_down": "Optional. Controls whether the IC Validator tool pulls down the coloring output\nspecified by the out_color_1  and out_color_2  arguments. The default is\ntrue.\n\u2022 true. Pulls down the coloring output from out_color_1  and out_color_2.\n\u2022 false. Does not pull down the coloring output from out_color_1  and\nout_color_2.\ntwo_color()\nFor information about how the tool pulls down data, see the pull_down()  and\npull_down_to()  functions.", "pre_color_reduce": "Optional. Controls whether the two_color()  function performs precolor filtering.\nThe default is false. Set this option to true  when you want to reduce memory\nusage by filtering precolored node data that does not affect the coloring results\nfor any uncolored node shapes.\nNote:\nEnabling the precolor data reduction can result in the following error\nconflict reporting changes:\n- Odd loops interacting with pruned precolor links might be omitted.\n- Even loops interacting with pruned precolor links might be omitted.", "generate_fix_guidance": "Optional. Controls whether fix guidance information is returned as violations and\nadded to the error database (PYDB). The default is false.", "fix_guidance_parameters": "Optional. Specifies the parameters used to generate fix guidance information.\n\u2022 odd_loop_limit. Optional. Sets the maximum number of errors that the tool\nreports with fix guidance information when the generate_fix_guidance\nargument is set to true. The default is 100, which means the two_color()\nfunction reports 100 odd loop errors with fix guidance information. Setting\nthis argument to 0  suppresses the reporting of fix guidance information.\nNote:\nThe tool selects odd loops based on their areas. Short-range odd\nloops are reported first.\nTo report fix guidance information, you must set the output_type\nargument to ODD_LOOP_INSIDE_RING. If you set the output_type\nargument to any other value, the function reports only double-\npatterning errors.\nTo report fix guidance information for all of the violations, set the\nodd_loop_limit  argument to ERROR_LIMIT_MAX.\n\u2022 color_spacing_rules. Optional. Defines the rule type and spacing values\nfor the fix guidance information output when the input layer specified by\nthe links  argument is not an error layer. For more information, see the\ncolor_spacing_rules  argument of the coloring_links()  function.\ntwo_color()\nNote:\nIf the links  input layer is an error layer, this argument is ignored\nand the error_color_spacing_rules  argument defines the rule\ntype and spacing values.\n\u25e6 rule_type. Required. Specifies how the distance is measured.\n\u25aa SIDE_TO_SIDE\n\u25aa LINE_END_TO_SIDE\n\u25aa LINE_END_TO_LINE_END\n\u25aa CORNER_TO_CORNER. (The extension  option must be RADIAL.)\n\u25aa NOTCH\n\u25aa CENTER_TO_CENTER\n\u25aa USER_DEFINED\n\u25e6 distance. Required. Specifies the check distance. For more information,\nsee Constraints  on page 3344.\n\u25e6 extension_distance. Optional. Specifies the check region extension\ndistance when the extension  option is RECTANGLE. The value must be\nnonnegative. The default is 0.0.\n\u25e6 projection_length. Optional. Specifies the projection length. For more\ninformation, see Constraints  on page 3344. The default is >0.0.\n\u25e6 extension. Optional. Specifies the extension of the check region beyond\nthe endpoints of the edge being checked. The default is NONE.\n- EDGE. Forms the check region by extending the edges, using the\nextension_distance  argument value, and by creating right-angle\nboundaries at the extended endpoints based on the distance  constraint.\nThe right-angle boundaries of the check region are exclusive. The far\nboundary of the check region is inclusive or exclusive depending on the\nconstraint of the distance  value.\nNote:\nThis setting is useful only where the minimum of the distance\nconstraint is nonzero and the extension_distance  is\nnonzero.\n- NONE. Does not extend the check region. It is formed with right-angle\nboundaries at the edge endpoints. The right-angle boundaries of the\ntwo_color()\ncheck region are exclusive. The far boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n- RADIAL. Extends the check region past the endpoints of the edges using\nthe distance  value with a radial curve. The boundary of the check region\nis inclusive or exclusive depending on the constraint of the distance\nvalue.\n- RECTANGLE. Extends the check region past the endpoints of the edges\nusing the extension_distance  value with a rectangle. The boundary of\nthe check region is inclusive or exclusive depending on the constraint of\nthe distance  value.\n- SQUARE. Extends the check region past the endpoints of the edges using\nthe distance  value with a square. The boundary of the check region is\ninclusive or exclusive depending on the constraint of the distance  value.\n\u25e6 look_thru. Optional. Specifies the edges that the spacing check looks\nthrough when measuring. The default is NONE.\n- NONE. Does not look through any edges, including edge endpoints.\n- NOT_ADJACENT. Looks through all edges, except for this special case:\nwhen measuring the extension region from endpoint X of edge A, the\ncheck does not look through any edges that share endpoint X with edge\nA. This setting avoids false violations that might be reported when the\nlook_thru  argument is ALL.\n- ALL. Looks through all edges.\n\u25e6 look_thru_count. Optional. Specifies the number of edges that must\nbe looked through for a measurement to occur. Edges coincident to the\nedge being measured are not included in the count. The value must be\nnonnegative. For more information, see\nConstraints  on page 3344. The\ndefault is >=0, which means the count is ignored.\nNote:\nUse this argument only when the extension  argument is NONE\nand the look_thru  argument is ALL.\n\u2022 error_color_spacing_rules. Optional. Defines the rule type and spacing\nvalues for the fix guidance information output when the input layer specified\nby the links  argument is an error layer.\nNote:\nIf the links  input layer is not an error layer, this argument is\nignored and the color_spacing_rules  argument defines the rule\ntype and spacing values.\ntwo_color()\n\u25e6 error_link. Required. Specifies the error edge pairs.\n\u25e6 distance. Required. Specifies the check distance for same mask\nviolations in double patterning.\n\u25e6 sized_by. Optional. Specifies the oversized value. The default is 0.0.\n\u25e6 measure_to. Optional. The default is ORIGINAL_SHAPE  when the distance\nargument is defined against original metal. Set to SIZED_SHAPE  if the\ndistance argument is defined against oversized metal.\n\u2022 user_defined_links. Optional. Specifies the link layer that is generated\nby the user-defined rules. Use the user_defined_links  argument only\nwhen the rule_type  argument of the color_spacing_rules  argument is\nUSER_DEFINED.\n\u2022 line_end_length. Optional. Used in conjunction with adjacent_length  to\nselect line-end edges. To be selected as a line-end edge, an edge must meet\nall of the following criteria:\n\u25e6 length less than or equal to line_end_length, and\n\u25e6 have internal angles of 90 degrees at both ends, and\n\u25e6 adjacent edges at both ends must have length greater than or equal to", "adjacent_length": "The default is 0.0.\n\u2022 adjacent_length. Optional. Used in conjunction with line_end_length\nto select line-end edges. See line_end_length  for more information. The\ndefault is 0.001.\n\u2022 line_end_expand. Optional. Specifies the expansion of the line-end edges.\nThe line-end edges are expanded before the side edges. The default is 0.0.\n\u2022 side_expand. Optional. Specifies the expansion of the side edges. The side\nedges are expanded after the line-end edges. The default is 0.0.\n\u2022 direction. Optional. Specifies the preferred direction of the selected metal\nlayer. The default is HORIZONTAL.\n\u2022 pitch. Required. Specifies the distance in preferred direction from the\ncenterline of one metal layer to the centerline of the adjacent metal layer.\n\u2022 min_width. Optional. Specifies the minimum width of the selected metal\nlayer.\n\u2022 track_layer. Optional. Specifies the track layer of the metal layer. By\ndefault, the tool attempts to guess the track layer.\ntwo_color()", "output_even_loops_mode": "Optional. Specifies which mode outputs the even loops when the\noutput_even_loops  argument is true. The default is NEIGHBORING_ODD.\n\u2022 ALL. Specifies the output polygon layer that contains all even loops.\n\u2022 NEIGHBORING_ODD. Specifies the output polygon layer that contains only\neven loops, which neighbor the odd loops.", "output_irregular_links": "Optional. Specifies which mode outputs the irregular links The default is ALL.\n\u2022 ALL. Outputs all irregular links, which includes dangling links and self-\nconnected links.\n\u2022 NONE. Specifies that no irregular links are output.\n\u2022 SELF_CONNECT. Specifies that only self-connected links, which are links\nconnecting to the same node are output.", "same_color_links": "Optional. Specifies a geometry layer that contains polygons that connect\nsame-color nodes. Each polygon in thesame_color_links  geometry layer\nmust interact, either by edge touch or polygon overlap, with exactly two\nnodes of another polygon to achieve correct coloring. Additionally, the\nsame_color_links  geometry layer must have the same type of links as the\ngeometry layer.", "same_color_optional_links": "Optional. Specifies a list of geometry layers. Each layer is a link layer and has\nan implied weight associated with it. The first layer has a weight of 1 and has\nthe highest priority after the required link layer. The second layer has a weight\nof 2 and has the next highest priority, and so on. The tool uses these weights\nin optimization, for example, in density balancing. You can specify up to seven\nlayers. The default is empty.\nNote:\nAll of the link layers, including the required link layer and layers\ndefined in the same_color_optional_links  argument must be\nthe same type, that is, they all must be either polygon layers, edge\nlayers, or error layers.\nColor conflicts that involve only same color optional links are not\noutput.\ntwo_color()", "error_link_interaction": "Optional. Specifies the rules used for error link identification. The default is\nCOMPLEX.\n\u2022 COMPLEX. Specifies that the complex rule is used for error link identification.\n\u2022 SIMPLE. Specifies that the simple rule is used for error link identification.", "optional_pre_color1": "Optional. Specifies a list of polygon layers. Each layer marks a subset of nodes\nthat must be colored with color1  as much as possible. In addition, each layer\nhas an implied weight associated with it. The first layer has a weight of 1, the\nsecond layer has a weight of 2, and so on. The smaller the weight, the higher\nthe priority. You can specify up to 15 layers. The default is empty.", "optional_pre_color2": "Optional. Specifies a list of polygon layers. Each layer marks a subset of nodes\nthat must be colored with color2  as much as possible. In addition, each layer\nhas an implied weight associated with it. The first layer has a weight of 1, the\nsecond layer has a weight of 2, and so on. The smaller the weight, the higher\nthe priority. You can specify up to 15 layers. The default is empty.", "search_mode": "Optional. Controls the turning on and off of the QUICK  mode for the current\nfunction, but also represents whether the current function specifies its own\nQUICK  mode status. The default is UNSET.\n\u2022 UNSET. Current two_color()  function does not specify its own QUICK  mode,\nand QUICK  mode is enabled by default.\n\u2022 NORMAL. Specifies that two_color()  never enters QUICK  mode or exits the\nordinary search flow.\n\u2022 QUICK. Specifies that two_color()  enters QUICK  mode when conditions\nare reached, and exits the odd_loop/pre_color_error_path  search when\nconditions are reached.", "quick_mode_spec": "Optional. Controls the early exit for an individual multiple patterning function.\n\u2022 min_conflicts. Specifies the minimum odd_loop  or\npre_color_error_path  that the two_color()  function found before\nentering into quick search mode. The default is 1, that is, if two_color()  is\ntoo slow, you need at least one odd_loop  or pre_color_error_path  for one\nnet group.\ntwo_color()\n\u2022 min_standard_time. Specifies the minimum time in\nseconds that the two_color()  spends (data preparing plus\nodd_loop/pre_color_error_path  searching), before two_color()  enters\ninto quick search mode.\n\u2022 min_standard_search_time. Specifies the minimum time in seconds that\nthe two_color()  function spends on odd_loop  or pre_color_error_path\nsearching, before the two_color()  function enters into quick search mode.\n\u2022 max_net_conflicts. If the two_color()  function already\nentered quick search mode, specifies the number of odd_loops  or\npre_color_error_path  that the two_color()  function already found,\nbefore two_color()  can exit the biconnected component in graph theory,\nor a combination of some neighboring biconnected components. If a net has\nno low-degree-node and no articulation point, a net is just a biconnected", "component": "\u2022 max_group_conflicts. If two_color()  already entered into quick\nsearch mode in current net-group, specifies the number of odd_loops  or\npre_color_error_path  that the two_color()  already found for this net\ngroup, before two_color()  can exit this net group.", "nonplanar_output_preference": "Optional. Specifies that the two_color()  function outputs odd_loops in a\nnonplanar drawing. The default is NONE.\nNote:\nThis argument is affects only the two_color()  output with\noutput_type = ODD_LOOP_INSIDE_RING.\n\u2022 NONE. All odd_loops  in a nonplanar drawing are output as\nODD_LOOP_ALL_LOOPS.\n\u2022 ALL_RINGS. Specifies that all odd_loops  in a nonplanar drawing are output\nas ring shapes.\n\u2022 SEPARATE_RINGS. Specifies that odd_loops  in a clear ring shape are output.\nIf one odd_loops  ring interacts with another odd_loops  ring, IC Validator\nselects the smaller of the two odd_loops  rings.", "output_ignored_same_color_links": "Optional. Specifies that ignored same_color_links  is output in the return\nlayer for any output type. The default is false.", "preference_color1": "Optional. Specifies that the layer marks a subset of the nodes that must be\ncolored with color1  as much as possible. This argument takes precedence\ntwo_color()\nover the optional_pre_color1, optional_pre_color2, and optional_links\narguments in this function.", "preference_color2": "Optional. Specifies that the layer marks a subset of the nodes that must be\ncolored with color2  as much as possible. This argument takes precedence\nover the optional_pre_color1, optional_pre_color2, and optional_links\narguments in this function.", "pre_color_include_touch": "Optional. When input polygons share active area with pre-color polygons, the\npre-color polygons are always valid. The input polygons sharing no active area\nwith pre-color polygons can be optionally valid based on outside touches, as\nspecified by this argument. The default is NONE.\n\u2022 NONE. Specifies that neither point touch nor line touch causes a polygon to be\nselected.\n\u2022 EDGE. Specifies that an edge touch causes a polygon to be selected.", "odd_loop_output_preference": "Optional. Specifies which odd_loops  to output. Also specifies how the odd_loop\noutput looks when you set output_type=ODD_LOOP_INSIDE_RING.\n\u2022 NONE. Default preference to choose odd_loops  to output. With this option\nset, two_color  does not ensure to output all equivalent smallest odd_loops.\n\u2022 ALL_SMALLEST_RINGS. Disables nonplanar_output_preference  argument\nand output ring shape for the odd_loop. If more than one odd_loop_rings\nare sharing the same link with each other, it returns the smallest odd_loops.\n\u2022 ALL_SMALLEST_LOOPS. Disables nonplanar_output_preference  argument\nand output all nodes and links shape in the odd_loop. If more than one\nodd_loops  are sharing the same link with each other, it returns the nodes\nand links of smallest odd_loop.", "pre_color_purpose": "Optional. Makes pre_color  to be used to decide node color, or to decide which\nlink must be free-of-conflict, and vote for whether to flip color for the net.\n\u2022 COLOR_NODE. Specifies whether the pre_color  is used to mark a subset of\nnodes polygons that must be assigned to the out_color.\n\u2022 PRIORITIZE_LINK. Specifies whether the pre_color  is used to mark a\nsubset of nodes polygons that two nodes must be different color or not.\ntwo_color()"}, "summary": "The two_color()  function is used in double-patterning flows to decompose the input layer\ninto two colors.", "function_name": "two_color()"}
{"description": "The unified_fill()  function can automatically generate a wide range of fill pattern types\nwhile satisfying stringent spacing rules and target densities.\nTable 74  lists the fill pattern\ntypes that the function can generate\nTable 74 Fill Pattern Types\nFill pattern type Used for\nPolygon fill Simple rectangles, rectilinear fill, multilayer fill\nAdjustable fill Rectangular fill with automatic size adjustments along\nfill area boundary\nStack fill Multilayer fill, with definition from automatic permutation\nof the original pattern\nCell fill Multilayer fill, with definition read from a database\nExpandable polygon fill Fill cells that get expanded along the boundaries of a fill\ntarget area\nStripe fill Stripe-shape fill across target areas\nExpandable cell fill Fill cells, with base cell component definitions provided\nin GDS files, that get expanded along the boundaries of\na fill target area\nSee the Unified Fill  chapter of the IC Validator User Guide  for detailed information about\nthe application of these fill pattern types, as well as discussions on defining spacing\nconstraints.", "syntax": "insertion  = {\niterations    = integer,\nshift_factor  = integer,\nsymmetry      = true | false,\nauto_rotate   = NONE  | PRIMARY_AXIS |\nFAILED_INSERTION | MAX_INSERTION,\nstarting_point  = LEFT_BOTTOM  | LEFT_TOP | CENTER |\nRIGHT_BOTTOM | RIGHT_TOP},\nprune_jogs,\nprune_notch      =\n{horizontal_length = doubleconstraint,\nvertical_length   = doubleconstraint},\nsymmetry_marker_layer  = polygon_layer\n}", "returns": "layer_groups_h\nThe output of the unified_fill()  function is a hash of string to list of polygon layer. The\nstrings are user-defined. The list is used for coloring.\nunified_fill()", "arguments": {"iterations": "Optional. Specifies how many times a given pattern is inserted in a given fill\nregion. This feature is useful only for nonrectangular fill regions. Use this when\nthe fill_context  option is REGION, but if the region for subsequent iterations\ndoes not have a new lower-left, then this option does not affect the fill process.\nThe maximum value is 10. Higher values slow the fill process. The default is 1.", "shift_factor": "Optional. Specifies how many times the tool tries a new starting point to\nmaximize fill. This feature is useful only for nonrectangular fill regions. The\nmaximum value is 10. Higher values slow the fill process. The default is 0, which\nmeans that no effort is made to shift the starting point.", "symmetry": "Optional. Specifies if this fill pattern is centered in a given fill region. The default\nis false.\n\u2022 true. Partitions the region and the fill is placed starting at the lower-left of the\npartition, and then the entire pattern is moved such that the top and bottom\nedges of the fill shapes are equidistant to the top and bottom edges of the\npartition, and that the left and right edges of the fill are equidistant to the left\nand right edges of the partition.\n\u2022 false. Does not center the fill pattern.", "auto_rotate": "Optional. Specifies how the fill can be rotated or aligned. whenever fill shapes\nare rotated, the space_x  and space_y  values are transposed accordingly. The\ndefault is NONE.\nunified_fill()\n\u2022 NONE. Does not change the orientation of the fill shapes.\n\u2022 PRIMARY_AXIS. Orients fill shapes along the major axis of the fill region. For\nnonrectangular fill or multilayer fill, the extents of the pattern are used. For\nnonrectangular fill area, the extents of the fill area are used to determine the\nmajor axis.\n\u2022 FAILED_INSERTION. Rotates fill 90 degrees if the original orientation\nprovided zero insertion for a given fill region.\n\u2022 MAX_INSERTION. Rotates fill either 0 or 90 degrees, whichever provides\nmaximum insertion.", "starting_point": "Optional. Specifies the location in fillable regions from which the fills are\ngenerated. The default is LEFT_BOTTOM.\n\u2022 LEFT_BOTTOM. Generates fill from the bottom-left corner of the fillable region.\n\u2022 LEFT_TOP. Generates fill from the top-left corner of the fillable region.\n\u2022 RIGHT_BOTTOM. Generates fill from the bottom-right corner of the fillable\nregion.\n\u2022 RIGHT_TOP. Generates fill from the top-right corner of the fillable region.\n\u2022 CENTER. Generates fill from the center point of the fillable region.\nThis value is not supported when the\nfill_context  option is set to\nSIGNAL_CONTEXT  or LINEAR_CONTEXT.\nNote that when using fill_context = PARTITION_CONTEXT, the center\npoint is based on the polygons that have been partitioned. When using\nfill_context = CHIP_CONTEXT, the starting point starts from the center\npoint of the output layer from the chip_extent()  function.\nunified_fill()\nAs shown in Figure 706, the fill is located at the starting point of the fillable\nregion. When starting_point = RIGHT_TOP, the fill whose (right, top) is in\nthe fillable region's (right, top) is represented.\nFigure 706 starting_point Example", "prune_notch": "Optional. Specifies the notch, which is an edge whose adjacent corners are all\n270 degrees, to be pruned. If the length of the edge meets the requirements of\nthe horizontal_length  or vertical_length  constraints, the edge must be\nextended to avoid a violation. The default is == 0. See\nFigure 707.\n\u2022 horizontal_length. Defines the length of notches in the horizontal\ndirection that need to be prune away.\n\u2022 vertical_length. Defines the length of notches in the vertical direction that\nneed to be prune away.\nNote:\nA notch is formed only by orthogonal edges. For all-angle edges, a\nnotch the horizontal_length  and vertical_length  constraints\nare never met.\nunified_fill()\nIn Figure 707, the red lines denote the notches and the dotted circle highlights a\nnotch that meets the constraint specified by the vertical_length  option.\nFigure 707 prune_notch Example\nIn Figure 708, the notch is extended to achieve the following result.\nFigure 708 prune_notch Example With Extension of the Notch", "prune_jogs": "Optional. Defines a list of jogs for pruning based on their horizontal and vertical\nlengths.\nA jog is defined by three consecutive orthogonal edges, the forward edge, the\nbackward edge and the middle edge, where at least one corner of the middle\nedge is a convex right-angle corner. A job is pruned if the lengths of its middle\nedge and one of its adjacent edges satisfy the length constraints. You do not\nneed to set both constraints. If the horizontal_length  constraint is equal to\nthe default of ==0, there is no length criteria for horizontal edges. Similarly, if the\nvertical_length  constraint is equal to the default, there is no length criteria\nfor vertical edges. If both constraints are set to their default ==0, no pruning is\nperformed.\nDefines a list of jogs for pruning based on their horizontal and vertical lengths.\nSee\nprune_jogs  for more information.", "symmetry_marker_layer": "Optional. Specifies the symmetric layer for symmetric fill insertion. The default is\nNULL_POLYGON_LAYER.\nunified_fill()", "fill_to_signal_spacing": ""}, "summary": "The unified_fill()  function can automatically generate a wide range of fill pattern types\nwhile satisfying stringent spacing rules and target densities.", "function_name": "unified_fill()"}
{"description": "The unified_fill_region()  function generates a polygon layer that represents the\nfillable region, which is produced based on a list of input fill_to_signal  spacing\nparameters.\nSee the Unified Fill  chapter of the IC Validator User Guide  for detailed information on\ndefining spacing constraints.", "syntax": "unified_fill_region(\nfill_to_signal_spacing_list = {\n{signal_layer          = polygon_layer,\nwidth_based_spacing   = {\n{width           = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}}, ...},\nmin_space             = double,\ncontext               =\nEXTERIOR  | INTERIOR |\nEXTERIOR_INTERIOR | BOUNDARY,\nmin_space_x           = double,\nmin_space_y           = double,\nwidth_based_spacing_x = {\n{width           = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}},\n...},\nwidth_based_spacing_y = {\n{width           = doubleconstraint,\nallowed_spacing = {doubleconstraint, ...}},\n...}},\ncolor_aware_to_fill   =\nALL  | ONLY_COLOR_1 | ONLY_COLOR_2\nONLY_COLOR_3 | ONLY_COLOR_4},\nmin_space_inside      = double,\nmin_space_inside_x    = double,\nmin_space_inside_y    = double,\nspace_extension       = double,\nspace_extension_x     = double,\nspace_extension_y     = double,\ndebug_layer_name      = \"string\",\ndelta_projection_spec = min_space  = double,\nmin_length = double,\nprojection            =\nALL  | CORNER,\n...},\nfill_boundary   = {type   = CHIP | LAYER | WINDOW | SIGNAL_EXTENT,\nlayer  = polygon_layer,\nwindow = {left  = double,  bottom = double,\nright = double, top = double}}, //optional\nregion_type     = UF_FILL_REGION  | UF_BLOCKAGE_REGION,       //optional\ndeangle_max_deviation  = double                               //optional\n);\nunified_fill_region()", "returns": "polygon layer", "arguments": {"fill_to_signal_spacing_list": "Required. Defines spacing rules between fill and signal layers.\n\u2022 signal_layer. Specifies the layer that is to be avoided.\n\u2022 width_based_spacing. Specifies where fill can go, and not go, based\non the width of the signal layer, and is only applicable when the context is\nEXTERIOR. The width_based_spacing  value overrides the min_space  value\nif both are specified.\n\u25e6 width. Specifies the width range.\n\u25e6 allowed_spacing. Lists the allowed spacing ranges for a given width.\n\u2022 min_space. Specifies the minimum acceptable value for fill-to-signal spacing,\nwhen the context is EXTERIOR, INTERIOR, or BOUNDARY.\nWhen the min_space_inside  option is also used, the min_space  option sets\nthe minimum value for spacing outside the layer.\n\u2022 context. Optional. Specifies where fill can be inserted in relation to the\ndesign layer. The default is EXTERIOR.\n\u25e6 EXTERIOR. Specifies that fill can go outside the layer. This option uses the\nwidth-based spacing values.\n\u25e6 INTERIOR. Specifies that fill can go inside the layer. This option uses\nthe minimum spacing values, if you specify them. Otherwise, it uses the\nmin_space  values.\n\u25e6 EXTERIOR_INTERIOR. Specifies that fill can go outside and inside the\nlayer. This option uses the minimum spacing values.\n\u25e6 BOUNDARY. Specifies that fill goes on the boundary of the polygons, within\nthe minimum spacing distance in both directions.\n\u2022 min_space_x. Specifies the minimum acceptable value for fill-to-signal\nspacing in the x-direction, when the context is INTERIOR  or BOUNDARY.\nWhen the min_space_inside_x  option is also used, the min_space_x\noption sets the minimum value for spacing in the x-direction outside the layer.\n\u2022 min_space_y. Specifies the minimum acceptable value for fill-to-signal\nspacing in the y-direction, when the context is INTERIOR  or BOUNDARY.\nunified_fill_region()\nWhen the min_space_inside_y  option is also used, the min_space_y\noption sets the minimum value for spacing in the y-direction outside the layer.\n\u2022 width_based_spacing_x. Specifies where fill can go, and not go, in the\nx-direction based on the width of the design layer, when the context is\nEXTERIOR. The width_based_spacing_x  value overrides the min_space_x\nvalue if both are specified.\n\u25e6 width. Specifies the width range in the x-direction.\n\u25e6 allowed_spacing. Lists the allowed spacing ranges for a given x-\ndirection width.\n\u2022 width_based_spacing_y. Specifies where fill can go, and not go, in the\ny-direction based on the width of the design layer, when the context is\nEXTERIOR. The width_based_spacing_y  value overrides the min_space_y\nvalue if both are specified.\n\u25e6 width. Specifies the width range in the y-direction.\n\u25e6 allowed_spacing. Lists the allowed spacing ranges for a given y-\ndirection width.\n\u2022 color_aware_to_fill. This option is not supported by the\nunified_fill_region()  function.\n\u2022 min_space_inside. Specifies the minimum acceptable value for fill-to-\nsignal spacing inside the layer when the context is EXTERIOR_INTERIOR\nor BOUNDARY. The min_space_inside  option cannot be used when the\nmin_space_inside_x  and min_space_inside_y  options are used.\n\u2022 min_space_inside_x. Specifies the minimum acceptable value for fill-\nto-signal spacing in the x-direction inside the layer when the context\nis INTERIOR_EXTERIOR  or BOUNDARY. The min_space_inside_x  and\nmin_space_inside_y  options cannot be used when the min_space_inside\noption is used.\n\u2022 min_space_inside_y. Specifies the minimum acceptable value for fill-\nto-signal spacing in the y-direction inside the layer when the context\nis INTERIOR_EXTERIOR  or BOUNDARY. The min_space_inside_x  and\nmin_space_inside_y  options cannot be used when the min_space_inside\noption is used.\n\u2022 space_extension. Specifies the minimum acceptable value for extended\nfill-to-signal spacing when the min_space  option is specified, when the\nmin_space_x  option is specified and the space_extension_y  option\nis not specified, or when the min_space_y  option is specified and the\nunified_fill_region()\nspace_extension_x  option is not specified. The space_extension  option is\navailable only when the context is EXTERIOR.\n\u2022 space_extension_x. Specifies the minimum acceptable value\nfor extended fill-to-signal spacing in the x-direction when the\nmin_space_y  option is specified or when the min_space  option is\nspecified and the space_extension  option is not specified in the same\nfill_to_signal_spacing  definition. The space_extension_x  option is\navailable only when the context is EXTERIOR.\n\u2022 space_extension_y. Specifies the minimum acceptable value\nfor extended fill-to-signal spacing in the y-direction when the\nmin_space_x  option is specified or when the min_space  option is\nspecified and the space_extension  option is not specified in the same\nfill_to_signal_spacing  definition. The space_extension_y  option is\navailable only when the context is EXTERIOR.\nThe following figure shows how the space_extension_y  option is used with\nthe min_space_x  option.\n\u2022 debug_layer_name. This option is not supported by the\nunified_fill_region()  function.\n\u2022 delta_projection_spec. This option is not supported by the\nunified_fill_region()  function.\n\u2022 projection. This option is not supported by the unified_fill_region()\nfunction.", "fill_boundary": "Optional. Specifies the extents of the fill operation, and restricts where the fill is\ninserted.\nunified_fill_region()\n\u2022 type. Specifies the type of extents being used. The default is\nSIGNAL_EXTENT.\n\u25e6 CHIP. Specifies the entire chip for the extents.\n\u25e6 LAYER. Specifies a layer for the extents. All fill fits inside the data of the\nspecified layer.\n\u25e6 WINDOW. Specifies a fixed window for the extents.\n\u25e6 SIGNAL_EXTENT. Specifies the extent of all signal layers.\n\u2022 layer. Specifies the polygon layer when the type  option is LAYER.\n\u2022 window. Uses left, bottom, right, and top  values, to define the extents\nwhen the type  option is WINDOW.", "region_type": "Optional. Specifies the type of output region. The default is UF_FILL_REGION\n\u2022 UF_FILL_REGION. Specifies the fill region output type formed by the\nfill_to_signal_spacing  rules.\n\u2022 UF_BLOCKAGE_REGION. Specifies the blockage region output type formed by\nthe fill_to_signal_spacing  rules.", "deangle_max_deviation": "Optional. Generates the ladder shapes inside the fillable region, and limits\nthe distance between the ladder shape and the original angled shape. When\nspecified, this argument should be a positive value."}, "summary": "The unified_fill_region()  function generates a polygon layer that represents the\nfillable region, which is produced based on a list of input fill_to_signal  spacing\nparameters.", "function_name": "unified_fill_region()"}
{"description": "The vertex()  function creates polygons that represent the specified vertices with the\nspecified output format.\nNote:\nFor edge layers, a vertex is a point where the start of exactly one edge is\ncoincident with the end of exactly one edge, and the edges are not collinear.", "syntax": "vertex(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nshape           = TRIANGLE | DIAMOND | SQUARE_INSIDE |\nSQUARE_OUTSIDE | SQUARE_CENTERED|\nEXTENTS,                                  //optional\nshape_size       = double,                                   //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,                //optional\nname            = \"layer_label\"                             //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "angles": "Required. Specifies the angles that determine the vertices to find. Angle\nmeasurements are made on the interior of the polygon or edge. The angles\nmust be greater than 0 and less than 360. A specification of 180 is ignored. See\nConstraints  for more information.", "shape": "Optional. Specifies the shape of the polygon generated at each selected vertex.\nThe default is SQUARE_CENTERED.\n\u2022 TRIANGLE. The vertex is marked with a triangle that fills the inside of convex\nangles and the outside of concave angles.\n\u2022 DIAMOND. The vertex is marked with a diamond that is centered on the vertex.\nvertex()\n\u2022 SQUARE_INSIDE. The vertex is marked with a square that is placed inside the\npolygon, point touching the vertex.\n\u2022 SQUARE_OUTSIDE. The vertex is marked with a square that is placed outside\nthe polygon, point touching the vertex.\n\u2022 SQUARE_CENTERED. The vertex is marked with a square that is centered on\nthe vertex.\n\u2022 EXTENTS. The vertex is marked with extents boxes from the TRIANGLE\nshapes.", "shape_size": "Optional. Size of the output shape. The value must be positive. When shape is\nSQUARE_CENTERED  or DIAMOND, the value is rounded to the nearest even multiple\nof the internal resolution, with a minimum of twice the internal resolution. The\ninternal_resolution  argument of the\nresolution_options()  function sets\nthe internal resolution. Otherwise, the value is rounded to the nearest internal\nresolution unit, with a minimum of one internal resolution unit. The default is\nDRC_ERROR_BOX, which has a default of 0.1.\nNote:\nWhen shape = TRIANGLE, the sides of the triangle coincident with\nthe input edges are not longer than the edges forming the vertex.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertex()  function creates polygons that represent the specified vertices with the\nspecified output format.", "function_name": "vertex()"}
{"description": "The vertex_edge()  function selects layer1  edges that form the specified vertices. The\nshape_size  argument specifies the maximum length of the edge portion selected.\nNote:\nFor edge layers, a vertex is a point where the start of exactly one edge is\ncoincident with the end of exactly one edge, and the edges are not collinear.", "syntax": "vertex_edge(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nshape_size       = double,                     //optional\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "angles": "Required. Specifies the angles that determine the vertices to find. Angle\nmeasurements are made on the interior of the polygon or edge. The angles\nmust be greater than 0 and less than 360. A specification of 180 is ignored. See\nConstraints  for more information.", "shape_size": "Optional. Maximum length of the output edges. The value must be positive.\nIt is rounded to the nearest internal resolution unit, with a minimum of\none internal resolution unit. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The default is\nDRC_ERROR_BOX, which has a default of 0.1.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\nvertex_edge()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertex_edge()  function selects layer1  edges that form the specified vertices.", "function_name": "vertex_edge()"}
{"description": "The vertex_error()  function measures the interior angle of layer1  vertices and creates\nerrors based on the specified list of angles. The shape_size  argument specifies the\nmaximum length of error edges created.\nNote:\nFor edge layers, a vertex is a point where the start of exactly one edge is\ncoincident with the end of exactly one edge, and the edges are not collinear.", "syntax": "vertex_error(\nlayer1          = data_layer,\nangles          = {doubleconstraint, ...},\nshape_size       = double,                     //optional\nprocessing_mode  = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "error_layer or error result", "arguments": {"layer1": "Required. Specifies the edge or polygon layer.", "angles": "Required. Specifies the angles that determine the vertices to find. Angle\nmeasurements are made on the interior of the polygon or edge. The angles\nmust be greater than 0 and less than 360. A specification of 180 is ignored. See\nConstraints  for more information.", "shape_size": "Optional. Maximum length of the output edges. The value must be positive.\nIt is rounded to the nearest internal resolution unit, with a minimum of\none internal resolution unit. The internal_resolution  argument of the\nresolution_options()  function sets the internal resolution. The default is\nDRC_ERROR_BOX, which has a default of 0.1.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\nvertex_error()\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertex_error()  function measures the interior angle of layer1  vertices and creates\nerrors based on the specified list of angles.", "function_name": "vertex_error()"}
{"description": "The vertices()  function selects polygons based on their number of vertices. The\ncomplement of this function is the not_vertices()  function.\nNote:\nVertices are counted visually rather than the actual number of vertices required\nto digitize a polygon.", "syntax": "vertices(\nlayer1           = polygon_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_vertices(\nlayer1           = polygon_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "count": "Required. Specifies the number of vertices. The value is an integer. See\nConstraints  for more information. The minimum value is 3.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nvertices() and not_vertices()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertices()  function selects polygons based on their number of vertices.", "function_name": "vertices()"}
{"description": "The vertices_edge()  function selects edge chains based on their number of vertices.\nThe complement of this function is the not_vertices_edge()  function.", "syntax": "vertices_edge(\nlayer1          = edge_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_vertices_edge(\nlayer1          = edge_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "count": "Required. Specifies the number of vertices. The value is an integer. See\nConstraints  for more information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nvertices_edge() and not_vertices_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertices_edge()  function selects edge chains based on their number of vertices.", "function_name": "not_vertices_edge()"}
{"description": "The vertices_edge()  function selects edge chains based on their number of vertices.\nThe complement of this function is the not_vertices_edge()  function.", "syntax": "vertices_edge(\nlayer1          = edge_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);\nnot_vertices_edge(\nlayer1          = edge_layer,\ncount           = integerconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "count": "Required. Specifies the number of vertices. The value is an integer. See\nConstraints  for more information. The default is >0.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nvertices_edge() and not_vertices_edge()\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The vertices_edge()  function selects edge chains based on their number of vertices.", "function_name": "vertices_edge()"}
{"description": "Similar to the -svc  command-line option, this function selects the specified rules whose\ncomments match those listed in the comment list. See the IC Validator Basics  chapter in\nthe IC Validator User Guide  for more information on command-line options.", "syntax": "violation_comment_select (\ncomments  = {\"string\", ...}\n);", "returns": "Boolean", "arguments": {"comments": "Required. Specifies the violation comment to select or suppress."}, "summary": "Similar to the -svc  command-line option, this function selects the specified rules whose\ncomments match those listed in the comment list.", "function_name": "violation_comment_select()"}
{"description": "Similar to the -uvc  command-line option, this function unselects the specified rules whose\ncomments match those specified in the comment list.\nNote:\nIf a given rule's comment matches a specification in both the\nviolation_comment_select()  and violation_comment_unselect()\nfunctions, the rule is NOT selected (unselection wins).", "syntax": "violation_comment_select (\ncomments  = {\"string\", ...}\n);", "returns": "Boolean", "arguments": {"comments": "Required. Specifies the violation comment to select or suppress."}, "summary": "Similar to the -uvc  command-line option, this function unselects the specified rules whose\ncomments match those specified in the comment list.", "function_name": "violation_comment_unselect()"}
{"description": "The violation_empty()  function, which is a runtime-conditional function, is used within\nflow control constructs. The function returns a value of true if the specified violation is\nempty; otherwise, the function returns a value of false. Use this function to check whether\na particular function or group of functions produced error output.\nNote:\nUse of runtime-conditional functions might inhibit distributed scheduling and\nrunset optimization.", "syntax": "violations_empty(\nviolations = {violation, ...}\n);", "returns": "Boolean", "arguments": {"violations": "Required. Specifies the violations that are checked. A violation is usually the\nleft side of an @= assignment. For more information about violations, see the\nViolation Blocks  section in the IC Validator User Guide."}, "summary": "The violation_empty()  function, which is a runtime-conditional function, is used within\nflow control constructs.", "function_name": "violation_empty()"}
{"description": "Defines a violation group that can be selected or unselected using the\nviolation_name_select()  or violation_name_unselect()  function, respectively.\nIn addition, the -svn  or -uvn  command line options can also be used to select violations\nusing violation group names.\nThe \u201cnames\u201d list of strings can contain rule names as well as other previously-defined\ngroups.\nAny rule name values specified can also include the \u201c*\u201d wildcard. However, group names\ncannot be chosen via wildcard. For example,\nviolation_name_group( \"GR_1_CHECKS\", { \"GR_1_*\" } );\nviolation_name_group( \"GR_2_CHECKS\", { \"GR_2_*\" } );\nviolation_name_group( \"GR_3_CHECKS\", { \"GR_3_*\" } );\nThis example creates groups to choose rules with names  that begin with GR_1_, GR_2_,\nand so on.\nThe group, GR_1_CHECKS  can then be supplied, as usual, to\nviolation_name_select()\nor violation_name_unselect(), or even another violation_name_group()  command.\nFor example,\nviolation_name_group( \"ALL_GR_CHECKS\", { \"GR_1_CHECKS\", \"GR_2_CHECKS\",\n\"GR_3_CHECKS\" } );\nviolation_name_select( { \"ALL_GR_CHECKS\" } );\nAs mentioned previously, you cannot select a group name via wildcard. Therefore, this\nexample does NOT work to select groups that end with _CHECKS. For example,\nviolation_name_select( { \"*_CHECKS\" } );", "syntax": "violation_name_group (\ngroup  = \"string\",\nnames  = {\"string\", ...}\n);", "returns": "Boolean\nviolation_name_group()", "arguments": {"group": "Required. Specifies the name of the group to be created by the\nviolation_name_group()  call. A group is a named list (tree) of violation names\nand other group names. The leaf-nodes of a group tree should only contain\nviolation names. However, the middle and uppermost groups can contain both\nviolation names and group names.\nThe defined group (name) can then be supplied to both\nviolation_name_select(names={\u2026})  to select all rules and subgroups listed\nwithin the group, or to violation_name_unselect(names={\u2026})  to unselect the\ngroup's rules and subgroups. Finally, the defined group (name) can be specified\nin other violation_name_group(names={\u2026})  to create trees of subgroups\nwithin a group.", "names": "Required. Specifies a list of strings generally comprised of any combination of\nviolation names and other group names. Any named group should have been\npreviously defined by violation_name_group()."}, "summary": "Defines a violation group that can be selected or unselected using the\nviolation_name_select()  or violation_name_unselect()  function, respectively.", "function_name": "violation_name_group()"}
{"description": "Similar to the -svn  command-line option, this function selects the specified rules and\n(resolved) groups which match those listed in the names  argument. All other rules are\nunselected by default. See the IC Validator Basics  chapter in the IC Validator User Guide\nfor more information on command-line options.", "syntax": "violation_name_select (\nnames  = {\"string\", ...}\n);", "returns": "Boolean", "arguments": {"names": "Required. Specifies a list of strings generally comprised of any combination of\nviolation names and other group names. Any named group should have been\npreviously defined by violation_name_select().\nSee the\nviolation_name_group()  function for more information on rule name\nvalues."}, "summary": "Similar to the -svn  command-line option, this function selects the specified rules and\n(resolved) groups which match those listed in the names  argument.", "function_name": "violation_name_select()"}
{"description": "Similar to the -uvn  command-line option, this function unselects the specified rules and\n(resolved) groups which match those listed in the names parameter. All other rules are\nselected by default. However, if at least one\nviolation_name_select()  rule appears\nin the runset, the remaining rules are unselected. See the violation_name_group()\nfunction for more information on rule name values.\nNote:\nIf a rule name is contained (or resolved via a rule group) both in a\nviolation_name_select()  and violation_name_unselect()  rule, the rule is\nNOT selected (unselection wins).", "syntax": "violation_name_unselect (\nnames  = {\"string\", ...}\n);", "returns": "Boolean", "arguments": {"names": "Required. Specifies a list of strings generally comprised of any combination of\nviolation names and other group names. Any named group should have been\npreviously defined by violation_name_unselect()."}, "summary": "Similar to the -uvn  command-line option, this function unselects the specified rules and\n(resolved) groups which match those listed in the names parameter.", "function_name": "violation_name_unselect()"}
{"description": "The voltage_property_override()  function takes one or multiple property layers with\ntwo net-ID properties and one double property to create a net-pair property to override\ndelta voltage.", "syntax": "voltage_property_override(\nconnect_sequence  = connect_database,\nsources  = {{property_layer = geometry_layer,\nnet_id1_property_name = \"string\",\nnet_id2_property_name = \"string\",\npriority       = integer},\n...},\nproperty_name     = \"string\"\n);", "returns": "connect database", "arguments": {"connect_sequence": "Required. Specifies the connect database used to store property information\nthat is overridden.", "sources": "Required. Specifies layer and property information to create a net-pair property\nfor overriding delta voltage value.\n\u2022 property_layer. Specifies that the property_layer  layer must be\ncreated by drc_features()  or drc_feaures_edge()  with two net-\nID properties, which are specified by net_id1_property_name  and\nnet_id2_property_name, and with one double property specified by\nproperty_name. The voltage_property_override()  function read\nthese three properties from each polygon or edge to create an overridden\nrelationship in the output connect database.\n\u2022 net_id1_property_name. Required. Defines the first net-ID property name\nin the property_layer.\n\u2022 net_id2_property_name. Required. Defines the second net-ID property\nname in the property_layer.\nvoltage_property_override()\n\u2022 priority. Optional. Defines the priority of this property source. If there\nare polygons or edges from different property layers, the overridden value\nbetween the same (NET1, NET2) pair is overridden, and the property layer\nwith the higher priority is used. If the priorities are equal, the highest value is\nused. A value of 0 is the lowest priority.", "property_name": "Required. Specifies the double property name whose value is used to override\ndelta voltage value."}, "summary": "The voltage_property_override()  function takes one or multiple property layers with\ntwo net-ID properties and one double property to create a net-pair property to override\ndelta voltage.", "function_name": "voltage_property_override()"}
{"description": "The waiver_options()  function controls how waivers are applied and reported\nduring the IC Validator run. This function enables a new waiver flow, which supersedes\nerror_options(match_errors).\nIf the waiver flow is enabled, waived errors are not included in the\nblock.LAYOUT_ERRORS file, but they are reported in a separate\nblock.WAIVER_REPORT file.", "syntax": "waiver_options(\ndatabases  = {\n{database        = \"string\",\nmissing_database =\nABORT  | IGNORE,\nsuppress_classifications = {\"string\", ...},\nreport_unmatched_waivers = true |\nfalse},\ncell_prefixes    = {\"string\", ...},\ncell_suffixes    = {\"string\", ...}},\n}, ...},                                               //optional\nmatching_mode   = EXACT | ENCLOSE  | INTERACT,                //optional\ntolerance       = double,                                    //optional\ninclude_touch   = NONE | EDGE | ALL,                         //optional\nrule_overrides  = {\n{violation_comments = {\"string\", ...},\ntolerance     = double,\nmatching_mode = UNSPECIFIED,\ninclude_touch = UNSPECIFIED},\n}, ...},\nrule_name_match_delimiter  = { search_string = \"string\" },   //optional\ntool_renamed_cells  = MATCH_NEW_NAME  |\nMATCH_ORIGINAL_NAME,                   //optional\nreport_waiver_details  = true | false,                       //optional\nperc_waiver_file_list  = {\n\"<path to PERC error classification csv file1>\",\n\"<path to PERC error classification csv file2>\",\n\"<path to PERC error classification csv file3>\",\n\u2026\n}\n\u2026\n);", "returns": "void\nwaiver_options()", "arguments": {"databases": "Optional. Specifies the list of waiver databases that the IC Validator tool uses to\napply waivers. Specifying waiver databases in this list enables the new waiver\nflow, which supersedes error_options(match_errors).\n\u2022 database. Required. Specifies the file path to the waiver database created\nby the pydb_export utility. The waiver database can be in cPYDB or OASIS\nformats.\n\u2022 missing_database. The default is ABORT.\n\u25e6 ABORT. Specifies that the run stops when the waiver database is not\nfound.\n\u25e6 IGNORE. Continues the IC Validator run if the tool cannot find the waiver\ndatabase.\n\u2022 suppress_classifications. Optional. Specifies if errors that are classified\nfrom this waiver database are to be suppressed. This argument accepts\na list of strings that represent the classification status of the waivers to be\nsuppressed. String matching using metacharacters is allowed. See\nString\nMatching  for more information. By default, the IC Validator tool does not\nsuppress matched errors.\nFor example, to suppress all errors that match Waive or Ignore classifications\nfrom this waiver database:\nsuppress_matched_errors = {\"Waive\",\"Ignore\"}\nTo suppress all errors from this waiver database:\nsuppress_matched_errors = {\"*\"}\nThe default is that no errors are suppressed.\n\u2022 report_unmatched_waivers. Specifies whether the IC Validator tool\nincludes details of waivers from this waiver database that were not applied to\nany errors during the run in the block.WAIVER_REPORT file. The default is\nfalse. Details of unmatched waivers can be reported by the icv_pydb utility\neven if this argument is set to false.\n\u2022 cell_prefixes. Optional. Specifies a list of cell prefixes that might be used\nto match cell names from the layout to cell names from this waiver database.\nFor example, if the waiver database was created at the block level, and a\nprefix was added to the block and all of its subcells before chip integration,\nspecifying the prefix in this list allows those waivers to be applied to the\ncurrent layout.\nwaiver_options()\n\u2022 cell_suffixes. Specifies a list of cell suffixes that might be used to match\ncell names from the layout to cell names from this waiver database. For\nexample, if the waiver database was created at the block level, and a\nsuffix was added to the block and all of its subcells before chip integration,\nspecifying the suffix in this list allows those waivers to be applied to the\ncurrent layout.", "matching_mode": "Optional. Controls how waivers are matched. The default is ENCLOSE.\n\u2022 EXACT  Specifies that when either an individual error or a complete shape\nhierarchically formed by all touching or overlapping errors matches either an\nindividual waiver or a complete shape hierarchically formed by all touching\nor overlapping waivers, the waiver or waivers are applied to the error. This\nmatches the behavior of the legacy hierarchical error classification flow.\n\u2022 ENCLOSE. Specifies that when an error shape is enclosed by a complete\nwaiver shape hierarchically formed by touching or overlapping waivers, the\nwaiver or waivers are applied to the error.\n\u2022 INTERACT. Specifies that when an error interacts hierarchically with a waiver,\nthe waiver is applied to the error.", "tolerance": "Optional. Specifies a tolerance in microns to be used when matching error\nshapes to waiver shapes.", "include_touch": "Optional. Specifies the outside touches that are included in the interaction when\nmatching waivers are in INTERACT  mode. The default is ALL.\n\u2022 NONE. Includes neither point touch nor line touch.\n\u2022 EDGE. Includes edge touch.\n\u2022 ALL. Includes all touches (edge and point).", "rule_overrides": "Optional. Allows waiver matching options to be overridden for specific rules.\n\u2022 violation_comments. Required. Specifies a list of violation comments.\nString matching with metacharacters is supported.\n\u2022 tolerance. Optional. Overrides the value of waiver_options(tolerance)\nfor the specified rules.\nwaiver_options()\n\u2022 matching_mode. Optional. Overrides the value of\nwaiver_options(matching_mode)  for the specified rules.\n\u2022 include_touch. Optional. Overrides the value of\nwaiver_options(include_touch)  for the specified rules.", "rule_name_match_delimiter": "Optional. Specifies a delimiter that is used to match runset violation comments\nto waiver violation comments. If the delimiter is specified, the waivers are\napplied to violations of a particular rule if the runset violation comment matches\nthe waiver violation comment up to the first occurrence of the delimiter.\n\u2022 search_string. Specifies the delimiter. The search string must be a GNU\nextended regular expression. The default is\n\"[[:space:]]+:|[[:space:]]*:[[:space:]]\"\nThat is, the default is one of the following:\n\u25e6 One or more white space characters followed by a colon.\n\u25e6 Zero or more white space characters followed by a colon followed by one\nwhite space character.\n\u2022 ignore_case. Specifies if the character case in the violation comment is\nconsidered when matching the delimiter. The default is false.\n\u25e6 true. The search is case-sensitive.\n\u25e6 false. The search is not case-sensitive.", "tool_renamed_cells": "Optional. When the IC Validator tool renames cells while reading Milkyway,\nNDM, or OpenAccess layouts this argument specifies whether to use the original\nlayout name or the new unique name when searching waiver databases for\nclassified errors, and when exporting waivers using pydb_export. The default is\nMATCH_NEW_NAME.\n\u2022 MATCH_NEW_NAME. For renamed cells, the new unique name given by the tool\nis used to search for matching waiver cells in the waiver database..\n\u2022 MATCH_ORIGINAL_NAME. For renamed cells, the original layout name is used\nto search for matching waiver cells in the waiver database.", "report_waiver_details": "Optional. Specifies whether to include details of all waived errors in the\nblock.WAIVER_REPORT file. A report, which includes the details can be\ngenerated by the icv_pydb utility regardless of this argument setting. The default\nis false.\nwaiver_options()", "perc_waiver_file_list": "The PERC error classification csv file syntax is as follows:\n<cell>, <Rule>, <device>|<net>, [<optional setting1>], [<optional\nsetting2>], [<optional setting3>],[\u2026]\nThe delimiter is comma. If the string does not contain \u201c,\u201d it does not need be put\nin \u201c\u201d.\nThe description of the CSV format of the waiver file is as follows:\n\u2022 cell: Cell name. It should be the same cell that is reported as violation in\n.LAYOUT_ERRORS  file.\n\u2022 rule: Rule name (violation name)\n\u2022 device_name: name for device error\n\u2022 net_name: name for net error\nThe device  and net  are mutually exclusive, and one of them is required.\nThe tool issues error message when none of them is set, or both are set.\n\u2022 holding_cell  (optional): Defines the violations that can be waived only\nwhen it is within the holding cell. Here the waiver_cell  does not need to be\nplaced directly under holding_cell. A typical usage is, when doing block\nlevel waiver, you should always set the block name as the holding cell, so all\nthe waivers created at block level affects other blocks when running at chip\nlevel even their device name or violation comments are the same.\nFor manually created waiver file, the holding_cell  could be a sub cell of\ncurrent block. Again this restricts the waiver within the holding_cell.\nIn\nFigure 713, the CELL C has 3 devices named ERR1, ERR2, ERR3. If you\ndefine a waiver rule by using the cell name, rule name, and device name of\nERR1, then all instances of ERR1 is waived. If you only want to waive ERR1\nunder CELL A, then you can provide H = \"CELL A\"  in addition, where H\nrefers to holding cell.\nwaiver_options()\nFigure 713 Holding Cell\n\u2022 path  (optional): Defines which waiver cell\u2019s placements should be waived.\nDuring waiver creation, when holding_cell  is present, the waiver cell\u2019s\nplacements are relative to the holding_cell. Otherwise, the placements are\nrelative to the top cell. At the 2nd run with waiver matching, if holding_cell\nis present, the IC Validator tool should only matches the violation inside\nholding_cell  with the same instance path as defined in the waiver file,\notherwise, any waiver cell\u2019s placement containing path is waived.\nIn\nFigure 714, the CELL B has 2 placements under CELL A, that is,\nXCORE1 and XCORE2. If you can define waiver rules for each placement\nby using the cell name, rule name, device name, and instance path of M1.\nOnly the matched instance of M1 is waived. If Cell A is top cell, then the\ninstance_path  of waiver isIP=\"XCORE1\"  and its device name is D=\"M1\".\nFigure 714 Instance Path\n\u2022 trace_net_violation  (optional): It is for net violation waiver only. It controls\nwhether the tool should trace the violated net to all the connected cells to see\nif they meet any waiver criteria.\n\u2022 comment_match(optional): It is used to control whether the violation\ndetails need to be compared. If not set, the tool ignores the violation detail\nwaiver_options()\ndifferences. For example, when a path\u2019s resistance is reported in comment\nsection, although the new run has different resistance, if comment_match\nis not set, the difference is ignored, the tool only uses waiver cell and\ndevice_name  or net_name  to match the violation. For some rules, the\ninstance path could be saved in violation comment, and they are ignored if\ncomment_match  is not set. When comment_match  is present, the tool checks\nwhether the comment_match  string is showing up in the new run to waive the\nviolation.\n\u2022 category  (optional): It can be one of Fixed, Ignore, Waive, Watch, or Error\nwhich are consistent to DRC violations. If Category is not set, the default\nsetting is Waive.\n\u2022 user: It is used to manage wavier rules and keeps track of waiver rule\nmodification. Optional for manually created waiver command.\n\u2022 note: It is used to manage wavier rules and keeps track of waiver rule\nmodification. Optional for manually created waiver command.\n\u2022 date: It is used to manage wavier rules and keeps track of waiver rule\nmodification. Optional for manually created waiver command."}, "summary": "The waiver_options()  function controls how waivers are applied and reported\nduring the IC Validator run.", "function_name": "waiver_options()"}
{"description": "The wide()  function creates polygons that consist of the regions of layer1  which have\nwidths meeting the specified distance  constraint. When data is non rectilinear and\nangled=CIRCULAR, the wide regions are ones that can contain a circle with a diameter\nof the specified distance. When data is non rectilinear and angled=TRUNCATE, the\nwide regions are determined by inside-to-inside spacing measurements of the specified\ndistance. See the INTERNAL  option for more information.", "syntax": "wide(\nlayer1          = polygon_layer,\ndistance        = doubleconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",              //optional\nangled          = CIRCULAR  | TRUNCATE         //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the check distance. It must be a positive value. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are >, >=, ==, !=, <=, and <.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.\nwide()", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "angled": "Optional. Specifies the treatment of non rectilinear data. The default is\nCIRCULAR.\n\u2022 CIRCULAR. Specifies that wide regions are ones that can contain a circle with\na diameter of the specified distance.\n\u2022 TRUNCATE. Specifies that wide regions of polygons with 45-degree angled\nedges are determined by inside-to-inside spacing with the specified distance,\nand the wide regions of polygons with non-45 degree angled edges are\ndetermined by the size()  function. A polygon with non-45 degree angled\nedges is undersized first and then oversized. The acute corner is clipped\nwide()\nusing TRUNCATE, which is described in the size()  function. The size  and\nclip_distance  values make up the width.\nFigure 715 Example of angled Argument"}, "summary": "The wide()  function creates polygons that consist of the regions of layer1  which have\nwidths meeting the specified distance  constraint.", "function_name": "wide()"}
{"description": "The wide_edge()  function creates edges that consist of layer1  edges which define\nregions which are wider than the specified distance. When data is non rectilinear, the\nwide regions are ones that can contain a circle with a diameter of the specified distance.", "syntax": "wide_edge(\nlayer1          = polygon_layer,\ndistance        = doubleconstraint,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\",      //optional\nangled          = CIRCULAR  | TRUNCATE         //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the polygon layer.", "distance": "Required. Specifies the minimum distance. It must be a positive value. See\nConstraints  for more information.\nNote:\nThe only constraint operators allowed are >, >=, ==, !=, <=, and <.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.\nwide_edge()", "angled": "Optional. Specifies the treatment of non rectilinear data. The default is\nCIRCULAR.\n\u2022 CIRCULAR. Specifies that wide regions are ones that can contain a circle with\na diameter of the specified distance. See\nFigure 717.\n\u2022 TRUNCATE. Specifies that wide regions of polygons with 45-degree angled\nedges are determined by inside-to-inside spacing with the specified distance,\nand the wide regions of polygons with non-45 degree angled edges are\ndetermined by the size()  function. A polygon with non-45 degree angled\nedges is undersized first and then oversized. The acute corner is clipped\nusing TRUNCATE, which is described in the size()  function. The size  and\nclip_distance  values make up the width.\nwide_edge()\nFigure 717 Example of angled Argument With CIRCULAR\nwide_edge()\nFigure 718 Example of angled Argument"}, "summary": "The wide_edge()  function creates edges that consist of layer1  edges which define\nregions which are wider than the specified distance.", "function_name": "wide_edge()"}
{"description": "The write_annotation_file()  function generates a property\nannotation file\nannotation file that\ncontains device instances and their corresponding environment-sensitive property\nvalues. The environment-sensitive properties are specified in the properties  argument\nof device functions when the write_property_to  option is ANNOTATION_FILE,\nNETLIST_ANNOTATION_FILE_SPICE, or NETLIST_SKIP_PCELL.\nBecause the extraction of environment-sensitive non-compared properties might cause the\nextracted netlist to become more flattened, the purpose of the property annotation file is to\nstore device instances and their associated non-compared properties into a file separate\nfrom the compare netlist. In this way, the layout extracted netlist for compare can maintain\nas much hierarchy as possible, and the more flattened property annotation file can be\npassed to downstream tools, such as the StarRC tool, that process environment-sensitive\nproperties for simulation flows. This property annotation file is used in the\ndual-hierarchy extraction\ndual-hierarchy\nextraction flow that is initiated when the dual_hierarchy_extraction  argument of the\ninit_device_matrix()  function is true.\nNote:\nIf you enable the dual-hierarchy extraction flow, but there is no\nwrite_annotation_file()  function call in your runset, the IC Validator\ntool generates a default with the name, top_block_properties.gz, that uses a\nprecision value of 6.\nThe annotation file has the following format:\n*Property Annotation File Version: 1.0\n*Created on: date\n*Design: top_layout_cell\n.SUBCKT cell_name\ninstance_name prop_name=prop_value [prop_name=prop_value ... ]\n[instance_name prop_name=prop_value [prop_name=prop_value ... ]]\n...\n.ENDS\n[\n.SUBCKT cell_name\ninstance_name prop_name=prop_value [prop_name=prop_value ... ]\n[instance_name prop_name=prop_value [prop_name=prop_value ... ]]\n...\n.ENDS\n]\nEach .SUBCKT  section represents a cell retained during the dual-hierarchy extraction\nphase that generates properties for the annotation file. (This phase is the simulation pass.)\nwrite_annotation_file()\nEach line within the .SUBCKT  section contains the full instance name followed by a list of\nproperty names with a value for an individual MOSFET instance. The instance names\ncorrespond to MOSFET instances contained in the layout extracted netlist generated by\nthe\nnetlist()  function.", "syntax": "write_annotation_file(\ndevice_db    = device_database,\noutput_file  = property_annotation_file_handle,\nprecision    = integer                                      //optional\n);", "returns": "void", "arguments": {"device_db": "Required. Specifies the device database from which the output file is generated.\nThe\nextract_devices()  function generates this database.", "output_file": "Required. Specifies the annotation file handle. The handle is defined using the\nproperty_annotation_file()  function.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\noutput file. The value can be from 1 through 15. The default is 6."}, "summary": "The write_annotation_file()  function generates a property\nannotation file\nannotation file that\ncontains device instances and their corresponding environment-sensitive property\nvalues.", "function_name": "write_annotation_file()"}
{"description": "The write_ascii()  function provides an ASCII representation of a geometry layer and a\nviolation result.", "syntax": "write_ascii(\nfile   = {ascii_file_handle, ...},\nlayer  = geometry_layer,\nname  = \"string\",   //optional\ncomments     = {string, [string, ...]},   //optional\nannotations  = {string, [string, ...]},   //optional\nhierarchy_output   = INTERNAL  | ORIGINAL,         //optional\ncoordinate_system  = TOP_CELL  | CELL_LEVEL,       //optional\npydb_output  = true | false,                      //optional\ndata_limit   = integer                     //optional\n);", "returns": "violation", "arguments": {"file": "Required. File handle that specifies the ASCII destination. This file is derived\nfrom the fopen()  function.", "layer": "Required. Geometry layer that specifies the polygon, edge, or error layer.", "name": "Optional. Specifies an identifier for the layer in the output file. This argument is\nuseful for layers that are a member of a list or otherwise. The default is an empty\nstring, which means this argument is not used.", "comments": "Optional. Specifies comments to be included in the header of the output. The\ndefault is an empty list.", "annotations": "Optional. Specifies annotations to be included with each geometry. The default\nis an empty list.\nwrite_ascii()", "hierarchy_output": "Optional. Specifies the hierarchy used for ASCII output. The default is\nINTERNAL.\n\u2022 INTERNAL. Specifies the hierarchy used in the IC Validator tool. This is the\ncurrent behavior.\n\u2022 ORIGINAL. Maintains the original hierarchy. This option explodes\nautomatically the vcells and any cells whose flat reference count is different\nthan the original hierarchy.", "coordinate_system": "Optional. Specifies the coordinate system for reporting geometry coordinates.\nThe default is TOP_CELL. This setting also affects the coordinate translation\nlisted in the output below.\n\u2022 TOP_CELL. Specifies that coordinates are reported in the top cell coordinate\nsystem, using an arbitrarily selected placement of the cell. The coordinate\ntranslation maps top cell coordinates to the coordinates of the cell.\n\u2022 CELL_LEVEL. Specifies that coordinates are reported in the given cell\u2019s\ncoordinate system. The coordinate translation maps cell coordinates to the\ntop cell coordinate system.", "pydb_output": "Optional. Specifies error output to the error database (PYDB). The default is\nfalse.\n\u2022 true. Specifies that errors are reported.\n\u2022 false. Specifies that errors are not reported.", "data_limit": "Optional. Specifies the required maximum number of geometries to be\noutput. This applies to ASCII file and layout errors file output. The default is\nNULL_INTEGER, which means no limit is applied."}, "summary": "The write_ascii()  function provides an ASCII representation of a geometry layer and a\nviolation result.", "function_name": "write_ascii()"}
{"description": "The write_customized_spice()  function invokes the netlist utility, icv_netlist, to\ngenerate a SPICE netlist. The netlist data is created using the device database output\nfrom the\nextract_devices()  function and the polygon layers specified in the connect()\nfunction. Therefore, call the write_customized_spice()  function after these functions.\nNote:\nThe icv_netlist utility is in the IC Validator installation directory.\nThe write_customized_spice()  function constructs SPICE instance names as\ndescribed later in this function.", "syntax": "write_customized_spice(\ndevice_db                   = device_database,\noutput_file                 = spice_netlist_file_handle,\nmodel_name_format           = NONE | INSTANCE_NAME | SPICE |\nCOMMENT,                      //optional\ninclude_empty_cells         = NONE  | WITH_PORTS | ALL,      //optional\nprecision                   = integer,                      //optional\nerror_report                = BRIEF  | VERBOSE,              //optional\nuser_functions_file         = \"string\",                     //optional\ninclude_placement_data       = true | false,                 //optional\nflatten                     = true | false,                 //optional\ncompress_netlist            = true | false                  //optional\n);", "returns": "void", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.", "output_file": "Required. Specifies the SPICE handle. The handle is defined using the\nspice_netlist_file()  function.", "model_name_format": "Optional. Specifies how to write the model name on the device line in a SPICE\nnetlist. The default is COMMENT.\nwrite_customized_spice()\n\u2022 NONE. The model name is not written.\n\u2022 INSTANCE_NAME. The model name is appended to the instance name of the\ndevice.\n\u2022 SPICE. The model name is written as the fourth field on the device line, just\nbefore the value.\n\u2022 COMMENT. The model name is written in a comment at the end of the device\nline in the format: $.model=modelName.\nFor example,\nNONE: C1 node1 node2 value\nINSTANCE_NAME: C1_modelName node1 node2 value\nSPICE: C1 node1 node2 modelName value\nCOMMENT: C1 node1 node2 value $.model=modelName\nNote:\nThis argument applies only to capacitor, inductor, and resistor\ndevices.", "include_empty_cells": "Optional. Specifies which empty cells\nempty cellscells, empty\nare written to the cell.net file. Empty cells\ndo not have devices or instances. A cell is always written out when it is defined\nas an equivalence or black-box cell. The default is NONE.\n\u2022 NONE. Does not write empty cells to the cell.net file.\n\u2022 WITH_PORTS. Writes empty cells that have ports to the cell.net file.\n\u2022 ALL. Writes all empty cells to the cell.net file.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\noutput SPICE netlist (cell.sp file) for all device properties. The value can be\nfrom 1 through 15. The default is 6. When the precision argument is <=0, the\nIC Validator tool treats this value as the default precision.", "error_report": "Optional. Specifies the verbosity of the error report. The information is written to\noutput_file.err. If, however, the output_file  argument is not set, the default file\nname cell.sp.err is used. The default is BRIEF.\nwrite_customized_spice()\n\u2022 BRIEF. Writes only a summary, which contains the total count of layout\nnames that cannot be cross-referenced.\n\u2022 VERBOSE. Writes details of cross-referencing errors, such as specific layout\nnames that cannot be cross-referenced.", "user_functions_file": "Optional. Specifies the file that contains the remote functions. See Flexible\nNetlisting Utility Functions  for more information about the utility functions you\ncan use to define a remote function.", "include_placement_data": "Optional. When set to true, the generated SPICE netlist includes coordinate\ninformation for device instances, and coordinate and rotation information for cell\ninstances. The cell instance information is output for both the placement origin\nand the lower-left bounding box position. The default is false.\nThe following device instance example shows where $X and $Y are the\ncoordinates at the center of body polygon:\nMM0 1 4 3 3 p L=2e-06 W=1.2e-05 $X=11500 $Y=26500\nThe following cell instance example shows the $X and $Y lower-left bounding\nbox coordinates and the $T origin placement data:\n$T=field1 field2 field3 field4 $X= field5 $Y= field6\nfield1 = x-coordinate of placement origin\nfield2 = y-coordinate of placement origin\nfield3 = reflection (0, 1)\nfield4 = rotation (0 90 180 270)\nfield5 = x-coordinate of lower-left\nfield6 = y-coordinate of lower-left\n\uff0cthe bounding-box of cell INV is (top=0.150000 bottom=-0.115000\n\uff0cleft=-0.120000 right=0.180000)\nX1 A Z VDD VSS INV $T=0.82 -0.27 1 270 $X=0.67 $Y=-0.45\nInstance X1 is a placement of master cell INV with bounding box = (-0.12 -0.115,\n0.18, 0.15). It is placed on (0.82, -0.27) with reflection of 1 and rotation of 270\ndegrees. The lower-left coordinate of the bounding box of X1 in the parent call is\n(0.67, -0.45).", "flatten": "Optional. Specifies if the netlist is flattened. The default is false.\nwrite_customized_spice()\n\u2022 true. Writes a flattened SPICE netlist.\nNote:\nWhen flatten  is true, the model_name_format\nand user_functions_file  arguments of the\nwrite_customized_spice()  function are ignored.\n\u2022 false. Writes a SPICE netlist that is not flattened.\nThe IC Validator tool adds instance name prefixes, known as SPICE cards,\nto cell and device names. The form of the prefix depends on the value of the\nflatten  argument.\n\u2022 flatten = true\n\u25e6 A hierarchical path name for a device is constructed using instance\nnames originating in the cell.net layout netlist generated by the\nnetlist()  function. A SPICE card prefix is added to the hierarchical path\nname. The SPICE card prefix to be added is defined by the prefix on the\noriginal device instance name in the preflattened netlist. For example, the\nprefix for an NMOS device is \u201cM_\u201d.\nThe slash character (/) delineates hierarchical levels inside the flattened\nhierarchical instance name.\n\u2022 flatten = false\n\u25e6 All device instance names identically match names originating in the\ncell.net layout netlist generated by the netlist()  function. No additional\nSPICE card is added as a prefix to the device instance name because the\nnetlist()  function already adds a prefix to each device instance name\nwith the appropriate SPICE card.\n\u25e6 An \u201cx\u201d prefix is added to cell instance names that originate in the cell.net\nlayout netlist generated by the netlist()  function.\nFor example, prefixed names for an NMOS device are shown in\nTable 75.\nTable 75 SPICE Instance Names With Prefixes for an NMOS Device\nInstance name Output from the\nnetlist()  function\nOutput when\nflatten = true\nOutput when\nflatten = false\nDevice instance name M1 M_l1/M1 M1\nCell instance name l1 (not applicable) xl1\nwrite_customized_spice()", "compress_netlist": "Optional. Compresses the output netlist generated using the write_spice()\nfunction. The output file name is not altered from the user-specified name set in\nthe spice_netlist_file()  function. The default is false."}, "summary": "The write_customized_spice()  function invokes the netlist utility, icv_netlist, to\ngenerate a SPICE netlist.", "function_name": "write_customized_spice()"}
{"description": "The write_gds()  function writes layers and violations to a\nGDSII file\nGDSII file. There can be\nmultiple write_gds()  functions within a runset.\nNote:\nThe GDSII format does not support 64-bit coordinates. Therefore, do not use\nthe -64  command-line option with the write_gds()  function.\nThe\nextract_devices()  function modifies the input connect database with hierarchy\npreprocessing, such as leveling and merging. In the write function, you can use the same\nconnect database from which the layout netlist is generated. Then, the net names in the\noutput layout match the netlist. Use the\nget_netlist_connect_database()  function to\naccess the connect database.\nNote:\nErrors consisting of a single point or two points have polygon data generated for\noutput to the GDSII file. These polygons match what you see in VUE associated\nwith these errors (an X for a single point or a flyline for multiple points).\nSee the\nLimits on Number of Vertices of a Polygon  section for information about writing out\nlarge polygons.", "syntax": "write_gds(\noutput_library     = gds_library_handle,\nresolution         = double  | INTERNAL_RESOLUTION_AUTO |\nWORKING_RESOLUTION,               //optional\nholding_cell       = \"string\",                              //optional\noutput_cell        = \"string\",                              //optional\napply_prefix       = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL},\n//optional\nmerge_input_layout  = true | false,                          //optional\npoint_limit         = integer,                               //optional\ncell_prefix        = \"string\",                              //optional\nerror_cell_prefix  = \"string\",                              //optional\nvirtual_cells      = KEEP | EXPLODE,                        //optional\nlayers = {{layer         = layername,\nlayer_num     = {layer_num = integer, data_type = integer},\ncell_prefix   = \"string\",\naref = {{cell    = \"string\",\nwidth   = doubleconstraint,\nheight  = doubleconstraint,\nminimum_elements = integer,\nreplace = {{x = double, y = double}, ...}\n}, ...\nwrite_gds()\n},\ncell_suffix   = \"string\",\nuser_defined_properties =\n{double_properties = {{name   = \"string\",\nnumber = integer}, ...},\nstring_properties  = {{name   = \"string\",\nnumber = integer}, ...}},\ncompress_fill           = {mode =\nNONE  | AUTO,\ncell = \"string\"},     //optional\nname = \"string\"},\n...},                                             //optional\nerrors = {{error       = violation,\nlayer_num   = {layer_num = integer, data_type = integer},\nviolation_comments = {\"string\", \u2026}},  // optional\ncell_prefix = \"string\",\ncell_suffix = \"string\",\nclassifications = {\"string\", ...}},\n...},                                             //optional\nerror_shapes  = {point_error =  X_SHAPE  |\nBOX_SHAPE | UNSET,\nbox_width = UNSPECIFIED_DOUBLE,\n//2dbu is the default\nflyline_error =  LINE_SHAPE |\nLINE_AND_X_SHAPE  |\nUNSET}, //optional\nproperties            = {instance_name                 = integer,\nnet_name                      = integer,\ninternal_net_name             = integer,\nnet_type                      = integer,\ndevice_name                   = integer,\ndevice_instance_name          = integer,\ndevice_terminal_instance_name = integer\n},                                   //optional\nconnect_sequence     = connect_database,                    //optional\nmagnification_factor  = double,                              //optional\ncell_suffix           = \"string\",                            //optional\nerror_cell_suffix    = \"string\",                            //optional\napply_suffix          = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL},\n//optional\ndevice_db             = device_database,                     //optional\nplace_cells          = {{cell           = cell_handle,\nmarker_layer   = polygon_layer,\ncompress       = NONE  | AUTO,\nabort          = {DIFFERENT_SIZE_RECTANGLES,\nNON_RECTANGULAR_SHAPES},\nlayer_map_file = \"string\",\nreflection     = true | false,\nrotation       = ROTATE_0  | ROTATE_90 |\nROTATE_180 | ROTATE_270,\nshift          = {x = double, y = double}},\ncell_prefix = string,\ncell_suffix    = string},\n...},                              //optional\nwrite_gds()\noutput_generated_instance_names   = true  | false,           //optional\nexclude_from_generated_cell_names = {\"string\", ...},        //optional\nhierarchy_output     = ORIGINAL | INTERNAL,                 //optional\nlayers_from_connect_sequences     = {layer_map_file    = \"string\",\nconnect_sequences =\n{connect_database}\n...},                 //optional\nlayers_from_device_db  = {layer_types = {CONNECTED |\nNON_CONNECTED_DEVICE_BODY},\nstarting_layer_num = integer,\n},                                  //optional\noutput_layer_map_file  = \"string\",                           //optional\nplace_cell_prefix   = \"string\",                              //optional\nplace_cell_suffix      = \"string\"                            //optional\n);", "returns": "void", "arguments": {"output_library": "Required. Specifies the GDSII file handle. The handle is defined using the\ngds_library()  function.\nNote:\nMultiple write_gds()  functions that have the same file name cause\nan overwrite of the GDSII file.", "resolution": "Optional.\nGDSII file, output resolutionresolutionGDSII output\nSnaps output data to this resolution before it is written to the GDSII\nfile. The default is the input library resolution.\nWhen resolution  is set to INTERNAL_RESOLUTION  means the\noutput_resolution = internal_resolution  value.\nWhen resolution  is set to WORKING_RESOLUTION  means the\noutput_resolution = working_resolution  value.", "holding_cell": "Optional. Generated top cell that references the output hierarchy from the run.\nThis cell is a generated holding cell; it does not contain any polygon or text data.\nThe holding cell contains both the error and layer cells. By default, error data\nis written to cells with the ERR_  prefix and layers are written to the layout cell\nnames. The error data can be placed within the layer hierarchy if you change the\nERR_  prefix to an empty string (\"\") using the error_cell_prefix  argument.\nwrite_gds()\nYou can rename cell_top_name using the output_cell  argument. For example,\nfrom the previous example, you could change it to cell_top_new_name:", "output_cell": "Optional. Specifies the new name for the top cell\ntop cellGDSII output library\nof the design to be used in the\noutput library. The name should not conflict with existing cells in the design. The\ndefault name is the original top cell name.", "apply_prefix": "Optional. Specifies the cells in the output library to which the prefix is applied. By\ndefault, the IC Validator tool applies the prefix to the output cell and lower cells.\n\u2022 OUTPUT_CELL. Specifies the prefix that is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Specifies the prefix that is applied to cells placed underneath\nthe top cell.\n\u2022 HOLDING_CELL. Specifies the prefix that is applied to the holding cell.", "merge_input_layout": "Optional. Specifies if the input and generated GDSII files are merged. The\ndefault is false.\nNote:\nPolygons added through the add_shapes  and add_shapes_files\narguments of the\nlibrary()  function are not considered part of the\ninput layout with regard to the merge_input_layout  argument.\n\u2022 true. Merges the input and generated GDSII files to make the final output\nGDSII file. The output GDSII file is a copy of the input GDSII file with\nthe output of the specified layers placed hierarchically at (0,0) under the\ntop of the input cell. For layer output in the layers  argument list, set the\ncell_prefix  or cell_suffix  arguments to give the output cells a name\ndifferent from the original input cells. For cells in the place_cells  argument\nlist, set the place_cell_prefix  or place_cell_suffix  arguments to give\nthe output cells a name different from the original input cells.\n\u2022 false. Outputs only the generated file.\nwrite_gds()", "point_limit": "Optional. Maximum number of points that a polygon can contain. Any polygon\nwith more than this amount is split. The value can be 0, which indicates no limit\nset, or from 6 to 600. If a value from 1 to 5 is specified, the point limit is 6; if a\nvalue greater than 600 is specified, the point limit is 600. The default is 0.", "cell_prefix": "Optional. Specifies the prefix for all cell names written from the layers\nargument list. This value can be overridden by the cell_prefix  option inside of\nthe layers  argument list. The default is an empty string (\"\"); that is, no added\nprefix.\nNote:\nThis argument does not apply to cells added through the\nplace_cells  argument.", "error_cell_prefix": "Optional. Specifies the prefix for all cell names written from the errors\nargument list. This value can be overridden by the cell_prefix  option inside of\nthe errors  list. Set this argument to \u201c\u201d if you do not want a prefix. The default is\n\"ERR_\".", "virtual_cells": "Optional. Specifies the action to take for virtual cells. The default is KEEP.\n\u2022 KEEP. Virtual cells are kept and written to the output library. The output\nhierarchy contains references to virtual cells.\n\u2022 EXPLODE. All data and placements from virtual cells are exploded to the first\nparent design cell before writing to the output library. The output hierarchy\ndoes not contain references to virtual cells.", "layers": "Optional. Lists the layers to write to the GDSII file along with mapping and prefix\ninformation.\n\u2022 layer. Specifies the layer. This layer can be an edge, polygon, or text layer.\n\u2022 layer_num. Specifies the layer number, which is composed of a layer\nnumber and the datatype. This value is used when writing to a library.\nThe data_type  option has a default of 0. See\nLayout Layer and Datatype\nRanges  for information about the limits of the values.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the cell_prefix  argument.\nwrite_gds()\n\u2022 aref\nAREFarray structureSREF\n. Optional. Lists the regular patterns of rectangles to be converted into\narrayed structures. You can specify multiple patterns per layer. This behavior\nis a cell-level operation, and it is typically used to reduce the size of the\noutput layout by converting flat fill to arrayed structures.\nThe IC Validator tool determines if rectangles that meet the provided\ndimensions, specified in the width  and height  options, are in an arrayed\npattern. These rectangles with an arrayed pattern are replaced with a\nnew cell containing a single rectangle of the specified width and height\ndimensions. The origin of the new cell is the lower-left corner of the\nrectangle. Any data in the layer that is not arrayed is output unchanged.\nThe replace  option allows the single rectangle in the new AREF (array\nreference) cell to be replaced by specified polygons.\n\u25e6 cell. Required. Names the new cells created when rectangles are\ngrouped into arrayed structures. The IC Validator tool adds a suffix if\nthere is any conflict with existing cells in the hierarchy or other new cells.\nFor example, if the cell name is icv_aref and there is a conflict, a suffix is\nadded and the new cell is named icv_aref_1. If there is a conflict with this\nname, the new cell is named icv_aref_2, and so on.\n\u25e6 width. Required. Width of the rectangles. See\nConstraints  on page 3344\nfor more information.\nThe IC Validator tool looks for all rectangles with a width equal to the\nwidth  value and height equal to the height  value, and forms arrayed\nstructures, if possible, with 0-degree rotation. It also looks for rectangles\nwith a height equal to the width  value and width equal to the height\nvalue, and forms arrayed structures, if possible, with 90-degree rotation.\nBoth the 0-degree and 90-degree array placements point to the same\ncreated cell.\n\u25e6 height. Required. Height of the rectangles. See\nConstraints  on\npage 3344 for more information.\n\u25e6 minimum_elements. Optional. Minimum number of rectangles for an\narrayed structure to be formed. The IC Validator tool creates an SREF\n(structured reference) instead of an array placement when there is an\narrayed structure of only one rectangle. The default is 16.\n\u25e6 replace. Optional. Lists the polygons that replace the rectangle in the\nnew cells. This feature allows a rectangle marker layer to be used to\ncreate arrayed structures of more complex shapes in the output layout.\nwrite_gds()\nNote:\nSetting the minimum_elements  option to 1 ensures that all\nrectangles of the specified width and height dimensions are\nreplaced by a placement to a cell with the polygons provided.\nThe list contains xy coordinate pairs for each created polygon. The\ncoordinates can be either\n- Two coordinates, which are interpreted as the opposing corners of a\nrectangle.\n- Three or more coordinates, which define the outer boundary of a closed\npolygon. You do not need to repeat the first coordinate at the end of\nthe list. The coordinates can be ordered in either direction around the\npolygon.\nNote:\nPolygons, or portions of polygons with no area, are ignored.\nAreas of self-intersection are left empty.\n\u2022 cell_suffix. Optional. Suffix for all cells written from this layer. New cells\nare generated for this layer if a unique suffix is specified. The default is the\nvalue of the write_gds(cell_suffix) argument.\n\u2022 user_defined_properties. Optional. Specifies user-defined properties that\nare written to specified property numbers. By default, the IC Validator tool\ndoes not write any properties.\n\u25e6 double_properties. Specifies the double value properties that are\nwritten to the specified property numbers.\n- name. Specifies the property name.\n- number. Specifies the property number. The property numbers must be\nin the range of 0\u2013255, inclusive.\n\u25e6 string_properties. Specifies the string value properties that are written\nto the specified property numbers.\n- name. Specifies the property name.\n- number. Specifies the property number. The property numbers must be\nin the range of 0\u2013255, inclusive.\nSee the gds  argument of the\nassign()  function for more information.\n\u2022 compress_fill. Optional. Specifies the compression of fill by replacing\nblocks of fill with placements of new cells.\nwrite_gds()\nNote:\nEach layer to be compressed must be specified with the layers\nargument and the mode of the compress_fill  option set to AUTO.\n\u25e6 mode. Optional. Specifies the type of compression. The default is NONE.\n- NONE. Does not compress the fill.\n- AUTO. Compresses the fill. During the fill compression process, new\ncells are created; some cells have only one fill rectangle and others have\nmultiple fill rectangles. The fill is compressed by replacing the fill data of\nthese cells with single and AREF placements, as appropriate.\n\u25e6 cell. Optional. Names the cell created when fill rectangles are grouped\ninto a sub cell. The IC Validator tool adds a suffix if there is any conflict\nwith existing cells in the hierarchy or other new cells. For example, if the\ncell name is specified as icv_fill and there is a conflict, a suffix is added\nand the new cell is named icv_fill_1. If there is a conflict with this name,\nthe new cell is named icv_fill_2, and so on.\n\u2022 name. Specifies the layer name used by the IC Validator tool for the data\ncounts in the summary file. The default behavior is to extract a name based\non an internal IC Validator file name used for the layer, which might not\nmatch the runset layer variable name specified in the layer argument.", "errors": "Optional. Lists the errors written to the GDSII file along with mapping and prefix\ninformation.\n\u2022 error. Specifies the violation name for the error geometry.\n\u2022 layer_num. Specifies the layer number, which is composed of a layer\nnumber and the datatype. This value is used when writing to a library.\nThe data_type  option has a default of 0. See\nLayout Layer and Datatype\nRanges  on page 3347 for information about the limits of the values.\n\u2022 violation_comments. Optional. Separates the specified comment/rule from\nget_layout_grid_violation()  when writing.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the error_cell_prefix  argument.\n\u2022 cell_suffix. Optional. Specifies the suffix for all cells written from this layer.\nNew cells are generated for this layer if a unique suffix is specified. The\ndefault is the value of the error_cell_suffix  argument.\nwrite_gds()\n\u2022 classifications. Optional. Lists the error classifications that the IC\nValidator tool uses to filter the violations for the specified output layer. For\nexample, this argument allows you to write waived violations to one layer and\nunwaived violations to another layer.\nThe valid error classifications are Error, Ignore, Waive, Watch, Fixed, and\nDebug. By default, no error classification filtering is performed and all errors\nare written for the output layer.\nNote:\nThe error_limit_per_check  argument of the\nerror_options()\nfunction, which has a default of 100, applies to all error output,\nincluding violations written using the write_gds()  function.", "error_shapes": "Optional. Determines the shapes of point errors and flyline errors.\n\u2022 point_error. Defines the representation of point errors. Point errors can be\nrepresented by X shape or box shape. A box shape can be more appropriate\nfor LVL comparison of errors. Default is X_SHAPE.\n\u25e6 X_SHAPE. Represents a point error with an X shape centered on the point.\n\u25e6 BOX_SHAPE. Represents a point error with a box shape centered on the\npoint.\n\u2022 box_width. Controls the width of the box shape which is specified in\nmircrons. Default is 2dbu.\n\u2022 flyline_error. Defines the shape of flyline errors. It can be line with\nendpoints or line without endpoints. Default is LINE_AND_X_SHAPE.\n\u25e6 LINE_AND_X_SHAPE. Represents a flyline error with a line between points\nand X shape at each point.\n\u25e6 LINE_SHAPE. Represents a flyline error with only a line between points.", "properties": "Optional. Associates property numbers with specific properties for output. The\nproperty numbers must be in the range of 0\u2013255, inclusive. By default, the IC\nValidator tool does not write any properties.\n\u2022 instance_name. Optional. Specifies the property number to which cell\ninstance names are written. By default, the IC Validator tool does not write\ninstance names.\n\u2022 net_name. Optional. Specifies the property number to which polygon net\nnames are written. Either a connect database must be specified in the\nwrite_gds()\nconnect_sequence  argument or a device database must be specified in\nthe device_db  argument. By default, the IC Validator tool does not write net\nnames.\n\u2022 internal_net_name. Optional. Specifies the property number to which\ninternal net names are written. The internal net name is the net prefix plus\nthe base net number. Either a connect database must be specified in the\nconnect_sequence  argument or a device database must be specified in\nthe device_db  argument. By default, the IC Validator tool does not write the\ninternal net name.\n\u2022 net_type. Optional. Specifies the property number to which polygon net\ntypes are written. If a polygon\u2019s net connects up or down the hierarchy, the\nproperty value is \u201cIO\u201d; otherwise, the property is not set. Either a connect\ndatabase must be specified in the connect_sequence  argument or a device\ndatabase must be specified in the device_db  argument. By default, the IC\nValidator tool does not write the net type.\n\u2022 device_name. Optional. Specifies the property number to which device\nnames associated with the device body or terminal polygon are written. A\ndevice database must be specified in the device_db  argument. By default,\nthe IC Validator tool does not write the device name.\n\u2022 device_instance_name. Optional. Specifies the property number to which\ndevice instance names associated with device body polygons are written.\nA device database must be specified in the device_db  argument. If more\nthan one device is associated with a polygon, the polygon gets multiple\nproperties in the output. By default, the IC Validator tool does not write the\ndevice instance name.\n\u2022 device_terminal_instance_name. Optional. Specifies the property\nnumber to which device instance names associated with the device terminal\npolygon are written. A device database must be specified in the device_db\nargument. If more than one device is associated with a polygon, the polygon\ngets multiple properties in the output. By default, the IC Validator tool does\nnot write the device terminal instance name.", "connect_sequence": "Optional. Specifies the connect database used to output net name and type\nproperties when the properties  argument is used. If you specify both the\nconnect_sequence  and the device_db  arguments, the connectivity in the\ndevice database is used.", "magnification_factor": "Optional. The output coordinates are multiplied by this factor before writing to\nthe output library.\nmagnification factoroutput coordinates\nA magnification factor between 0.0 and less than 1.0 shrinks\nwrite_gds()\ndata. A magnification factor greater than 1.0 enlarges data. The default is 1.0\n(no magnification).", "cell_suffix": "Optional. Suffix for all cell names written from the layers  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the layers\nargument list. The default is an empty string (\"\").\nNote:\nThis argument does not apply to cells added through the\nplace_cells  argument.", "error_cell_suffix": "Optional. Suffix for all cell names written from the errors  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the errors\nargument list. Set this value to an empty string (\"\") if you do not want a suffix.\nThe default is \"ERR_\".", "apply_suffix": "Optional. Specifies the cells in the output library to which the suffix is applied. By\ndefault, the IC Validator tool applies the suffix to the output cell and lower cells.\n\u2022 OUTPUT_CELL. Suffix is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Suffix is applied to cells placed underneath the top cell.\n\u2022 HOLDING_CELL. Suffix is applied to the holding cell.", "device_db": "Optional. Specifies a device database used to output device name properties\nwhen the properties  argument is used. If you are writing the device name,\ndevice instance name, or device terminal instance name, you must specify\na device database. The\nextract_devices()  function generates a device\ndatabase. If you specify both the connect_sequence  and the device_db\narguments, the connectivity in the device database is used.", "place_cells": "Optional. Places complex fill cells programmatically, instead of layer-by-layer\nfill, into the output layout based on a marker layer containing rectangles. A layer\nconsisting of rectangles is converted into placements of predefined fill cells\ncontaining arbitrary polygons on multiple layers during data output.\nThe imported cell can be renamed to prevent cell name conflicts. The origin of\nthe placement is the lower-left corner of the rectangle.\nwrite_gds()\n\u2022 cell. Specifies the handle to the cell that is imported. The handle is created\nby the import_gds_cell()  or import_oasis_cell()  function.\n\u2022 marker_layer. Specifies the layer that has the rectangles which define the\nfill placement.\n\u2022 compress. Specifies if cell placements should be compressed. The default is\nNONE.\n\u25e6 NONE. Does not compress placements of this cell.\n\u25e6 AUTO. Compresses placements of this cell.\n\u2022 abort. Lists the error severity for rectangles of different sizes\nand nonrectangular shapes on the marker layer. The default is\n{DIFFERENT_SIZE_RECTANGLES, NON_RECTANGULAR_SHAPES}.\n\u25e6 DIFFERENT_SIZE_RECTANGLES. Aborts with an error if there are\nrectangles of different sizes on a single marker layer. If this option is not\nlisted, a warning message is reported. The default is to abort the run if\nthere are rectangles of different sizes on the marker layer. This condition\nindicates the possibility of overlapping or abutting shapes being merged.\n\u25e6 NON_RECTANGULAR_SHAPES. Aborts with an error if there are\nnonrectangular shapes on a single marker layer. If this option is not listed,\na warning message is reported. The default is to abort the run if there are\nnonrectangular shapes on the marker layer. This condition indicates the\npossibility of overlapping shapes being merged.\n\u2022 layer_map_file. Specifies a unified Milkyway layer mapping file that maps\nlayers from the imported fill cell to the output format. The color mappings are\nspecific to Milkyway and only apply when the output format is Milkyway. The\nother mappings can be used for all output formats.\nNote:\nThe unified Milkyway layer mapping file has backward compatible\nsupport for the older Milkyway stream-in layer mapping file syntax.\nThe format of the Milkyway unified file\nMilkyway unified file format", "is": "\u25e6 Mapping for all data:\nA mwlayer[:mwdtype] gdsiilayer[:gdsiidtype]\n\u25e6 Mapping for polygons:\nD mwlayer[:mwdtype] gdsiilayer[:gdsiidtype]\nwrite_gds()\n\u25e6 Mapping for text:\nT mwlayer[:mwdtype] gdsiilayer[:gdsiidtype]\n\u25e6 Color mapping from gdsiidtype to SAME_COLOR:\nM * *:gdsiidtype\n\u25e6 Color mapping from gdsiidtype to MASK_ONE_HARD:\nM1 * *:gdsiidtype\n\u25e6 Color mapping from gdsiidtype to MASK_TWO_HARD:\nM2 * *:gdsiidtype\nThe format of the Milkyway stream-in file is\n\u25e6 DestLayer[:DestDatatype] SrcLayer[:SrcDatatype]\nNote:\nComments are specified with a semicolon. All of the text following\nthe semicolon on the current line is part of the comment.\n\u2022 reflection. Optional. Specifies if the pattern is reflected. See\nFigure 719  for\nan example of reflection and rotation.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is false.\n\u25e6 true. Reflects the pattern.\n\u25e6 false. Does not reflect the pattern.\n\u2022 rotation. Optional. Specifies the rotation of the pattern.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is ROTATE_0; that is, no rotation.\n\u25e6 ROTATE_0.\n\u25e6 ROTATE_90.\nwrite_gds()\n\u25e6 ROTATE_180.\n\u25e6 ROTATE_270.\n\u2022 shift. Optional. Specifies the shift of the pattern origin from the lower-left\ncorner of the marker layer rectangle. The default is {0.0, 0.0}; that is, the\npattern is not shifted.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nRotation does not affect the placement of the origin; it is always\nthe lower-left corner of the marker layer rectangle.\n\u2022 cell_prefix. Optional. Prefix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_prefix).\n\u2022 cell_suffix. Optional. Suffix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_suffix).", "output_generated_instance_names": "Optional. Specifies if instance names internally generated by the IC Validator\ntool are written to the GDSII file in addition to instance names from the input\nlayout. Instance names are written out only if the instance_name  option of the\nproperty  argument is defined. The default is true.\n\u2022 true. Writes internally generated instance names to the GDSII file.\n\u2022 false. Does not write internally generated instance names to the GDSII file.", "exclude_from_generated_cell_names": "Required. Specifies the list of strings that cannot be included in cell names\ngenerated during multilayer fill compression. This does not apply to cell names\ngenerated by single layer fill compression. Multilayer fill compression still calls\nsingle layer fill compression on the remaining uncompressed data.", "hierarchy_output": "Optional. Specifies the type of cell to be exploded.\nwrite_gds()\n\u2022 ORIGINAL. Maintains the original hierarchy. This option explodes\nautomatically the vcells and any cells whose flat reference count is different\nthan the original hierarchy.\n\u2022 INTERNAL. Specifies the hierarchy used in the IC Validator tool. This is the\ncurrent behavior.", "layers_from_connect_sequences": "Optional. Outputs all of the layers associated with each of the connect\ndatabases in the layers_from_connect_sequences.connect_sequences  list.\nThese layers are output to unique layer and datatype pairs that do not conflict\nwith the layer or datatype values specified in the layers  argument. If one of\nthese layers is also specified in the layers  list argument, that specification\n(layer and datatype) is used.\n\u2022 layer_map_file. Specifies an output text file that shows the layer names for\neach connect database along with the layer and datatype to which that layer\nwas written.\n\u2022 connect_sequences. Specifies that all layers associated with this list of\nconnect databases are written to the output library.\nNote:\nThis argument can dramatically affect performance. Use only for\ndebugging purposes.", "layers_from_device_db": "Outputs the required layers associated with device_db  based on the\nlayer_type  lists in this argument. When specified, the required layers are\nmerged with the layers  argument.\nNote:\nThis argument cannot be specified with the\nlayers_from_connect_sequences  argument.\n\u2022 layer_types. Specifies the type of layers to be output.\n\u25e6 CONNECTED. Specifies that all layers in device_db  are used by the\nconnect functions.\n\u25e6 NON_CONNECTED_DEVICE_BODY. Specifies that all device body layers in\ndevice_db  are not connected.\n\u2022 starting_layer_num. Specifies the starting layer number of the written\nlayers. The default is 1.\nwrite_gds()", "output_layer_map_file": "Specifies the name of the output layer map, which lists the name, number, and\ndatatype of the layers written to the GDSII or OASIS files.\nNote:\nThis argument cannot be specified with the\nlayers_from_connect_sequences  argument.", "place_cell_prefix": "Optional. Specifies the prefix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_prefix  argument\ninside theplace_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added prefix.", "place_cell_suffix": "Optional. Specifies the suffix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_suffix  argument\ninside the place_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added suffix."}, "summary": "The write_gds()  function writes layers and violations to a\nGDSII file\nGDSII file.", "function_name": "write_gds()"}
{"description": "The write_gds_global_options()  function overwrites all resolution settings\nin the write_gds()  function in the runset. The write_gds_global_options()\nfunction can be used with -runset_config, which adds or replaces the\noriginal write_gds_global_options()  in the runset file. If you have\nwrite_gds_global_options()  in runset file or not, the resolution for write_gds()  is\nspecified by write_gds_global_options()  in the runset_config  file.\nIt is defined in options_public.rh  and the only input argument is resolution.", "syntax": "write_gds_global_options(\nresolution         = double,\n);", "returns": "void", "arguments": {"resolution": "Replaces the resolution arguments in write_gds()."}, "summary": "The write_gds_global_options()  function overwrites all resolution settings\nin the write_gds()  function in the runset.", "function_name": "write_gds_global_options()"}
{"description": "The write_milkyway()  function writes layers and violations to a Milkyway library. There\ncan be multiple write_milkyway()  functions within a runset.\nNote:\nThe Milkyway format does not support 64-bit coordinates. Therefore, do not use\nthe -64  command-line option with the write_milkyway()  function.\nThe write_milkyway()  function is longer supported starting in X-2025.06.\nErrors consisting of a single point or two points have polygon data generated for output to\nthe Milkyway library. These polygons match what you see in VUE associated with these\nerrors (an X for a single point or a flyline for multiple points).\nNote:\nSee the \u201cRuntimes and Memory Use Report\u201d section in the Licensing and\nResource Requirements  chapter of the IC Validator User Guide  for information\nabout the reported Milkyway memory usage.\nSee the\nLimits on Number of Vertices of a Polygon  section for information about\nwriting out large polygons.", "syntax": "write_milkyway(\noutput_library  = milkyway_library_handle,\nholding_cell    = \"string\",                                 //optional\noutput_cell     = \"string\",                                 //optional\napply_prefix    = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL}, //optional\nview            = \"string\",                                 //optional\nmode            = APPEND | APPEND_NEW_VERSION | OVERWRITE,  //optional\ntechnology_file = \"string\",                                 //optional\nnet_id           = true | false,                             //optional\nconnect_sequence   = connect_database,                       //optional\ncell_prefix       = \"string\",                               //optional\nerror_cell_prefix = \"string\",                               //optional\nvirtual_cells     = KEEP | EXPLODE,                         //optional\nboundary_layer    = polygon_layer,                          //optional\nlayers = {{layer       = layername,\nlayer_num   = {layer_num = integer, data_type = integer},\ncell_prefix = \"string\",\nroute_type  = route_type,\naref = {{cell    = \"string\",\nwidth   = doubleconstraint,\nheight  = doubleconstraint,\nminimum_elements = integer,\nreplace = {{x = double, y = double}, ...}},\nwrite_milkyway()\n...},\nconvert_to  =\nNONE  | WIRE | RECT,\ncell_suffix = \"string\",\nattach_properties = {{assign_layer = data_layer,\nproperties = {OWNER_NET, ROUTE_TYPE}\n}, ...},\nboolean_attributes = {{name  = \"string\",\nvalue = true | false}, ...},\ndouble_attributes  = {{name  = \"string\",\nvalue = double}, ...},\nfloat_attributes   = {{name  = \"string\",\nvalue = double}, ...},\ninteger_attributes = {{name  = \"string\",\nvalue = integer}, ...},\nstring_attributes  = {{name  = \"string\",\nvalue = \"string\"}, ...},\ncolor              = color,\ncompress_fill      = {mode =\nNONE  | AUTO,\ncell = \"string\"},          //optional\nerror_layer_format = DATA  | ERRORS},\n...},                                             //optional\nerrors = {{error       = violation,\nlayer_num   = {layer_num = integer, data_type = integer},\ncell_prefix = \"string\",\nroute_type  = route_type,\ncell_suffix = \"string\",\nclassifications = {\"string\", ...}},\n...},                                             //optional\nerror_shapes  = {point_error =  X_SHAPE  |\nBOX_SHAPE | UNSET,\nbox_width = UNSPECIFIED_DOUBLE,\n//2dbu is the default\nflyline_error =  LINE_SHAPE |\nLINE_AND_X_SHAPE  |\nUNSET}, //optional\noutput_hierarchy       = true  | false,                      //optional\nupdate_technology_file  = true  | false,                      //optional\nmagnification_factor   = double,                             //optional\ninstance_name         = {write    = true  | false,\nconflict = ABORT | SKIP  | RENAME}, //optional\ncell_suffix            = \"string\",                           //optional\nerror_cell_suffix     = \"string\",                           //optional\napply_suffix           = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL},\n//optional\nplace_cells           = {{cell           = cell_handle,\nmarker_layer   = polygon_layer,\ncompress       = NONE  | AUTO,\nabort          = {DIFFERENT_SIZE_RECTANGLES,\nNON_RECTANGULAR_SHAPES},\nlayer_map_file = \"string\",\nreflection     = true | false,\nrotation       = ROTATE_0  | ROTATE_90 |\nROTATE_180 | ROTATE_270,\nwrite_milkyway()\nshift          = {x = double, y = double}\ncell_prefix = string,\ncell_suffix    = string},\n...},                              //optional\nlayer_mode             = AUTO  | NORMAL | EXTENDED,           //optional\ndatatype_mode         = AUTO  | NORMAL | EXTENDED,           //optional\nexclude_from_generated_cell_names        = {\"string\", ...}, //optional\nhierarchy_output     = ORIGINAL | INTERNAL,                 //optional\nlayers_from_connect_sequences     = {{layer_map_file    = \"string\",\nconnect_sequences =\n{connect_database}\n...},                  //\noptional\nplace_cell_prefix  = \"string\",                //optional\nplace_cell_suffix     = \"string\"                 //optional\n);", "returns": "void", "arguments": {"output_library": "Required. Specifies the Milkyway library handle. The handle is defined using the\nmilkyway_library()  function.", "holding_cell": "Optional. Specifies the generated top cell that references the output hierarchy\nfrom the run. This cell is a generated holding cell; it does not contain any\npolygon or text data.\nThe holding cell contains both the error and layer cells. By default, error data\nis written to cells with the ERR_  prefix and layers are written to the layout cell\nnames. The error data can be placed within the layer hierarchy if you change\nthe ERR_  prefix to an empty string (\"\") using the error_cell_prefix  argument.\nSee the\nerror_cell_prefix  argument of the write_milkyway()  function for\nmore information.", "output_cell": "Optional. Specifies a new name for the top cell\ntop cellGDSII output library\nof the design to be used in the\noutput library. The name should not conflict with existing cells in the design. The\ndefault name is the original top cell name.", "apply_prefix": "Optional. Specifies the cells in the output library to which the prefix is applied. By\ndefault, the IC Validator tool applies the prefix to the output cell and lower cells.\nwrite_milkyway()\n\u2022 OUTPUT_CELL. Specifies the prefix that is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Specifies the prefix that is applied to cells placed underneath\nthe top cell.\n\u2022 HOLDING_CELL. Specifies the prefix that is applied to the holding cell.", "view": "Optional. Names the view created to store graphical output. The default is\n\"HOUT\".", "mode": "Optional. Specifies the action for when the library already exists. The default is\nOVERWRITE.\n\u2022 APPEND. When you write data into a cell that already exists in the target\nMilkyway library, the cell has both the old and new data.\n\u2022 APPEND_NEW_VERSION. When you write data into a cell that already exists\nin the target Milkyway library, the cell has both the old and new data. In\naddition, due to the Milkyway version system, a previous version of the same\ncell is also stored in the library.\n\u2022 OVERWRITE. Specifies that the previously read library is overwritten.", "technology_file": "Optional. Specifies the technology file used if a new Milkyway library is being\ncreated. If appending to an existing Milkyway library, its technology information\nis used. If this argument is not specified and the input library was Milkyway,\nthe technology information from the input library is used; otherwise a default\ntechnology file is created. Output layers that do not exist in the technology\ninformation of the target library are appended. If you do not want to update the\nMilkyway technology file, set the update_technology_file  argument to false.", "net_id": "Optional. Specifies if the net ID is generated for rectangle and polygon data.\nThe connect database that generated the nets must be specified in the\nconnect_sequence  argument. The default is false.", "connect_sequence": "Optional. Specifies the connect database that contains net information used for\noutputting net IDs when the net_id  argument is true.", "cell_prefix": "Optional. Specifies the prefix for all cell names written from the layers\nargument list. This value can be overridden by the cell_prefix  option inside of\nwrite_milkyway()\nthe layers  argument list. The default is an empty string (\"\"); that is, no added\nprefix.", "error_cell_prefix": "Optional. Specifies the prefix for all cell names written from the errors\nargument list. This value can be overridden by the cell_prefix  option inside\nof the errors  argument list. Set this value to an empty string (\"\") if you do not\nwant a prefix. The default is \"ERR_\".", "virtual_cells": "Optional. Specifies the action to take for virtual cells. The default is KEEP.\n\u2022 KEEP. Virtual cells are kept and written to the output library. The output\nhierarchy contains references to virtual cells.\n\u2022 EXPLODE. All data and placements from virtual cells are exploded to the first\nparent design cell before writing to the output library. The output hierarchy\ndoes not contain references to virtual cells.", "boundary_layer": "Optional. Specifies the boundary layer. When the boundary layer is specified,\nthe write_milkyway()  function uses polygons from the boundary layer as\ncell boundaries in the output layout. If there is no polygon in a given cell in the\nboundary layer, the default behavior applies. The default behavior is that the\nwrite_milkyway()  function uses a rectangle representing the extents of the\ncell's data and all of its children as the boundary. If a cell and all of its children\ncontain no data other than the boundary layer polygon, that cell is omitted from\nthe output layout.", "layers": "Optional. Lists the layers to write to the Milkyway library along with mapping,\nprefix, and attribute information.\n\u2022 layer. Specifies the layer name. This layer can be an edge, polygon, or text\nlayer.\n\u2022 layer_num. Specifies the layer number, which is composed of a layer\nnumber and the datatype. This value is used when writing to a library.\nThe data_type  option has a default of 0. See\nLayout Layer and Datatype\nRanges  on page 3347 for information about the limits of the values.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the cell_prefix  argument.\n\u2022 route_type. Optional. Specifies the route type to set when writing\nrectangles from this layer. By default, the IC Validator tool uses the\nwrite_milkyway()\nFILL_TRACK  route type when writing rectangles to the FILL view and does\nnot set the route type for other views. See Table 59  for a list of route types.\n\u2022 aref\nAREFarray structureSREF\n. Optional. Lists the regular patterns of rectangles to be converted into\narrayed structures. You can specify multiple patterns per layer. This behavior\nis a cell-level operation. This feature is typically used to reduce the size of\nthe output layout by converting flat fill to arrayed structures.\nThe IC Validator tool determines if rectangles that meet the provided\ndimensions, specified in the width  and height  options, are in an arrayed\npattern. These rectangles with an arrayed pattern are replaced with a\nnew cell containing a single rectangle of the specified width and height\ndimensions. The origin of the new cell is the lower-left corner of the\nrectangle. Any data in the layer that is not arrayed is output unchanged.\nThe replace  option allows the single rectangle in the new AREF (array\nreference) cell to be replaced by specified polygons.\n\u25e6 cell. Required. Names new cells created when rectangles are grouped\ninto arrayed structures. The IC Validator tool adds a suffix if there is\nany conflict with existing cells in the hierarchy or other new cells. For\nexample, if the cell name is icv_aref and there is a conflict, a suffix is\nadded and the new cell is named icv_aref_1. There is a conflict with this\nname, the new cell is named icv_aref_2, and so on.\n\u25e6 width. Required. Width of the rectangles. See\nConstraints  on page 3344\nfor more information.\nThe IC Validator tool looks for all rectangles with a width equal to the\nwidth  value and height equal to the height  value, and forms arrayed\nstructures, if possible, with 0-degree rotation. It also looks for rectangles\nwith a height equal to the width  value and width equal to the height\nvalue, and forms arrayed structures, if possible, with 90-degree rotation.\nBoth the 0-degree and 90-degree array placements point to the same\ncreated cell.\n\u25e6 height. Required. Height of the rectangles. See\nConstraints  on\npage 3344 for more information.\n\u25e6 minimum_elements. Optional. Minimum number of rectangles for an\narrayed structure to be formed. The IC Validator tool creates an SREF\n(structured reference) instead of an array placement when there is an\narrayed structure of only one rectangle. The default is 16.\n\u25e6 replace. Optional. Lists the polygons that replace the rectangle in the\nnew cells. This behavior allows a rectangle marker layer to be used to\ncreate arrayed structures of more complex shapes in the output layout.\nwrite_milkyway()\nNote:\nSetting minimum_elements  option to 1 ensures all rectangles\nof the specified width and height dimensions are replaced by a\nplacement to a cell with the polygons provided.\nThe list contains xy coordinate pairs for each created polygon. The\ncoordinates can be either\n- Two coordinates, which are interpreted as the opposing corners of a\nrectangle.\n- Three or more coordinates, which define the outer boundary of a closed\npolygon. You do not need to repeat the first coordinate at the end of\nthe list. The coordinates can be ordered in either direction around the\npolygon.\nNote:\nPolygons, or portions of polygons with no area, are ignored.\nAreas of self-intersection are left empty.\n\u2022 convert_to. Optional. Indicates if data should be written as a wire or as a\nrectangle rather than a polygon. The default is NONE.\nNote:\nThe WIRE  option can be used only when writing to the CEL\nview. If you are appending to an existing cell by setting the mode\nargument to APPEND, the cell must be Milkyway schema version\n5.0 or greater.\nWhen set to WIRE,\n\u25e6 The IC Validator tool converts all rectilinear data in the top cell to wires.\nData in lower-level cells is not converted.\n\u25e6 Each wire is stored as either a vertical wire (VWIRE) or a horizontal wire\n(HWIRE).\n\u25e6 Odd width rectangles are represented as two overlapping wires.\n\u25e6 If data that cannot be converted to a wire is encountered, such as a\nnonrectangular polygon or a 1x1 rectangle, the IC Validator tool gives a\nWARNING message and writes the shape unconverted.\n\u25e6 The IC Validator tool makes no attempt to connect the centerlines of\nthe wires. The footprint of the output data exactly matches the polygons\nfrom the input layer, but the orientation, length, and width of the wires is\narbitrary.\nwrite_milkyway()\nWhen set to RECT,\n\u25e6 The IC Validator tool puts all polygons that can be decomposed into\nrectangles into the Milkyway library as rectangles with the correct\nproperties.\n\u25e6 Polygons that are not rectilinear or can otherwise not be decomposed into\nrectangles remain as polygons.\n\u2022 cell_suffix. Optional. Suffix for all cells written from this layer. New cells\nare generated for this layer if a unique suffix is specified. The default is the\nvalue of the write_milkyway(cell_suffix)  argument.\n\u2022 attach_properties. Optional. Lists the properties to attach to output\nshapes on this layer based on the interaction with a specified assign layer.\nProperties to be attached must have been specified in the keep_properties\noption list of the assign layer. By default, the IC Validator tool does not attach\nany properties.\n\u25e6 assign_layer. Specifies the layer from which the properties are\nattached. This layer must be the output of the\nassign()  function.\n\u25e6 properties. Optional. Specifies which properties are attached. These\nproperties must have been present in the keep_properties  option list in\nthe assign()  function. By default, the IC Validator tool does not attach\nany properties.\n- OWNER_NET. Output shapes are assigned to nets based on assign layer\nshapes that they interact with. If an output shape interacts with multiple\ninput shapes having different nets, one is chosen arbitrarily and a warning\nis reported. See the milkyway  argument of the\nassign()  function for\nmore information.\n- ROUTE_TYPE. Output shapes are assigned a route type based on\nassign layer shapes that they interact with. If an output shape interacts\nwith multiple input shapes having different route types, a predefined\nprecedence is used to determine which route type the output shape\ntakes, and a warning is reported. See the milkyway  argument of the\nassign()  function for more information.\nNote:\nOnly certain types of objects can be given a route type in\nMilkyway libraries: rectangles, wires, paths, contacts, and\ncontact arrays. To break down polygons into constituent\nrectangles so that they can be given a route type, set the\nconvert_to  option to RECT.\nwrite_milkyway()\nIn the following example, layer m1_ext is written to Milkyway layer 31, with\nOWNER_NET  and ROUTE_TYPE  properties attached based on the properties of\nthe m1 shapes with which m1_ext interacts.\nm = milkyway_library(\"OUT\");\nwrite_milkyway(\noutput_library = m,\noutput_cell = \"c\",\nview = \"CEL\",\nlayers = {\n{m1_ext,\n{31},\nattach_properties = {{m1, {OWNER_NET,\nROUTE_TYPE}}}\n}\n}\n);\n\u2022 boolean_attributes. Optional. Creates Boolean attributes for the specified\nlayer. All shapes on the layer have the same Boolean attribute name and\nvalue.\nNote:\nAn error occurs if an attribute of the same name is redefined as\na different type. This behavior includes appending to an existing\nMilkyway library where the attribute is already defined.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the Boolean value, true  or false.\n\u2022 double_attributes. Optional. Creates double attributes for the specified\nlayer. All shapes on the layer have the same double attribute name and\nvalue.\nNote:\nAn error occurs if an attribute of the same name is redefined as\na different type. This behavior includes appending to an existing\nMilkyway library where the attribute is already defined.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value, which is a double.\n\u2022 float_attributes. Optional. Creates float attributes for the specified layer.\nAll shapes on the layer have the same float attribute name and value.\nwrite_milkyway()\nNote:\nAn error occurs if an attribute of the same name is redefined as\na different type. This behavior includes appending to an existing\nMilkyway library where the attribute is already defined.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value, which is a floating point.\n\u2022 integer_attributes. Optional. Creates integer attributes for the specified\nlayer. All shapes on the layer have the same integer attribute name and\nvalue.\nNote:\nAn error occurs if an attribute of the same name is redefined as\na different type. This behavior includes appending to an existing\nMilkyway library where the attribute is already defined.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value, which is an integer.\n\u2022 string_attributes. Optional. Creates string attributes for the specified\nlayer. All shapes on the layer have the same string attribute name and value.\nNote:\nAn error occurs if an attribute of the same name is redefined as\na different type. This behavior includes appending to an existing\nMilkyway library where the attribute is already defined.\n\u25e6 name. Specifies the attribute name.\n\u25e6 value. Specifies the attribute value, which is a string.\n\u2022 color. Optional. Applies the specified Milkyway library color attribute to the\noutput layer.\nTable 13  lists the attributes. By default, the IC Validator tool\nreads data of all color attribute values\nNote:\nThis feature is used in runsets that support double patterning\ntechnology (DPT). See the\ntwo_color()  function for more\ninformation. Use the colors  option of the milkyway  argument of\nthe assign()  function to select the color attributes.\n\u2022 compress_fill. Optional. Specifies the compression of fill by replacing\nblocks of fill with placements of new cells.\nwrite_milkyway()\nNote:\nEach layer to be compressed must be specified with the layers\nargument and the mode of the compress_fill  option set to AUTO.\n\u25e6 mode. Optional. Specifies the type of compression. The default is NONE.\n- NONE. Does not compress the fill.\n- AUTO. Compresses the fill. During the fill compression process, new\ncells are created; some cells have only one fill rectangle and others have\nmultiple fill rectangles. The fill is compressed by replacing the fill data of\nthese cells with single and AREF placements, as appropriate.\n\u25e6 cell. Optional. Names the cell created when fill rectangles are grouped\ninto a sub cell. The IC Validator tool adds a suffix if there is any conflict\nwith existing cells in the hierarchy or other new cells. For example, if the\ncell name is specified as icv_fill and there is a conflict, a suffix is added\nand the new cell is named icv_fill_1. If there is a conflict with this name,\nthe new cell is named icv_fill_2, and so on.\n\u2022 error_layer_format. Optional. Specifies how layers of type error_layer are\nwritten. The default is DATA.\n\u25e6 DATA. Specifies that errors are written as either zero-width paths or\nboundaries depending on the type of error. The shapes that are written\ncan be viewed in a layout editor.\n\u25e6 ERROR. Specifies a setting for an internal IC Validator flow and should not\nbe used by the customer.", "errors": "Optional. Lists the errors written to the Milkyway library along with mapping and\nprefix information.\n\u2022 error. Specifies the violation name for the error geometry.\n\u2022 layer_num. Specifies the layer number, which is composed of a layer\nnumber and the datatype. This value is used when writing to a library.\nThe data_type  option has a default of 0. See\nLayout Layer and Datatype\nRanges  for information about the limits of the values.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the error_cell_prefix  argument.\n\u2022 route_type. Optional. Specifies the route type to set when writing\nrectangles from this layer. By default, the IC Validator tool uses the\nwrite_milkyway()\nFILL_TRACK  route type when writing rectangles to the FILL view and does\nnot set the route type for other views. See Table 59  for a list of route types.\n\u2022 cell_suffix. Optional. Suffix for all cells written from this layer. New cells\nare generated for this layer if a unique suffix is specified. The default is the\nvalue of the error_cell_suffix  argument.\n\u2022 classifications. Optional. Lists the error classifications that the IC\nValidator tool uses to filter the violations for the specified output layer. For\nexample, this argument allows you to write waived violations to one layer and\nunwaived violations to another layer.\nThe valid error classifications are Error, Ignore, Waive, Watch, Fixed, and\nDebug. By default, no error classification filtering is performed and all errors\nare written for the output layer.", "error_shapes": "Optional. Determines the shapes of point errors and flyline errors.\n\u2022 point_error. Defines the representation of point errors. Point errors can be\nrepresented by X shape or box shape. A box shape can be more appropriate\nfor LVL comparison of errors. Default is X_SHAPE.\n\u25e6 X_SHAPE. Represents a point error with an X shape centered on the point.\n\u25e6 BOX_SHAPE. Represents a point error with a box shape centered on the\npoint.\n\u2022 box_width. Controls the width of the box shape which is specified in\nmircrons. Default is 2dbu.\n\u2022 flyline_error. Defines the shape of flyline errors. It can be line with\nendpoints or line without endpoints. Default is LINE_AND_X_SHAPE.\n\u25e6 LINE_AND_X_SHAPE. Represents a flyline error with a line between points\nand X shape at each point.\n\u25e6 LINE_SHAPE. Represents a flyline error with only a line between points.", "output_hierarchy": "Optional. Controls the writing of cell references into the Milkyway library.\nThis argument is typically set to false  when the virtual_cells  argument\nis EXPLODE  and the mode  argument is APPEND  so that polygon data can be\nappended to existing cells without affecting the hierarchy. The default is true.", "update_technology_file": "Optional. When set to false, output layers are not appended to the technology\ndata in the output database. The default is true.\nwrite_milkyway()", "magnification_factor": "Optional. The output coordinates are multiplied by this factor before writing to\nthe output library.\nmagnification factoroutput coordinates\nA magnification factor between 0.0 and less than 1.0 shrinks\ndata. A magnification factor greater than 1.0 enlarges data. The default is 1.0\n(no magnification).", "instance_name": "Optional. Specifies whether instance names are written.\n\u2022 write. Optional. Specifies whether to write instance names. The default is\ntrue.\n\u2022 conflict. Optional. Specifies what happens when a newly written instance\nname is in conflict with an existing instance name. This situation is relevant\nonly when you set the mode  argument to APPEND. The default is SKIP.\n\u25e6 ABORT. Abort the run.\n\u25e6 SKIP. Do not write the cell reference.\n\u25e6 RENAME. Rename the new cell reference with a unique instance name.", "cell_suffix": "Optional. Suffix for all cell names written from the layers  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the layers\nargument list. The default is an empty string (\"\").", "error_cell_suffix": "Optional. Suffix for all cell names written from the errors  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the errors\nargument list. Set this value to an empty string (\"\") if you do not want a suffix.\nThe default is \"ERR_\".", "apply_suffix": "Optional. Specifies the cells in the output library to which the suffix is applied. By\ndefault, the IC Validator tool applies the suffix to the output cell and lower cells.\n\u2022 OUTPUT_CELL. Suffix is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Suffix is applied to cells placed underneath the top cell.\n\u2022 HOLDING_CELL. Suffix is applied to the holding cell.", "place_cells": "Optional. Places complex fill cells programmatically, instead of layer-by-layer\nfill, into the output layout based on a marker layer containing rectangles. A layer\nwrite_milkyway()\nconsisting of rectangles is converted into placements of predefined fill cells\ncontaining arbitrary polygons on multiple layers during data output.\nThe imported cell can be renamed to prevent cell name conflicts. The origin of\nthe placement is the lower-left corner of the rectangle.\n\u2022 cell. Specifies the handle to the cell that is imported. The handle is created\nby the\nimport_gds_cell()  or import_oasis_cell()  function.\n\u2022 marker_layer. Specifies the layer that has the rectangles which define the\nfill placement.\n\u2022 compress. Specifies if cell placements should be compressed. The default is\nNONE.\n\u25e6 NONE. Does not compress placements of this cell.\n\u25e6 AUTO. Compresses placements of this cell.\n\u2022 abort. Lists the error severity for rectangles of different sizes\nand nonrectangular shapes on the marker layer. The default is\n{DIFFERENT_SIZE_RECTANGLES, NON_RECTANGULAR_SHAPES}.\n\u25e6 DIFFERENT_SIZE_RECTANGLES. Aborts with an error if there are\nrectangles of different sizes on a single marker layer. If this option is not\nlisted, a warning message is reported. The default is to abort the run if\nthere are rectangles of different sizes on the marker layer. This condition\nindicates the possibility of overlapping or abutting shapes being merged.\n\u25e6 NON_RECTANGULAR_SHAPES. Aborts with an error if there are\nnonrectangular shapes on a single marker layer. If this option is not listed,\na warning message is reported. The default is to abort the run if there are\nnonrectangular shapes on the marker layer. This condition indicates the\npossibility of overlapping shapes being merged.\n\u2022 layer_map_file. Specifies a unified Milkyway layer mapping file that maps\nlayers from the imported fill cell to the output format. The color mappings are\nspecific to Milkyway and only apply when the output format is Milkyway. The\nother mappings can be used for all output formats.\nNote:\nThe unified Milkyway layer mapping file has backward compatible\nsupport for the older Milkyway stream in layer mapping file syntax.\nSee the place_cells  argument of the write_gds()  function for information\nabout the format of the Milkyway unified file.\n\u2022 reflection. Optional. Specifies if the pattern is reflected. See\nFigure 719  for\nan example of reflection and rotation.\nwrite_milkyway()\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is false.\n\u25e6 true. Reflects the pattern.\n\u25e6 false. Does not reflect the pattern.\n\u2022 rotation. Optional. Specifies the rotation of the pattern.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is ROTATE_0; that is, no rotation.\n\u25e6 ROTATE_0\n\u25e6 ROTATE_90\n\u25e6 ROTATE_180\n\u25e6 ROTATE_270\n\u2022 shift. Optional. Specifies the shift of the pattern origin from the lower-left\ncorner of the marker layer rectangle. The default is {0.0, 0.0}; that is, the\npattern is not shifted.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nRotation does not affect the placement of the origin; it is always\nthe lower-left corner of the marker layer rectangle.\n\u2022 cell_prefix. Optional. Prefix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_prefix).\n\u2022 cell_suffix. Optional. Suffix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_suffix).", "layer_mode": "Optional. Specifies the Milkyway extended layer mode. The default is AUTO.\nwrite_milkyway()\n\u2022 AUTO. Specifies that\n\u25e6 If the output library exists, the output Milkyway library is in the layer mode\nof the output library. If a layer number used by the write_milkyway()\nfunction is out of range for the output library, the IC Validator tool issues\nan error message.\n\u25e6 If the output library does not exist, the tool creates it in extended\nlayer mode if the input Milkyway library is in extended layer mode.\nOtherwise, the tool creates it in normal layer mode. Layer range checking\ncorresponds to the mode of the created library.\n\u2022 NORMAL. Specifies that the output Milkyway library is in normal layer mode. If\nthe output library exists in extended layer mode, the IC Validator tool issues\nan error message.\nNote:\nNormal mode supports numbers up to 255.\nExtended mode supports layer or datatype numbers up to 4095.\n\u2022 EXTENDED. Specifies that the output Milkyway library is in extended layer\nmode. If the output library exists in normal layer mode, the IC Validator tool\nissues an error message.", "datatype_mode": "Optional. Specifies the Milkyway extended layer mode. The default is AUTO.\nThe IC Validator tool allows you to write a Milkyway library in extended datatype\nmode if one of the following is true:\n\u2022 The input library is in extended datatype mode.\n\u2022 The destination library exists and is in extended datatype mode.\n\u2022 The datatype_mode  argument of the write_milkyway()  function is\nEXTENDED.\nNote:\nNormal mode supports layer or datatype numbers up to 255.\nExtended mode supports layer or datatype numbers up to 4095.\n\u2022 AUTO. Specifies that\n\u25e6 If the output library exists, the output Milkyway library is in the\ndatatype mode of the existing library. If a datatype number used by the\nwrite_milkyway()  function is out of range for the output library, the\nIC Validator tool issues an error message.\nwrite_milkyway()\n\u25e6 If the output library does not exist, the tool creates it in extended datatype\nmode if the input Milkyway library is in extended datatype mode.\nOtherwise, the tool creates it in normal datatype mode. Datatype range\nchecking corresponds to the mode of the created library.\n\u2022 NORMAL. Specifies that the output Milkyway library is in normal datatype\nmode. If the output library exists in extended datatype mode, the IC Validator\ntool issues an error message.\n\u2022 EXTENDED. Specifies that the output Milkyway library is in extended datatype\nmode. If the output library exists in normal datatype mode, the IC Validator\ntool issues an error message.", "exclude_from_generated_cell_names": "Required. Specifies the list of strings that cannot be included in cell names\ngenerated during multilayer fill compression. This does not apply to cell names\ngenerated by single layer fill compression. Multilayer fill compression still calls\nsingle layer fill compression on the remaining uncompressed data.", "hierarchy_output": "Optional. Specifies the type of cell to be exploded.\n\u2022 ORIGINAL. Maintains the original hierarchy. This option explodes\nautomatically the vcells and any cells whose flat reference count is different\nthan the original hierarchy.\n\u2022 INTERNAL. Specifies the hierarchy used in the IC Validator tool. This is the\ncurrent behavior.", "layers_from_connect_sequences": "Optional. Outputs all of the layers associated with each of the connect\ndatabases in the layers_from_connect_sequences.connect_sequences  list.\nThese layers are output to unique layer and datatype pairs that do not conflict\nwith the layer or datatype values specified in the layers  argument. If one of\nthese layers is also specified in the layers  list argument, that specification\n(layer and datatype) is used.\n\u2022 layer_map_file. Specifies an output text file that shows the layer names for\neach connect database along with the layer and datatype to which that layer\nwas written.\n\u2022 connect_sequences. Specifies that all layers associated with this list of\nconnect databases are written to the output library.\nwrite_milkyway()\nNote:\nThis argument can dramatically affect performance. Use only for\ndebugging purposes.", "place_cell_prefix": "Optional. Specifies the prefix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_prefix  argument\ninside theplace_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added prefix.", "place_cell_suffix": "Optional. Specifies the suffix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_suffix  argument\ninside the place_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added suffix."}, "summary": "The write_milkyway()  function writes layers and violations to a Milkyway library.", "function_name": "write_milkyway()"}
{"description": "The write_openaccess()  function writes layers and violations to an OpenAccess library.\nThere can be multiple write_openaccess()  functions within a runset.\nNote:\nThe OpenAccess format does not support 64-bit coordinates. Therefore, do not\nuse the -64  command-line option with the write_openaccess()  function.\nIf the input layout is OpenAccess, library and view names from input cells are used unless\nthe library  or view  arguments of the write_openaccess()  function are specified.\nErrors consisting of a single point or two points have polygon data generated for output\nto the OpenAccess library. These polygons match what you see in VUE associated with\nthese errors (an X for a single point or a flyline for multiple points).\nSee the\nLimits on Number of Vertices of a Polygon  section for information about writing out\nlarge polygons.", "syntax": "write_openaccess(\noutput_library       = openaccess_library_handle,\nview                 = \"string\",                            //optional\nlibrary              = \"string\",                            //optional\nmode                 = APPEND | OVERWRITE,                  //optional\nholding_cell         = \"string\",                            //optional\noutput_cell          = \"string\",                            //optional\ncell_prefix          = \"string\",                            //optional\nerror_cell_prefix    = \"string\",                            //optional\napply_prefix         = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL},\n//optional\nvirtual_cells        = KEEP | EXPLODE,                      //optional\noutput_hierarchy     = true  | false,                        //optional\nnet_id                = true | false,                        //optional\nconnect_sequence      = connect_database,                    //optional\nmagnification_factor  = double,                              //optional\nlayers = {{layer         = layername,\nlpp           = {layer_name    = \"string\",\npurpose_name  = \"string\"},\ncell_prefix   = \"string\",\naref = {{cell    = \"string\",\nwidth   = doubleconstraint,\nheight  = doubleconstraint,\nminimum_elements = integer,\nreplace = {{{x = double, y = double}, ...}, ...}},\n...},\ncell_suffix   = \"string\",\nwrite_openaccess()\ncompress_fill = {mode = NONE  | AUTO,\ncell = \"string\"}},              //optional\ncolor         = {GRAY, MASK_ONE_UNLOCKED, MASK_ONE_LOCKED,\nMASK_TWO_UNLOCKED, MASK_TWO_LOCKED,\nMASK_THREE_UNLOCKED, MASK_THREE_LOCKED,\nBLACK, MULTI, SAME,\n...},                                             //optional\nerrors = {{error       = violation,\nlpp         = {layer_name    = \"string\",\npurpose_name  = \"string\"},\nviolation_comments = {\"string\", \u2026}},  // optional\ncell_prefix = \"string\",\ncell_suffix = \"string\"},\nclassifications = {\"string\", ...},\n...},                                             //optional\nerror_shapes  = {point_error =  X_SHAPE  |\nBOX_SHAPE | UNSET,\nbox_width = UNSPECIFIED_DOUBLE,\n//2dbu is the default\nflyline_error =  LINE_SHAPE |\nLINE_AND_X_SHAPE  |\nUNSET}, //optional\ninstance_name        = {write    = true  | false,\nconflict = ABORT | SKIP  | RENAME},  //optional\ncell_suffix           = \"string\",                            //optional\nerror_cell_suffix    = \"string\",                            //optional\napply_suffix          = {OUTPUT_CELL, LOWER_CELLS, HOLDING_CELL},\n//optional\nplace_cells          = {{cell           = cell_handle,\nmarker_layer   = polygon_layer,\ncompress       = NONE  | AUTO,\nabort          = {DIFFERENT_SIZE_RECTANGLES,\nNON_RECTANGULAR_SHAPES},\nlayer_map_file = \"string\",\nreflection     = true | false,\nrotation       = ROTATE_0  | ROTATE_90 |\nROTATE_180 | ROTATE_270,\nshift          = {x = double, y = double}},\ncell_prefix    = string,\ncell_suffix    = string},\n...}                                //optional\nexclude_from_generated_cell_names       = {\"string\", ...},  //optional\nhierarchy_output     = ORIGINAL | INTERNAL,                 //optional\nplace_references     = {{library        = \"string\",\ncell           = \"string\",\nview           = \"string\",\nmarker_layer   = polygon_layer,\ncompress       = NONE  | AUTO,\nabort          = {DIFFERENT_SIZE_RECTANGLES,\nNON_RECTANGULAR_SHAPES},\nreflection     = true | false,\nrotation       = ROTATE_0  | ROTATE_90 |\nROTATE_180 | ROTATE_270,\nwrite_openaccess()\nshift          = {x = double, y = double}}\n...},                               //optional\nlayers_from_connect_sequences     = {{layer_map_file    = \"string\",\nconnect_sequences =\n{connect_database}\n...},                  //\noptional\nplace_cell_prefix  = \"string\",                //optional\nplace_cell_suffix   = \"string\"                //optional\n);", "returns": "void", "arguments": {"output_library": "Required. Specifies an OpenAccess library handle. The handle is defined using", "the": "openaccess_library()  function.", "view": "Optional. Specifies the view used for output cells. By default, the IC Validator\ntool uses the view names from OpenAccess input layout cells, or if the input\nlayout is not OpenAccess, the default is \"layout\".\nNote:\nIf a cell name conflicts with another name after renaming the view,\nthe name is modified such that it is unique in the output hierarchy.", "library": "Optional. Names the library to use for output cells. By default, the IC Validator\ntool uses the library names from any OpenAccess input layout cells or the name\nof the OpenAccess input library. This argument is required if the input layout is\nnot OpenAccess.\nNote:\nIf a cell name conflicts with another name after renaming the library,\nthe name is modified such that it is unique in the output hierarchy.", "mode": "Optional. Specifies the action for when the library already exists. The default is\nOVERWRITE.\nwrite_openaccess()\n\u2022 APPEND. When you write data into a cell that already exists in the target\nOpenAccess library, the cell has both the old and new data.\n\u2022 OVERWRITE. When you write data into a cell that already exists in the target\nlibrary, any previous data is overwritten.", "holding_cell": "Optional. Generated top cell that references the output hierarchy from the run.\nThis cell is a generated holding cell; it does not contain any polygon or text data.\nThe holding cell contains both the error and layer cells. By default, error data\nis written to cells with the ERR_  prefix and layers are written to the layout cell\nnames. The error data can be placed within the layer hierarchy if you change\nthe ERR_  prefix to an empty string (\"\") using the error_cell_prefix  argument.\nSee the\nholding_cell  argument of the write_milkyway()  function for more\ninformation.", "output_cell": "Optional. Specifies the new name for the top cell\ntop cellGDSII output library\nof the design to be used in the\noutput library. The name should not conflict with existing cells in the design. The\ndefault name is the original top cell name.", "cell_prefix": "Optional. Specifies the prefix for all cell names written from the layers\nargument list. This value can be overridden by the cell_prefix  option inside of\nthe layers  argument list. The default is an empty string (\"\"); that is, no added\nprefix.", "error_cell_prefix": "Optional. Specifies the prefix for all cell names written from the errors\nargument list. This value can be overridden by the cell_prefix  option inside\nof the errors  argument list. Set this value to an empty string (\"\") if you do not\nwant a prefix. The default is \"ERR_\".", "apply_prefix": "Optional. Specifies the cells in the output library to which the prefix is applied. By\ndefault, the IC Validator tool applies the prefix to the output cell and lower cells.\n\u2022 OUTPUT_CELL. Specifies the prefix that is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Specifies the prefix that is applied to cells placed underneath\nthe top cell.\n\u2022 HOLDING_CELL. Specifies the prefix that is applied to the holding cell.\nwrite_openaccess()", "virtual_cells": "Optional. Specifies the action to take for virtual cells. Virtual cells can\ninclude cells that the IC Validator tool creates to represent standard vias or\nprogrammable cells. The default is KEEP.\n\u2022 KEEP. Virtual cells are kept and written to the output library. The output\nhierarchy contains references to virtual cells.\n\u2022 EXPLODE. All data and placements from virtual cells are exploded to the first\nparent design cell before writing to the output library. The output hierarchy\ndoes not contain references to virtual cells.", "output_hierarchy": "Optional. Controls the writing of cell references into the output OpenAccess\nlibrary. This argument is typically set to false  when the virtual_cells\nargument is EXPLODE  and the mode  argument is APPEND  so that polygon data\ncan be appended to existing cells without affecting the hierarchy. The default is\ntrue.", "net_id": "Optional. Specifies if the net ID is generated for rectangle and polygon data.\nThe connect database that generated the nets must be specified in the\nconnect_sequence  argument. The default is false.", "connect_sequence": "Optional. Specifies the connect database that contains net information used for\noutputting net IDs when the net_id  argument is true.", "magnification_factor": "Optional. The output coordinates are multiplied by this factor before writing to\nthe output library.\nmagnification factoroutput coordinates\nA magnification factor between 0.0 and less than 1.0 shrinks\ndata. A magnification factor greater than 1.0 enlarges data. The default is 1.0\n(no magnification).", "layers": "Optional. Lists the layers to write to the OpenAccess library along with mapping\nand prefix information.\n\u2022 layer. Specifies the layer name. This layer can be an edge, polygon, or text\nlayer.\n\u2022 lpp. Specifies the layer and purpose name pair to which data is written.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the cell_prefix  argument.\nwrite_openaccess()\n\u2022 aref\nAREFarray structureSREF\n. Optional. Lists the regular patterns of rectangles to be converted into\narrayed structures. You can specify multiple patterns per layer. This behavior\nis a cell-level operation. This feature is typically used to reduce the size of\nthe output layout by converting flat fill to arrayed structures.\nThe IC Validator tool determines if rectangles that meet the provided\ndimensions, specified in the width  and height  options, are in an arrayed\npattern. These rectangles with an arrayed pattern are replaced with a\nnew cell containing a single rectangle of the specified width and height\ndimensions. The origin of the new cell is the lower-left corner of the\nrectangle. Any data in the layer that is not arrayed is output unchanged.\nThe replace  option allows the single rectangle in the new AREF (array\nreference) cell to be replaced by specified polygons.\n\u25e6 cell. Required. Names new cells created when rectangles are grouped\ninto arrayed structures. The IC Validator tool adds a suffix if there is\nany conflict with existing cells in the hierarchy or other new cells. For\nexample, if the cell name is icv_aref and there is a conflict, a suffix is\nadded and the new cell is named icv_aref_1. There is a conflict with this\nname, the new cell is named icv_aref_2, and so on.\n\u25e6 width. Required. Width of the rectangles. See\nConstraints  on page 3344\nfor more information.\nThe IC Validator tool looks for all rectangles with a width equal to the\nwidth  value and height equal to the height  value, and forms arrayed\nstructures, if possible, with 0-degree rotation. It also looks for rectangles\nwith a height equal to the width  value and width equal to the height\nvalue, and forms arrayed structures, if possible, with 90-degree rotation.\nBoth the 0-degree and 90-degree array placements point to the same\ncreated cell.\n\u25e6 height. Required. Height of the rectangles. See\nConstraints  on\npage 3344 for more information.\n\u25e6 minimum_elements. Optional. Minimum number of rectangles for an\narrayed structure to be formed. The IC Validator tool creates an SREF\n(structured reference) instead of an array placement when there is an\narrayed structure of only one rectangle. The default is 16.\n\u25e6 replace. Optional. Lists the polygons that replace the rectangle in the\nnew cells. This behavior allows a rectangle marker layer to be used to\ncreate arrayed structures of more complex shapes in the output layout.\nwrite_openaccess()\nNote:\nSetting minimum_elements  option to 1 ensures all rectangles\nof the specified width and height dimensions are replaced by a\nplacement to a cell with the polygons provided.\nThe list contains xy coordinate pairs for each created polygon. The\ncoordinates can be either\n- Two coordinates, which are interpreted as the opposing corners of a\nrectangle.\n- Three or more coordinates, which define the outer boundary of a closed\npolygon. You do not need to repeat the first coordinate at the end of\nthe list. The coordinates can be ordered in either direction around the\npolygon.\nNote:\nPolygons, or portions of polygons with no area, are ignored.\nAreas of self-intersection are left empty.\n\u2022 cell_suffix. Optional. Suffix for all cells written from this layer. New cells\nare generated for this layer if a unique suffix is specified. The default is the\nvalue of the write_openaccess(cell_suffix)  argument.\n\u2022 compress_fill. Optional. Specifies the compression of fill by replacing\nblocks of fill with placements of new cells.\nNote:\nEach layer to be compressed must be specified with the layers\nargument and the mode of the compress_fill  option set to AUTO.\n\u25e6 mode. Optional. Specifies the type of compression. The default is NONE.\n- NONE. Does not compress the fill.\n- AUTO. Compresses the fill. During the fill compression process, new\ncells are created; some cells have only one fill rectangle and others have\nmultiple fill rectangles. The fill is compressed by replacing the fill data of\nthese cells with single and AREF placements, as appropriate.\n\u25e6 cell. Optional. Names the cell created when fill rectangles are grouped\ninto a sub cell. The IC Validator tool adds a suffix if there is any conflict\nwith existing cells in the hierarchy or other new cells. For example, if the\ncell name is specified as icv_fill and there is a conflict, a suffix is added\nand the new cell is named icv_fill_1. If there is a conflict with this name,\nthe new cell is named icv_fill_2, and so on.\nwrite_openaccess()\n\u2022 color. Optional. Specifies the multi-patterning color to set for shapes written\nto NDM from this layer. The default is GRAY. See Table 30  in the colors\nargument of the assign_openaccess() function for a list of the OpenAccess\ncolor attributes.", "errors": "Optional. Lists the errors written to the OpenAccess library along with mapping\nand prefix information.\n\u2022 error. Specifies the violation name for the error geometry.\n\u2022 lpp. Specifies the layer and purpose name pair to which data is written.\n\u2022 violation_comments. Optional. Separates the specified comment/rule from\nget_layout_grid_violation()  when writing.\n\u2022 cell_prefix. Optional. Specifies the prefix for all cells written from this\nlayer. New cells are generated for this layer if a unique prefix is specified.\nThe default is the value of the error_cell_prefix  argument.\n\u2022 cell_suffix. Optional. Suffix for all cells written from this layer. New cells\nare generated for this layer if a unique suffix is specified. The default is the\nvalue of the error_cell_suffix  argument.\n\u2022 classifications. Optional. Lists the error classifications that the IC\nValidator tool uses to filter the violations for the specified output layer. For\nexample, this argument allows you to write waived violations to one layer and\nunwaived violations to another layer.\nThe valid error classifications are Error, Ignore, Waive, Watch, Fixed, and\nDebug. By default, no error classification filtering is performed and all errors\nare written for the output layer.\nNote:\nThe error_limit_per_check  argument of the\nerror_options()\nfunction, which has a default of 100, applies to all error output,\nincluding violations written using the write_openaccess()  function.", "error_shapes": "Optional. Determines the shapes of point errors and flyline errors.\nwrite_openaccess()\n\u2022 point_error. Defines the representation of point errors. Point errors can be\nrepresented by X shape or box shape. A box shape can be more appropriate\nfor LVL comparison of errors. Default is X_SHAPE.\n\u25e6 X_SHAPE. Represents a point error with an X shape centered on the point.\n\u25e6 BOX_SHAPE. Represents a point error with a box shape centered on the\npoint.\n\u2022 box_width. Controls the width of the box shape which is specified in\nmircrons. Default is 2dbu.\n\u2022 flyline_error. Defines the shape of flyline errors. It can be line with\nendpoints or line without endpoints. Default is LINE_AND_X_SHAPE.\n\u25e6 LINE_AND_X_SHAPE. Represents a flyline error with a line between points\nand X shape at each point.\n\u25e6 LINE_SHAPE. Represents a flyline error with only a line between points.", "instance_name": "Optional. Specifies whether instance names are written.\n\u2022 write. Optional. Specifies whether to write instance names. The default is\ntrue.\n\u2022 conflict. Optional. Specifies what happens when a newly written instance\nname is in conflict with an existing instance name. This behavior is relevant\nonly when you set the mode  argument to APPEND. The default is SKIP.\n\u25e6 ABORT. Abort the run.\n\u25e6 SKIP. Do not write the cell reference.\n\u25e6 RENAME. Rename the new cell reference with a unique instance name.", "cell_suffix": "Optional. Suffix for all cell names written from the layers  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the layers\nargument list. The default is an empty string (\"\").", "error_cell_suffix": "Optional. Suffix for all cell names written from the errors  argument list. This\nvalue can be overridden by the cell_suffix  option inside of the errors\nargument list. Set this value to an empty string (\"\") if you do not want a suffix.\nThe default is \"ERR_\".\nwrite_openaccess()", "apply_suffix": "Optional. Specifies the cells in the output library to which the suffix is applied. By\ndefault, the IC Validator tool applies the suffix to the output cell and lower cells.\n\u2022 OUTPUT_CELL. Suffix is applied to the top cell of the design.\n\u2022 LOWER_CELLS. Suffix is applied to cells placed underneath the top cell.\n\u2022 HOLDING_CELL. Suffix is applied to the holding cell.", "place_cells": "Optional. Places complex fill cells programmatically, instead of layer-by-layer\nfill, into the output layout based on a marker layer containing rectangles. A layer\nconsisting of rectangles is converted into placements of predefined fill cells\ncontaining arbitrary polygons on multiple layers during data output.\nThe imported cell can be renamed to prevent cell name conflicts. The origin of\nthe placement is the lower-left corner of the rectangle.\n\u2022 cell. Specifies the handle to the cell that is imported. The handle is created\nby the\nimport_gds_cell()  or import_oasis_cell()  function.\n\u2022 marker_layer. Specifies the layer that has the rectangles which define the\nfill placement.\n\u2022 compress. Specifies if cell placements should be compressed. The default is\nNONE.\n\u25e6 NONE. Does not compress placements of this cell.\n\u25e6 AUTO. Compresses placements of this cell.\n\u2022 abort. Lists the error severity for rectangles of different sizes\nand nonrectangular shapes on the marker layer. The default is\n{DIFFERENT_SIZE_RECTANGLES, NON_RECTANGULAR_SHAPES}.\n\u25e6 DIFFERENT_SIZE_RECTANGLES. Aborts with an error if there are\nrectangles of different sizes on a single marker layer. If this option is not\nlisted, a warning message is reported. The default is to abort the run if\nthere are rectangles of different sizes on the marker layer. This condition\nindicates the possibility of overlapping or abutting shapes being merged.\n\u25e6 NON_RECTANGULAR_SHAPES. Aborts with an error if there are\nnonrectangular shapes on a single marker layer. If this option is not listed,\na warning message is reported. The default is to abort the run if there are\nnonrectangular shapes on the marker layer. This condition indicates the\npossibility of overlapping shapes being merged.\nwrite_openaccess()\n\u2022 layer_map_file. Specifies an OpenAccess layer mapping file that\nmaps layers from the imported fill cell to the output format. See the\nlayer_mapping_file  argument of the openaccess_options()  function for\ninformation about the OpenAccess layer mapping file.\n\u2022 reflection. Optional. Specifies if the pattern is reflected. See Figure 719  for\nan example of reflection and rotation.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is false.\n\u25e6 true. Reflects the pattern.\n\u25e6 false. Does not reflect the pattern.\n\u2022 rotation. Optional. Specifies the rotation of the pattern.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is ROTATE_0; that is, no rotation.\n\u25e6 ROTATE_0.\n\u25e6 ROTATE_90.\n\u25e6 ROTATE_180.\n\u25e6 ROTATE_270.\n\u2022 shift. Optional. Specifies the shift of the pattern origin from the lower-left\ncorner of the marker layer rectangle. The default is {0.0, 0.0}; that is, the\npattern is not shifted.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nRotation does not affect the placement of the origin; it is always\nthe lower-left corner of the marker layer rectangle.\nwrite_openaccess()\n\u2022 cell_prefix. Optional. Prefix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_prefix).\n\u2022 cell_suffix. Optional. Suffix for all cells written for\nthis place_cell  definition. The default is the value of\nwrite_milkyway(place_cell_suffix).", "exclude_from_generated_cell_names": "Required. Specifies the list of strings that cannot be included in cell names\ngenerated during multilayer fill compression. This does not apply to cell names\ngenerated by single layer fill compression. Multilayer fill compression still calls\nsingle layer fill compression on the remaining uncompressed data.", "hierarchy_output": "Optional. Specifies the type of cell to be exploded.\n\u2022 ORIGINAL. Maintains the original hierarchy. This option explodes\nautomatically the vcells and any cells whose flat reference count is different\nthan the original hierarchy.\n\u2022 INTERNAL. Specifies the hierarchy used in the IC Validator tool. This is the\ncurrent behavior.", "place_references": "Optional. Places references to cells in an OpenAccess output layout without\ncreating the referenced cell. The referenced cell might or might not exist in the\nlayout. The referenced cell is described by library, cell, and view name.\n\u2022 library. Specifies the library name of the referenced cell.\n\u2022 cell. Specifies the cell name of the referenced cell.\n\u2022 view. Specifies the view name of the referenced cell.\n\u2022 marker_layer. Specifies the layer that has the rectangles which define the\ncell placements. Cells are placed at the lower-left corner of each rectangle.\n\u2022 compress. Specifies if cell placements should be compressed. The default is\nNONE.\n\u25e6 NONE. Does not compress placements of this cell.\n\u25e6 AUTO. Compresses placements of this cell.\n\u2022 abort. Lists the error severity for rectangles of different sizes\nand nonrectangular shapes on the marker layer. The default is\n{DIFFERENT_SIZE_RECTANGLES, NON_RECTANGULAR_SHAPES}.\nwrite_openaccess()\n\u25e6 DIFFERENT_SIZE_RECTANGLES. Aborts with an error if there are\nrectangles of different sizes on a single marker layer. If this option is not\nlisted, a warning message is reported. The default is to abort the run if\nthere are rectangles of different sizes on the marker layer. This condition\nindicates the possibility of overlapping or abutting shapes being merged.\n\u25e6 NON_RECTANGULAR_SHAPES. Aborts with an error if there are\nnonrectangular shapes on a single marker layer. If this option is not listed,\na warning message is reported. The default is to abort the run if there are\nnonrectangular shapes on the marker layer. This condition indicates the\npossibility of overlapping shapes being merged.\n\u2022 reflection. Optional. Specifies if the placement is reflected. See\nFigure 719  for an example of reflection and rotation.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is false.\n\u25e6 true. Reflects the placement.\n\u25e6 false. Does not reflect the placement.\n\u2022 rotation. Optional. Specifies the rotation of the placement.\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nThe default is ROTATE_0; that is, no rotation.\n\u25e6 ROTATE_0.\n\u25e6 ROTATE_90.\n\u25e6 ROTATE_180.\n\u25e6 ROTATE_270.\n\u2022 shift. Optional. Specifies the shift of the placement origin from the lower-left\ncorner of the marker layer rectangle. The default is {0.0, 0.0}; that is, the\nplacement is not shifted.\nwrite_openaccess()\nNote:\nReflection is performed before rotation. Rotation is performed\nbefore shifting.\nRotation does not affect the placement of the origin; it is always\nthe lower-left corner of the marker layer rectangle.", "layers_from_connect_sequences": "Optional. Outputs all of the layers associated with each of the connect\ndatabases in the layers_from_connect_sequences.connect_sequences  list.\nThese layers are output to unique layerName and purposeName pairs that do\nnot conflict with the layerName or purposeName values specified in the layers\nargument. If one of these layers is also specified in the layers  list argument,\nthat specification (layerName and purposeName) is used.\n\u2022 layer_map_file. Specifies an output text file that shows the layer names\nfor each connect database along with the layerName and purposeName to\nwhich that layer was written.\n\u2022 connect_sequences. Specifies that all layers associated with this list of\nconnect databases are written to the output library.\nNote:\nThis argument can dramatically affect performance. Use only for\ndebugging purposes.", "place_cell_prefix": "Optional. Specifies the prefix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_prefix  argument\ninside theplace_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added prefix.", "place_cell_suffix": "Optional. Specifies the suffix for all cell names written from the place_cells\nargument list. This value can be overridden by the cell_suffix  argument\ninside the place_cells  argument list. The default is an empty string (\u201c\u201d); that is,\nno added suffix."}, "summary": "The write_openaccess()  function writes layers and violations to an OpenAccess library.", "function_name": "write_openaccess()"}
{"description": "The write_pex_spice()  function invokes the netlist utility, icv_netlist, to generate a PEX\noutput SPICE netlist when the PEX flow is not used.\nThe SPICE netlist output by the write_pex_spice()  function differs from the\nwrite_customized_spice()  function output in that it follows the conventions\nof the SPICE netlist output by the pex_generate_database()  function. Use the\nwrite_pex_spice()  function when you need such a netlist, but do not want to call the\npex_generate_database()  function.\nThe netlist data is created using the device database output from the\nextract_devices()\nfunction and the polygon layers specified in the connect()  function. Therefore, call the\nwrite_pex_spice()  function after these functions.\nNote:\nThe icv_netlist utility is in the IC Validator installation directory.", "syntax": "write_pex_spice(\ndevice_db                   = device_database,\noutput_file                 = spice_netlist_file_handle,\nprecision                   = integer,                    //optional\ncompress_netlist            = true | false                //optional\n);", "returns": "void", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.", "output_file": "Required. Specifies the SPICE handle. The handle is defined using the\nspice_netlist_file()  function.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\noutput SPICE netlist (cell.sp file) for all device properties. The value can be\nfrom 1 through 15. The default is 6. When the precision argument is <=0, the\nIC Validator tool exits with an error message.\nwrite_pex_spice()", "compress_netlist": "Optional. Compresses the output netlist generated using the\nwrite_pex_spice()  function. The output file name is not altered from the\nuser-specified name set in the spice_netlist_file()  function. The default is\nfalse."}, "summary": "The write_pex_spice()  function invokes the netlist utility, icv_netlist, to generate a PEX\noutput SPICE netlist when the PEX flow is not used.", "function_name": "write_pex_spice()"}
{"description": "The write_spice()  function invokes the netlist utility, icv_netlist, to generate a\nSPICE netlist. The netlist data is created using the device database output from the\nextract_devices()  function and the polygon layers specified in the connect()  function.\nTherefore, call the write_spice()  function after these functions.\nNote:\nThe icv_netlist utility is in the IC Validator installation directory.\nNote:\nFor lvs_netlist_flow=SPICE  in the run_options()  function, it is\nrecommended to use the write_customized_spice()  function to provide\ncustomization to the input SPICE netlist.\nThe write_spice()  function constructs SPICE instance names as described later in this\nfunction.", "syntax": "write_spice(\ndevice_db                   = device_database,\noutput_file                 = spice_netlist_file_handle,\nmodel_name_format           = NONE | INSTANCE_NAME | SPICE |\nCOMMENT,                      //optional\ninclude_empty_cells         = NONE  | WITH_PORTS | ALL,      //optional\nprecision                   = integer,                      //optional\nerror_report                = BRIEF  | VERBOSE,              //optional\nuser_functions_file         = \"string\",                     //optional\ninclude_placement_data       = true | false,                 //optional\nflatten                     = true | false,                 //optional\ncreate_x_card_device_subckt  = true | false,                 //optional\ncompress_netlist            = true | false                  //optional\n);", "returns": "void", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.\nwrite_spice()", "output_file": "Required. Specifies the SPICE handle. The handle is defined using the\nspice_netlist_file()  function.", "model_name_format": "Optional. Specifies how to write the model name on the device line in a SPICE\nnetlist. The default is COMMENT.\n\u2022 NONE. The model name is not written.\n\u2022 INSTANCE_NAME. The model name is appended to the instance name of the\ndevice.\n\u2022 SPICE. The model name is written as the fourth field on the device line, just\nbefore the value.\n\u2022 COMMENT. The model name is written in a comment at the end of the device\nline in the format: $.model=modelName.\nFor example,\nNONE: C1 node1 node2 value\nINSTANCE_NAME: C1_modelName node1 node2 value\nSPICE: C1 node1 node2 modelName value\nCOMMENT: C1 node1 node2 value $.model=modelName\nNote:\nThis argument applies only to capacitor, inductor, and resistor\ndevices.", "include_empty_cells": "Optional. Specifies which empty cells\nempty cellscells, empty\nare written to the cell.net file. Empty cells\ndo not have devices or instances. A cell is always written out when it is defined\nas an equivalence or black-box cell. The default is NONE.\n\u2022 NONE. Does not write empty cells to the cell.net file.\n\u2022 WITH_PORTS. Writes empty cells that have ports to the cell.net file.\n\u2022 ALL. Writes all empty cells to the cell.net file.", "precision": "Optional. Specifies the maximum number of significant figures reported in the\noutput SPICE netlist (cell.sp file) for all device properties. The value can be\nfrom 1 through 15. The default is 6. When the precision argument is <=0, the\nIC Validator tool treats this value as the default precision.\nwrite_spice()", "error_report": "Optional. Specifies the verbosity of the error report. The information is written to\noutput_file.err. If, however, the output_file  argument is not set, the default file\nname cell.sp.err is used. The default is BRIEF.\n\u2022 BRIEF. Writes only a summary, which contains the total count of layout\nnames that cannot be cross-referenced.\n\u2022 VERBOSE. Writes details of cross-referencing errors, such as specific layout\nnames that cannot be cross-referenced.", "user_functions_file": "Optional. Specifies the file that contains the remote functions. See\nFlexible\nNetlisting Utility Functions  for more information about the utility functions you\ncan use to define a remote function.", "include_placement_data": "Optional. When set to true, the generated SPICE netlist includes coordinate\ninformation for device instances, and coordinate and rotation information for cell\ninstances. The cell instance information is output for both the placement origin\nand the lower-left bounding box position. The default is false.\nThe following device instance example shows where $X and $Y are the\ncoordinates at the center of body polygon:\nMM0 1 4 3 3 p L=2e-06 W=1.2e-05 $X=11500 $Y=26500\nThe following cell instance example shows the $X and $Y lower-left bounding\nbox coordinates and the $T origin placement data:\n$T=field1 field2 field3 field4 $X= field5 $Y= field6\nfield1 = x-coordinate of placement origin\nfield2 = y-coordinate of placement origin\nfield3 = reflection (0, 1)\nfield4 = rotation (0 90 180 270)\nfield5 = x-coordinate of lower-left\nfield6 = y-coordinate of lower-left\n\uff0cthe bounding-box of cell INV is (top=0.150000 bottom=-0.115000\n\uff0cleft=-0.120000 right=0.180000)\nX1 A Z VDD VSS INV $T=0.82 -0.27 1 270 $X=0.67 $Y=-0.45\nInstance X1 is a placement of master cell INV with bounding box = (-0.12 -0.115,\n0.18, 0.15). It is placed on (0.82, -0.27) with reflection of 1 and rotation of 270\ndegrees. The lower-left coordinate of the bounding box of X1 in the parent call is\n(0.67, -0.45).", "flatten": "Optional. Specifies if the netlist is flattened. The default is false.\nwrite_spice()\n\u2022 true. Writes a flattened SPICE netlist.\nNote:\nWhen flatten  is true, the model_name_format  and\nuser_functions_file  arguments of the write_spice()  function\nare ignored.\n\u2022 false. Writes a SPICE netlist that is not flattened.", "create_x_card_device_subckt": "Optional. Specifies if the SUBCKT models writes additional empty SUBCKT\ndefinitions in the output netlist for x-card devices that are extracted by the\ngendev()  function. The default is false.\n\u2022 true. Generates additional empty SUBCKT definition for x-card devices.\n\u2022 false. Does not generate empty SUBCKT definitions for x-card devices.\nLimitation: This argument cannot be used with the flatten  argument.", "compress_netlist": "Optional. Compresses the output netlist generated using the write_spice()\nfunction. The output file name is not altered from the user-specified name set in\nthe spice_netlist_file()  function. The default is false.\nThe IC Validator tool adds instance name prefixes, known as SPICE cards,\nto cell and device names. The form of the prefix depends on the value of the\nflatten  argument.\n\u2022 flatten = true\n\u25e6 A hierarchical path name for a device is constructed using instance\nnames originating in the cell.net layout netlist generated by the\nnetlist()  function. A SPICE card prefix is added to the hierarchical path\nname. The SPICE card prefix to be added is defined by the prefix on the\noriginal device instance name in the preflattened netlist. For example, the\nprefix for an NMOS device is \u201cM_\u201d.\nThe slash character (/) delineates hierarchical levels inside the flattened\nhierarchical instance name.\n\u2022 flatten = false\n\u25e6 All device instance names identically match names originating in the\ncell.net layout netlist generated by the netlist()  function. No additional\nSPICE card is added as a prefix to the device instance name because the\nwrite_spice()\nnetlist()  function already adds a prefix to each device instance name\nwith the appropriate SPICE card.\n\u25e6 An \u201cx\u201d prefix is added to cell instance names that originate in the cell.net\nlayout netlist generated by the netlist()  function.\nFor example, prefixed names for an NMOS device are shown in Table 76.\nTable 76 SPICE Instance Names With Prefixes for an NMOS Device\nInstance name Output from the\nnetlist()  function\nOutput when\nflatten = true\nOutput when\nflatten = false\nDevice instance name M1 M_l1/M1 M1\nCell instance name l1 (not applicable) xl1"}, "summary": "The write_spice()  function invokes the netlist utility, icv_netlist, to generate a\nSPICE netlist.", "function_name": "write_spice()"}
{"description": "The write_xref_spice()  function invokes the netlist utility (icv_netlist) to generate\na cross-referenced SPICE netlist. To generate a cross-referenced SPICE netlist, the\nwrite_xref_spice()  function must be called after LVS comparison. The resulting SPICE\nnetlist has back-annotated schematic device and net names.\nNote:\nThe icv_netlist utility is in the IC Validator installation directory.\nThe write_xref_spice()  function constructs SPICE instance names as described in the\nwrite_spice()  function.", "syntax": "write_xref_spice(\ndevice_db                     = device_database,\nxref_db                       = xref_database_handle,\noutput_file                   = spice_netlist_file_handle,\nmodel_name_format             = NONE | INSTANCE_NAME |\nSPICE | COMMENT,            //optional\ninclude_empty_cells           = NONE  | WITH_PORTS | ALL,    //optional\nprecision                     = integer,                    //optional\nerror_report                  = BRIEF  | VERBOSE,            //optional\nxref_cell_delimiter           = \"string\",                   //optional\nxref_prefixes                 = {device_prefix   = \"string\",\nnet_prefix      = \"string\",\ninstance_prefix = \"string\"},\n//optional\nuser_functions_file           = \"string\",                   //optional\ninclude_placement_data         = true | false,               //optional\nflatten                       = true | false,               //optional\ncompress_netlist              = true | false                //optional\n);", "returns": "void", "arguments": {"device_db": "Required. Generates the layout netlist from the specified device database. The\nextract_devices()  function generates this database.\nwrite_xref_spice()", "xref_db": "Required. Specifies the handle of the database from which cross-reference\ninformation is generated. The handle must be previously defined by the\ncompare()  function.", "output_file": "Required. Specifies the SPICE file for output. The file is defined using the\nspice_netlist_file()  function.", "model_name_format": "Optional. Specifies how to write the model name on the device line in a SPICE\nnetlist. The default is COMMENT.\n\u2022 NONE. The model name is not written.\n\u2022 INSTANCE_NAME. The model name is appended to the instance name of the\ndevice.\n\u2022 SPICE. The model name is written as the fourth field on the device line, just\nbefore the value.\n\u2022 COMMENT. The model name is written in a comment at the end of the device\nline in the format: $.model=modelName.\nFor example,\nNONE: C1 node1 node2 value\nINSTANCE_NAME: C1_modelName node1 node2 value\nSPICE: C1 node1 node2 modelName value\nCOMMENT: C1 node1 node2 value $.model=modelName\nNote:\nThis argument applies only to capacitor, inductor, and resistor\ndevices.", "include_empty_cells": "Optional. Specifies which empty cells\nempty cellscells, empty\nare written to the cell.net file. Empty cells\ndo not have devices or instances. A cell is always written out when it is defined\nas an equivalence or black-box cell. The default is NONE.\n\u2022 NONE. Does not write empty cells to the cell.net file.\n\u2022 WITH_PORTS. Writes empty cells that have ports to the cell.net file.\n\u2022 ALL. Writes all empty cells to the cell.net file.\nwrite_xref_spice()", "precision": "Optional. Specifies the maximum number of significant figures reported in the\noutput SPICE netlist (cell.sp file) for all device properties. The value can be\nfrom 1 through 15. The default is 6. When the precision argument is <=0, the\nIC Validator tool treats this value as the default precision.", "error_report": "Optional. Specifies the verbosity of the error report. The information is written to\noutput_file.err. If, however, the output_file  argument is not set, the default file\nname cell.sp.err is used. The default is BRIEF.\n\u2022 BRIEF. Writes only a summary, which contains the total count of layout\nnames that cannot be cross-referenced.\n\u2022 VERBOSE. Writes details of cross-referencing errors, such as specific layout\nnames that cannot be cross-referenced.", "xref_cell_delimiter": "Optional. Specifies the delimiter to use when multiple layout cells are netlisted\nbecause several layout cells are matched to the same schematic cell. The\ndelimiter and an ID determined by the function are the suffix. The default is\n\"_\" (underscore).", "xref_prefixes": "Optional. Specifies the prefixes to use when layout and schematic device\nnames, net names, and cell names cannot be cross-referenced properly.\nFor example, if a device with the layout name M1 cannot be properly cross-\nreferenced, the netlisted device name is the device-type letter (M), plus the\ndevice_prefix  option and the layout name. If the default device prefix is used,\nthe netlisted device name is M_ld_M1.\n\u2022 device_prefix. Specifies the prefix to use when a layout device name\ncannot be cross-referenced properly to a schematic device name. The\ndefault is \"ld\".\n\u2022 net_prefix. Specifies the prefix to use when a layout net name cannot be\ncross-referenced properly to a schematic net name. The default is \"ln\".\n\u2022 instance_prefix. Specifies the prefix to use when a layout cell-instance\nname cannot be cross-referenced properly to a schematic cell-instance\nname. The default is \"li\".\nwrite_xref_spice()", "user_functions_file": "Optional. Specifies the file that contains the remote functions. See Flexible\nNetlisting Utility Functions  on page 2894 for more information about the utility\nfunctions you can use to define a remote function.", "include_placement_data": "Optional. When set to true, the generated SPICE netlist includes coordinate\ninformation for device instances, and coordinate and rotation information for cell\ninstances. The cell instance information is output for both the placement origin\nand the lower-left bounding box position. The default is false.\nSee the include_placement_data  argument of the\nwrite_spice()  function for\nexamples.", "flatten": "Optional. Specifies if the netlist is flattened. The default is false. See the\nwrite_spice()  function for more information.\n\u2022 true. Writes a flattened SPICE netlist.\nNote:\nWhen flatten  is true, the model_name_format  and\nuser_functions_file  arguments of the write_spice()  function\nare ignored.\n\u2022 false. Writes a SPICE netlist that is not flattened.", "compress_netlist": "Optional. Compresses the output netlist generated using the write_spice()\nfunction. The output file name is not altered from the user-specified name set in\nthe spice_netlist_file()  function. The default is false."}, "summary": "The write_xref_spice()  function invokes the netlist utility (icv_netlist) to generate\na cross-referenced SPICE netlist.", "function_name": "write_xref_spice()"}
{"description": "The xor()  function creates polygons that represent the unique data from two specified\nlayers. That is, it subtracts the intersecting data of the two layers from the combined data\nof the two layers.", "syntax": "xor(\nlayer1          = polygon_layer,\nlayer2          = polygon_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "polygon layer or error result", "arguments": {"layer1": "Required. Specifies a polygon layer.", "layer2": "Required. Specifies a polygon layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The xor()  function creates polygons that represent the unique data from two specified\nlayers.", "function_name": "xor()"}
{"description": "The xor_edge()  function creates the edges that represent the difference between the two\ninput layers. Opposing collinear edges are considered different. See\nedge  in the Glossary\nfor more information about the direction of edges.", "syntax": "xor_edge(\nlayer1           = edge_layer,\nlayer2           = edge_layer,\nprocessing_mode = CELL_LEVEL | HIERARCHICAL,  //optional\nname            = \"layer_label\"               //optional\n);", "returns": "edge layer or error result", "arguments": {"layer1": "Required. Specifies the edge layer.", "layer2": "Required. Specifies the edge layer.", "processing_mode": "Optional. Specifies how the hierarchy is processed. The default is\nHIERARCHICAL.\n\u2022 CELL_LEVEL. Processes data only within the context of each individual cell;\nplacements are ignored.\n\u2022 HIERARCHICAL. Processes all data within the context of the top cell.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The xor_edge()  function creates the edges that represent the difference between the two\ninput layers.", "function_name": "xor_edge()"}
{"description": "The xref_to_double_property()  function collects schematic net names and the\ncorresponding voltage values from a property file that you provide and creates a polygon\nlayer annotated with voltage property values for the matching layout nets. To find the\nlayout nets that match the schematic net names, the xref_to_double_property()\nfunction processes a database of cross-reference information generated by a compare()\nfunction.\nNote:\nProperties on a polygon layer are only recognized by the drc_features(),\nnet_polygon_by_property(), and select_by_double_property()\nfunctions. All other functions ignore properties on a polygon layer and do not\npropagate the properties to their result.", "syntax": "xref_to_double_property(\nxref_db               = xref_database_handle,\nproperty_file          = \"string\",\noutput_from_layer     = polygon_layer,\nin_connect_sequence   = connect_database,\nout_connect_sequence  = out_connect_database,\nname                  = \"layer_label\"          //optional\n);", "returns": "polygon layer", "arguments": {"xref_db": "Required. Specifies the handle of the database from which layout hierarchical\nnet corresponding to the names defined in the property_file  argument is\nselected. The handle must be previously defined by the\ncompare()  function.", "property_file": "Required. Specifies the property values and names in the corresponding\nschematic file. The file format is\nfile_description property-name-1 property-name-2 ...\nschematic_net-1 value value ...\nschematic_net-2 value value ...\n// this is a comment\nschematic_net-3 value value ...\n...\nxref_to_double_property()\nThe file description is a comment. The following names on the first line define\nthe property names attached to the output polygons. A maximum of 16 different\nproperties are supported. Additional or duplicate property names cause a\nwarning and are ignored.\nStarting from the second line in the file, each line defines a schematic net with\nits property values. If fewer property values than the number of property names\non the first line are given, the last value on the line is repeated for the remaining\nvalues.\nEach schematic net is composed by a hierarchical path from top to the\nleaf-equivalence cell, I1/I2/I3/NET1. Each instance (I1, I2\u2026), refers to an\nequivalence point and NET1 is the local net inside the last equivalence point.\nThe local net indicates that it is not  a port of that equivalence point. For\nexample, if X1/N1 is connected to top-level net NT1, you must specify the latter\none. In addition, nets that do not meet these criteria or are not found in the\ncross-reference database are reported in the LAYOUT_ERRORS file.\nA line that starts with two slashes (//) is a comment.\nAn incorrectly formatted file results in empty output and a warning message in\nthe summary file. The IC Validator tool exits the xref_to_double_property()\nfunction but continues running the downstream functions.\nThe cell-level net can also be defined, as shown in the following format:\ncellname net property-name-1 property-name-2\nequiv_cell schematic_net-1 value value\nequiv_cell schematic_net-2 value value\nequiv_cell schematic_net-3 value value\n...\nThe cellname is a predefined keyword that indicates an additional file format\nused to define properties by a cell-level net.\nThe cell in the first column must be an equiv-cell and matic_net-X must be the\nnon-port net under the equiv-cell.", "output_from_layer": "Required. Specifies the layer used to create the output property\nlayer. This layer must be connected in the connect database\nspecified by the in_connect_sequence  argument. For each net, the\nxref_to_double_property()  function selects an arbitrary polygon, attaches\nthe properties on it, and writes it to the output polygon layer.", "in_connect_sequence": "Required. Specifies the connect database in which the output_from_layer\nlayer is connected.\nxref_to_double_property()\nNote:\nThis database must be the output of another\nxref_to_double_property()  function or the\nget_netlist_connect_database()  function.", "out_connect_sequence": "Required. Specifies the output connect database that contains the attached\nproperties.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created."}, "summary": "The xref_to_double_property()  function collects schematic net names and the\ncorresponding voltage values from a property file that you provide and creates a polygon\nlayer annotated with voltage property values for the matching layout nets.", "function_name": "xref_to_double_property()"}
{"description": "The xref_to_net_property()  function collects schematic net names and the\ncorresponding voltage values from a property file that attaches to the connect\ndatabase. To find the layout nets that match the schematic net names, the\nxref_to_net_property()  function processes a database of cross-reference information\ngenerated by a compare()  function.\nNote:\nThis function is typically used in conjunction with the property_to_net(),\nptn_get_net_double_property(), ptn_get_list_of_double_property(),\nand ptn_get_net_string_property()  functions to read the property files that\nare attached in the output connect database.", "syntax": "xref_to_net_property(\nxref_db                = xref_database_handle,\nproperty_file           = \"string\",\nin_connect_sequence    = connect_database,\nproperty_merge_methods = {{property_name   = \"string\",\nproperty_type   = DOUBLE | DOUBLE_LIST |\nSTRING},\nmerge_method    = MAX  | MIN | CONCATENATE\nAUTO} ...},    //optional\nreport_conflict  =\ntrue  | false  //optional\nsave_property_mode = OVERWRITE  | APPEND,\nsuppress_errors        = {SERIES_MERGED_NETS}               //optional\n);", "returns": "connect database", "arguments": {"xref_db": "Required. Specifies the handle of the database from which layout hierarchical\nnet corresponding to the names defined in the property_file  argument is\nselected. The handle must be previously defined by the\ncompare()  function.", "property_file": "Required. Specifies the property values and names in the corresponding\nschematic file. The file format is\nfile_description property-name-1 property-name-2 ...\nschematic_net-1 value value ...\nxref_to_net_property()\nschematic_net-2 value value ...\n// this is a comment\nschematic_net-3 value value ...\n...\nThe file description is a comment. The following names on the first line define\nthe property names attached to the output polygons. A maximum of 16 different\nproperties are supported. Additional or duplicate property names cause a\nwarning and are ignored.\nStarting from the second line in the file, each line defines a schematic net with\nits property values. If fewer property values than the number of property names\non the first line are given, the last value on the line is repeated for the remaining\nvalues.\nEach schematic net is composed by a hierarchical path from top to the\nleaf-equivalence cell, I1/I2/I3/NET1. Each instance (I1, I2\u2026), refers to an\nequivalence point and NET1 is the local net inside the last equivalence point.\nThe local net indicates that it is not  a port of that equivalence point. For\nexample, if X1/N1 is connected to top-level net NT1, you must specify the latter\none. In addition, nets that do not meet these criteria or are not found in the\ncross-reference database are reported in the LAYOUT_ERRORS file.\nA line that starts with two slashes (//) is a comment.\nAn incorrectly formatted file results in empty output and a warning message in\nthe summary file. The IC Validator tool exits the xref_to_double_property()\nfunction but continues running the downstream functions.\nThe cell-level net can also be defined, as shown in the following format:\ncellname net property-name-1 property-name-2\nequiv_cell schematic_net-1 value value\nequiv_cell schematic_net-2 value value\nequiv_cell schematic_net-3 value value\n...\nThe cellname is a predefined keyword that indicates an additional file format\nused to define properties by a cell-level net.\nThe cell in the first column must be an equiv-cell and matic_net-X must be the\nnon-port net under the equiv-cell.", "in_connect_sequence": "Required. Specifies the connect database in which the output_from_layer\nlayer is connected.\nxref_to_net_property()\nNote:\nThis database must be the output of another xref_to_property()\nfunction or the get_netlist_connect_database()  function.", "property_merge_methods": "Optional. Specifies that all of the property types and merge methods in the\nproperty file must be included when non-empty property merge methods are\ndefined. The IC Validator tool uses the first entry of a property merge method\nto account for that property. For a DOUBLE  property, the merge_method=MAX\nsetting is used. If a property appears in the property file, but is not defined in the\nproperty_merge_methods  argument, a runtime error is reported when parsing\nthe property file.\n\u2022 property_name. Required. Specifies the user-defined name of the property.\n\u2022 property_type. Specifies the data type of the property. The default is\nSTRING.\n\u25e6 DOUBLE. Specifies the data type as double.\n\u25e6 DOUBLE_LIST. Specifies the data type as a double list.\n\u25e6 STRING. Specifies the data type as string.\n\u2022 merge_method. Specifies the behavior of the IC Validator tool when two or\nmore entries point to the same layout net. This occurs when the duplicated\nentries are defined in the property file, or two nets belong to the same\ncomposited net when using the short_equivalent_nodes()  function. The\ndefault is MAX.\n\u25e6 MIN. Specifies the minimum value of the DOUBLE  property.\n\u25e6 MAX. Specifies the maximum value of the DOUBLE  property.\n\u25e6 CONCATENATE. Specifies the value only for the DOUBLE_LIST  property.\n\u25e6 AUTO. Specifies the value only for the STRING  property.\nThe restrictions for using the argument are\n\u25e6 If property_type  is DOUBLE, merge_method  can only be set to MAX  or\nMIN.\n\u25e6 If property_type  is DOUBLE_LIST, merge_method  can only be set to\nCONCATENATE.\n\u25e6 If property_type  is AUTO, merge_method  can only be set to AUTO.\n\u2022 report_conflict. Optional. Reports conflicted property values and the\ncorresponding net name to the LAYOUT_ERRORS file. The default is true.\nxref_to_net_property()\n\u25e6 true. Reports an error when there is a property value conflict.\n\u25e6 false. Suppresses an error when there is a property value conflict.\n\u2022 save_property_mode. Optional. Specifies the property values that are\ndefined in the input connect database. The default is OVERWRITE.\n\u25e6 OVERWRITE. Discards all of the property values defined in the input\nconnect database.\n\u25e6 APPEND. Maintains the existing property values in the input connect\ndatabase.", "suppress_errors": "Optional. Suppresses errors. The default is an empty list of predefined values.\n\u2022 SERIES_MERGED_NETS. Suppresses the cross-reference errors for non-\ncompared nets, that is, nets merged by the merge_series()  function."}, "summary": "The xref_to_net_property()  function collects schematic net names and the\ncorresponding voltage values from a property file that attaches to the connect\ndatabase.", "function_name": "xref_to_net_property()"}
{"description": "The xref_to_property()  function collects schematic net names and the corresponding\nvoltage values from a property file that you provide and creates a polygon layer annotated\nwith voltage property values for the matching layout nets. To find the layout nets that\nmatch the schematic net names, the xref_to_property()  function processes a database\nof cross-reference information generated by a compare()  function.\nNote:\nProperties on a polygon layer are only recognized by the drc_features(),\nnet_polygon_by_property(), and select_by_double_property()\nfunctions. All other functions ignore properties on a polygon layer and do not\npropagate the properties to their result.", "syntax": "xref_to_property(\nxref_db                = xref_database_handle,\nproperty_file           = \"string\",\noutput_from_layer      = polygon_layer,\nin_connect_sequence    = connect_database,\nout_connect_sequence   = out_connect_database,\nname                   = \"layer_label,\"                     //optional\nproperty_merge_methods = {{property_name   = \"string\",\nproperty_type   = DOUBLE | DOUBLE_LIST |\nSTRING},\nmerge_method    = MAX  | MIN | CONCATENATE\nAUTO} ...},    //optional\nreport_conflict =\ntrue  | false,  //optional\nsuppress_errors        = {SERIES_MERGED_NETS}               //optional\n);", "returns": "polygon layer", "arguments": {"xref_db": "Required. Specifies the handle of the database from which layout hierarchical\nnet corresponding to the names defined in the property_file  argument is\nselected. The handle must be previously defined by the\ncompare()  function.", "property_file": "Required. Specifies the property values and names in the corresponding\nschematic file. The file format is\nxref_to_property()\nfile_description property-name-1 property-name-2 ...\nschematic_net-1 value value ...\nschematic_net-2 value value ...\n// this is a comment\nschematic_net-3 value value ...\n...\nThe file description is a comment. The following names on the first line define\nthe property names attached to the output polygons. A maximum of 16 different\nproperties are supported. Additional or duplicate property names cause a\nwarning and are ignored.\nStarting from the second line in the file, each line defines a schematic net with\nits property values. If fewer property values than the number of property names\non the first line are given, the last value on the line is repeated for the remaining\nvalues.\nEach schematic net is composed by a hierarchical path from top to the\nleaf-equivalence cell, I1/I2/I3/NET1. Each instance (I1, I2\u2026), refers to an\nequivalence point and NET1 is the local net inside the last equivalence point.\nThe local net indicates that it is not  a port of that equivalence point. For\nexample, if X1/N1 is connected to top-level net NT1, you must specify the latter\none. In addition, nets that do not meet these criteria or are not found in the\ncross-reference database are reported in the LAYOUT_ERRORS file.\nA line that starts with two slashes (//) is a comment.\nAn incorrectly formatted file results in empty output and a warning message in\nthe summary file. The IC Validator tool exits the xref_to_double_property()\nfunction but continues running the downstream functions.\nThe cell-level net can also be defined, as shown in the following format:\ncellname net property-name-1 property-name-2\nequiv_cell schematic_net-1 value value\nequiv_cell schematic_net-2 value value\nequiv_cell schematic_net-3 value value\n...\nThe cellname is a predefined keyword that indicates an additional file format\nused to define properties by a cell-level net.\nThe cell in the first column must be an equiv-cell and matic_net-X must be the\nnon-port net under the equiv-cell.", "output_from_layer": "Required. Specifies the layer used to create the output property\nlayer. This layer must be connected in the connect database\nspecified by the in_connect_sequence  argument. For each net, the\nxref_to_property()\nxref_to_double_property()  function selects an arbitrary polygon, attaches\nthe properties on it, and writes it to the output polygon layer.", "in_connect_sequence": "Required. Specifies the connect database in which the output_from_layer\nlayer is connected.\nNote:\nThis database must be the output of another xref_to_property()\nfunction or the get_netlist_connect_database()  function.", "out_connect_sequence": "Required. Specifies the output connect database that contains the attached\nproperties.", "name": "Optional. Specifies the name used by the IC Validator tool for the output layer.\nThis name is displayed in various output log files, such as the summary, tree,\nand distributed processing log files. It is used only for log files; runset variables\nare not changed. The default is the name of the layer being created.", "property_merge_methods": "Optional. Specifies that all of the property types and merge methods in the\nproperty file must be included when non-empty property merge methods are\ndefined. The IC Validator tool uses the first entry of a property merge method to\naccount for that property. For a DOUBLE  property, the merge_method=MAX  setting\nis used. If a property is defined by a property merge method, but does not show\nup in the property file, a warning message is reported.\n\u2022 property_name. Required. Specifies the user-defined name of the property.\n\u2022 property_type. Specifies the data type of the property. The default is\nSTRING.\n\u25e6 DOUBLE. Specifies the data type as double.\n\u25e6 DOUBLE_LIST. Specifies the data type as a double list.\n\u25e6 STRING. Specifies the data type as string.\n\u2022 merge_method. Specifies the behavior of the IC Validator tool when two or\nmore entries point to the same layout net. This occurs when the duplicated\nentries are defined in the property file, or two nets belong to the same\ncomposited net when using the short_equivalent_nodes()  function. The\ndefault is MAX.\nxref_to_property()\n\u25e6 MIN. Specifies the minimum value of the DOUBLE  property.\n\u25e6 MAX. Specifies the maximum value of the DOUBLE  property.\n\u25e6 CONCATENATE. Specifies the value only for the DOUBLE_LIST  property.\n\u25e6 AUTO. Specifies the value only for the STRING  property.\nThe restrictions for using the argument are\n\u25e6 If property_type  is DOUBLE, merge_method  can only be set to MAX  or\nMIN.\n\u25e6 If property_type  is DOUBLE_LIST, merge_method  can only be set to\nCONCATENATE.\n\u25e6 If property_type  is AUTO, merge_method  can only be set to AUTO.\n\u2022 report_conflict. Optional. Reports conflicted property values and the\ncorresponding net name to the LAYOUT_ERRORS file. The default is true.\n\u25e6 true. Reports an error when there is a property value conflict.\n\u25e6 false. Suppresses an error when there is a property value conflict.", "suppress_errors": "Optional. Suppresses errors. The default is an empty list of predefined values.\n\u2022 SERIES_MERGED_NETS. Suppresses the cross-reference errors for non-\ncompared nets, that is, nets merged by the merge_series()  function."}, "summary": "The xref_to_property()  function collects schematic net names and the corresponding\nvoltage values from a property file that you provide and creates a polygon layer annotated\nwith voltage property values for the matching layout nets.", "function_name": "xref_to_property()"}
